/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/jquery";
exports.ids = ["vendor-chunks/jquery"];
exports.modules = {

/***/ "(ssr)/./node_modules/jquery/dist/jquery.js":
/*!********************************************!*\
  !*** ./node_modules/jquery/dist/jquery.js ***!
  \********************************************/
/***/ (function(module, exports) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!\n * jQuery JavaScript Library v3.7.1\n * https://jquery.com/\n *\n * Copyright OpenJS Foundation and other contributors\n * Released under the MIT license\n * https://jquery.org/license\n *\n * Date: 2023-08-28T13:37Z\n */ (function(global, factory) {\n    \"use strict\";\n    if ( true && typeof module.exports === \"object\") {\n        // For CommonJS and CommonJS-like environments where a proper `window`\n        // is present, execute the factory and get jQuery.\n        // For environments that do not have a `window` with a `document`\n        // (such as Node.js), expose a factory as module.exports.\n        // This accentuates the need for the creation of a real `window`.\n        // e.g. var jQuery = require(\"jquery\")(window);\n        // See ticket trac-14549 for more info.\n        module.exports = global.document ? factory(global, true) : function(w) {\n            if (!w.document) {\n                throw new Error(\"jQuery requires a window with a document\");\n            }\n            return factory(w);\n        };\n    } else {\n        factory(global);\n    }\n// Pass this if window is not defined yet\n})( false ? 0 : this, function(window1, noGlobal) {\n    // Edge <= 12 - 13+, Firefox <=18 - 45+, IE 10 - 11, Safari 5.1 - 9+, iOS 6 - 9.1\n    // throw exceptions when non-strict code (e.g., ASP.NET 4.5) accesses strict mode\n    // arguments.callee.caller (trac-13335). But as of jQuery 3.0 (2016), strict mode should be common\n    // enough that all such attempts are guarded in a try block.\n    \"use strict\";\n    var arr = [];\n    var getProto = Object.getPrototypeOf;\n    var slice = arr.slice;\n    var flat = arr.flat ? function(array) {\n        return arr.flat.call(array);\n    } : function(array) {\n        return arr.concat.apply([], array);\n    };\n    var push = arr.push;\n    var indexOf = arr.indexOf;\n    var class2type = {};\n    var toString = class2type.toString;\n    var hasOwn = class2type.hasOwnProperty;\n    var fnToString = hasOwn.toString;\n    var ObjectFunctionString = fnToString.call(Object);\n    var support = {};\n    var isFunction = function isFunction(obj) {\n        // Support: Chrome <=57, Firefox <=52\n        // In some browsers, typeof returns \"function\" for HTML <object> elements\n        // (i.e., `typeof document.createElement( \"object\" ) === \"function\"`).\n        // We don't want to classify *any* DOM node as a function.\n        // Support: QtWeb <=3.8.5, WebKit <=534.34, wkhtmltopdf tool <=0.12.5\n        // Plus for old WebKit, typeof returns \"function\" for HTML collections\n        // (e.g., `typeof document.getElementsByTagName(\"div\") === \"function\"`). (gh-4756)\n        return typeof obj === \"function\" && typeof obj.nodeType !== \"number\" && typeof obj.item !== \"function\";\n    };\n    var isWindow = function isWindow(obj) {\n        return obj != null && obj === obj.window;\n    };\n    var document = window1.document;\n    var preservedScriptAttributes = {\n        type: true,\n        src: true,\n        nonce: true,\n        noModule: true\n    };\n    function DOMEval(code, node, doc) {\n        doc = doc || document;\n        var i, val, script = doc.createElement(\"script\");\n        script.text = code;\n        if (node) {\n            for(i in preservedScriptAttributes){\n                // Support: Firefox 64+, Edge 18+\n                // Some browsers don't support the \"nonce\" property on scripts.\n                // On the other hand, just using `getAttribute` is not enough as\n                // the `nonce` attribute is reset to an empty string whenever it\n                // becomes browsing-context connected.\n                // See https://github.com/whatwg/html/issues/2369\n                // See https://html.spec.whatwg.org/#nonce-attributes\n                // The `node.getAttribute` check was added for the sake of\n                // `jQuery.globalEval` so that it can fake a nonce-containing node\n                // via an object.\n                val = node[i] || node.getAttribute && node.getAttribute(i);\n                if (val) {\n                    script.setAttribute(i, val);\n                }\n            }\n        }\n        doc.head.appendChild(script).parentNode.removeChild(script);\n    }\n    function toType(obj) {\n        if (obj == null) {\n            return obj + \"\";\n        }\n        // Support: Android <=2.3 only (functionish RegExp)\n        return typeof obj === \"object\" || typeof obj === \"function\" ? class2type[toString.call(obj)] || \"object\" : typeof obj;\n    }\n    /* global Symbol */ // Defining this global in .eslintrc.json would create a danger of using the global\n    // unguarded in another place, it seems safer to define global only for this module\n    var version = \"3.7.1\", rhtmlSuffix = /HTML$/i, // Define a local copy of jQuery\n    jQuery = function(selector, context) {\n        // The jQuery object is actually just the init constructor 'enhanced'\n        // Need init if jQuery is called (just allow error to be thrown if not included)\n        return new jQuery.fn.init(selector, context);\n    };\n    jQuery.fn = jQuery.prototype = {\n        // The current version of jQuery being used\n        jquery: version,\n        constructor: jQuery,\n        // The default length of a jQuery object is 0\n        length: 0,\n        toArray: function() {\n            return slice.call(this);\n        },\n        // Get the Nth element in the matched element set OR\n        // Get the whole matched element set as a clean array\n        get: function(num) {\n            // Return all the elements in a clean array\n            if (num == null) {\n                return slice.call(this);\n            }\n            // Return just the one element from the set\n            return num < 0 ? this[num + this.length] : this[num];\n        },\n        // Take an array of elements and push it onto the stack\n        // (returning the new matched element set)\n        pushStack: function(elems) {\n            // Build a new jQuery matched element set\n            var ret = jQuery.merge(this.constructor(), elems);\n            // Add the old object onto the stack (as a reference)\n            ret.prevObject = this;\n            // Return the newly-formed element set\n            return ret;\n        },\n        // Execute a callback for every element in the matched set.\n        each: function(callback) {\n            return jQuery.each(this, callback);\n        },\n        map: function(callback) {\n            return this.pushStack(jQuery.map(this, function(elem, i) {\n                return callback.call(elem, i, elem);\n            }));\n        },\n        slice: function() {\n            return this.pushStack(slice.apply(this, arguments));\n        },\n        first: function() {\n            return this.eq(0);\n        },\n        last: function() {\n            return this.eq(-1);\n        },\n        even: function() {\n            return this.pushStack(jQuery.grep(this, function(_elem, i) {\n                return (i + 1) % 2;\n            }));\n        },\n        odd: function() {\n            return this.pushStack(jQuery.grep(this, function(_elem, i) {\n                return i % 2;\n            }));\n        },\n        eq: function(i) {\n            var len = this.length, j = +i + (i < 0 ? len : 0);\n            return this.pushStack(j >= 0 && j < len ? [\n                this[j]\n            ] : []);\n        },\n        end: function() {\n            return this.prevObject || this.constructor();\n        },\n        // For internal use only.\n        // Behaves like an Array's method, not like a jQuery method.\n        push: push,\n        sort: arr.sort,\n        splice: arr.splice\n    };\n    jQuery.extend = jQuery.fn.extend = function() {\n        var options, name, src, copy, copyIsArray, clone, target = arguments[0] || {}, i = 1, length = arguments.length, deep = false;\n        // Handle a deep copy situation\n        if (typeof target === \"boolean\") {\n            deep = target;\n            // Skip the boolean and the target\n            target = arguments[i] || {};\n            i++;\n        }\n        // Handle case when target is a string or something (possible in deep copy)\n        if (typeof target !== \"object\" && !isFunction(target)) {\n            target = {};\n        }\n        // Extend jQuery itself if only one argument is passed\n        if (i === length) {\n            target = this;\n            i--;\n        }\n        for(; i < length; i++){\n            // Only deal with non-null/undefined values\n            if ((options = arguments[i]) != null) {\n                // Extend the base object\n                for(name in options){\n                    copy = options[name];\n                    // Prevent Object.prototype pollution\n                    // Prevent never-ending loop\n                    if (name === \"__proto__\" || target === copy) {\n                        continue;\n                    }\n                    // Recurse if we're merging plain objects or arrays\n                    if (deep && copy && (jQuery.isPlainObject(copy) || (copyIsArray = Array.isArray(copy)))) {\n                        src = target[name];\n                        // Ensure proper type for the source value\n                        if (copyIsArray && !Array.isArray(src)) {\n                            clone = [];\n                        } else if (!copyIsArray && !jQuery.isPlainObject(src)) {\n                            clone = {};\n                        } else {\n                            clone = src;\n                        }\n                        copyIsArray = false;\n                        // Never move original objects, clone them\n                        target[name] = jQuery.extend(deep, clone, copy);\n                    // Don't bring in undefined values\n                    } else if (copy !== undefined) {\n                        target[name] = copy;\n                    }\n                }\n            }\n        }\n        // Return the modified object\n        return target;\n    };\n    jQuery.extend({\n        // Unique for each copy of jQuery on the page\n        expando: \"jQuery\" + (version + Math.random()).replace(/\\D/g, \"\"),\n        // Assume jQuery is ready without the ready module\n        isReady: true,\n        error: function(msg) {\n            throw new Error(msg);\n        },\n        noop: function() {},\n        isPlainObject: function(obj) {\n            var proto, Ctor;\n            // Detect obvious negatives\n            // Use toString instead of jQuery.type to catch host objects\n            if (!obj || toString.call(obj) !== \"[object Object]\") {\n                return false;\n            }\n            proto = getProto(obj);\n            // Objects with no prototype (e.g., `Object.create( null )`) are plain\n            if (!proto) {\n                return true;\n            }\n            // Objects with prototype are plain iff they were constructed by a global Object function\n            Ctor = hasOwn.call(proto, \"constructor\") && proto.constructor;\n            return typeof Ctor === \"function\" && fnToString.call(Ctor) === ObjectFunctionString;\n        },\n        isEmptyObject: function(obj) {\n            var name;\n            for(name in obj){\n                return false;\n            }\n            return true;\n        },\n        // Evaluates a script in a provided context; falls back to the global one\n        // if not specified.\n        globalEval: function(code, options, doc) {\n            DOMEval(code, {\n                nonce: options && options.nonce\n            }, doc);\n        },\n        each: function(obj, callback) {\n            var length, i = 0;\n            if (isArrayLike(obj)) {\n                length = obj.length;\n                for(; i < length; i++){\n                    if (callback.call(obj[i], i, obj[i]) === false) {\n                        break;\n                    }\n                }\n            } else {\n                for(i in obj){\n                    if (callback.call(obj[i], i, obj[i]) === false) {\n                        break;\n                    }\n                }\n            }\n            return obj;\n        },\n        // Retrieve the text value of an array of DOM nodes\n        text: function(elem) {\n            var node, ret = \"\", i = 0, nodeType = elem.nodeType;\n            if (!nodeType) {\n                // If no nodeType, this is expected to be an array\n                while(node = elem[i++]){\n                    // Do not traverse comment nodes\n                    ret += jQuery.text(node);\n                }\n            }\n            if (nodeType === 1 || nodeType === 11) {\n                return elem.textContent;\n            }\n            if (nodeType === 9) {\n                return elem.documentElement.textContent;\n            }\n            if (nodeType === 3 || nodeType === 4) {\n                return elem.nodeValue;\n            }\n            // Do not include comment or processing instruction nodes\n            return ret;\n        },\n        // results is for internal usage only\n        makeArray: function(arr, results) {\n            var ret = results || [];\n            if (arr != null) {\n                if (isArrayLike(Object(arr))) {\n                    jQuery.merge(ret, typeof arr === \"string\" ? [\n                        arr\n                    ] : arr);\n                } else {\n                    push.call(ret, arr);\n                }\n            }\n            return ret;\n        },\n        inArray: function(elem, arr, i) {\n            return arr == null ? -1 : indexOf.call(arr, elem, i);\n        },\n        isXMLDoc: function(elem) {\n            var namespace = elem && elem.namespaceURI, docElem = elem && (elem.ownerDocument || elem).documentElement;\n            // Assume HTML when documentElement doesn't yet exist, such as inside\n            // document fragments.\n            return !rhtmlSuffix.test(namespace || docElem && docElem.nodeName || \"HTML\");\n        },\n        // Support: Android <=4.0 only, PhantomJS 1 only\n        // push.apply(_, arraylike) throws on ancient WebKit\n        merge: function(first, second) {\n            var len = +second.length, j = 0, i = first.length;\n            for(; j < len; j++){\n                first[i++] = second[j];\n            }\n            first.length = i;\n            return first;\n        },\n        grep: function(elems, callback, invert) {\n            var callbackInverse, matches = [], i = 0, length = elems.length, callbackExpect = !invert;\n            // Go through the array, only saving the items\n            // that pass the validator function\n            for(; i < length; i++){\n                callbackInverse = !callback(elems[i], i);\n                if (callbackInverse !== callbackExpect) {\n                    matches.push(elems[i]);\n                }\n            }\n            return matches;\n        },\n        // arg is for internal usage only\n        map: function(elems, callback, arg) {\n            var length, value, i = 0, ret = [];\n            // Go through the array, translating each of the items to their new values\n            if (isArrayLike(elems)) {\n                length = elems.length;\n                for(; i < length; i++){\n                    value = callback(elems[i], i, arg);\n                    if (value != null) {\n                        ret.push(value);\n                    }\n                }\n            // Go through every key on the object,\n            } else {\n                for(i in elems){\n                    value = callback(elems[i], i, arg);\n                    if (value != null) {\n                        ret.push(value);\n                    }\n                }\n            }\n            // Flatten any nested arrays\n            return flat(ret);\n        },\n        // A global GUID counter for objects\n        guid: 1,\n        // jQuery.support is not used in Core but other projects attach their\n        // properties to it so it needs to exist.\n        support: support\n    });\n    if (typeof Symbol === \"function\") {\n        jQuery.fn[Symbol.iterator] = arr[Symbol.iterator];\n    }\n    // Populate the class2type map\n    jQuery.each(\"Boolean Number String Function Array Date RegExp Object Error Symbol\".split(\" \"), function(_i, name) {\n        class2type[\"[object \" + name + \"]\"] = name.toLowerCase();\n    });\n    function isArrayLike(obj) {\n        // Support: real iOS 8.2 only (not reproducible in simulator)\n        // `in` check used to prevent JIT error (gh-2145)\n        // hasOwn isn't used here due to false negatives\n        // regarding Nodelist length in IE\n        var length = !!obj && \"length\" in obj && obj.length, type = toType(obj);\n        if (isFunction(obj) || isWindow(obj)) {\n            return false;\n        }\n        return type === \"array\" || length === 0 || typeof length === \"number\" && length > 0 && length - 1 in obj;\n    }\n    function nodeName(elem, name) {\n        return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();\n    }\n    var pop = arr.pop;\n    var sort = arr.sort;\n    var splice = arr.splice;\n    var whitespace = \"[\\\\x20\\\\t\\\\r\\\\n\\\\f]\";\n    var rtrimCSS = new RegExp(\"^\" + whitespace + \"+|((?:^|[^\\\\\\\\])(?:\\\\\\\\.)*)\" + whitespace + \"+$\", \"g\");\n    // Note: an element does not contain itself\n    jQuery.contains = function(a, b) {\n        var bup = b && b.parentNode;\n        return a === bup || !!(bup && bup.nodeType === 1 && // Support: IE 9 - 11+\n        // IE doesn't have `contains` on SVG.\n        (a.contains ? a.contains(bup) : a.compareDocumentPosition && a.compareDocumentPosition(bup) & 16));\n    };\n    // CSS string/identifier serialization\n    // https://drafts.csswg.org/cssom/#common-serializing-idioms\n    var rcssescape = /([\\0-\\x1f\\x7f]|^-?\\d)|^-$|[^\\x80-\\uFFFF\\w-]/g;\n    function fcssescape(ch, asCodePoint) {\n        if (asCodePoint) {\n            // U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER\n            if (ch === \"\\x00\") {\n                return \"ï¿½\";\n            }\n            // Control characters and (dependent upon position) numbers get escaped as code points\n            return ch.slice(0, -1) + \"\\\\\" + ch.charCodeAt(ch.length - 1).toString(16) + \" \";\n        }\n        // Other potentially-special ASCII characters get backslash-escaped\n        return \"\\\\\" + ch;\n    }\n    jQuery.escapeSelector = function(sel) {\n        return (sel + \"\").replace(rcssescape, fcssescape);\n    };\n    var preferredDoc = document, pushNative = push;\n    (function() {\n        var i, Expr, outermostContext, sortInput, hasDuplicate, push = pushNative, // Local document vars\n        document, documentElement, documentIsHTML, rbuggyQSA, matches, // Instance-specific data\n        expando = jQuery.expando, dirruns = 0, done = 0, classCache = createCache(), tokenCache = createCache(), compilerCache = createCache(), nonnativeSelectorCache = createCache(), sortOrder = function(a, b) {\n            if (a === b) {\n                hasDuplicate = true;\n            }\n            return 0;\n        }, booleans = \"checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|\" + \"loop|multiple|open|readonly|required|scoped\", // Regular expressions\n        // https://www.w3.org/TR/css-syntax-3/#ident-token-diagram\n        identifier = \"(?:\\\\\\\\[\\\\da-fA-F]{1,6}\" + whitespace + \"?|\\\\\\\\[^\\\\r\\\\n\\\\f]|[\\\\w-]|[^\\x00-\\\\x7f])+\", // Attribute selectors: https://www.w3.org/TR/selectors/#attribute-selectors\n        attributes = \"\\\\[\" + whitespace + \"*(\" + identifier + \")(?:\" + whitespace + // Operator (capture 2)\n        \"*([*^$|!~]?=)\" + whitespace + // \"Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]\"\n        \"*(?:'((?:\\\\\\\\.|[^\\\\\\\\'])*)'|\\\"((?:\\\\\\\\.|[^\\\\\\\\\\\"])*)\\\"|(\" + identifier + \"))|)\" + whitespace + \"*\\\\]\", pseudos = \":(\" + identifier + \")(?:\\\\((\" + // To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:\n        // 1. quoted (capture 3; capture 4 or capture 5)\n        \"('((?:\\\\\\\\.|[^\\\\\\\\'])*)'|\\\"((?:\\\\\\\\.|[^\\\\\\\\\\\"])*)\\\")|\" + // 2. simple (capture 6)\n        \"((?:\\\\\\\\.|[^\\\\\\\\()[\\\\]]|\" + attributes + \")*)|\" + // 3. anything else (capture 2)\n        \".*\" + \")\\\\)|)\", // Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter\n        rwhitespace = new RegExp(whitespace + \"+\", \"g\"), rcomma = new RegExp(\"^\" + whitespace + \"*,\" + whitespace + \"*\"), rleadingCombinator = new RegExp(\"^\" + whitespace + \"*([>+~]|\" + whitespace + \")\" + whitespace + \"*\"), rdescend = new RegExp(whitespace + \"|>\"), rpseudo = new RegExp(pseudos), ridentifier = new RegExp(\"^\" + identifier + \"$\"), matchExpr = {\n            ID: new RegExp(\"^#(\" + identifier + \")\"),\n            CLASS: new RegExp(\"^\\\\.(\" + identifier + \")\"),\n            TAG: new RegExp(\"^(\" + identifier + \"|[*])\"),\n            ATTR: new RegExp(\"^\" + attributes),\n            PSEUDO: new RegExp(\"^\" + pseudos),\n            CHILD: new RegExp(\"^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\\\(\" + whitespace + \"*(even|odd|(([+-]|)(\\\\d*)n|)\" + whitespace + \"*(?:([+-]|)\" + whitespace + \"*(\\\\d+)|))\" + whitespace + \"*\\\\)|)\", \"i\"),\n            bool: new RegExp(\"^(?:\" + booleans + \")$\", \"i\"),\n            // For use in libraries implementing .is()\n            // We use this for POS matching in `select`\n            needsContext: new RegExp(\"^\" + whitespace + \"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\\\(\" + whitespace + \"*((?:-\\\\d)?\\\\d*)\" + whitespace + \"*\\\\)|)(?=[^-]|$)\", \"i\")\n        }, rinputs = /^(?:input|select|textarea|button)$/i, rheader = /^h\\d$/i, // Easily-parseable/retrievable ID or TAG or CLASS selectors\n        rquickExpr = /^(?:#([\\w-]+)|(\\w+)|\\.([\\w-]+))$/, rsibling = /[+~]/, // CSS escapes\n        // https://www.w3.org/TR/CSS21/syndata.html#escaped-characters\n        runescape = new RegExp(\"\\\\\\\\[\\\\da-fA-F]{1,6}\" + whitespace + \"?|\\\\\\\\([^\\\\r\\\\n\\\\f])\", \"g\"), funescape = function(escape, nonHex) {\n            var high = \"0x\" + escape.slice(1) - 0x10000;\n            if (nonHex) {\n                // Strip the backslash prefix from a non-hex escape sequence\n                return nonHex;\n            }\n            // Replace a hexadecimal escape sequence with the encoded Unicode code point\n            // Support: IE <=11+\n            // For values outside the Basic Multilingual Plane (BMP), manually construct a\n            // surrogate pair\n            return high < 0 ? String.fromCharCode(high + 0x10000) : String.fromCharCode(high >> 10 | 0xD800, high & 0x3FF | 0xDC00);\n        }, // Used for iframes; see `setDocument`.\n        // Support: IE 9 - 11+, Edge 12 - 18+\n        // Removing the function wrapper causes a \"Permission Denied\"\n        // error in IE/Edge.\n        unloadHandler = function() {\n            setDocument();\n        }, inDisabledFieldset = addCombinator(function(elem) {\n            return elem.disabled === true && nodeName(elem, \"fieldset\");\n        }, {\n            dir: \"parentNode\",\n            next: \"legend\"\n        });\n        // Support: IE <=9 only\n        // Accessing document.activeElement can throw unexpectedly\n        // https://bugs.jquery.com/ticket/13393\n        function safeActiveElement() {\n            try {\n                return document.activeElement;\n            } catch (err) {}\n        }\n        // Optimize for push.apply( _, NodeList )\n        try {\n            push.apply(arr = slice.call(preferredDoc.childNodes), preferredDoc.childNodes);\n            // Support: Android <=4.0\n            // Detect silently failing push.apply\n            // eslint-disable-next-line no-unused-expressions\n            arr[preferredDoc.childNodes.length].nodeType;\n        } catch (e) {\n            push = {\n                apply: function(target, els) {\n                    pushNative.apply(target, slice.call(els));\n                },\n                call: function(target) {\n                    pushNative.apply(target, slice.call(arguments, 1));\n                }\n            };\n        }\n        function find(selector, context, results, seed) {\n            var m, i, elem, nid, match, groups, newSelector, newContext = context && context.ownerDocument, // nodeType defaults to 9, since context defaults to document\n            nodeType = context ? context.nodeType : 9;\n            results = results || [];\n            // Return early from calls with invalid selector or context\n            if (typeof selector !== \"string\" || !selector || nodeType !== 1 && nodeType !== 9 && nodeType !== 11) {\n                return results;\n            }\n            // Try to shortcut find operations (as opposed to filters) in HTML documents\n            if (!seed) {\n                setDocument(context);\n                context = context || document;\n                if (documentIsHTML) {\n                    // If the selector is sufficiently simple, try using a \"get*By*\" DOM method\n                    // (excepting DocumentFragment context, where the methods don't exist)\n                    if (nodeType !== 11 && (match = rquickExpr.exec(selector))) {\n                        // ID selector\n                        if (m = match[1]) {\n                            // Document context\n                            if (nodeType === 9) {\n                                if (elem = context.getElementById(m)) {\n                                    // Support: IE 9 only\n                                    // getElementById can match elements by name instead of ID\n                                    if (elem.id === m) {\n                                        push.call(results, elem);\n                                        return results;\n                                    }\n                                } else {\n                                    return results;\n                                }\n                            // Element context\n                            } else {\n                                // Support: IE 9 only\n                                // getElementById can match elements by name instead of ID\n                                if (newContext && (elem = newContext.getElementById(m)) && find.contains(context, elem) && elem.id === m) {\n                                    push.call(results, elem);\n                                    return results;\n                                }\n                            }\n                        // Type selector\n                        } else if (match[2]) {\n                            push.apply(results, context.getElementsByTagName(selector));\n                            return results;\n                        // Class selector\n                        } else if ((m = match[3]) && context.getElementsByClassName) {\n                            push.apply(results, context.getElementsByClassName(m));\n                            return results;\n                        }\n                    }\n                    // Take advantage of querySelectorAll\n                    if (!nonnativeSelectorCache[selector + \" \"] && (!rbuggyQSA || !rbuggyQSA.test(selector))) {\n                        newSelector = selector;\n                        newContext = context;\n                        // qSA considers elements outside a scoping root when evaluating child or\n                        // descendant combinators, which is not what we want.\n                        // In such cases, we work around the behavior by prefixing every selector in the\n                        // list with an ID selector referencing the scope context.\n                        // The technique has to be used as well when a leading combinator is used\n                        // as such selectors are not recognized by querySelectorAll.\n                        // Thanks to Andrew Dupont for this technique.\n                        if (nodeType === 1 && (rdescend.test(selector) || rleadingCombinator.test(selector))) {\n                            // Expand context for sibling selectors\n                            newContext = rsibling.test(selector) && testContext(context.parentNode) || context;\n                            // We can use :scope instead of the ID hack if the browser\n                            // supports it & if we're not changing the context.\n                            // Support: IE 11+, Edge 17 - 18+\n                            // IE/Edge sometimes throw a \"Permission denied\" error when\n                            // strict-comparing two documents; shallow comparisons work.\n                            // eslint-disable-next-line eqeqeq\n                            if (newContext != context || !support.scope) {\n                                // Capture the context ID, setting it first if necessary\n                                if (nid = context.getAttribute(\"id\")) {\n                                    nid = jQuery.escapeSelector(nid);\n                                } else {\n                                    context.setAttribute(\"id\", nid = expando);\n                                }\n                            }\n                            // Prefix every selector in the list\n                            groups = tokenize(selector);\n                            i = groups.length;\n                            while(i--){\n                                groups[i] = (nid ? \"#\" + nid : \":scope\") + \" \" + toSelector(groups[i]);\n                            }\n                            newSelector = groups.join(\",\");\n                        }\n                        try {\n                            push.apply(results, newContext.querySelectorAll(newSelector));\n                            return results;\n                        } catch (qsaError) {\n                            nonnativeSelectorCache(selector, true);\n                        } finally{\n                            if (nid === expando) {\n                                context.removeAttribute(\"id\");\n                            }\n                        }\n                    }\n                }\n            }\n            // All others\n            return select(selector.replace(rtrimCSS, \"$1\"), context, results, seed);\n        }\n        /**\n * Create key-value caches of limited size\n * @returns {function(string, object)} Returns the Object data after storing it on itself with\n *\tproperty name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)\n *\tdeleting the oldest entry\n */ function createCache() {\n            var keys = [];\n            function cache(key, value) {\n                // Use (key + \" \") to avoid collision with native prototype properties\n                // (see https://github.com/jquery/sizzle/issues/157)\n                if (keys.push(key + \" \") > Expr.cacheLength) {\n                    // Only keep the most recent entries\n                    delete cache[keys.shift()];\n                }\n                return cache[key + \" \"] = value;\n            }\n            return cache;\n        }\n        /**\n * Mark a function for special use by jQuery selector module\n * @param {Function} fn The function to mark\n */ function markFunction(fn) {\n            fn[expando] = true;\n            return fn;\n        }\n        /**\n * Support testing using an element\n * @param {Function} fn Passed the created element and returns a boolean result\n */ function assert(fn) {\n            var el = document.createElement(\"fieldset\");\n            try {\n                return !!fn(el);\n            } catch (e) {\n                return false;\n            } finally{\n                // Remove from its parent by default\n                if (el.parentNode) {\n                    el.parentNode.removeChild(el);\n                }\n                // release memory in IE\n                el = null;\n            }\n        }\n        /**\n * Returns a function to use in pseudos for input types\n * @param {String} type\n */ function createInputPseudo(type) {\n            return function(elem) {\n                return nodeName(elem, \"input\") && elem.type === type;\n            };\n        }\n        /**\n * Returns a function to use in pseudos for buttons\n * @param {String} type\n */ function createButtonPseudo(type) {\n            return function(elem) {\n                return (nodeName(elem, \"input\") || nodeName(elem, \"button\")) && elem.type === type;\n            };\n        }\n        /**\n * Returns a function to use in pseudos for :enabled/:disabled\n * @param {Boolean} disabled true for :disabled; false for :enabled\n */ function createDisabledPseudo(disabled) {\n            // Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable\n            return function(elem) {\n                // Only certain elements can match :enabled or :disabled\n                // https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled\n                // https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled\n                if (\"form\" in elem) {\n                    // Check for inherited disabledness on relevant non-disabled elements:\n                    // * listed form-associated elements in a disabled fieldset\n                    //   https://html.spec.whatwg.org/multipage/forms.html#category-listed\n                    //   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled\n                    // * option elements in a disabled optgroup\n                    //   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled\n                    // All such elements have a \"form\" property.\n                    if (elem.parentNode && elem.disabled === false) {\n                        // Option elements defer to a parent optgroup if present\n                        if (\"label\" in elem) {\n                            if (\"label\" in elem.parentNode) {\n                                return elem.parentNode.disabled === disabled;\n                            } else {\n                                return elem.disabled === disabled;\n                            }\n                        }\n                        // Support: IE 6 - 11+\n                        // Use the isDisabled shortcut property to check for disabled fieldset ancestors\n                        return elem.isDisabled === disabled || // Where there is no isDisabled, check manually\n                        elem.isDisabled !== !disabled && inDisabledFieldset(elem) === disabled;\n                    }\n                    return elem.disabled === disabled;\n                // Try to winnow out elements that can't be disabled before trusting the disabled property.\n                // Some victims get caught in our net (label, legend, menu, track), but it shouldn't\n                // even exist on them, let alone have a boolean value.\n                } else if (\"label\" in elem) {\n                    return elem.disabled === disabled;\n                }\n                // Remaining elements are neither :enabled nor :disabled\n                return false;\n            };\n        }\n        /**\n * Returns a function to use in pseudos for positionals\n * @param {Function} fn\n */ function createPositionalPseudo(fn) {\n            return markFunction(function(argument) {\n                argument = +argument;\n                return markFunction(function(seed, matches) {\n                    var j, matchIndexes = fn([], seed.length, argument), i = matchIndexes.length;\n                    // Match elements found at the specified indexes\n                    while(i--){\n                        if (seed[j = matchIndexes[i]]) {\n                            seed[j] = !(matches[j] = seed[j]);\n                        }\n                    }\n                });\n            });\n        }\n        /**\n * Checks a node for validity as a jQuery selector context\n * @param {Element|Object=} context\n * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value\n */ function testContext(context) {\n            return context && typeof context.getElementsByTagName !== \"undefined\" && context;\n        }\n        /**\n * Sets document-related variables once based on the current document\n * @param {Element|Object} [node] An element or document object to use to set the document\n * @returns {Object} Returns the current document\n */ function setDocument(node) {\n            var subWindow, doc = node ? node.ownerDocument || node : preferredDoc;\n            // Return early if doc is invalid or already selected\n            // Support: IE 11+, Edge 17 - 18+\n            // IE/Edge sometimes throw a \"Permission denied\" error when strict-comparing\n            // two documents; shallow comparisons work.\n            // eslint-disable-next-line eqeqeq\n            if (doc == document || doc.nodeType !== 9 || !doc.documentElement) {\n                return document;\n            }\n            // Update global variables\n            document = doc;\n            documentElement = document.documentElement;\n            documentIsHTML = !jQuery.isXMLDoc(document);\n            // Support: iOS 7 only, IE 9 - 11+\n            // Older browsers didn't support unprefixed `matches`.\n            matches = documentElement.matches || documentElement.webkitMatchesSelector || documentElement.msMatchesSelector;\n            // Support: IE 9 - 11+, Edge 12 - 18+\n            // Accessing iframe documents after unload throws \"permission denied\" errors\n            // (see trac-13936).\n            // Limit the fix to IE & Edge Legacy; despite Edge 15+ implementing `matches`,\n            // all IE 9+ and Edge Legacy versions implement `msMatchesSelector` as well.\n            if (documentElement.msMatchesSelector && // Support: IE 11+, Edge 17 - 18+\n            // IE/Edge sometimes throw a \"Permission denied\" error when strict-comparing\n            // two documents; shallow comparisons work.\n            // eslint-disable-next-line eqeqeq\n            preferredDoc != document && (subWindow = document.defaultView) && subWindow.top !== subWindow) {\n                // Support: IE 9 - 11+, Edge 12 - 18+\n                subWindow.addEventListener(\"unload\", unloadHandler);\n            }\n            // Support: IE <10\n            // Check if getElementById returns elements by name\n            // The broken getElementById methods don't pick up programmatically-set names,\n            // so use a roundabout getElementsByName test\n            support.getById = assert(function(el) {\n                documentElement.appendChild(el).id = jQuery.expando;\n                return !document.getElementsByName || !document.getElementsByName(jQuery.expando).length;\n            });\n            // Support: IE 9 only\n            // Check to see if it's possible to do matchesSelector\n            // on a disconnected node.\n            support.disconnectedMatch = assert(function(el) {\n                return matches.call(el, \"*\");\n            });\n            // Support: IE 9 - 11+, Edge 12 - 18+\n            // IE/Edge don't support the :scope pseudo-class.\n            support.scope = assert(function() {\n                return document.querySelectorAll(\":scope\");\n            });\n            // Support: Chrome 105 - 111 only, Safari 15.4 - 16.3 only\n            // Make sure the `:has()` argument is parsed unforgivingly.\n            // We include `*` in the test to detect buggy implementations that are\n            // _selectively_ forgiving (specifically when the list includes at least\n            // one valid selector).\n            // Note that we treat complete lack of support for `:has()` as if it were\n            // spec-compliant support, which is fine because use of `:has()` in such\n            // environments will fail in the qSA path and fall back to jQuery traversal\n            // anyway.\n            support.cssHas = assert(function() {\n                try {\n                    document.querySelector(\":has(*,:jqfake)\");\n                    return false;\n                } catch (e) {\n                    return true;\n                }\n            });\n            // ID filter and find\n            if (support.getById) {\n                Expr.filter.ID = function(id) {\n                    var attrId = id.replace(runescape, funescape);\n                    return function(elem) {\n                        return elem.getAttribute(\"id\") === attrId;\n                    };\n                };\n                Expr.find.ID = function(id, context) {\n                    if (typeof context.getElementById !== \"undefined\" && documentIsHTML) {\n                        var elem = context.getElementById(id);\n                        return elem ? [\n                            elem\n                        ] : [];\n                    }\n                };\n            } else {\n                Expr.filter.ID = function(id) {\n                    var attrId = id.replace(runescape, funescape);\n                    return function(elem) {\n                        var node = typeof elem.getAttributeNode !== \"undefined\" && elem.getAttributeNode(\"id\");\n                        return node && node.value === attrId;\n                    };\n                };\n                // Support: IE 6 - 7 only\n                // getElementById is not reliable as a find shortcut\n                Expr.find.ID = function(id, context) {\n                    if (typeof context.getElementById !== \"undefined\" && documentIsHTML) {\n                        var node, i, elems, elem = context.getElementById(id);\n                        if (elem) {\n                            // Verify the id attribute\n                            node = elem.getAttributeNode(\"id\");\n                            if (node && node.value === id) {\n                                return [\n                                    elem\n                                ];\n                            }\n                            // Fall back on getElementsByName\n                            elems = context.getElementsByName(id);\n                            i = 0;\n                            while(elem = elems[i++]){\n                                node = elem.getAttributeNode(\"id\");\n                                if (node && node.value === id) {\n                                    return [\n                                        elem\n                                    ];\n                                }\n                            }\n                        }\n                        return [];\n                    }\n                };\n            }\n            // Tag\n            Expr.find.TAG = function(tag, context) {\n                if (typeof context.getElementsByTagName !== \"undefined\") {\n                    return context.getElementsByTagName(tag);\n                // DocumentFragment nodes don't have gEBTN\n                } else {\n                    return context.querySelectorAll(tag);\n                }\n            };\n            // Class\n            Expr.find.CLASS = function(className, context) {\n                if (typeof context.getElementsByClassName !== \"undefined\" && documentIsHTML) {\n                    return context.getElementsByClassName(className);\n                }\n            };\n            /* QSA/matchesSelector\n\t---------------------------------------------------------------------- */ // QSA and matchesSelector support\n            rbuggyQSA = [];\n            // Build QSA regex\n            // Regex strategy adopted from Diego Perini\n            assert(function(el) {\n                var input;\n                documentElement.appendChild(el).innerHTML = \"<a id='\" + expando + \"' href='' disabled='disabled'></a>\" + \"<select id='\" + expando + \"-\\r\\\\' disabled='disabled'>\" + \"<option selected=''></option></select>\";\n                // Support: iOS <=7 - 8 only\n                // Boolean attributes and \"value\" are not treated correctly in some XML documents\n                if (!el.querySelectorAll(\"[selected]\").length) {\n                    rbuggyQSA.push(\"\\\\[\" + whitespace + \"*(?:value|\" + booleans + \")\");\n                }\n                // Support: iOS <=7 - 8 only\n                if (!el.querySelectorAll(\"[id~=\" + expando + \"-]\").length) {\n                    rbuggyQSA.push(\"~=\");\n                }\n                // Support: iOS 8 only\n                // https://bugs.webkit.org/show_bug.cgi?id=136851\n                // In-page `selector#id sibling-combinator selector` fails\n                if (!el.querySelectorAll(\"a#\" + expando + \"+*\").length) {\n                    rbuggyQSA.push(\".#.+[+~]\");\n                }\n                // Support: Chrome <=105+, Firefox <=104+, Safari <=15.4+\n                // In some of the document kinds, these selectors wouldn't work natively.\n                // This is probably OK but for backwards compatibility we want to maintain\n                // handling them through jQuery traversal in jQuery 3.x.\n                if (!el.querySelectorAll(\":checked\").length) {\n                    rbuggyQSA.push(\":checked\");\n                }\n                // Support: Windows 8 Native Apps\n                // The type and name attributes are restricted during .innerHTML assignment\n                input = document.createElement(\"input\");\n                input.setAttribute(\"type\", \"hidden\");\n                el.appendChild(input).setAttribute(\"name\", \"D\");\n                // Support: IE 9 - 11+\n                // IE's :disabled selector does not pick up the children of disabled fieldsets\n                // Support: Chrome <=105+, Firefox <=104+, Safari <=15.4+\n                // In some of the document kinds, these selectors wouldn't work natively.\n                // This is probably OK but for backwards compatibility we want to maintain\n                // handling them through jQuery traversal in jQuery 3.x.\n                documentElement.appendChild(el).disabled = true;\n                if (el.querySelectorAll(\":disabled\").length !== 2) {\n                    rbuggyQSA.push(\":enabled\", \":disabled\");\n                }\n                // Support: IE 11+, Edge 15 - 18+\n                // IE 11/Edge don't find elements on a `[name='']` query in some cases.\n                // Adding a temporary attribute to the document before the selection works\n                // around the issue.\n                // Interestingly, IE 10 & older don't seem to have the issue.\n                input = document.createElement(\"input\");\n                input.setAttribute(\"name\", \"\");\n                el.appendChild(input);\n                if (!el.querySelectorAll(\"[name='']\").length) {\n                    rbuggyQSA.push(\"\\\\[\" + whitespace + \"*name\" + whitespace + \"*=\" + whitespace + \"*(?:''|\\\"\\\")\");\n                }\n            });\n            if (!support.cssHas) {\n                // Support: Chrome 105 - 110+, Safari 15.4 - 16.3+\n                // Our regular `try-catch` mechanism fails to detect natively-unsupported\n                // pseudo-classes inside `:has()` (such as `:has(:contains(\"Foo\"))`)\n                // in browsers that parse the `:has()` argument as a forgiving selector list.\n                // https://drafts.csswg.org/selectors/#relational now requires the argument\n                // to be parsed unforgivingly, but browsers have not yet fully adjusted.\n                rbuggyQSA.push(\":has\");\n            }\n            rbuggyQSA = rbuggyQSA.length && new RegExp(rbuggyQSA.join(\"|\"));\n            /* Sorting\n\t---------------------------------------------------------------------- */ // Document order sorting\n            sortOrder = function(a, b) {\n                // Flag for duplicate removal\n                if (a === b) {\n                    hasDuplicate = true;\n                    return 0;\n                }\n                // Sort on method existence if only one input has compareDocumentPosition\n                var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;\n                if (compare) {\n                    return compare;\n                }\n                // Calculate position if both inputs belong to the same document\n                // Support: IE 11+, Edge 17 - 18+\n                // IE/Edge sometimes throw a \"Permission denied\" error when strict-comparing\n                // two documents; shallow comparisons work.\n                // eslint-disable-next-line eqeqeq\n                compare = (a.ownerDocument || a) == (b.ownerDocument || b) ? a.compareDocumentPosition(b) : // Otherwise we know they are disconnected\n                1;\n                // Disconnected nodes\n                if (compare & 1 || !support.sortDetached && b.compareDocumentPosition(a) === compare) {\n                    // Choose the first element that is related to our preferred document\n                    // Support: IE 11+, Edge 17 - 18+\n                    // IE/Edge sometimes throw a \"Permission denied\" error when strict-comparing\n                    // two documents; shallow comparisons work.\n                    // eslint-disable-next-line eqeqeq\n                    if (a === document || a.ownerDocument == preferredDoc && find.contains(preferredDoc, a)) {\n                        return -1;\n                    }\n                    // Support: IE 11+, Edge 17 - 18+\n                    // IE/Edge sometimes throw a \"Permission denied\" error when strict-comparing\n                    // two documents; shallow comparisons work.\n                    // eslint-disable-next-line eqeqeq\n                    if (b === document || b.ownerDocument == preferredDoc && find.contains(preferredDoc, b)) {\n                        return 1;\n                    }\n                    // Maintain original order\n                    return sortInput ? indexOf.call(sortInput, a) - indexOf.call(sortInput, b) : 0;\n                }\n                return compare & 4 ? -1 : 1;\n            };\n            return document;\n        }\n        find.matches = function(expr, elements) {\n            return find(expr, null, null, elements);\n        };\n        find.matchesSelector = function(elem, expr) {\n            setDocument(elem);\n            if (documentIsHTML && !nonnativeSelectorCache[expr + \" \"] && (!rbuggyQSA || !rbuggyQSA.test(expr))) {\n                try {\n                    var ret = matches.call(elem, expr);\n                    // IE 9's matchesSelector returns false on disconnected nodes\n                    if (ret || support.disconnectedMatch || // As well, disconnected nodes are said to be in a document\n                    // fragment in IE 9\n                    elem.document && elem.document.nodeType !== 11) {\n                        return ret;\n                    }\n                } catch (e) {\n                    nonnativeSelectorCache(expr, true);\n                }\n            }\n            return find(expr, document, null, [\n                elem\n            ]).length > 0;\n        };\n        find.contains = function(context, elem) {\n            // Set document vars if needed\n            // Support: IE 11+, Edge 17 - 18+\n            // IE/Edge sometimes throw a \"Permission denied\" error when strict-comparing\n            // two documents; shallow comparisons work.\n            // eslint-disable-next-line eqeqeq\n            if ((context.ownerDocument || context) != document) {\n                setDocument(context);\n            }\n            return jQuery.contains(context, elem);\n        };\n        find.attr = function(elem, name) {\n            // Set document vars if needed\n            // Support: IE 11+, Edge 17 - 18+\n            // IE/Edge sometimes throw a \"Permission denied\" error when strict-comparing\n            // two documents; shallow comparisons work.\n            // eslint-disable-next-line eqeqeq\n            if ((elem.ownerDocument || elem) != document) {\n                setDocument(elem);\n            }\n            var fn = Expr.attrHandle[name.toLowerCase()], // Don't get fooled by Object.prototype properties (see trac-13807)\n            val = fn && hasOwn.call(Expr.attrHandle, name.toLowerCase()) ? fn(elem, name, !documentIsHTML) : undefined;\n            if (val !== undefined) {\n                return val;\n            }\n            return elem.getAttribute(name);\n        };\n        find.error = function(msg) {\n            throw new Error(\"Syntax error, unrecognized expression: \" + msg);\n        };\n        /**\n * Document sorting and removing duplicates\n * @param {ArrayLike} results\n */ jQuery.uniqueSort = function(results) {\n            var elem, duplicates = [], j = 0, i = 0;\n            // Unless we *know* we can detect duplicates, assume their presence\n            //\n            // Support: Android <=4.0+\n            // Testing for detecting duplicates is unpredictable so instead assume we can't\n            // depend on duplicate detection in all browsers without a stable sort.\n            hasDuplicate = !support.sortStable;\n            sortInput = !support.sortStable && slice.call(results, 0);\n            sort.call(results, sortOrder);\n            if (hasDuplicate) {\n                while(elem = results[i++]){\n                    if (elem === results[i]) {\n                        j = duplicates.push(i);\n                    }\n                }\n                while(j--){\n                    splice.call(results, duplicates[j], 1);\n                }\n            }\n            // Clear input after sorting to release objects\n            // See https://github.com/jquery/sizzle/pull/225\n            sortInput = null;\n            return results;\n        };\n        jQuery.fn.uniqueSort = function() {\n            return this.pushStack(jQuery.uniqueSort(slice.apply(this)));\n        };\n        Expr = jQuery.expr = {\n            // Can be adjusted by the user\n            cacheLength: 50,\n            createPseudo: markFunction,\n            match: matchExpr,\n            attrHandle: {},\n            find: {},\n            relative: {\n                \">\": {\n                    dir: \"parentNode\",\n                    first: true\n                },\n                \" \": {\n                    dir: \"parentNode\"\n                },\n                \"+\": {\n                    dir: \"previousSibling\",\n                    first: true\n                },\n                \"~\": {\n                    dir: \"previousSibling\"\n                }\n            },\n            preFilter: {\n                ATTR: function(match) {\n                    match[1] = match[1].replace(runescape, funescape);\n                    // Move the given value to match[3] whether quoted or unquoted\n                    match[3] = (match[3] || match[4] || match[5] || \"\").replace(runescape, funescape);\n                    if (match[2] === \"~=\") {\n                        match[3] = \" \" + match[3] + \" \";\n                    }\n                    return match.slice(0, 4);\n                },\n                CHILD: function(match) {\n                    /* matches from matchExpr[\"CHILD\"]\n\t\t\t\t1 type (only|nth|...)\n\t\t\t\t2 what (child|of-type)\n\t\t\t\t3 argument (even|odd|\\d*|\\d*n([+-]\\d+)?|...)\n\t\t\t\t4 xn-component of xn+y argument ([+-]?\\d*n|)\n\t\t\t\t5 sign of xn-component\n\t\t\t\t6 x of xn-component\n\t\t\t\t7 sign of y-component\n\t\t\t\t8 y of y-component\n\t\t\t*/ match[1] = match[1].toLowerCase();\n                    if (match[1].slice(0, 3) === \"nth\") {\n                        // nth-* requires argument\n                        if (!match[3]) {\n                            find.error(match[0]);\n                        }\n                        // numeric x and y parameters for Expr.filter.CHILD\n                        // remember that false/true cast respectively to 0/1\n                        match[4] = +(match[4] ? match[5] + (match[6] || 1) : 2 * (match[3] === \"even\" || match[3] === \"odd\"));\n                        match[5] = +(match[7] + match[8] || match[3] === \"odd\");\n                    // other types prohibit arguments\n                    } else if (match[3]) {\n                        find.error(match[0]);\n                    }\n                    return match;\n                },\n                PSEUDO: function(match) {\n                    var excess, unquoted = !match[6] && match[2];\n                    if (matchExpr.CHILD.test(match[0])) {\n                        return null;\n                    }\n                    // Accept quoted arguments as-is\n                    if (match[3]) {\n                        match[2] = match[4] || match[5] || \"\";\n                    // Strip excess characters from unquoted arguments\n                    } else if (unquoted && rpseudo.test(unquoted) && // Get excess from tokenize (recursively)\n                    (excess = tokenize(unquoted, true)) && // advance to the next closing parenthesis\n                    (excess = unquoted.indexOf(\")\", unquoted.length - excess) - unquoted.length)) {\n                        // excess is a negative index\n                        match[0] = match[0].slice(0, excess);\n                        match[2] = unquoted.slice(0, excess);\n                    }\n                    // Return only captures needed by the pseudo filter method (type and argument)\n                    return match.slice(0, 3);\n                }\n            },\n            filter: {\n                TAG: function(nodeNameSelector) {\n                    var expectedNodeName = nodeNameSelector.replace(runescape, funescape).toLowerCase();\n                    return nodeNameSelector === \"*\" ? function() {\n                        return true;\n                    } : function(elem) {\n                        return nodeName(elem, expectedNodeName);\n                    };\n                },\n                CLASS: function(className) {\n                    var pattern = classCache[className + \" \"];\n                    return pattern || (pattern = new RegExp(\"(^|\" + whitespace + \")\" + className + \"(\" + whitespace + \"|$)\")) && classCache(className, function(elem) {\n                        return pattern.test(typeof elem.className === \"string\" && elem.className || typeof elem.getAttribute !== \"undefined\" && elem.getAttribute(\"class\") || \"\");\n                    });\n                },\n                ATTR: function(name, operator, check) {\n                    return function(elem) {\n                        var result = find.attr(elem, name);\n                        if (result == null) {\n                            return operator === \"!=\";\n                        }\n                        if (!operator) {\n                            return true;\n                        }\n                        result += \"\";\n                        if (operator === \"=\") {\n                            return result === check;\n                        }\n                        if (operator === \"!=\") {\n                            return result !== check;\n                        }\n                        if (operator === \"^=\") {\n                            return check && result.indexOf(check) === 0;\n                        }\n                        if (operator === \"*=\") {\n                            return check && result.indexOf(check) > -1;\n                        }\n                        if (operator === \"$=\") {\n                            return check && result.slice(-check.length) === check;\n                        }\n                        if (operator === \"~=\") {\n                            return (\" \" + result.replace(rwhitespace, \" \") + \" \").indexOf(check) > -1;\n                        }\n                        if (operator === \"|=\") {\n                            return result === check || result.slice(0, check.length + 1) === check + \"-\";\n                        }\n                        return false;\n                    };\n                },\n                CHILD: function(type, what, _argument, first, last) {\n                    var simple = type.slice(0, 3) !== \"nth\", forward = type.slice(-4) !== \"last\", ofType = what === \"of-type\";\n                    return first === 1 && last === 0 ? // Shortcut for :nth-*(n)\n                    function(elem) {\n                        return !!elem.parentNode;\n                    } : function(elem, _context, xml) {\n                        var cache, outerCache, node, nodeIndex, start, dir = simple !== forward ? \"nextSibling\" : \"previousSibling\", parent = elem.parentNode, name = ofType && elem.nodeName.toLowerCase(), useCache = !xml && !ofType, diff = false;\n                        if (parent) {\n                            // :(first|last|only)-(child|of-type)\n                            if (simple) {\n                                while(dir){\n                                    node = elem;\n                                    while(node = node[dir]){\n                                        if (ofType ? nodeName(node, name) : node.nodeType === 1) {\n                                            return false;\n                                        }\n                                    }\n                                    // Reverse direction for :only-* (if we haven't yet done so)\n                                    start = dir = type === \"only\" && !start && \"nextSibling\";\n                                }\n                                return true;\n                            }\n                            start = [\n                                forward ? parent.firstChild : parent.lastChild\n                            ];\n                            // non-xml :nth-child(...) stores cache data on `parent`\n                            if (forward && useCache) {\n                                // Seek `elem` from a previously-cached index\n                                outerCache = parent[expando] || (parent[expando] = {});\n                                cache = outerCache[type] || [];\n                                nodeIndex = cache[0] === dirruns && cache[1];\n                                diff = nodeIndex && cache[2];\n                                node = nodeIndex && parent.childNodes[nodeIndex];\n                                while(node = ++nodeIndex && node && node[dir] || // Fallback to seeking `elem` from the start\n                                (diff = nodeIndex = 0) || start.pop()){\n                                    // When found, cache indexes on `parent` and break\n                                    if (node.nodeType === 1 && ++diff && node === elem) {\n                                        outerCache[type] = [\n                                            dirruns,\n                                            nodeIndex,\n                                            diff\n                                        ];\n                                        break;\n                                    }\n                                }\n                            } else {\n                                // Use previously-cached element index if available\n                                if (useCache) {\n                                    outerCache = elem[expando] || (elem[expando] = {});\n                                    cache = outerCache[type] || [];\n                                    nodeIndex = cache[0] === dirruns && cache[1];\n                                    diff = nodeIndex;\n                                }\n                                // xml :nth-child(...)\n                                // or :nth-last-child(...) or :nth(-last)?-of-type(...)\n                                if (diff === false) {\n                                    // Use the same loop as above to seek `elem` from the start\n                                    while(node = ++nodeIndex && node && node[dir] || (diff = nodeIndex = 0) || start.pop()){\n                                        if ((ofType ? nodeName(node, name) : node.nodeType === 1) && ++diff) {\n                                            // Cache the index of each encountered element\n                                            if (useCache) {\n                                                outerCache = node[expando] || (node[expando] = {});\n                                                outerCache[type] = [\n                                                    dirruns,\n                                                    diff\n                                                ];\n                                            }\n                                            if (node === elem) {\n                                                break;\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                            // Incorporate the offset, then check against cycle size\n                            diff -= last;\n                            return diff === first || diff % first === 0 && diff / first >= 0;\n                        }\n                    };\n                },\n                PSEUDO: function(pseudo, argument) {\n                    // pseudo-class names are case-insensitive\n                    // https://www.w3.org/TR/selectors/#pseudo-classes\n                    // Prioritize by case sensitivity in case custom pseudos are added with uppercase letters\n                    // Remember that setFilters inherits from pseudos\n                    var args, fn = Expr.pseudos[pseudo] || Expr.setFilters[pseudo.toLowerCase()] || find.error(\"unsupported pseudo: \" + pseudo);\n                    // The user may use createPseudo to indicate that\n                    // arguments are needed to create the filter function\n                    // just as jQuery does\n                    if (fn[expando]) {\n                        return fn(argument);\n                    }\n                    // But maintain support for old signatures\n                    if (fn.length > 1) {\n                        args = [\n                            pseudo,\n                            pseudo,\n                            \"\",\n                            argument\n                        ];\n                        return Expr.setFilters.hasOwnProperty(pseudo.toLowerCase()) ? markFunction(function(seed, matches) {\n                            var idx, matched = fn(seed, argument), i = matched.length;\n                            while(i--){\n                                idx = indexOf.call(seed, matched[i]);\n                                seed[idx] = !(matches[idx] = matched[i]);\n                            }\n                        }) : function(elem) {\n                            return fn(elem, 0, args);\n                        };\n                    }\n                    return fn;\n                }\n            },\n            pseudos: {\n                // Potentially complex pseudos\n                not: markFunction(function(selector) {\n                    // Trim the selector passed to compile\n                    // to avoid treating leading and trailing\n                    // spaces as combinators\n                    var input = [], results = [], matcher = compile(selector.replace(rtrimCSS, \"$1\"));\n                    return matcher[expando] ? markFunction(function(seed, matches, _context, xml) {\n                        var elem, unmatched = matcher(seed, null, xml, []), i = seed.length;\n                        // Match elements unmatched by `matcher`\n                        while(i--){\n                            if (elem = unmatched[i]) {\n                                seed[i] = !(matches[i] = elem);\n                            }\n                        }\n                    }) : function(elem, _context, xml) {\n                        input[0] = elem;\n                        matcher(input, null, xml, results);\n                        // Don't keep the element\n                        // (see https://github.com/jquery/sizzle/issues/299)\n                        input[0] = null;\n                        return !results.pop();\n                    };\n                }),\n                has: markFunction(function(selector) {\n                    return function(elem) {\n                        return find(selector, elem).length > 0;\n                    };\n                }),\n                contains: markFunction(function(text) {\n                    text = text.replace(runescape, funescape);\n                    return function(elem) {\n                        return (elem.textContent || jQuery.text(elem)).indexOf(text) > -1;\n                    };\n                }),\n                // \"Whether an element is represented by a :lang() selector\n                // is based solely on the element's language value\n                // being equal to the identifier C,\n                // or beginning with the identifier C immediately followed by \"-\".\n                // The matching of C against the element's language value is performed case-insensitively.\n                // The identifier C does not have to be a valid language name.\"\n                // https://www.w3.org/TR/selectors/#lang-pseudo\n                lang: markFunction(function(lang) {\n                    // lang value must be a valid identifier\n                    if (!ridentifier.test(lang || \"\")) {\n                        find.error(\"unsupported lang: \" + lang);\n                    }\n                    lang = lang.replace(runescape, funescape).toLowerCase();\n                    return function(elem) {\n                        var elemLang;\n                        do {\n                            if (elemLang = documentIsHTML ? elem.lang : elem.getAttribute(\"xml:lang\") || elem.getAttribute(\"lang\")) {\n                                elemLang = elemLang.toLowerCase();\n                                return elemLang === lang || elemLang.indexOf(lang + \"-\") === 0;\n                            }\n                        }while ((elem = elem.parentNode) && elem.nodeType === 1);\n                        return false;\n                    };\n                }),\n                // Miscellaneous\n                target: function(elem) {\n                    var hash = window1.location && window1.location.hash;\n                    return hash && hash.slice(1) === elem.id;\n                },\n                root: function(elem) {\n                    return elem === documentElement;\n                },\n                focus: function(elem) {\n                    return elem === safeActiveElement() && document.hasFocus() && !!(elem.type || elem.href || ~elem.tabIndex);\n                },\n                // Boolean properties\n                enabled: createDisabledPseudo(false),\n                disabled: createDisabledPseudo(true),\n                checked: function(elem) {\n                    // In CSS3, :checked should return both checked and selected elements\n                    // https://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked\n                    return nodeName(elem, \"input\") && !!elem.checked || nodeName(elem, \"option\") && !!elem.selected;\n                },\n                selected: function(elem) {\n                    // Support: IE <=11+\n                    // Accessing the selectedIndex property\n                    // forces the browser to treat the default option as\n                    // selected when in an optgroup.\n                    if (elem.parentNode) {\n                        // eslint-disable-next-line no-unused-expressions\n                        elem.parentNode.selectedIndex;\n                    }\n                    return elem.selected === true;\n                },\n                // Contents\n                empty: function(elem) {\n                    // https://www.w3.org/TR/selectors/#empty-pseudo\n                    // :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),\n                    //   but not by others (comment: 8; processing instruction: 7; etc.)\n                    // nodeType < 6 works because attributes (2) do not appear as children\n                    for(elem = elem.firstChild; elem; elem = elem.nextSibling){\n                        if (elem.nodeType < 6) {\n                            return false;\n                        }\n                    }\n                    return true;\n                },\n                parent: function(elem) {\n                    return !Expr.pseudos.empty(elem);\n                },\n                // Element/input types\n                header: function(elem) {\n                    return rheader.test(elem.nodeName);\n                },\n                input: function(elem) {\n                    return rinputs.test(elem.nodeName);\n                },\n                button: function(elem) {\n                    return nodeName(elem, \"input\") && elem.type === \"button\" || nodeName(elem, \"button\");\n                },\n                text: function(elem) {\n                    var attr;\n                    return nodeName(elem, \"input\") && elem.type === \"text\" && // Support: IE <10 only\n                    // New HTML5 attribute values (e.g., \"search\") appear\n                    // with elem.type === \"text\"\n                    ((attr = elem.getAttribute(\"type\")) == null || attr.toLowerCase() === \"text\");\n                },\n                // Position-in-collection\n                first: createPositionalPseudo(function() {\n                    return [\n                        0\n                    ];\n                }),\n                last: createPositionalPseudo(function(_matchIndexes, length) {\n                    return [\n                        length - 1\n                    ];\n                }),\n                eq: createPositionalPseudo(function(_matchIndexes, length, argument) {\n                    return [\n                        argument < 0 ? argument + length : argument\n                    ];\n                }),\n                even: createPositionalPseudo(function(matchIndexes, length) {\n                    var i = 0;\n                    for(; i < length; i += 2){\n                        matchIndexes.push(i);\n                    }\n                    return matchIndexes;\n                }),\n                odd: createPositionalPseudo(function(matchIndexes, length) {\n                    var i = 1;\n                    for(; i < length; i += 2){\n                        matchIndexes.push(i);\n                    }\n                    return matchIndexes;\n                }),\n                lt: createPositionalPseudo(function(matchIndexes, length, argument) {\n                    var i;\n                    if (argument < 0) {\n                        i = argument + length;\n                    } else if (argument > length) {\n                        i = length;\n                    } else {\n                        i = argument;\n                    }\n                    for(; --i >= 0;){\n                        matchIndexes.push(i);\n                    }\n                    return matchIndexes;\n                }),\n                gt: createPositionalPseudo(function(matchIndexes, length, argument) {\n                    var i = argument < 0 ? argument + length : argument;\n                    for(; ++i < length;){\n                        matchIndexes.push(i);\n                    }\n                    return matchIndexes;\n                })\n            }\n        };\n        Expr.pseudos.nth = Expr.pseudos.eq;\n        // Add button/input type pseudos\n        for(i in {\n            radio: true,\n            checkbox: true,\n            file: true,\n            password: true,\n            image: true\n        }){\n            Expr.pseudos[i] = createInputPseudo(i);\n        }\n        for(i in {\n            submit: true,\n            reset: true\n        }){\n            Expr.pseudos[i] = createButtonPseudo(i);\n        }\n        // Easy API for creating new setFilters\n        function setFilters() {}\n        setFilters.prototype = Expr.filters = Expr.pseudos;\n        Expr.setFilters = new setFilters();\n        function tokenize(selector, parseOnly) {\n            var matched, match, tokens, type, soFar, groups, preFilters, cached = tokenCache[selector + \" \"];\n            if (cached) {\n                return parseOnly ? 0 : cached.slice(0);\n            }\n            soFar = selector;\n            groups = [];\n            preFilters = Expr.preFilter;\n            while(soFar){\n                // Comma and first run\n                if (!matched || (match = rcomma.exec(soFar))) {\n                    if (match) {\n                        // Don't consume trailing commas as valid\n                        soFar = soFar.slice(match[0].length) || soFar;\n                    }\n                    groups.push(tokens = []);\n                }\n                matched = false;\n                // Combinators\n                if (match = rleadingCombinator.exec(soFar)) {\n                    matched = match.shift();\n                    tokens.push({\n                        value: matched,\n                        // Cast descendant combinators to space\n                        type: match[0].replace(rtrimCSS, \" \")\n                    });\n                    soFar = soFar.slice(matched.length);\n                }\n                // Filters\n                for(type in Expr.filter){\n                    if ((match = matchExpr[type].exec(soFar)) && (!preFilters[type] || (match = preFilters[type](match)))) {\n                        matched = match.shift();\n                        tokens.push({\n                            value: matched,\n                            type: type,\n                            matches: match\n                        });\n                        soFar = soFar.slice(matched.length);\n                    }\n                }\n                if (!matched) {\n                    break;\n                }\n            }\n            // Return the length of the invalid excess\n            // if we're just parsing\n            // Otherwise, throw an error or return tokens\n            if (parseOnly) {\n                return soFar.length;\n            }\n            return soFar ? find.error(selector) : // Cache the tokens\n            tokenCache(selector, groups).slice(0);\n        }\n        function toSelector(tokens) {\n            var i = 0, len = tokens.length, selector = \"\";\n            for(; i < len; i++){\n                selector += tokens[i].value;\n            }\n            return selector;\n        }\n        function addCombinator(matcher, combinator, base) {\n            var dir = combinator.dir, skip = combinator.next, key = skip || dir, checkNonElements = base && key === \"parentNode\", doneName = done++;\n            return combinator.first ? // Check against closest ancestor/preceding element\n            function(elem, context, xml) {\n                while(elem = elem[dir]){\n                    if (elem.nodeType === 1 || checkNonElements) {\n                        return matcher(elem, context, xml);\n                    }\n                }\n                return false;\n            } : // Check against all ancestor/preceding elements\n            function(elem, context, xml) {\n                var oldCache, outerCache, newCache = [\n                    dirruns,\n                    doneName\n                ];\n                // We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching\n                if (xml) {\n                    while(elem = elem[dir]){\n                        if (elem.nodeType === 1 || checkNonElements) {\n                            if (matcher(elem, context, xml)) {\n                                return true;\n                            }\n                        }\n                    }\n                } else {\n                    while(elem = elem[dir]){\n                        if (elem.nodeType === 1 || checkNonElements) {\n                            outerCache = elem[expando] || (elem[expando] = {});\n                            if (skip && nodeName(elem, skip)) {\n                                elem = elem[dir] || elem;\n                            } else if ((oldCache = outerCache[key]) && oldCache[0] === dirruns && oldCache[1] === doneName) {\n                                // Assign to newCache so results back-propagate to previous elements\n                                return newCache[2] = oldCache[2];\n                            } else {\n                                // Reuse newcache so results back-propagate to previous elements\n                                outerCache[key] = newCache;\n                                // A match means we're done; a fail means we have to keep checking\n                                if (newCache[2] = matcher(elem, context, xml)) {\n                                    return true;\n                                }\n                            }\n                        }\n                    }\n                }\n                return false;\n            };\n        }\n        function elementMatcher(matchers) {\n            return matchers.length > 1 ? function(elem, context, xml) {\n                var i = matchers.length;\n                while(i--){\n                    if (!matchers[i](elem, context, xml)) {\n                        return false;\n                    }\n                }\n                return true;\n            } : matchers[0];\n        }\n        function multipleContexts(selector, contexts, results) {\n            var i = 0, len = contexts.length;\n            for(; i < len; i++){\n                find(selector, contexts[i], results);\n            }\n            return results;\n        }\n        function condense(unmatched, map, filter, context, xml) {\n            var elem, newUnmatched = [], i = 0, len = unmatched.length, mapped = map != null;\n            for(; i < len; i++){\n                if (elem = unmatched[i]) {\n                    if (!filter || filter(elem, context, xml)) {\n                        newUnmatched.push(elem);\n                        if (mapped) {\n                            map.push(i);\n                        }\n                    }\n                }\n            }\n            return newUnmatched;\n        }\n        function setMatcher(preFilter, selector, matcher, postFilter, postFinder, postSelector) {\n            if (postFilter && !postFilter[expando]) {\n                postFilter = setMatcher(postFilter);\n            }\n            if (postFinder && !postFinder[expando]) {\n                postFinder = setMatcher(postFinder, postSelector);\n            }\n            return markFunction(function(seed, results, context, xml) {\n                var temp, i, elem, matcherOut, preMap = [], postMap = [], preexisting = results.length, // Get initial elements from seed or context\n                elems = seed || multipleContexts(selector || \"*\", context.nodeType ? [\n                    context\n                ] : context, []), // Prefilter to get matcher input, preserving a map for seed-results synchronization\n                matcherIn = preFilter && (seed || !selector) ? condense(elems, preMap, preFilter, context, xml) : elems;\n                if (matcher) {\n                    // If we have a postFinder, or filtered seed, or non-seed postFilter\n                    // or preexisting results,\n                    matcherOut = postFinder || (seed ? preFilter : preexisting || postFilter) ? // ...intermediate processing is necessary\n                    [] : // ...otherwise use results directly\n                    results;\n                    // Find primary matches\n                    matcher(matcherIn, matcherOut, context, xml);\n                } else {\n                    matcherOut = matcherIn;\n                }\n                // Apply postFilter\n                if (postFilter) {\n                    temp = condense(matcherOut, postMap);\n                    postFilter(temp, [], context, xml);\n                    // Un-match failing elements by moving them back to matcherIn\n                    i = temp.length;\n                    while(i--){\n                        if (elem = temp[i]) {\n                            matcherOut[postMap[i]] = !(matcherIn[postMap[i]] = elem);\n                        }\n                    }\n                }\n                if (seed) {\n                    if (postFinder || preFilter) {\n                        if (postFinder) {\n                            // Get the final matcherOut by condensing this intermediate into postFinder contexts\n                            temp = [];\n                            i = matcherOut.length;\n                            while(i--){\n                                if (elem = matcherOut[i]) {\n                                    // Restore matcherIn since elem is not yet a final match\n                                    temp.push(matcherIn[i] = elem);\n                                }\n                            }\n                            postFinder(null, matcherOut = [], temp, xml);\n                        }\n                        // Move matched elements from seed to results to keep them synchronized\n                        i = matcherOut.length;\n                        while(i--){\n                            if ((elem = matcherOut[i]) && (temp = postFinder ? indexOf.call(seed, elem) : preMap[i]) > -1) {\n                                seed[temp] = !(results[temp] = elem);\n                            }\n                        }\n                    }\n                // Add elements to results, through postFinder if defined\n                } else {\n                    matcherOut = condense(matcherOut === results ? matcherOut.splice(preexisting, matcherOut.length) : matcherOut);\n                    if (postFinder) {\n                        postFinder(null, results, matcherOut, xml);\n                    } else {\n                        push.apply(results, matcherOut);\n                    }\n                }\n            });\n        }\n        function matcherFromTokens(tokens) {\n            var checkContext, matcher, j, len = tokens.length, leadingRelative = Expr.relative[tokens[0].type], implicitRelative = leadingRelative || Expr.relative[\" \"], i = leadingRelative ? 1 : 0, // The foundational matcher ensures that elements are reachable from top-level context(s)\n            matchContext = addCombinator(function(elem) {\n                return elem === checkContext;\n            }, implicitRelative, true), matchAnyContext = addCombinator(function(elem) {\n                return indexOf.call(checkContext, elem) > -1;\n            }, implicitRelative, true), matchers = [\n                function(elem, context, xml) {\n                    // Support: IE 11+, Edge 17 - 18+\n                    // IE/Edge sometimes throw a \"Permission denied\" error when strict-comparing\n                    // two documents; shallow comparisons work.\n                    // eslint-disable-next-line eqeqeq\n                    var ret = !leadingRelative && (xml || context != outermostContext) || ((checkContext = context).nodeType ? matchContext(elem, context, xml) : matchAnyContext(elem, context, xml));\n                    // Avoid hanging onto element\n                    // (see https://github.com/jquery/sizzle/issues/299)\n                    checkContext = null;\n                    return ret;\n                }\n            ];\n            for(; i < len; i++){\n                if (matcher = Expr.relative[tokens[i].type]) {\n                    matchers = [\n                        addCombinator(elementMatcher(matchers), matcher)\n                    ];\n                } else {\n                    matcher = Expr.filter[tokens[i].type].apply(null, tokens[i].matches);\n                    // Return special upon seeing a positional matcher\n                    if (matcher[expando]) {\n                        // Find the next relative operator (if any) for proper handling\n                        j = ++i;\n                        for(; j < len; j++){\n                            if (Expr.relative[tokens[j].type]) {\n                                break;\n                            }\n                        }\n                        return setMatcher(i > 1 && elementMatcher(matchers), i > 1 && toSelector(// If the preceding token was a descendant combinator, insert an implicit any-element `*`\n                        tokens.slice(0, i - 1).concat({\n                            value: tokens[i - 2].type === \" \" ? \"*\" : \"\"\n                        })).replace(rtrimCSS, \"$1\"), matcher, i < j && matcherFromTokens(tokens.slice(i, j)), j < len && matcherFromTokens(tokens = tokens.slice(j)), j < len && toSelector(tokens));\n                    }\n                    matchers.push(matcher);\n                }\n            }\n            return elementMatcher(matchers);\n        }\n        function matcherFromGroupMatchers(elementMatchers, setMatchers) {\n            var bySet = setMatchers.length > 0, byElement = elementMatchers.length > 0, superMatcher = function(seed, context, xml, results, outermost) {\n                var elem, j, matcher, matchedCount = 0, i = \"0\", unmatched = seed && [], setMatched = [], contextBackup = outermostContext, // We must always have either seed elements or outermost context\n                elems = seed || byElement && Expr.find.TAG(\"*\", outermost), // Use integer dirruns iff this is the outermost matcher\n                dirrunsUnique = dirruns += contextBackup == null ? 1 : Math.random() || 0.1, len = elems.length;\n                if (outermost) {\n                    // Support: IE 11+, Edge 17 - 18+\n                    // IE/Edge sometimes throw a \"Permission denied\" error when strict-comparing\n                    // two documents; shallow comparisons work.\n                    // eslint-disable-next-line eqeqeq\n                    outermostContext = context == document || context || outermost;\n                }\n                // Add elements passing elementMatchers directly to results\n                // Support: iOS <=7 - 9 only\n                // Tolerate NodeList properties (IE: \"length\"; Safari: <number>) matching\n                // elements by id. (see trac-14142)\n                for(; i !== len && (elem = elems[i]) != null; i++){\n                    if (byElement && elem) {\n                        j = 0;\n                        // Support: IE 11+, Edge 17 - 18+\n                        // IE/Edge sometimes throw a \"Permission denied\" error when strict-comparing\n                        // two documents; shallow comparisons work.\n                        // eslint-disable-next-line eqeqeq\n                        if (!context && elem.ownerDocument != document) {\n                            setDocument(elem);\n                            xml = !documentIsHTML;\n                        }\n                        while(matcher = elementMatchers[j++]){\n                            if (matcher(elem, context || document, xml)) {\n                                push.call(results, elem);\n                                break;\n                            }\n                        }\n                        if (outermost) {\n                            dirruns = dirrunsUnique;\n                        }\n                    }\n                    // Track unmatched elements for set filters\n                    if (bySet) {\n                        // They will have gone through all possible matchers\n                        if (elem = !matcher && elem) {\n                            matchedCount--;\n                        }\n                        // Lengthen the array for every element, matched or not\n                        if (seed) {\n                            unmatched.push(elem);\n                        }\n                    }\n                }\n                // `i` is now the count of elements visited above, and adding it to `matchedCount`\n                // makes the latter nonnegative.\n                matchedCount += i;\n                // Apply set filters to unmatched elements\n                // NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`\n                // equals `i`), unless we didn't visit _any_ elements in the above loop because we have\n                // no element matchers and no seed.\n                // Incrementing an initially-string \"0\" `i` allows `i` to remain a string only in that\n                // case, which will result in a \"00\" `matchedCount` that differs from `i` but is also\n                // numerically zero.\n                if (bySet && i !== matchedCount) {\n                    j = 0;\n                    while(matcher = setMatchers[j++]){\n                        matcher(unmatched, setMatched, context, xml);\n                    }\n                    if (seed) {\n                        // Reintegrate element matches to eliminate the need for sorting\n                        if (matchedCount > 0) {\n                            while(i--){\n                                if (!(unmatched[i] || setMatched[i])) {\n                                    setMatched[i] = pop.call(results);\n                                }\n                            }\n                        }\n                        // Discard index placeholder values to get only actual matches\n                        setMatched = condense(setMatched);\n                    }\n                    // Add matches to results\n                    push.apply(results, setMatched);\n                    // Seedless set matches succeeding multiple successful matchers stipulate sorting\n                    if (outermost && !seed && setMatched.length > 0 && matchedCount + setMatchers.length > 1) {\n                        jQuery.uniqueSort(results);\n                    }\n                }\n                // Override manipulation of globals by nested matchers\n                if (outermost) {\n                    dirruns = dirrunsUnique;\n                    outermostContext = contextBackup;\n                }\n                return unmatched;\n            };\n            return bySet ? markFunction(superMatcher) : superMatcher;\n        }\n        function compile(selector, match /* Internal Use Only */ ) {\n            var i, setMatchers = [], elementMatchers = [], cached = compilerCache[selector + \" \"];\n            if (!cached) {\n                // Generate a function of recursive functions that can be used to check each element\n                if (!match) {\n                    match = tokenize(selector);\n                }\n                i = match.length;\n                while(i--){\n                    cached = matcherFromTokens(match[i]);\n                    if (cached[expando]) {\n                        setMatchers.push(cached);\n                    } else {\n                        elementMatchers.push(cached);\n                    }\n                }\n                // Cache the compiled function\n                cached = compilerCache(selector, matcherFromGroupMatchers(elementMatchers, setMatchers));\n                // Save selector and tokenization\n                cached.selector = selector;\n            }\n            return cached;\n        }\n        /**\n * A low-level selection function that works with jQuery's compiled\n *  selector functions\n * @param {String|Function} selector A selector or a pre-compiled\n *  selector function built with jQuery selector compile\n * @param {Element} context\n * @param {Array} [results]\n * @param {Array} [seed] A set of elements to match against\n */ function select(selector, context, results, seed) {\n            var i, tokens, token, type, find, compiled = typeof selector === \"function\" && selector, match = !seed && tokenize(selector = compiled.selector || selector);\n            results = results || [];\n            // Try to minimize operations if there is only one selector in the list and no seed\n            // (the latter of which guarantees us context)\n            if (match.length === 1) {\n                // Reduce context if the leading compound selector is an ID\n                tokens = match[0] = match[0].slice(0);\n                if (tokens.length > 2 && (token = tokens[0]).type === \"ID\" && context.nodeType === 9 && documentIsHTML && Expr.relative[tokens[1].type]) {\n                    context = (Expr.find.ID(token.matches[0].replace(runescape, funescape), context) || [])[0];\n                    if (!context) {\n                        return results;\n                    // Precompiled matchers will still verify ancestry, so step up a level\n                    } else if (compiled) {\n                        context = context.parentNode;\n                    }\n                    selector = selector.slice(tokens.shift().value.length);\n                }\n                // Fetch a seed set for right-to-left matching\n                i = matchExpr.needsContext.test(selector) ? 0 : tokens.length;\n                while(i--){\n                    token = tokens[i];\n                    // Abort if we hit a combinator\n                    if (Expr.relative[type = token.type]) {\n                        break;\n                    }\n                    if (find = Expr.find[type]) {\n                        // Search, expanding context for leading sibling combinators\n                        if (seed = find(token.matches[0].replace(runescape, funescape), rsibling.test(tokens[0].type) && testContext(context.parentNode) || context)) {\n                            // If seed is empty or no tokens remain, we can return early\n                            tokens.splice(i, 1);\n                            selector = seed.length && toSelector(tokens);\n                            if (!selector) {\n                                push.apply(results, seed);\n                                return results;\n                            }\n                            break;\n                        }\n                    }\n                }\n            }\n            // Compile and execute a filtering function if one is not provided\n            // Provide `match` to avoid retokenization if we modified the selector above\n            (compiled || compile(selector, match))(seed, context, !documentIsHTML, results, !context || rsibling.test(selector) && testContext(context.parentNode) || context);\n            return results;\n        }\n        // One-time assignments\n        // Support: Android <=4.0 - 4.1+\n        // Sort stability\n        support.sortStable = expando.split(\"\").sort(sortOrder).join(\"\") === expando;\n        // Initialize against the default document\n        setDocument();\n        // Support: Android <=4.0 - 4.1+\n        // Detached nodes confoundingly follow *each other*\n        support.sortDetached = assert(function(el) {\n            // Should return 1, but returns 4 (following)\n            return el.compareDocumentPosition(document.createElement(\"fieldset\")) & 1;\n        });\n        jQuery.find = find;\n        // Deprecated\n        jQuery.expr[\":\"] = jQuery.expr.pseudos;\n        jQuery.unique = jQuery.uniqueSort;\n        // These have always been private, but they used to be documented as part of\n        // Sizzle so let's maintain them for now for backwards compatibility purposes.\n        find.compile = compile;\n        find.select = select;\n        find.setDocument = setDocument;\n        find.tokenize = tokenize;\n        find.escape = jQuery.escapeSelector;\n        find.getText = jQuery.text;\n        find.isXML = jQuery.isXMLDoc;\n        find.selectors = jQuery.expr;\n        find.support = jQuery.support;\n        find.uniqueSort = jQuery.uniqueSort;\n    /* eslint-enable */ })();\n    var dir = function(elem, dir, until) {\n        var matched = [], truncate = until !== undefined;\n        while((elem = elem[dir]) && elem.nodeType !== 9){\n            if (elem.nodeType === 1) {\n                if (truncate && jQuery(elem).is(until)) {\n                    break;\n                }\n                matched.push(elem);\n            }\n        }\n        return matched;\n    };\n    var siblings = function(n, elem) {\n        var matched = [];\n        for(; n; n = n.nextSibling){\n            if (n.nodeType === 1 && n !== elem) {\n                matched.push(n);\n            }\n        }\n        return matched;\n    };\n    var rneedsContext = jQuery.expr.match.needsContext;\n    var rsingleTag = /^<([a-z][^\\/\\0>:\\x20\\t\\r\\n\\f]*)[\\x20\\t\\r\\n\\f]*\\/?>(?:<\\/\\1>|)$/i;\n    // Implement the identical functionality for filter and not\n    function winnow(elements, qualifier, not) {\n        if (isFunction(qualifier)) {\n            return jQuery.grep(elements, function(elem, i) {\n                return !!qualifier.call(elem, i, elem) !== not;\n            });\n        }\n        // Single element\n        if (qualifier.nodeType) {\n            return jQuery.grep(elements, function(elem) {\n                return elem === qualifier !== not;\n            });\n        }\n        // Arraylike of elements (jQuery, arguments, Array)\n        if (typeof qualifier !== \"string\") {\n            return jQuery.grep(elements, function(elem) {\n                return indexOf.call(qualifier, elem) > -1 !== not;\n            });\n        }\n        // Filtered directly for both simple and complex selectors\n        return jQuery.filter(qualifier, elements, not);\n    }\n    jQuery.filter = function(expr, elems, not) {\n        var elem = elems[0];\n        if (not) {\n            expr = \":not(\" + expr + \")\";\n        }\n        if (elems.length === 1 && elem.nodeType === 1) {\n            return jQuery.find.matchesSelector(elem, expr) ? [\n                elem\n            ] : [];\n        }\n        return jQuery.find.matches(expr, jQuery.grep(elems, function(elem) {\n            return elem.nodeType === 1;\n        }));\n    };\n    jQuery.fn.extend({\n        find: function(selector) {\n            var i, ret, len = this.length, self = this;\n            if (typeof selector !== \"string\") {\n                return this.pushStack(jQuery(selector).filter(function() {\n                    for(i = 0; i < len; i++){\n                        if (jQuery.contains(self[i], this)) {\n                            return true;\n                        }\n                    }\n                }));\n            }\n            ret = this.pushStack([]);\n            for(i = 0; i < len; i++){\n                jQuery.find(selector, self[i], ret);\n            }\n            return len > 1 ? jQuery.uniqueSort(ret) : ret;\n        },\n        filter: function(selector) {\n            return this.pushStack(winnow(this, selector || [], false));\n        },\n        not: function(selector) {\n            return this.pushStack(winnow(this, selector || [], true));\n        },\n        is: function(selector) {\n            return !!winnow(this, // If this is a positional/relative selector, check membership in the returned set\n            // so $(\"p:first\").is(\"p:last\") won't return true for a doc with two \"p\".\n            typeof selector === \"string\" && rneedsContext.test(selector) ? jQuery(selector) : selector || [], false).length;\n        }\n    });\n    // Initialize a jQuery object\n    // A central reference to the root jQuery(document)\n    var rootjQuery, // A simple way to check for HTML strings\n    // Prioritize #id over <tag> to avoid XSS via location.hash (trac-9521)\n    // Strict HTML recognition (trac-11290: must start with <)\n    // Shortcut simple #id case for speed\n    rquickExpr = /^(?:\\s*(<[\\w\\W]+>)[^>]*|#([\\w-]+))$/, init = jQuery.fn.init = function(selector, context, root) {\n        var match, elem;\n        // HANDLE: $(\"\"), $(null), $(undefined), $(false)\n        if (!selector) {\n            return this;\n        }\n        // Method init() accepts an alternate rootjQuery\n        // so migrate can support jQuery.sub (gh-2101)\n        root = root || rootjQuery;\n        // Handle HTML strings\n        if (typeof selector === \"string\") {\n            if (selector[0] === \"<\" && selector[selector.length - 1] === \">\" && selector.length >= 3) {\n                // Assume that strings that start and end with <> are HTML and skip the regex check\n                match = [\n                    null,\n                    selector,\n                    null\n                ];\n            } else {\n                match = rquickExpr.exec(selector);\n            }\n            // Match html or make sure no context is specified for #id\n            if (match && (match[1] || !context)) {\n                // HANDLE: $(html) -> $(array)\n                if (match[1]) {\n                    context = context instanceof jQuery ? context[0] : context;\n                    // Option to run scripts is true for back-compat\n                    // Intentionally let the error be thrown if parseHTML is not present\n                    jQuery.merge(this, jQuery.parseHTML(match[1], context && context.nodeType ? context.ownerDocument || context : document, true));\n                    // HANDLE: $(html, props)\n                    if (rsingleTag.test(match[1]) && jQuery.isPlainObject(context)) {\n                        for(match in context){\n                            // Properties of context are called as methods if possible\n                            if (isFunction(this[match])) {\n                                this[match](context[match]);\n                            // ...and otherwise set as attributes\n                            } else {\n                                this.attr(match, context[match]);\n                            }\n                        }\n                    }\n                    return this;\n                // HANDLE: $(#id)\n                } else {\n                    elem = document.getElementById(match[2]);\n                    if (elem) {\n                        // Inject the element directly into the jQuery object\n                        this[0] = elem;\n                        this.length = 1;\n                    }\n                    return this;\n                }\n            // HANDLE: $(expr, $(...))\n            } else if (!context || context.jquery) {\n                return (context || root).find(selector);\n            // HANDLE: $(expr, context)\n            // (which is just equivalent to: $(context).find(expr)\n            } else {\n                return this.constructor(context).find(selector);\n            }\n        // HANDLE: $(DOMElement)\n        } else if (selector.nodeType) {\n            this[0] = selector;\n            this.length = 1;\n            return this;\n        // HANDLE: $(function)\n        // Shortcut for document ready\n        } else if (isFunction(selector)) {\n            return root.ready !== undefined ? root.ready(selector) : // Execute immediately if ready is not present\n            selector(jQuery);\n        }\n        return jQuery.makeArray(selector, this);\n    };\n    // Give the init function the jQuery prototype for later instantiation\n    init.prototype = jQuery.fn;\n    // Initialize central reference\n    rootjQuery = jQuery(document);\n    var rparentsprev = /^(?:parents|prev(?:Until|All))/, // Methods guaranteed to produce a unique set when starting from a unique set\n    guaranteedUnique = {\n        children: true,\n        contents: true,\n        next: true,\n        prev: true\n    };\n    jQuery.fn.extend({\n        has: function(target) {\n            var targets = jQuery(target, this), l = targets.length;\n            return this.filter(function() {\n                var i = 0;\n                for(; i < l; i++){\n                    if (jQuery.contains(this, targets[i])) {\n                        return true;\n                    }\n                }\n            });\n        },\n        closest: function(selectors, context) {\n            var cur, i = 0, l = this.length, matched = [], targets = typeof selectors !== \"string\" && jQuery(selectors);\n            // Positional selectors never match, since there's no _selection_ context\n            if (!rneedsContext.test(selectors)) {\n                for(; i < l; i++){\n                    for(cur = this[i]; cur && cur !== context; cur = cur.parentNode){\n                        // Always skip document fragments\n                        if (cur.nodeType < 11 && (targets ? targets.index(cur) > -1 : // Don't pass non-elements to jQuery#find\n                        cur.nodeType === 1 && jQuery.find.matchesSelector(cur, selectors))) {\n                            matched.push(cur);\n                            break;\n                        }\n                    }\n                }\n            }\n            return this.pushStack(matched.length > 1 ? jQuery.uniqueSort(matched) : matched);\n        },\n        // Determine the position of an element within the set\n        index: function(elem) {\n            // No argument, return index in parent\n            if (!elem) {\n                return this[0] && this[0].parentNode ? this.first().prevAll().length : -1;\n            }\n            // Index in selector\n            if (typeof elem === \"string\") {\n                return indexOf.call(jQuery(elem), this[0]);\n            }\n            // Locate the position of the desired element\n            return indexOf.call(this, // If it receives a jQuery object, the first element is used\n            elem.jquery ? elem[0] : elem);\n        },\n        add: function(selector, context) {\n            return this.pushStack(jQuery.uniqueSort(jQuery.merge(this.get(), jQuery(selector, context))));\n        },\n        addBack: function(selector) {\n            return this.add(selector == null ? this.prevObject : this.prevObject.filter(selector));\n        }\n    });\n    function sibling(cur, dir) {\n        while((cur = cur[dir]) && cur.nodeType !== 1){}\n        return cur;\n    }\n    jQuery.each({\n        parent: function(elem) {\n            var parent = elem.parentNode;\n            return parent && parent.nodeType !== 11 ? parent : null;\n        },\n        parents: function(elem) {\n            return dir(elem, \"parentNode\");\n        },\n        parentsUntil: function(elem, _i, until) {\n            return dir(elem, \"parentNode\", until);\n        },\n        next: function(elem) {\n            return sibling(elem, \"nextSibling\");\n        },\n        prev: function(elem) {\n            return sibling(elem, \"previousSibling\");\n        },\n        nextAll: function(elem) {\n            return dir(elem, \"nextSibling\");\n        },\n        prevAll: function(elem) {\n            return dir(elem, \"previousSibling\");\n        },\n        nextUntil: function(elem, _i, until) {\n            return dir(elem, \"nextSibling\", until);\n        },\n        prevUntil: function(elem, _i, until) {\n            return dir(elem, \"previousSibling\", until);\n        },\n        siblings: function(elem) {\n            return siblings((elem.parentNode || {}).firstChild, elem);\n        },\n        children: function(elem) {\n            return siblings(elem.firstChild);\n        },\n        contents: function(elem) {\n            if (elem.contentDocument != null && // Support: IE 11+\n            // <object> elements with no `data` attribute has an object\n            // `contentDocument` with a `null` prototype.\n            getProto(elem.contentDocument)) {\n                return elem.contentDocument;\n            }\n            // Support: IE 9 - 11 only, iOS 7 only, Android Browser <=4.3 only\n            // Treat the template element as a regular one in browsers that\n            // don't support it.\n            if (nodeName(elem, \"template\")) {\n                elem = elem.content || elem;\n            }\n            return jQuery.merge([], elem.childNodes);\n        }\n    }, function(name, fn) {\n        jQuery.fn[name] = function(until, selector) {\n            var matched = jQuery.map(this, fn, until);\n            if (name.slice(-5) !== \"Until\") {\n                selector = until;\n            }\n            if (selector && typeof selector === \"string\") {\n                matched = jQuery.filter(selector, matched);\n            }\n            if (this.length > 1) {\n                // Remove duplicates\n                if (!guaranteedUnique[name]) {\n                    jQuery.uniqueSort(matched);\n                }\n                // Reverse order for parents* and prev-derivatives\n                if (rparentsprev.test(name)) {\n                    matched.reverse();\n                }\n            }\n            return this.pushStack(matched);\n        };\n    });\n    var rnothtmlwhite = /[^\\x20\\t\\r\\n\\f]+/g;\n    // Convert String-formatted options into Object-formatted ones\n    function createOptions(options) {\n        var object = {};\n        jQuery.each(options.match(rnothtmlwhite) || [], function(_, flag) {\n            object[flag] = true;\n        });\n        return object;\n    }\n    /*\n * Create a callback list using the following parameters:\n *\n *\toptions: an optional list of space-separated options that will change how\n *\t\t\tthe callback list behaves or a more traditional option object\n *\n * By default a callback list will act like an event callback list and can be\n * \"fired\" multiple times.\n *\n * Possible options:\n *\n *\tonce:\t\t\twill ensure the callback list can only be fired once (like a Deferred)\n *\n *\tmemory:\t\t\twill keep track of previous values and will call any callback added\n *\t\t\t\t\tafter the list has been fired right away with the latest \"memorized\"\n *\t\t\t\t\tvalues (like a Deferred)\n *\n *\tunique:\t\t\twill ensure a callback can only be added once (no duplicate in the list)\n *\n *\tstopOnFalse:\tinterrupt callings when a callback returns false\n *\n */ jQuery.Callbacks = function(options) {\n        // Convert options from String-formatted to Object-formatted if needed\n        // (we check in cache first)\n        options = typeof options === \"string\" ? createOptions(options) : jQuery.extend({}, options);\n        var firing, // Last fire value for non-forgettable lists\n        memory, // Flag to know if list was already fired\n        fired, // Flag to prevent firing\n        locked, // Actual callback list\n        list = [], // Queue of execution data for repeatable lists\n        queue = [], // Index of currently firing callback (modified by add/remove as needed)\n        firingIndex = -1, // Fire callbacks\n        fire = function() {\n            // Enforce single-firing\n            locked = locked || options.once;\n            // Execute callbacks for all pending executions,\n            // respecting firingIndex overrides and runtime changes\n            fired = firing = true;\n            for(; queue.length; firingIndex = -1){\n                memory = queue.shift();\n                while(++firingIndex < list.length){\n                    // Run callback and check for early termination\n                    if (list[firingIndex].apply(memory[0], memory[1]) === false && options.stopOnFalse) {\n                        // Jump to end and forget the data so .add doesn't re-fire\n                        firingIndex = list.length;\n                        memory = false;\n                    }\n                }\n            }\n            // Forget the data if we're done with it\n            if (!options.memory) {\n                memory = false;\n            }\n            firing = false;\n            // Clean up if we're done firing for good\n            if (locked) {\n                // Keep an empty list if we have data for future add calls\n                if (memory) {\n                    list = [];\n                // Otherwise, this object is spent\n                } else {\n                    list = \"\";\n                }\n            }\n        }, // Actual Callbacks object\n        self = {\n            // Add a callback or a collection of callbacks to the list\n            add: function() {\n                if (list) {\n                    // If we have memory from a past run, we should fire after adding\n                    if (memory && !firing) {\n                        firingIndex = list.length - 1;\n                        queue.push(memory);\n                    }\n                    (function add(args) {\n                        jQuery.each(args, function(_, arg) {\n                            if (isFunction(arg)) {\n                                if (!options.unique || !self.has(arg)) {\n                                    list.push(arg);\n                                }\n                            } else if (arg && arg.length && toType(arg) !== \"string\") {\n                                // Inspect recursively\n                                add(arg);\n                            }\n                        });\n                    })(arguments);\n                    if (memory && !firing) {\n                        fire();\n                    }\n                }\n                return this;\n            },\n            // Remove a callback from the list\n            remove: function() {\n                jQuery.each(arguments, function(_, arg) {\n                    var index;\n                    while((index = jQuery.inArray(arg, list, index)) > -1){\n                        list.splice(index, 1);\n                        // Handle firing indexes\n                        if (index <= firingIndex) {\n                            firingIndex--;\n                        }\n                    }\n                });\n                return this;\n            },\n            // Check if a given callback is in the list.\n            // If no argument is given, return whether or not list has callbacks attached.\n            has: function(fn) {\n                return fn ? jQuery.inArray(fn, list) > -1 : list.length > 0;\n            },\n            // Remove all callbacks from the list\n            empty: function() {\n                if (list) {\n                    list = [];\n                }\n                return this;\n            },\n            // Disable .fire and .add\n            // Abort any current/pending executions\n            // Clear all callbacks and values\n            disable: function() {\n                locked = queue = [];\n                list = memory = \"\";\n                return this;\n            },\n            disabled: function() {\n                return !list;\n            },\n            // Disable .fire\n            // Also disable .add unless we have memory (since it would have no effect)\n            // Abort any pending executions\n            lock: function() {\n                locked = queue = [];\n                if (!memory && !firing) {\n                    list = memory = \"\";\n                }\n                return this;\n            },\n            locked: function() {\n                return !!locked;\n            },\n            // Call all callbacks with the given context and arguments\n            fireWith: function(context, args) {\n                if (!locked) {\n                    args = args || [];\n                    args = [\n                        context,\n                        args.slice ? args.slice() : args\n                    ];\n                    queue.push(args);\n                    if (!firing) {\n                        fire();\n                    }\n                }\n                return this;\n            },\n            // Call all the callbacks with the given arguments\n            fire: function() {\n                self.fireWith(this, arguments);\n                return this;\n            },\n            // To know if the callbacks have already been called at least once\n            fired: function() {\n                return !!fired;\n            }\n        };\n        return self;\n    };\n    function Identity(v) {\n        return v;\n    }\n    function Thrower(ex) {\n        throw ex;\n    }\n    function adoptValue(value, resolve, reject, noValue) {\n        var method;\n        try {\n            // Check for promise aspect first to privilege synchronous behavior\n            if (value && isFunction(method = value.promise)) {\n                method.call(value).done(resolve).fail(reject);\n            // Other thenables\n            } else if (value && isFunction(method = value.then)) {\n                method.call(value, resolve, reject);\n            // Other non-thenables\n            } else {\n                // Control `resolve` arguments by letting Array#slice cast boolean `noValue` to integer:\n                // * false: [ value ].slice( 0 ) => resolve( value )\n                // * true: [ value ].slice( 1 ) => resolve()\n                resolve.apply(undefined, [\n                    value\n                ].slice(noValue));\n            }\n        // For Promises/A+, convert exceptions into rejections\n        // Since jQuery.when doesn't unwrap thenables, we can skip the extra checks appearing in\n        // Deferred#then to conditionally suppress rejection.\n        } catch (value) {\n            // Support: Android 4.0 only\n            // Strict mode functions invoked without .call/.apply get global-object context\n            reject.apply(undefined, [\n                value\n            ]);\n        }\n    }\n    jQuery.extend({\n        Deferred: function(func) {\n            var tuples = [\n                // action, add listener, callbacks,\n                // ... .then handlers, argument index, [final state]\n                [\n                    \"notify\",\n                    \"progress\",\n                    jQuery.Callbacks(\"memory\"),\n                    jQuery.Callbacks(\"memory\"),\n                    2\n                ],\n                [\n                    \"resolve\",\n                    \"done\",\n                    jQuery.Callbacks(\"once memory\"),\n                    jQuery.Callbacks(\"once memory\"),\n                    0,\n                    \"resolved\"\n                ],\n                [\n                    \"reject\",\n                    \"fail\",\n                    jQuery.Callbacks(\"once memory\"),\n                    jQuery.Callbacks(\"once memory\"),\n                    1,\n                    \"rejected\"\n                ]\n            ], state = \"pending\", promise = {\n                state: function() {\n                    return state;\n                },\n                always: function() {\n                    deferred.done(arguments).fail(arguments);\n                    return this;\n                },\n                \"catch\": function(fn) {\n                    return promise.then(null, fn);\n                },\n                // Keep pipe for back-compat\n                pipe: function() {\n                    var fns = arguments;\n                    return jQuery.Deferred(function(newDefer) {\n                        jQuery.each(tuples, function(_i, tuple) {\n                            // Map tuples (progress, done, fail) to arguments (done, fail, progress)\n                            var fn = isFunction(fns[tuple[4]]) && fns[tuple[4]];\n                            // deferred.progress(function() { bind to newDefer or newDefer.notify })\n                            // deferred.done(function() { bind to newDefer or newDefer.resolve })\n                            // deferred.fail(function() { bind to newDefer or newDefer.reject })\n                            deferred[tuple[1]](function() {\n                                var returned = fn && fn.apply(this, arguments);\n                                if (returned && isFunction(returned.promise)) {\n                                    returned.promise().progress(newDefer.notify).done(newDefer.resolve).fail(newDefer.reject);\n                                } else {\n                                    newDefer[tuple[0] + \"With\"](this, fn ? [\n                                        returned\n                                    ] : arguments);\n                                }\n                            });\n                        });\n                        fns = null;\n                    }).promise();\n                },\n                then: function(onFulfilled, onRejected, onProgress) {\n                    var maxDepth = 0;\n                    function resolve(depth, deferred, handler, special) {\n                        return function() {\n                            var that = this, args = arguments, mightThrow = function() {\n                                var returned, then;\n                                // Support: Promises/A+ section 2.3.3.3.3\n                                // https://promisesaplus.com/#point-59\n                                // Ignore double-resolution attempts\n                                if (depth < maxDepth) {\n                                    return;\n                                }\n                                returned = handler.apply(that, args);\n                                // Support: Promises/A+ section 2.3.1\n                                // https://promisesaplus.com/#point-48\n                                if (returned === deferred.promise()) {\n                                    throw new TypeError(\"Thenable self-resolution\");\n                                }\n                                // Support: Promises/A+ sections 2.3.3.1, 3.5\n                                // https://promisesaplus.com/#point-54\n                                // https://promisesaplus.com/#point-75\n                                // Retrieve `then` only once\n                                then = returned && // Support: Promises/A+ section 2.3.4\n                                // https://promisesaplus.com/#point-64\n                                // Only check objects and functions for thenability\n                                (typeof returned === \"object\" || typeof returned === \"function\") && returned.then;\n                                // Handle a returned thenable\n                                if (isFunction(then)) {\n                                    // Special processors (notify) just wait for resolution\n                                    if (special) {\n                                        then.call(returned, resolve(maxDepth, deferred, Identity, special), resolve(maxDepth, deferred, Thrower, special));\n                                    // Normal processors (resolve) also hook into progress\n                                    } else {\n                                        // ...and disregard older resolution values\n                                        maxDepth++;\n                                        then.call(returned, resolve(maxDepth, deferred, Identity, special), resolve(maxDepth, deferred, Thrower, special), resolve(maxDepth, deferred, Identity, deferred.notifyWith));\n                                    }\n                                // Handle all other returned values\n                                } else {\n                                    // Only substitute handlers pass on context\n                                    // and multiple values (non-spec behavior)\n                                    if (handler !== Identity) {\n                                        that = undefined;\n                                        args = [\n                                            returned\n                                        ];\n                                    }\n                                    // Process the value(s)\n                                    // Default process is resolve\n                                    (special || deferred.resolveWith)(that, args);\n                                }\n                            }, // Only normal processors (resolve) catch and reject exceptions\n                            process = special ? mightThrow : function() {\n                                try {\n                                    mightThrow();\n                                } catch (e) {\n                                    if (jQuery.Deferred.exceptionHook) {\n                                        jQuery.Deferred.exceptionHook(e, process.error);\n                                    }\n                                    // Support: Promises/A+ section 2.3.3.3.4.1\n                                    // https://promisesaplus.com/#point-61\n                                    // Ignore post-resolution exceptions\n                                    if (depth + 1 >= maxDepth) {\n                                        // Only substitute handlers pass on context\n                                        // and multiple values (non-spec behavior)\n                                        if (handler !== Thrower) {\n                                            that = undefined;\n                                            args = [\n                                                e\n                                            ];\n                                        }\n                                        deferred.rejectWith(that, args);\n                                    }\n                                }\n                            };\n                            // Support: Promises/A+ section 2.3.3.3.1\n                            // https://promisesaplus.com/#point-57\n                            // Re-resolve promises immediately to dodge false rejection from\n                            // subsequent errors\n                            if (depth) {\n                                process();\n                            } else {\n                                // Call an optional hook to record the error, in case of exception\n                                // since it's otherwise lost when execution goes async\n                                if (jQuery.Deferred.getErrorHook) {\n                                    process.error = jQuery.Deferred.getErrorHook();\n                                // The deprecated alias of the above. While the name suggests\n                                // returning the stack, not an error instance, jQuery just passes\n                                // it directly to `console.warn` so both will work; an instance\n                                // just better cooperates with source maps.\n                                } else if (jQuery.Deferred.getStackHook) {\n                                    process.error = jQuery.Deferred.getStackHook();\n                                }\n                                window1.setTimeout(process);\n                            }\n                        };\n                    }\n                    return jQuery.Deferred(function(newDefer) {\n                        // progress_handlers.add( ... )\n                        tuples[0][3].add(resolve(0, newDefer, isFunction(onProgress) ? onProgress : Identity, newDefer.notifyWith));\n                        // fulfilled_handlers.add( ... )\n                        tuples[1][3].add(resolve(0, newDefer, isFunction(onFulfilled) ? onFulfilled : Identity));\n                        // rejected_handlers.add( ... )\n                        tuples[2][3].add(resolve(0, newDefer, isFunction(onRejected) ? onRejected : Thrower));\n                    }).promise();\n                },\n                // Get a promise for this deferred\n                // If obj is provided, the promise aspect is added to the object\n                promise: function(obj) {\n                    return obj != null ? jQuery.extend(obj, promise) : promise;\n                }\n            }, deferred = {};\n            // Add list-specific methods\n            jQuery.each(tuples, function(i, tuple) {\n                var list = tuple[2], stateString = tuple[5];\n                // promise.progress = list.add\n                // promise.done = list.add\n                // promise.fail = list.add\n                promise[tuple[1]] = list.add;\n                // Handle state\n                if (stateString) {\n                    list.add(function() {\n                        // state = \"resolved\" (i.e., fulfilled)\n                        // state = \"rejected\"\n                        state = stateString;\n                    }, // rejected_callbacks.disable\n                    // fulfilled_callbacks.disable\n                    tuples[3 - i][2].disable, // rejected_handlers.disable\n                    // fulfilled_handlers.disable\n                    tuples[3 - i][3].disable, // progress_callbacks.lock\n                    tuples[0][2].lock, // progress_handlers.lock\n                    tuples[0][3].lock);\n                }\n                // progress_handlers.fire\n                // fulfilled_handlers.fire\n                // rejected_handlers.fire\n                list.add(tuple[3].fire);\n                // deferred.notify = function() { deferred.notifyWith(...) }\n                // deferred.resolve = function() { deferred.resolveWith(...) }\n                // deferred.reject = function() { deferred.rejectWith(...) }\n                deferred[tuple[0]] = function() {\n                    deferred[tuple[0] + \"With\"](this === deferred ? undefined : this, arguments);\n                    return this;\n                };\n                // deferred.notifyWith = list.fireWith\n                // deferred.resolveWith = list.fireWith\n                // deferred.rejectWith = list.fireWith\n                deferred[tuple[0] + \"With\"] = list.fireWith;\n            });\n            // Make the deferred a promise\n            promise.promise(deferred);\n            // Call given func if any\n            if (func) {\n                func.call(deferred, deferred);\n            }\n            // All done!\n            return deferred;\n        },\n        // Deferred helper\n        when: function(singleValue) {\n            var // count of uncompleted subordinates\n            remaining = arguments.length, // count of unprocessed arguments\n            i = remaining, // subordinate fulfillment data\n            resolveContexts = Array(i), resolveValues = slice.call(arguments), // the primary Deferred\n            primary = jQuery.Deferred(), // subordinate callback factory\n            updateFunc = function(i) {\n                return function(value) {\n                    resolveContexts[i] = this;\n                    resolveValues[i] = arguments.length > 1 ? slice.call(arguments) : value;\n                    if (!--remaining) {\n                        primary.resolveWith(resolveContexts, resolveValues);\n                    }\n                };\n            };\n            // Single- and empty arguments are adopted like Promise.resolve\n            if (remaining <= 1) {\n                adoptValue(singleValue, primary.done(updateFunc(i)).resolve, primary.reject, !remaining);\n                // Use .then() to unwrap secondary thenables (cf. gh-3000)\n                if (primary.state() === \"pending\" || isFunction(resolveValues[i] && resolveValues[i].then)) {\n                    return primary.then();\n                }\n            }\n            // Multiple arguments are aggregated like Promise.all array elements\n            while(i--){\n                adoptValue(resolveValues[i], updateFunc(i), primary.reject);\n            }\n            return primary.promise();\n        }\n    });\n    // These usually indicate a programmer mistake during development,\n    // warn about them ASAP rather than swallowing them by default.\n    var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;\n    // If `jQuery.Deferred.getErrorHook` is defined, `asyncError` is an error\n    // captured before the async barrier to get the original error cause\n    // which may otherwise be hidden.\n    jQuery.Deferred.exceptionHook = function(error, asyncError) {\n        // Support: IE 8 - 9 only\n        // Console exists when dev tools are open, which can happen at any time\n        if (window1.console && window1.console.warn && error && rerrorNames.test(error.name)) {\n            window1.console.warn(\"jQuery.Deferred exception: \" + error.message, error.stack, asyncError);\n        }\n    };\n    jQuery.readyException = function(error) {\n        window1.setTimeout(function() {\n            throw error;\n        });\n    };\n    // The deferred used on DOM ready\n    var readyList = jQuery.Deferred();\n    jQuery.fn.ready = function(fn) {\n        readyList.then(fn)// Wrap jQuery.readyException in a function so that the lookup\n        // happens at the time of error handling instead of callback\n        // registration.\n        .catch(function(error) {\n            jQuery.readyException(error);\n        });\n        return this;\n    };\n    jQuery.extend({\n        // Is the DOM ready to be used? Set to true once it occurs.\n        isReady: false,\n        // A counter to track how many items to wait for before\n        // the ready event fires. See trac-6781\n        readyWait: 1,\n        // Handle when the DOM is ready\n        ready: function(wait) {\n            // Abort if there are pending holds or we're already ready\n            if (wait === true ? --jQuery.readyWait : jQuery.isReady) {\n                return;\n            }\n            // Remember that the DOM is ready\n            jQuery.isReady = true;\n            // If a normal DOM Ready event fired, decrement, and wait if need be\n            if (wait !== true && --jQuery.readyWait > 0) {\n                return;\n            }\n            // If there are functions bound, to execute\n            readyList.resolveWith(document, [\n                jQuery\n            ]);\n        }\n    });\n    jQuery.ready.then = readyList.then;\n    // The ready event handler and self cleanup method\n    function completed() {\n        document.removeEventListener(\"DOMContentLoaded\", completed);\n        window1.removeEventListener(\"load\", completed);\n        jQuery.ready();\n    }\n    // Catch cases where $(document).ready() is called\n    // after the browser event has already occurred.\n    // Support: IE <=9 - 10 only\n    // Older IE sometimes signals \"interactive\" too soon\n    if (document.readyState === \"complete\" || document.readyState !== \"loading\" && !document.documentElement.doScroll) {\n        // Handle it asynchronously to allow scripts the opportunity to delay ready\n        window1.setTimeout(jQuery.ready);\n    } else {\n        // Use the handy event callback\n        document.addEventListener(\"DOMContentLoaded\", completed);\n        // A fallback to window.onload, that will always work\n        window1.addEventListener(\"load\", completed);\n    }\n    // Multifunctional method to get and set values of a collection\n    // The value/s can optionally be executed if it's a function\n    var access = function(elems, fn, key, value, chainable, emptyGet, raw) {\n        var i = 0, len = elems.length, bulk = key == null;\n        // Sets many values\n        if (toType(key) === \"object\") {\n            chainable = true;\n            for(i in key){\n                access(elems, fn, i, key[i], true, emptyGet, raw);\n            }\n        // Sets one value\n        } else if (value !== undefined) {\n            chainable = true;\n            if (!isFunction(value)) {\n                raw = true;\n            }\n            if (bulk) {\n                // Bulk operations run against the entire set\n                if (raw) {\n                    fn.call(elems, value);\n                    fn = null;\n                // ...except when executing function values\n                } else {\n                    bulk = fn;\n                    fn = function(elem, _key, value) {\n                        return bulk.call(jQuery(elem), value);\n                    };\n                }\n            }\n            if (fn) {\n                for(; i < len; i++){\n                    fn(elems[i], key, raw ? value : value.call(elems[i], i, fn(elems[i], key)));\n                }\n            }\n        }\n        if (chainable) {\n            return elems;\n        }\n        // Gets\n        if (bulk) {\n            return fn.call(elems);\n        }\n        return len ? fn(elems[0], key) : emptyGet;\n    };\n    // Matches dashed string for camelizing\n    var rmsPrefix = /^-ms-/, rdashAlpha = /-([a-z])/g;\n    // Used by camelCase as callback to replace()\n    function fcamelCase(_all, letter) {\n        return letter.toUpperCase();\n    }\n    // Convert dashed to camelCase; used by the css and data modules\n    // Support: IE <=9 - 11, Edge 12 - 15\n    // Microsoft forgot to hump their vendor prefix (trac-9572)\n    function camelCase(string) {\n        return string.replace(rmsPrefix, \"ms-\").replace(rdashAlpha, fcamelCase);\n    }\n    var acceptData = function(owner) {\n        // Accepts only:\n        //  - Node\n        //    - Node.ELEMENT_NODE\n        //    - Node.DOCUMENT_NODE\n        //  - Object\n        //    - Any\n        return owner.nodeType === 1 || owner.nodeType === 9 || !+owner.nodeType;\n    };\n    function Data() {\n        this.expando = jQuery.expando + Data.uid++;\n    }\n    Data.uid = 1;\n    Data.prototype = {\n        cache: function(owner) {\n            // Check if the owner object already has a cache\n            var value = owner[this.expando];\n            // If not, create one\n            if (!value) {\n                value = {};\n                // We can accept data for non-element nodes in modern browsers,\n                // but we should not, see trac-8335.\n                // Always return an empty object.\n                if (acceptData(owner)) {\n                    // If it is a node unlikely to be stringify-ed or looped over\n                    // use plain assignment\n                    if (owner.nodeType) {\n                        owner[this.expando] = value;\n                    // Otherwise secure it in a non-enumerable property\n                    // configurable must be true to allow the property to be\n                    // deleted when data is removed\n                    } else {\n                        Object.defineProperty(owner, this.expando, {\n                            value: value,\n                            configurable: true\n                        });\n                    }\n                }\n            }\n            return value;\n        },\n        set: function(owner, data, value) {\n            var prop, cache = this.cache(owner);\n            // Handle: [ owner, key, value ] args\n            // Always use camelCase key (gh-2257)\n            if (typeof data === \"string\") {\n                cache[camelCase(data)] = value;\n            // Handle: [ owner, { properties } ] args\n            } else {\n                // Copy the properties one-by-one to the cache object\n                for(prop in data){\n                    cache[camelCase(prop)] = data[prop];\n                }\n            }\n            return cache;\n        },\n        get: function(owner, key) {\n            return key === undefined ? this.cache(owner) : // Always use camelCase key (gh-2257)\n            owner[this.expando] && owner[this.expando][camelCase(key)];\n        },\n        access: function(owner, key, value) {\n            // In cases where either:\n            //\n            //   1. No key was specified\n            //   2. A string key was specified, but no value provided\n            //\n            // Take the \"read\" path and allow the get method to determine\n            // which value to return, respectively either:\n            //\n            //   1. The entire cache object\n            //   2. The data stored at the key\n            //\n            if (key === undefined || key && typeof key === \"string\" && value === undefined) {\n                return this.get(owner, key);\n            }\n            // When the key is not a string, or both a key and value\n            // are specified, set or extend (existing objects) with either:\n            //\n            //   1. An object of properties\n            //   2. A key and value\n            //\n            this.set(owner, key, value);\n            // Since the \"set\" path can have two possible entry points\n            // return the expected data based on which path was taken[*]\n            return value !== undefined ? value : key;\n        },\n        remove: function(owner, key) {\n            var i, cache = owner[this.expando];\n            if (cache === undefined) {\n                return;\n            }\n            if (key !== undefined) {\n                // Support array or space separated string of keys\n                if (Array.isArray(key)) {\n                    // If key is an array of keys...\n                    // We always set camelCase keys, so remove that.\n                    key = key.map(camelCase);\n                } else {\n                    key = camelCase(key);\n                    // If a key with the spaces exists, use it.\n                    // Otherwise, create an array by matching non-whitespace\n                    key = key in cache ? [\n                        key\n                    ] : key.match(rnothtmlwhite) || [];\n                }\n                i = key.length;\n                while(i--){\n                    delete cache[key[i]];\n                }\n            }\n            // Remove the expando if there's no more data\n            if (key === undefined || jQuery.isEmptyObject(cache)) {\n                // Support: Chrome <=35 - 45\n                // Webkit & Blink performance suffers when deleting properties\n                // from DOM nodes, so set to undefined instead\n                // https://bugs.chromium.org/p/chromium/issues/detail?id=378607 (bug restricted)\n                if (owner.nodeType) {\n                    owner[this.expando] = undefined;\n                } else {\n                    delete owner[this.expando];\n                }\n            }\n        },\n        hasData: function(owner) {\n            var cache = owner[this.expando];\n            return cache !== undefined && !jQuery.isEmptyObject(cache);\n        }\n    };\n    var dataPriv = new Data();\n    var dataUser = new Data();\n    //\tImplementation Summary\n    //\n    //\t1. Enforce API surface and semantic compatibility with 1.9.x branch\n    //\t2. Improve the module's maintainability by reducing the storage\n    //\t\tpaths to a single mechanism.\n    //\t3. Use the same single mechanism to support \"private\" and \"user\" data.\n    //\t4. _Never_ expose \"private\" data to user code (TODO: Drop _data, _removeData)\n    //\t5. Avoid exposing implementation details on user objects (eg. expando properties)\n    //\t6. Provide a clear path for implementation upgrade to WeakMap in 2014\n    var rbrace = /^(?:\\{[\\w\\W]*\\}|\\[[\\w\\W]*\\])$/, rmultiDash = /[A-Z]/g;\n    function getData(data) {\n        if (data === \"true\") {\n            return true;\n        }\n        if (data === \"false\") {\n            return false;\n        }\n        if (data === \"null\") {\n            return null;\n        }\n        // Only convert to a number if it doesn't change the string\n        if (data === +data + \"\") {\n            return +data;\n        }\n        if (rbrace.test(data)) {\n            return JSON.parse(data);\n        }\n        return data;\n    }\n    function dataAttr(elem, key, data) {\n        var name;\n        // If nothing was found internally, try to fetch any\n        // data from the HTML5 data-* attribute\n        if (data === undefined && elem.nodeType === 1) {\n            name = \"data-\" + key.replace(rmultiDash, \"-$&\").toLowerCase();\n            data = elem.getAttribute(name);\n            if (typeof data === \"string\") {\n                try {\n                    data = getData(data);\n                } catch (e) {}\n                // Make sure we set the data so it isn't changed later\n                dataUser.set(elem, key, data);\n            } else {\n                data = undefined;\n            }\n        }\n        return data;\n    }\n    jQuery.extend({\n        hasData: function(elem) {\n            return dataUser.hasData(elem) || dataPriv.hasData(elem);\n        },\n        data: function(elem, name, data) {\n            return dataUser.access(elem, name, data);\n        },\n        removeData: function(elem, name) {\n            dataUser.remove(elem, name);\n        },\n        // TODO: Now that all calls to _data and _removeData have been replaced\n        // with direct calls to dataPriv methods, these can be deprecated.\n        _data: function(elem, name, data) {\n            return dataPriv.access(elem, name, data);\n        },\n        _removeData: function(elem, name) {\n            dataPriv.remove(elem, name);\n        }\n    });\n    jQuery.fn.extend({\n        data: function(key, value) {\n            var i, name, data, elem = this[0], attrs = elem && elem.attributes;\n            // Gets all values\n            if (key === undefined) {\n                if (this.length) {\n                    data = dataUser.get(elem);\n                    if (elem.nodeType === 1 && !dataPriv.get(elem, \"hasDataAttrs\")) {\n                        i = attrs.length;\n                        while(i--){\n                            // Support: IE 11 only\n                            // The attrs elements can be null (trac-14894)\n                            if (attrs[i]) {\n                                name = attrs[i].name;\n                                if (name.indexOf(\"data-\") === 0) {\n                                    name = camelCase(name.slice(5));\n                                    dataAttr(elem, name, data[name]);\n                                }\n                            }\n                        }\n                        dataPriv.set(elem, \"hasDataAttrs\", true);\n                    }\n                }\n                return data;\n            }\n            // Sets multiple values\n            if (typeof key === \"object\") {\n                return this.each(function() {\n                    dataUser.set(this, key);\n                });\n            }\n            return access(this, function(value) {\n                var data;\n                // The calling jQuery object (element matches) is not empty\n                // (and therefore has an element appears at this[ 0 ]) and the\n                // `value` parameter was not undefined. An empty jQuery object\n                // will result in `undefined` for elem = this[ 0 ] which will\n                // throw an exception if an attempt to read a data cache is made.\n                if (elem && value === undefined) {\n                    // Attempt to get data from the cache\n                    // The key will always be camelCased in Data\n                    data = dataUser.get(elem, key);\n                    if (data !== undefined) {\n                        return data;\n                    }\n                    // Attempt to \"discover\" the data in\n                    // HTML5 custom data-* attrs\n                    data = dataAttr(elem, key);\n                    if (data !== undefined) {\n                        return data;\n                    }\n                    // We tried really hard, but the data doesn't exist.\n                    return;\n                }\n                // Set the data...\n                this.each(function() {\n                    // We always store the camelCased key\n                    dataUser.set(this, key, value);\n                });\n            }, null, value, arguments.length > 1, null, true);\n        },\n        removeData: function(key) {\n            return this.each(function() {\n                dataUser.remove(this, key);\n            });\n        }\n    });\n    jQuery.extend({\n        queue: function(elem, type, data) {\n            var queue;\n            if (elem) {\n                type = (type || \"fx\") + \"queue\";\n                queue = dataPriv.get(elem, type);\n                // Speed up dequeue by getting out quickly if this is just a lookup\n                if (data) {\n                    if (!queue || Array.isArray(data)) {\n                        queue = dataPriv.access(elem, type, jQuery.makeArray(data));\n                    } else {\n                        queue.push(data);\n                    }\n                }\n                return queue || [];\n            }\n        },\n        dequeue: function(elem, type) {\n            type = type || \"fx\";\n            var queue = jQuery.queue(elem, type), startLength = queue.length, fn = queue.shift(), hooks = jQuery._queueHooks(elem, type), next = function() {\n                jQuery.dequeue(elem, type);\n            };\n            // If the fx queue is dequeued, always remove the progress sentinel\n            if (fn === \"inprogress\") {\n                fn = queue.shift();\n                startLength--;\n            }\n            if (fn) {\n                // Add a progress sentinel to prevent the fx queue from being\n                // automatically dequeued\n                if (type === \"fx\") {\n                    queue.unshift(\"inprogress\");\n                }\n                // Clear up the last queue stop function\n                delete hooks.stop;\n                fn.call(elem, next, hooks);\n            }\n            if (!startLength && hooks) {\n                hooks.empty.fire();\n            }\n        },\n        // Not public - generate a queueHooks object, or return the current one\n        _queueHooks: function(elem, type) {\n            var key = type + \"queueHooks\";\n            return dataPriv.get(elem, key) || dataPriv.access(elem, key, {\n                empty: jQuery.Callbacks(\"once memory\").add(function() {\n                    dataPriv.remove(elem, [\n                        type + \"queue\",\n                        key\n                    ]);\n                })\n            });\n        }\n    });\n    jQuery.fn.extend({\n        queue: function(type, data) {\n            var setter = 2;\n            if (typeof type !== \"string\") {\n                data = type;\n                type = \"fx\";\n                setter--;\n            }\n            if (arguments.length < setter) {\n                return jQuery.queue(this[0], type);\n            }\n            return data === undefined ? this : this.each(function() {\n                var queue = jQuery.queue(this, type, data);\n                // Ensure a hooks for this queue\n                jQuery._queueHooks(this, type);\n                if (type === \"fx\" && queue[0] !== \"inprogress\") {\n                    jQuery.dequeue(this, type);\n                }\n            });\n        },\n        dequeue: function(type) {\n            return this.each(function() {\n                jQuery.dequeue(this, type);\n            });\n        },\n        clearQueue: function(type) {\n            return this.queue(type || \"fx\", []);\n        },\n        // Get a promise resolved when queues of a certain type\n        // are emptied (fx is the type by default)\n        promise: function(type, obj) {\n            var tmp, count = 1, defer = jQuery.Deferred(), elements = this, i = this.length, resolve = function() {\n                if (!--count) {\n                    defer.resolveWith(elements, [\n                        elements\n                    ]);\n                }\n            };\n            if (typeof type !== \"string\") {\n                obj = type;\n                type = undefined;\n            }\n            type = type || \"fx\";\n            while(i--){\n                tmp = dataPriv.get(elements[i], type + \"queueHooks\");\n                if (tmp && tmp.empty) {\n                    count++;\n                    tmp.empty.add(resolve);\n                }\n            }\n            resolve();\n            return defer.promise(obj);\n        }\n    });\n    var pnum = /[+-]?(?:\\d*\\.|)\\d+(?:[eE][+-]?\\d+|)/.source;\n    var rcssNum = new RegExp(\"^(?:([+-])=|)(\" + pnum + \")([a-z%]*)$\", \"i\");\n    var cssExpand = [\n        \"Top\",\n        \"Right\",\n        \"Bottom\",\n        \"Left\"\n    ];\n    var documentElement = document.documentElement;\n    var isAttached = function(elem) {\n        return jQuery.contains(elem.ownerDocument, elem);\n    }, composed = {\n        composed: true\n    };\n    // Support: IE 9 - 11+, Edge 12 - 18+, iOS 10.0 - 10.2 only\n    // Check attachment across shadow DOM boundaries when possible (gh-3504)\n    // Support: iOS 10.0-10.2 only\n    // Early iOS 10 versions support `attachShadow` but not `getRootNode`,\n    // leading to errors. We need to check for `getRootNode`.\n    if (documentElement.getRootNode) {\n        isAttached = function(elem) {\n            return jQuery.contains(elem.ownerDocument, elem) || elem.getRootNode(composed) === elem.ownerDocument;\n        };\n    }\n    var isHiddenWithinTree = function(elem, el) {\n        // isHiddenWithinTree might be called from jQuery#filter function;\n        // in that case, element will be second argument\n        elem = el || elem;\n        // Inline style trumps all\n        return elem.style.display === \"none\" || elem.style.display === \"\" && // Otherwise, check computed style\n        // Support: Firefox <=43 - 45\n        // Disconnected elements can have computed display: none, so first confirm that elem is\n        // in the document.\n        isAttached(elem) && jQuery.css(elem, \"display\") === \"none\";\n    };\n    function adjustCSS(elem, prop, valueParts, tween) {\n        var adjusted, scale, maxIterations = 20, currentValue = tween ? function() {\n            return tween.cur();\n        } : function() {\n            return jQuery.css(elem, prop, \"\");\n        }, initial = currentValue(), unit = valueParts && valueParts[3] || (jQuery.cssNumber[prop] ? \"\" : \"px\"), // Starting value computation is required for potential unit mismatches\n        initialInUnit = elem.nodeType && (jQuery.cssNumber[prop] || unit !== \"px\" && +initial) && rcssNum.exec(jQuery.css(elem, prop));\n        if (initialInUnit && initialInUnit[3] !== unit) {\n            // Support: Firefox <=54\n            // Halve the iteration target value to prevent interference from CSS upper bounds (gh-2144)\n            initial = initial / 2;\n            // Trust units reported by jQuery.css\n            unit = unit || initialInUnit[3];\n            // Iteratively approximate from a nonzero starting point\n            initialInUnit = +initial || 1;\n            while(maxIterations--){\n                // Evaluate and update our best guess (doubling guesses that zero out).\n                // Finish if the scale equals or crosses 1 (making the old*new product non-positive).\n                jQuery.style(elem, prop, initialInUnit + unit);\n                if ((1 - scale) * (1 - (scale = currentValue() / initial || 0.5)) <= 0) {\n                    maxIterations = 0;\n                }\n                initialInUnit = initialInUnit / scale;\n            }\n            initialInUnit = initialInUnit * 2;\n            jQuery.style(elem, prop, initialInUnit + unit);\n            // Make sure we update the tween properties later on\n            valueParts = valueParts || [];\n        }\n        if (valueParts) {\n            initialInUnit = +initialInUnit || +initial || 0;\n            // Apply relative offset (+=/-=) if specified\n            adjusted = valueParts[1] ? initialInUnit + (valueParts[1] + 1) * valueParts[2] : +valueParts[2];\n            if (tween) {\n                tween.unit = unit;\n                tween.start = initialInUnit;\n                tween.end = adjusted;\n            }\n        }\n        return adjusted;\n    }\n    var defaultDisplayMap = {};\n    function getDefaultDisplay(elem) {\n        var temp, doc = elem.ownerDocument, nodeName = elem.nodeName, display = defaultDisplayMap[nodeName];\n        if (display) {\n            return display;\n        }\n        temp = doc.body.appendChild(doc.createElement(nodeName));\n        display = jQuery.css(temp, \"display\");\n        temp.parentNode.removeChild(temp);\n        if (display === \"none\") {\n            display = \"block\";\n        }\n        defaultDisplayMap[nodeName] = display;\n        return display;\n    }\n    function showHide(elements, show) {\n        var display, elem, values = [], index = 0, length = elements.length;\n        // Determine new display value for elements that need to change\n        for(; index < length; index++){\n            elem = elements[index];\n            if (!elem.style) {\n                continue;\n            }\n            display = elem.style.display;\n            if (show) {\n                // Since we force visibility upon cascade-hidden elements, an immediate (and slow)\n                // check is required in this first loop unless we have a nonempty display value (either\n                // inline or about-to-be-restored)\n                if (display === \"none\") {\n                    values[index] = dataPriv.get(elem, \"display\") || null;\n                    if (!values[index]) {\n                        elem.style.display = \"\";\n                    }\n                }\n                if (elem.style.display === \"\" && isHiddenWithinTree(elem)) {\n                    values[index] = getDefaultDisplay(elem);\n                }\n            } else {\n                if (display !== \"none\") {\n                    values[index] = \"none\";\n                    // Remember what we're overwriting\n                    dataPriv.set(elem, \"display\", display);\n                }\n            }\n        }\n        // Set the display of the elements in a second loop to avoid constant reflow\n        for(index = 0; index < length; index++){\n            if (values[index] != null) {\n                elements[index].style.display = values[index];\n            }\n        }\n        return elements;\n    }\n    jQuery.fn.extend({\n        show: function() {\n            return showHide(this, true);\n        },\n        hide: function() {\n            return showHide(this);\n        },\n        toggle: function(state) {\n            if (typeof state === \"boolean\") {\n                return state ? this.show() : this.hide();\n            }\n            return this.each(function() {\n                if (isHiddenWithinTree(this)) {\n                    jQuery(this).show();\n                } else {\n                    jQuery(this).hide();\n                }\n            });\n        }\n    });\n    var rcheckableType = /^(?:checkbox|radio)$/i;\n    var rtagName = /<([a-z][^\\/\\0>\\x20\\t\\r\\n\\f]*)/i;\n    var rscriptType = /^$|^module$|\\/(?:java|ecma)script/i;\n    (function() {\n        var fragment = document.createDocumentFragment(), div = fragment.appendChild(document.createElement(\"div\")), input = document.createElement(\"input\");\n        // Support: Android 4.0 - 4.3 only\n        // Check state lost if the name is set (trac-11217)\n        // Support: Windows Web Apps (WWA)\n        // `name` and `type` must use .setAttribute for WWA (trac-14901)\n        input.setAttribute(\"type\", \"radio\");\n        input.setAttribute(\"checked\", \"checked\");\n        input.setAttribute(\"name\", \"t\");\n        div.appendChild(input);\n        // Support: Android <=4.1 only\n        // Older WebKit doesn't clone checked state correctly in fragments\n        support.checkClone = div.cloneNode(true).cloneNode(true).lastChild.checked;\n        // Support: IE <=11 only\n        // Make sure textarea (and checkbox) defaultValue is properly cloned\n        div.innerHTML = \"<textarea>x</textarea>\";\n        support.noCloneChecked = !!div.cloneNode(true).lastChild.defaultValue;\n        // Support: IE <=9 only\n        // IE <=9 replaces <option> tags with their contents when inserted outside of\n        // the select element.\n        div.innerHTML = \"<option></option>\";\n        support.option = !!div.lastChild;\n    })();\n    // We have to close these tags to support XHTML (trac-13200)\n    var wrapMap = {\n        // XHTML parsers do not magically insert elements in the\n        // same way that tag soup parsers do. So we cannot shorten\n        // this by omitting <tbody> or other required elements.\n        thead: [\n            1,\n            \"<table>\",\n            \"</table>\"\n        ],\n        col: [\n            2,\n            \"<table><colgroup>\",\n            \"</colgroup></table>\"\n        ],\n        tr: [\n            2,\n            \"<table><tbody>\",\n            \"</tbody></table>\"\n        ],\n        td: [\n            3,\n            \"<table><tbody><tr>\",\n            \"</tr></tbody></table>\"\n        ],\n        _default: [\n            0,\n            \"\",\n            \"\"\n        ]\n    };\n    wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;\n    wrapMap.th = wrapMap.td;\n    // Support: IE <=9 only\n    if (!support.option) {\n        wrapMap.optgroup = wrapMap.option = [\n            1,\n            \"<select multiple='multiple'>\",\n            \"</select>\"\n        ];\n    }\n    function getAll(context, tag) {\n        // Support: IE <=9 - 11 only\n        // Use typeof to avoid zero-argument method invocation on host objects (trac-15151)\n        var ret;\n        if (typeof context.getElementsByTagName !== \"undefined\") {\n            ret = context.getElementsByTagName(tag || \"*\");\n        } else if (typeof context.querySelectorAll !== \"undefined\") {\n            ret = context.querySelectorAll(tag || \"*\");\n        } else {\n            ret = [];\n        }\n        if (tag === undefined || tag && nodeName(context, tag)) {\n            return jQuery.merge([\n                context\n            ], ret);\n        }\n        return ret;\n    }\n    // Mark scripts as having already been evaluated\n    function setGlobalEval(elems, refElements) {\n        var i = 0, l = elems.length;\n        for(; i < l; i++){\n            dataPriv.set(elems[i], \"globalEval\", !refElements || dataPriv.get(refElements[i], \"globalEval\"));\n        }\n    }\n    var rhtml = /<|&#?\\w+;/;\n    function buildFragment(elems, context, scripts, selection, ignored) {\n        var elem, tmp, tag, wrap, attached, j, fragment = context.createDocumentFragment(), nodes = [], i = 0, l = elems.length;\n        for(; i < l; i++){\n            elem = elems[i];\n            if (elem || elem === 0) {\n                // Add nodes directly\n                if (toType(elem) === \"object\") {\n                    // Support: Android <=4.0 only, PhantomJS 1 only\n                    // push.apply(_, arraylike) throws on ancient WebKit\n                    jQuery.merge(nodes, elem.nodeType ? [\n                        elem\n                    ] : elem);\n                // Convert non-html into a text node\n                } else if (!rhtml.test(elem)) {\n                    nodes.push(context.createTextNode(elem));\n                // Convert html into DOM nodes\n                } else {\n                    tmp = tmp || fragment.appendChild(context.createElement(\"div\"));\n                    // Deserialize a standard representation\n                    tag = (rtagName.exec(elem) || [\n                        \"\",\n                        \"\"\n                    ])[1].toLowerCase();\n                    wrap = wrapMap[tag] || wrapMap._default;\n                    tmp.innerHTML = wrap[1] + jQuery.htmlPrefilter(elem) + wrap[2];\n                    // Descend through wrappers to the right content\n                    j = wrap[0];\n                    while(j--){\n                        tmp = tmp.lastChild;\n                    }\n                    // Support: Android <=4.0 only, PhantomJS 1 only\n                    // push.apply(_, arraylike) throws on ancient WebKit\n                    jQuery.merge(nodes, tmp.childNodes);\n                    // Remember the top-level container\n                    tmp = fragment.firstChild;\n                    // Ensure the created nodes are orphaned (trac-12392)\n                    tmp.textContent = \"\";\n                }\n            }\n        }\n        // Remove wrapper from fragment\n        fragment.textContent = \"\";\n        i = 0;\n        while(elem = nodes[i++]){\n            // Skip elements already in the context collection (trac-4087)\n            if (selection && jQuery.inArray(elem, selection) > -1) {\n                if (ignored) {\n                    ignored.push(elem);\n                }\n                continue;\n            }\n            attached = isAttached(elem);\n            // Append to fragment\n            tmp = getAll(fragment.appendChild(elem), \"script\");\n            // Preserve script evaluation history\n            if (attached) {\n                setGlobalEval(tmp);\n            }\n            // Capture executables\n            if (scripts) {\n                j = 0;\n                while(elem = tmp[j++]){\n                    if (rscriptType.test(elem.type || \"\")) {\n                        scripts.push(elem);\n                    }\n                }\n            }\n        }\n        return fragment;\n    }\n    var rtypenamespace = /^([^.]*)(?:\\.(.+)|)/;\n    function returnTrue() {\n        return true;\n    }\n    function returnFalse() {\n        return false;\n    }\n    function on(elem, types, selector, data, fn, one) {\n        var origFn, type;\n        // Types can be a map of types/handlers\n        if (typeof types === \"object\") {\n            // ( types-Object, selector, data )\n            if (typeof selector !== \"string\") {\n                // ( types-Object, data )\n                data = data || selector;\n                selector = undefined;\n            }\n            for(type in types){\n                on(elem, type, selector, data, types[type], one);\n            }\n            return elem;\n        }\n        if (data == null && fn == null) {\n            // ( types, fn )\n            fn = selector;\n            data = selector = undefined;\n        } else if (fn == null) {\n            if (typeof selector === \"string\") {\n                // ( types, selector, fn )\n                fn = data;\n                data = undefined;\n            } else {\n                // ( types, data, fn )\n                fn = data;\n                data = selector;\n                selector = undefined;\n            }\n        }\n        if (fn === false) {\n            fn = returnFalse;\n        } else if (!fn) {\n            return elem;\n        }\n        if (one === 1) {\n            origFn = fn;\n            fn = function(event) {\n                // Can use an empty set, since event contains the info\n                jQuery().off(event);\n                return origFn.apply(this, arguments);\n            };\n            // Use same guid so caller can remove using origFn\n            fn.guid = origFn.guid || (origFn.guid = jQuery.guid++);\n        }\n        return elem.each(function() {\n            jQuery.event.add(this, types, fn, data, selector);\n        });\n    }\n    /*\n * Helper functions for managing events -- not part of the public interface.\n * Props to Dean Edwards' addEvent library for many of the ideas.\n */ jQuery.event = {\n        global: {},\n        add: function(elem, types, handler, data, selector) {\n            var handleObjIn, eventHandle, tmp, events, t, handleObj, special, handlers, type, namespaces, origType, elemData = dataPriv.get(elem);\n            // Only attach events to objects that accept data\n            if (!acceptData(elem)) {\n                return;\n            }\n            // Caller can pass in an object of custom data in lieu of the handler\n            if (handler.handler) {\n                handleObjIn = handler;\n                handler = handleObjIn.handler;\n                selector = handleObjIn.selector;\n            }\n            // Ensure that invalid selectors throw exceptions at attach time\n            // Evaluate against documentElement in case elem is a non-element node (e.g., document)\n            if (selector) {\n                jQuery.find.matchesSelector(documentElement, selector);\n            }\n            // Make sure that the handler has a unique ID, used to find/remove it later\n            if (!handler.guid) {\n                handler.guid = jQuery.guid++;\n            }\n            // Init the element's event structure and main handler, if this is the first\n            if (!(events = elemData.events)) {\n                events = elemData.events = Object.create(null);\n            }\n            if (!(eventHandle = elemData.handle)) {\n                eventHandle = elemData.handle = function(e) {\n                    // Discard the second event of a jQuery.event.trigger() and\n                    // when an event is called after a page has unloaded\n                    return typeof jQuery !== \"undefined\" && jQuery.event.triggered !== e.type ? jQuery.event.dispatch.apply(elem, arguments) : undefined;\n                };\n            }\n            // Handle multiple events separated by a space\n            types = (types || \"\").match(rnothtmlwhite) || [\n                \"\"\n            ];\n            t = types.length;\n            while(t--){\n                tmp = rtypenamespace.exec(types[t]) || [];\n                type = origType = tmp[1];\n                namespaces = (tmp[2] || \"\").split(\".\").sort();\n                // There *must* be a type, no attaching namespace-only handlers\n                if (!type) {\n                    continue;\n                }\n                // If event changes its type, use the special event handlers for the changed type\n                special = jQuery.event.special[type] || {};\n                // If selector defined, determine special event api type, otherwise given type\n                type = (selector ? special.delegateType : special.bindType) || type;\n                // Update special based on newly reset type\n                special = jQuery.event.special[type] || {};\n                // handleObj is passed to all event handlers\n                handleObj = jQuery.extend({\n                    type: type,\n                    origType: origType,\n                    data: data,\n                    handler: handler,\n                    guid: handler.guid,\n                    selector: selector,\n                    needsContext: selector && jQuery.expr.match.needsContext.test(selector),\n                    namespace: namespaces.join(\".\")\n                }, handleObjIn);\n                // Init the event handler queue if we're the first\n                if (!(handlers = events[type])) {\n                    handlers = events[type] = [];\n                    handlers.delegateCount = 0;\n                    // Only use addEventListener if the special events handler returns false\n                    if (!special.setup || special.setup.call(elem, data, namespaces, eventHandle) === false) {\n                        if (elem.addEventListener) {\n                            elem.addEventListener(type, eventHandle);\n                        }\n                    }\n                }\n                if (special.add) {\n                    special.add.call(elem, handleObj);\n                    if (!handleObj.handler.guid) {\n                        handleObj.handler.guid = handler.guid;\n                    }\n                }\n                // Add to the element's handler list, delegates in front\n                if (selector) {\n                    handlers.splice(handlers.delegateCount++, 0, handleObj);\n                } else {\n                    handlers.push(handleObj);\n                }\n                // Keep track of which events have ever been used, for event optimization\n                jQuery.event.global[type] = true;\n            }\n        },\n        // Detach an event or set of events from an element\n        remove: function(elem, types, handler, selector, mappedTypes) {\n            var j, origCount, tmp, events, t, handleObj, special, handlers, type, namespaces, origType, elemData = dataPriv.hasData(elem) && dataPriv.get(elem);\n            if (!elemData || !(events = elemData.events)) {\n                return;\n            }\n            // Once for each type.namespace in types; type may be omitted\n            types = (types || \"\").match(rnothtmlwhite) || [\n                \"\"\n            ];\n            t = types.length;\n            while(t--){\n                tmp = rtypenamespace.exec(types[t]) || [];\n                type = origType = tmp[1];\n                namespaces = (tmp[2] || \"\").split(\".\").sort();\n                // Unbind all events (on this namespace, if provided) for the element\n                if (!type) {\n                    for(type in events){\n                        jQuery.event.remove(elem, type + types[t], handler, selector, true);\n                    }\n                    continue;\n                }\n                special = jQuery.event.special[type] || {};\n                type = (selector ? special.delegateType : special.bindType) || type;\n                handlers = events[type] || [];\n                tmp = tmp[2] && new RegExp(\"(^|\\\\.)\" + namespaces.join(\"\\\\.(?:.*\\\\.|)\") + \"(\\\\.|$)\");\n                // Remove matching events\n                origCount = j = handlers.length;\n                while(j--){\n                    handleObj = handlers[j];\n                    if ((mappedTypes || origType === handleObj.origType) && (!handler || handler.guid === handleObj.guid) && (!tmp || tmp.test(handleObj.namespace)) && (!selector || selector === handleObj.selector || selector === \"**\" && handleObj.selector)) {\n                        handlers.splice(j, 1);\n                        if (handleObj.selector) {\n                            handlers.delegateCount--;\n                        }\n                        if (special.remove) {\n                            special.remove.call(elem, handleObj);\n                        }\n                    }\n                }\n                // Remove generic event handler if we removed something and no more handlers exist\n                // (avoids potential for endless recursion during removal of special event handlers)\n                if (origCount && !handlers.length) {\n                    if (!special.teardown || special.teardown.call(elem, namespaces, elemData.handle) === false) {\n                        jQuery.removeEvent(elem, type, elemData.handle);\n                    }\n                    delete events[type];\n                }\n            }\n            // Remove data and the expando if it's no longer used\n            if (jQuery.isEmptyObject(events)) {\n                dataPriv.remove(elem, \"handle events\");\n            }\n        },\n        dispatch: function(nativeEvent) {\n            var i, j, ret, matched, handleObj, handlerQueue, args = new Array(arguments.length), // Make a writable jQuery.Event from the native event object\n            event = jQuery.event.fix(nativeEvent), handlers = (dataPriv.get(this, \"events\") || Object.create(null))[event.type] || [], special = jQuery.event.special[event.type] || {};\n            // Use the fix-ed jQuery.Event rather than the (read-only) native event\n            args[0] = event;\n            for(i = 1; i < arguments.length; i++){\n                args[i] = arguments[i];\n            }\n            event.delegateTarget = this;\n            // Call the preDispatch hook for the mapped type, and let it bail if desired\n            if (special.preDispatch && special.preDispatch.call(this, event) === false) {\n                return;\n            }\n            // Determine handlers\n            handlerQueue = jQuery.event.handlers.call(this, event, handlers);\n            // Run delegates first; they may want to stop propagation beneath us\n            i = 0;\n            while((matched = handlerQueue[i++]) && !event.isPropagationStopped()){\n                event.currentTarget = matched.elem;\n                j = 0;\n                while((handleObj = matched.handlers[j++]) && !event.isImmediatePropagationStopped()){\n                    // If the event is namespaced, then each handler is only invoked if it is\n                    // specially universal or its namespaces are a superset of the event's.\n                    if (!event.rnamespace || handleObj.namespace === false || event.rnamespace.test(handleObj.namespace)) {\n                        event.handleObj = handleObj;\n                        event.data = handleObj.data;\n                        ret = ((jQuery.event.special[handleObj.origType] || {}).handle || handleObj.handler).apply(matched.elem, args);\n                        if (ret !== undefined) {\n                            if ((event.result = ret) === false) {\n                                event.preventDefault();\n                                event.stopPropagation();\n                            }\n                        }\n                    }\n                }\n            }\n            // Call the postDispatch hook for the mapped type\n            if (special.postDispatch) {\n                special.postDispatch.call(this, event);\n            }\n            return event.result;\n        },\n        handlers: function(event, handlers) {\n            var i, handleObj, sel, matchedHandlers, matchedSelectors, handlerQueue = [], delegateCount = handlers.delegateCount, cur = event.target;\n            // Find delegate handlers\n            if (delegateCount && // Support: IE <=9\n            // Black-hole SVG <use> instance trees (trac-13180)\n            cur.nodeType && // Support: Firefox <=42\n            // Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)\n            // https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click\n            // Support: IE 11 only\n            // ...but not arrow key \"clicks\" of radio inputs, which can have `button` -1 (gh-2343)\n            !(event.type === \"click\" && event.button >= 1)) {\n                for(; cur !== this; cur = cur.parentNode || this){\n                    // Don't check non-elements (trac-13208)\n                    // Don't process clicks on disabled elements (trac-6911, trac-8165, trac-11382, trac-11764)\n                    if (cur.nodeType === 1 && !(event.type === \"click\" && cur.disabled === true)) {\n                        matchedHandlers = [];\n                        matchedSelectors = {};\n                        for(i = 0; i < delegateCount; i++){\n                            handleObj = handlers[i];\n                            // Don't conflict with Object.prototype properties (trac-13203)\n                            sel = handleObj.selector + \" \";\n                            if (matchedSelectors[sel] === undefined) {\n                                matchedSelectors[sel] = handleObj.needsContext ? jQuery(sel, this).index(cur) > -1 : jQuery.find(sel, this, null, [\n                                    cur\n                                ]).length;\n                            }\n                            if (matchedSelectors[sel]) {\n                                matchedHandlers.push(handleObj);\n                            }\n                        }\n                        if (matchedHandlers.length) {\n                            handlerQueue.push({\n                                elem: cur,\n                                handlers: matchedHandlers\n                            });\n                        }\n                    }\n                }\n            }\n            // Add the remaining (directly-bound) handlers\n            cur = this;\n            if (delegateCount < handlers.length) {\n                handlerQueue.push({\n                    elem: cur,\n                    handlers: handlers.slice(delegateCount)\n                });\n            }\n            return handlerQueue;\n        },\n        addProp: function(name, hook) {\n            Object.defineProperty(jQuery.Event.prototype, name, {\n                enumerable: true,\n                configurable: true,\n                get: isFunction(hook) ? function() {\n                    if (this.originalEvent) {\n                        return hook(this.originalEvent);\n                    }\n                } : function() {\n                    if (this.originalEvent) {\n                        return this.originalEvent[name];\n                    }\n                },\n                set: function(value) {\n                    Object.defineProperty(this, name, {\n                        enumerable: true,\n                        configurable: true,\n                        writable: true,\n                        value: value\n                    });\n                }\n            });\n        },\n        fix: function(originalEvent) {\n            return originalEvent[jQuery.expando] ? originalEvent : new jQuery.Event(originalEvent);\n        },\n        special: {\n            load: {\n                // Prevent triggered image.load events from bubbling to window.load\n                noBubble: true\n            },\n            click: {\n                // Utilize native event to ensure correct state for checkable inputs\n                setup: function(data) {\n                    // For mutual compressibility with _default, replace `this` access with a local var.\n                    // `|| data` is dead code meant only to preserve the variable through minification.\n                    var el = this || data;\n                    // Claim the first handler\n                    if (rcheckableType.test(el.type) && el.click && nodeName(el, \"input\")) {\n                        // dataPriv.set( el, \"click\", ... )\n                        leverageNative(el, \"click\", true);\n                    }\n                    // Return false to allow normal processing in the caller\n                    return false;\n                },\n                trigger: function(data) {\n                    // For mutual compressibility with _default, replace `this` access with a local var.\n                    // `|| data` is dead code meant only to preserve the variable through minification.\n                    var el = this || data;\n                    // Force setup before triggering a click\n                    if (rcheckableType.test(el.type) && el.click && nodeName(el, \"input\")) {\n                        leverageNative(el, \"click\");\n                    }\n                    // Return non-false to allow normal event-path propagation\n                    return true;\n                },\n                // For cross-browser consistency, suppress native .click() on links\n                // Also prevent it if we're currently inside a leveraged native-event stack\n                _default: function(event) {\n                    var target = event.target;\n                    return rcheckableType.test(target.type) && target.click && nodeName(target, \"input\") && dataPriv.get(target, \"click\") || nodeName(target, \"a\");\n                }\n            },\n            beforeunload: {\n                postDispatch: function(event) {\n                    // Support: Firefox 20+\n                    // Firefox doesn't alert if the returnValue field is not set.\n                    if (event.result !== undefined && event.originalEvent) {\n                        event.originalEvent.returnValue = event.result;\n                    }\n                }\n            }\n        }\n    };\n    // Ensure the presence of an event listener that handles manually-triggered\n    // synthetic events by interrupting progress until reinvoked in response to\n    // *native* events that it fires directly, ensuring that state changes have\n    // already occurred before other listeners are invoked.\n    function leverageNative(el, type, isSetup) {\n        // Missing `isSetup` indicates a trigger call, which must force setup through jQuery.event.add\n        if (!isSetup) {\n            if (dataPriv.get(el, type) === undefined) {\n                jQuery.event.add(el, type, returnTrue);\n            }\n            return;\n        }\n        // Register the controller as a special universal handler for all event namespaces\n        dataPriv.set(el, type, false);\n        jQuery.event.add(el, type, {\n            namespace: false,\n            handler: function(event) {\n                var result, saved = dataPriv.get(this, type);\n                if (event.isTrigger & 1 && this[type]) {\n                    // Interrupt processing of the outer synthetic .trigger()ed event\n                    if (!saved) {\n                        // Store arguments for use when handling the inner native event\n                        // There will always be at least one argument (an event object), so this array\n                        // will not be confused with a leftover capture object.\n                        saved = slice.call(arguments);\n                        dataPriv.set(this, type, saved);\n                        // Trigger the native event and capture its result\n                        this[type]();\n                        result = dataPriv.get(this, type);\n                        dataPriv.set(this, type, false);\n                        if (saved !== result) {\n                            // Cancel the outer synthetic event\n                            event.stopImmediatePropagation();\n                            event.preventDefault();\n                            return result;\n                        }\n                    // If this is an inner synthetic event for an event with a bubbling surrogate\n                    // (focus or blur), assume that the surrogate already propagated from triggering\n                    // the native event and prevent that from happening again here.\n                    // This technically gets the ordering wrong w.r.t. to `.trigger()` (in which the\n                    // bubbling surrogate propagates *after* the non-bubbling base), but that seems\n                    // less bad than duplication.\n                    } else if ((jQuery.event.special[type] || {}).delegateType) {\n                        event.stopPropagation();\n                    }\n                // If this is a native event triggered above, everything is now in order\n                // Fire an inner synthetic event with the original arguments\n                } else if (saved) {\n                    // ...and capture the result\n                    dataPriv.set(this, type, jQuery.event.trigger(saved[0], saved.slice(1), this));\n                    // Abort handling of the native event by all jQuery handlers while allowing\n                    // native handlers on the same element to run. On target, this is achieved\n                    // by stopping immediate propagation just on the jQuery event. However,\n                    // the native event is re-wrapped by a jQuery one on each level of the\n                    // propagation so the only way to stop it for jQuery is to stop it for\n                    // everyone via native `stopPropagation()`. This is not a problem for\n                    // focus/blur which don't bubble, but it does also stop click on checkboxes\n                    // and radios. We accept this limitation.\n                    event.stopPropagation();\n                    event.isImmediatePropagationStopped = returnTrue;\n                }\n            }\n        });\n    }\n    jQuery.removeEvent = function(elem, type, handle) {\n        // This \"if\" is needed for plain objects\n        if (elem.removeEventListener) {\n            elem.removeEventListener(type, handle);\n        }\n    };\n    jQuery.Event = function(src, props) {\n        // Allow instantiation without the 'new' keyword\n        if (!(this instanceof jQuery.Event)) {\n            return new jQuery.Event(src, props);\n        }\n        // Event object\n        if (src && src.type) {\n            this.originalEvent = src;\n            this.type = src.type;\n            // Events bubbling up the document may have been marked as prevented\n            // by a handler lower down the tree; reflect the correct value.\n            this.isDefaultPrevented = src.defaultPrevented || src.defaultPrevented === undefined && // Support: Android <=2.3 only\n            src.returnValue === false ? returnTrue : returnFalse;\n            // Create target properties\n            // Support: Safari <=6 - 7 only\n            // Target should not be a text node (trac-504, trac-13143)\n            this.target = src.target && src.target.nodeType === 3 ? src.target.parentNode : src.target;\n            this.currentTarget = src.currentTarget;\n            this.relatedTarget = src.relatedTarget;\n        // Event type\n        } else {\n            this.type = src;\n        }\n        // Put explicitly provided properties onto the event object\n        if (props) {\n            jQuery.extend(this, props);\n        }\n        // Create a timestamp if incoming event doesn't have one\n        this.timeStamp = src && src.timeStamp || Date.now();\n        // Mark it as fixed\n        this[jQuery.expando] = true;\n    };\n    // jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding\n    // https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html\n    jQuery.Event.prototype = {\n        constructor: jQuery.Event,\n        isDefaultPrevented: returnFalse,\n        isPropagationStopped: returnFalse,\n        isImmediatePropagationStopped: returnFalse,\n        isSimulated: false,\n        preventDefault: function() {\n            var e = this.originalEvent;\n            this.isDefaultPrevented = returnTrue;\n            if (e && !this.isSimulated) {\n                e.preventDefault();\n            }\n        },\n        stopPropagation: function() {\n            var e = this.originalEvent;\n            this.isPropagationStopped = returnTrue;\n            if (e && !this.isSimulated) {\n                e.stopPropagation();\n            }\n        },\n        stopImmediatePropagation: function() {\n            var e = this.originalEvent;\n            this.isImmediatePropagationStopped = returnTrue;\n            if (e && !this.isSimulated) {\n                e.stopImmediatePropagation();\n            }\n            this.stopPropagation();\n        }\n    };\n    // Includes all common event props including KeyEvent and MouseEvent specific props\n    jQuery.each({\n        altKey: true,\n        bubbles: true,\n        cancelable: true,\n        changedTouches: true,\n        ctrlKey: true,\n        detail: true,\n        eventPhase: true,\n        metaKey: true,\n        pageX: true,\n        pageY: true,\n        shiftKey: true,\n        view: true,\n        \"char\": true,\n        code: true,\n        charCode: true,\n        key: true,\n        keyCode: true,\n        button: true,\n        buttons: true,\n        clientX: true,\n        clientY: true,\n        offsetX: true,\n        offsetY: true,\n        pointerId: true,\n        pointerType: true,\n        screenX: true,\n        screenY: true,\n        targetTouches: true,\n        toElement: true,\n        touches: true,\n        which: true\n    }, jQuery.event.addProp);\n    jQuery.each({\n        focus: \"focusin\",\n        blur: \"focusout\"\n    }, function(type, delegateType) {\n        function focusMappedHandler(nativeEvent) {\n            if (document.documentMode) {\n                // Support: IE 11+\n                // Attach a single focusin/focusout handler on the document while someone wants\n                // focus/blur. This is because the former are synchronous in IE while the latter\n                // are async. In other browsers, all those handlers are invoked synchronously.\n                // `handle` from private data would already wrap the event, but we need\n                // to change the `type` here.\n                var handle = dataPriv.get(this, \"handle\"), event = jQuery.event.fix(nativeEvent);\n                event.type = nativeEvent.type === \"focusin\" ? \"focus\" : \"blur\";\n                event.isSimulated = true;\n                // First, handle focusin/focusout\n                handle(nativeEvent);\n                // ...then, handle focus/blur\n                //\n                // focus/blur don't bubble while focusin/focusout do; simulate the former by only\n                // invoking the handler at the lower level.\n                if (event.target === event.currentTarget) {\n                    // The setup part calls `leverageNative`, which, in turn, calls\n                    // `jQuery.event.add`, so event handle will already have been set\n                    // by this point.\n                    handle(event);\n                }\n            } else {\n                // For non-IE browsers, attach a single capturing handler on the document\n                // while someone wants focusin/focusout.\n                jQuery.event.simulate(delegateType, nativeEvent.target, jQuery.event.fix(nativeEvent));\n            }\n        }\n        jQuery.event.special[type] = {\n            // Utilize native event if possible so blur/focus sequence is correct\n            setup: function() {\n                var attaches;\n                // Claim the first handler\n                // dataPriv.set( this, \"focus\", ... )\n                // dataPriv.set( this, \"blur\", ... )\n                leverageNative(this, type, true);\n                if (document.documentMode) {\n                    // Support: IE 9 - 11+\n                    // We use the same native handler for focusin & focus (and focusout & blur)\n                    // so we need to coordinate setup & teardown parts between those events.\n                    // Use `delegateType` as the key as `type` is already used by `leverageNative`.\n                    attaches = dataPriv.get(this, delegateType);\n                    if (!attaches) {\n                        this.addEventListener(delegateType, focusMappedHandler);\n                    }\n                    dataPriv.set(this, delegateType, (attaches || 0) + 1);\n                } else {\n                    // Return false to allow normal processing in the caller\n                    return false;\n                }\n            },\n            trigger: function() {\n                // Force setup before trigger\n                leverageNative(this, type);\n                // Return non-false to allow normal event-path propagation\n                return true;\n            },\n            teardown: function() {\n                var attaches;\n                if (document.documentMode) {\n                    attaches = dataPriv.get(this, delegateType) - 1;\n                    if (!attaches) {\n                        this.removeEventListener(delegateType, focusMappedHandler);\n                        dataPriv.remove(this, delegateType);\n                    } else {\n                        dataPriv.set(this, delegateType, attaches);\n                    }\n                } else {\n                    // Return false to indicate standard teardown should be applied\n                    return false;\n                }\n            },\n            // Suppress native focus or blur if we're currently inside\n            // a leveraged native-event stack\n            _default: function(event) {\n                return dataPriv.get(event.target, type);\n            },\n            delegateType: delegateType\n        };\n        // Support: Firefox <=44\n        // Firefox doesn't have focus(in | out) events\n        // Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787\n        //\n        // Support: Chrome <=48 - 49, Safari <=9.0 - 9.1\n        // focus(in | out) events fire after focus & blur events,\n        // which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order\n        // Related ticket - https://bugs.chromium.org/p/chromium/issues/detail?id=449857\n        //\n        // Support: IE 9 - 11+\n        // To preserve relative focusin/focus & focusout/blur event order guaranteed on the 3.x branch,\n        // attach a single handler for both events in IE.\n        jQuery.event.special[delegateType] = {\n            setup: function() {\n                // Handle: regular nodes (via `this.ownerDocument`), window\n                // (via `this.document`) & document (via `this`).\n                var doc = this.ownerDocument || this.document || this, dataHolder = document.documentMode ? this : doc, attaches = dataPriv.get(dataHolder, delegateType);\n                // Support: IE 9 - 11+\n                // We use the same native handler for focusin & focus (and focusout & blur)\n                // so we need to coordinate setup & teardown parts between those events.\n                // Use `delegateType` as the key as `type` is already used by `leverageNative`.\n                if (!attaches) {\n                    if (document.documentMode) {\n                        this.addEventListener(delegateType, focusMappedHandler);\n                    } else {\n                        doc.addEventListener(type, focusMappedHandler, true);\n                    }\n                }\n                dataPriv.set(dataHolder, delegateType, (attaches || 0) + 1);\n            },\n            teardown: function() {\n                var doc = this.ownerDocument || this.document || this, dataHolder = document.documentMode ? this : doc, attaches = dataPriv.get(dataHolder, delegateType) - 1;\n                if (!attaches) {\n                    if (document.documentMode) {\n                        this.removeEventListener(delegateType, focusMappedHandler);\n                    } else {\n                        doc.removeEventListener(type, focusMappedHandler, true);\n                    }\n                    dataPriv.remove(dataHolder, delegateType);\n                } else {\n                    dataPriv.set(dataHolder, delegateType, attaches);\n                }\n            }\n        };\n    });\n    // Create mouseenter/leave events using mouseover/out and event-time checks\n    // so that event delegation works in jQuery.\n    // Do the same for pointerenter/pointerleave and pointerover/pointerout\n    //\n    // Support: Safari 7 only\n    // Safari sends mouseenter too often; see:\n    // https://bugs.chromium.org/p/chromium/issues/detail?id=470258\n    // for the description of the bug (it existed in older Chrome versions as well).\n    jQuery.each({\n        mouseenter: \"mouseover\",\n        mouseleave: \"mouseout\",\n        pointerenter: \"pointerover\",\n        pointerleave: \"pointerout\"\n    }, function(orig, fix) {\n        jQuery.event.special[orig] = {\n            delegateType: fix,\n            bindType: fix,\n            handle: function(event) {\n                var ret, target = this, related = event.relatedTarget, handleObj = event.handleObj;\n                // For mouseenter/leave call the handler if related is outside the target.\n                // NB: No relatedTarget if the mouse left/entered the browser window\n                if (!related || related !== target && !jQuery.contains(target, related)) {\n                    event.type = handleObj.origType;\n                    ret = handleObj.handler.apply(this, arguments);\n                    event.type = fix;\n                }\n                return ret;\n            }\n        };\n    });\n    jQuery.fn.extend({\n        on: function(types, selector, data, fn) {\n            return on(this, types, selector, data, fn);\n        },\n        one: function(types, selector, data, fn) {\n            return on(this, types, selector, data, fn, 1);\n        },\n        off: function(types, selector, fn) {\n            var handleObj, type;\n            if (types && types.preventDefault && types.handleObj) {\n                // ( event )  dispatched jQuery.Event\n                handleObj = types.handleObj;\n                jQuery(types.delegateTarget).off(handleObj.namespace ? handleObj.origType + \".\" + handleObj.namespace : handleObj.origType, handleObj.selector, handleObj.handler);\n                return this;\n            }\n            if (typeof types === \"object\") {\n                // ( types-object [, selector] )\n                for(type in types){\n                    this.off(type, selector, types[type]);\n                }\n                return this;\n            }\n            if (selector === false || typeof selector === \"function\") {\n                // ( types [, fn] )\n                fn = selector;\n                selector = undefined;\n            }\n            if (fn === false) {\n                fn = returnFalse;\n            }\n            return this.each(function() {\n                jQuery.event.remove(this, types, fn, selector);\n            });\n        }\n    });\n    var // Support: IE <=10 - 11, Edge 12 - 13 only\n    // In IE/Edge using regex groups here causes severe slowdowns.\n    // See https://connect.microsoft.com/IE/feedback/details/1736512/\n    rnoInnerhtml = /<script|<style|<link/i, // checked=\"checked\" or checked\n    rchecked = /checked\\s*(?:[^=]|=\\s*.checked.)/i, rcleanScript = /^\\s*<!\\[CDATA\\[|\\]\\]>\\s*$/g;\n    // Prefer a tbody over its parent table for containing new rows\n    function manipulationTarget(elem, content) {\n        if (nodeName(elem, \"table\") && nodeName(content.nodeType !== 11 ? content : content.firstChild, \"tr\")) {\n            return jQuery(elem).children(\"tbody\")[0] || elem;\n        }\n        return elem;\n    }\n    // Replace/restore the type attribute of script elements for safe DOM manipulation\n    function disableScript(elem) {\n        elem.type = (elem.getAttribute(\"type\") !== null) + \"/\" + elem.type;\n        return elem;\n    }\n    function restoreScript(elem) {\n        if ((elem.type || \"\").slice(0, 5) === \"true/\") {\n            elem.type = elem.type.slice(5);\n        } else {\n            elem.removeAttribute(\"type\");\n        }\n        return elem;\n    }\n    function cloneCopyEvent(src, dest) {\n        var i, l, type, pdataOld, udataOld, udataCur, events;\n        if (dest.nodeType !== 1) {\n            return;\n        }\n        // 1. Copy private data: events, handlers, etc.\n        if (dataPriv.hasData(src)) {\n            pdataOld = dataPriv.get(src);\n            events = pdataOld.events;\n            if (events) {\n                dataPriv.remove(dest, \"handle events\");\n                for(type in events){\n                    for(i = 0, l = events[type].length; i < l; i++){\n                        jQuery.event.add(dest, type, events[type][i]);\n                    }\n                }\n            }\n        }\n        // 2. Copy user data\n        if (dataUser.hasData(src)) {\n            udataOld = dataUser.access(src);\n            udataCur = jQuery.extend({}, udataOld);\n            dataUser.set(dest, udataCur);\n        }\n    }\n    // Fix IE bugs, see support tests\n    function fixInput(src, dest) {\n        var nodeName = dest.nodeName.toLowerCase();\n        // Fails to persist the checked state of a cloned checkbox or radio button.\n        if (nodeName === \"input\" && rcheckableType.test(src.type)) {\n            dest.checked = src.checked;\n        // Fails to return the selected option to the default selected state when cloning options\n        } else if (nodeName === \"input\" || nodeName === \"textarea\") {\n            dest.defaultValue = src.defaultValue;\n        }\n    }\n    function domManip(collection, args, callback, ignored) {\n        // Flatten any nested arrays\n        args = flat(args);\n        var fragment, first, scripts, hasScripts, node, doc, i = 0, l = collection.length, iNoClone = l - 1, value = args[0], valueIsFunction = isFunction(value);\n        // We can't cloneNode fragments that contain checked, in WebKit\n        if (valueIsFunction || l > 1 && typeof value === \"string\" && !support.checkClone && rchecked.test(value)) {\n            return collection.each(function(index) {\n                var self = collection.eq(index);\n                if (valueIsFunction) {\n                    args[0] = value.call(this, index, self.html());\n                }\n                domManip(self, args, callback, ignored);\n            });\n        }\n        if (l) {\n            fragment = buildFragment(args, collection[0].ownerDocument, false, collection, ignored);\n            first = fragment.firstChild;\n            if (fragment.childNodes.length === 1) {\n                fragment = first;\n            }\n            // Require either new content or an interest in ignored elements to invoke the callback\n            if (first || ignored) {\n                scripts = jQuery.map(getAll(fragment, \"script\"), disableScript);\n                hasScripts = scripts.length;\n                // Use the original fragment for the last item\n                // instead of the first because it can end up\n                // being emptied incorrectly in certain situations (trac-8070).\n                for(; i < l; i++){\n                    node = fragment;\n                    if (i !== iNoClone) {\n                        node = jQuery.clone(node, true, true);\n                        // Keep references to cloned scripts for later restoration\n                        if (hasScripts) {\n                            // Support: Android <=4.0 only, PhantomJS 1 only\n                            // push.apply(_, arraylike) throws on ancient WebKit\n                            jQuery.merge(scripts, getAll(node, \"script\"));\n                        }\n                    }\n                    callback.call(collection[i], node, i);\n                }\n                if (hasScripts) {\n                    doc = scripts[scripts.length - 1].ownerDocument;\n                    // Re-enable scripts\n                    jQuery.map(scripts, restoreScript);\n                    // Evaluate executable scripts on first document insertion\n                    for(i = 0; i < hasScripts; i++){\n                        node = scripts[i];\n                        if (rscriptType.test(node.type || \"\") && !dataPriv.access(node, \"globalEval\") && jQuery.contains(doc, node)) {\n                            if (node.src && (node.type || \"\").toLowerCase() !== \"module\") {\n                                // Optional AJAX dependency, but won't run scripts if not present\n                                if (jQuery._evalUrl && !node.noModule) {\n                                    jQuery._evalUrl(node.src, {\n                                        nonce: node.nonce || node.getAttribute(\"nonce\")\n                                    }, doc);\n                                }\n                            } else {\n                                // Unwrap a CDATA section containing script contents. This shouldn't be\n                                // needed as in XML documents they're already not visible when\n                                // inspecting element contents and in HTML documents they have no\n                                // meaning but we're preserving that logic for backwards compatibility.\n                                // This will be removed completely in 4.0. See gh-4904.\n                                DOMEval(node.textContent.replace(rcleanScript, \"\"), node, doc);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return collection;\n    }\n    function remove(elem, selector, keepData) {\n        var node, nodes = selector ? jQuery.filter(selector, elem) : elem, i = 0;\n        for(; (node = nodes[i]) != null; i++){\n            if (!keepData && node.nodeType === 1) {\n                jQuery.cleanData(getAll(node));\n            }\n            if (node.parentNode) {\n                if (keepData && isAttached(node)) {\n                    setGlobalEval(getAll(node, \"script\"));\n                }\n                node.parentNode.removeChild(node);\n            }\n        }\n        return elem;\n    }\n    jQuery.extend({\n        htmlPrefilter: function(html) {\n            return html;\n        },\n        clone: function(elem, dataAndEvents, deepDataAndEvents) {\n            var i, l, srcElements, destElements, clone = elem.cloneNode(true), inPage = isAttached(elem);\n            // Fix IE cloning issues\n            if (!support.noCloneChecked && (elem.nodeType === 1 || elem.nodeType === 11) && !jQuery.isXMLDoc(elem)) {\n                // We eschew jQuery#find here for performance reasons:\n                // https://jsperf.com/getall-vs-sizzle/2\n                destElements = getAll(clone);\n                srcElements = getAll(elem);\n                for(i = 0, l = srcElements.length; i < l; i++){\n                    fixInput(srcElements[i], destElements[i]);\n                }\n            }\n            // Copy the events from the original to the clone\n            if (dataAndEvents) {\n                if (deepDataAndEvents) {\n                    srcElements = srcElements || getAll(elem);\n                    destElements = destElements || getAll(clone);\n                    for(i = 0, l = srcElements.length; i < l; i++){\n                        cloneCopyEvent(srcElements[i], destElements[i]);\n                    }\n                } else {\n                    cloneCopyEvent(elem, clone);\n                }\n            }\n            // Preserve script evaluation history\n            destElements = getAll(clone, \"script\");\n            if (destElements.length > 0) {\n                setGlobalEval(destElements, !inPage && getAll(elem, \"script\"));\n            }\n            // Return the cloned set\n            return clone;\n        },\n        cleanData: function(elems) {\n            var data, elem, type, special = jQuery.event.special, i = 0;\n            for(; (elem = elems[i]) !== undefined; i++){\n                if (acceptData(elem)) {\n                    if (data = elem[dataPriv.expando]) {\n                        if (data.events) {\n                            for(type in data.events){\n                                if (special[type]) {\n                                    jQuery.event.remove(elem, type);\n                                // This is a shortcut to avoid jQuery.event.remove's overhead\n                                } else {\n                                    jQuery.removeEvent(elem, type, data.handle);\n                                }\n                            }\n                        }\n                        // Support: Chrome <=35 - 45+\n                        // Assign undefined instead of using delete, see Data#remove\n                        elem[dataPriv.expando] = undefined;\n                    }\n                    if (elem[dataUser.expando]) {\n                        // Support: Chrome <=35 - 45+\n                        // Assign undefined instead of using delete, see Data#remove\n                        elem[dataUser.expando] = undefined;\n                    }\n                }\n            }\n        }\n    });\n    jQuery.fn.extend({\n        detach: function(selector) {\n            return remove(this, selector, true);\n        },\n        remove: function(selector) {\n            return remove(this, selector);\n        },\n        text: function(value) {\n            return access(this, function(value) {\n                return value === undefined ? jQuery.text(this) : this.empty().each(function() {\n                    if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {\n                        this.textContent = value;\n                    }\n                });\n            }, null, value, arguments.length);\n        },\n        append: function() {\n            return domManip(this, arguments, function(elem) {\n                if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {\n                    var target = manipulationTarget(this, elem);\n                    target.appendChild(elem);\n                }\n            });\n        },\n        prepend: function() {\n            return domManip(this, arguments, function(elem) {\n                if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {\n                    var target = manipulationTarget(this, elem);\n                    target.insertBefore(elem, target.firstChild);\n                }\n            });\n        },\n        before: function() {\n            return domManip(this, arguments, function(elem) {\n                if (this.parentNode) {\n                    this.parentNode.insertBefore(elem, this);\n                }\n            });\n        },\n        after: function() {\n            return domManip(this, arguments, function(elem) {\n                if (this.parentNode) {\n                    this.parentNode.insertBefore(elem, this.nextSibling);\n                }\n            });\n        },\n        empty: function() {\n            var elem, i = 0;\n            for(; (elem = this[i]) != null; i++){\n                if (elem.nodeType === 1) {\n                    // Prevent memory leaks\n                    jQuery.cleanData(getAll(elem, false));\n                    // Remove any remaining nodes\n                    elem.textContent = \"\";\n                }\n            }\n            return this;\n        },\n        clone: function(dataAndEvents, deepDataAndEvents) {\n            dataAndEvents = dataAndEvents == null ? false : dataAndEvents;\n            deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;\n            return this.map(function() {\n                return jQuery.clone(this, dataAndEvents, deepDataAndEvents);\n            });\n        },\n        html: function(value) {\n            return access(this, function(value) {\n                var elem = this[0] || {}, i = 0, l = this.length;\n                if (value === undefined && elem.nodeType === 1) {\n                    return elem.innerHTML;\n                }\n                // See if we can take a shortcut and just use innerHTML\n                if (typeof value === \"string\" && !rnoInnerhtml.test(value) && !wrapMap[(rtagName.exec(value) || [\n                    \"\",\n                    \"\"\n                ])[1].toLowerCase()]) {\n                    value = jQuery.htmlPrefilter(value);\n                    try {\n                        for(; i < l; i++){\n                            elem = this[i] || {};\n                            // Remove element nodes and prevent memory leaks\n                            if (elem.nodeType === 1) {\n                                jQuery.cleanData(getAll(elem, false));\n                                elem.innerHTML = value;\n                            }\n                        }\n                        elem = 0;\n                    // If using innerHTML throws an exception, use the fallback method\n                    } catch (e) {}\n                }\n                if (elem) {\n                    this.empty().append(value);\n                }\n            }, null, value, arguments.length);\n        },\n        replaceWith: function() {\n            var ignored = [];\n            // Make the changes, replacing each non-ignored context element with the new content\n            return domManip(this, arguments, function(elem) {\n                var parent = this.parentNode;\n                if (jQuery.inArray(this, ignored) < 0) {\n                    jQuery.cleanData(getAll(this));\n                    if (parent) {\n                        parent.replaceChild(elem, this);\n                    }\n                }\n            // Force callback invocation\n            }, ignored);\n        }\n    });\n    jQuery.each({\n        appendTo: \"append\",\n        prependTo: \"prepend\",\n        insertBefore: \"before\",\n        insertAfter: \"after\",\n        replaceAll: \"replaceWith\"\n    }, function(name, original) {\n        jQuery.fn[name] = function(selector) {\n            var elems, ret = [], insert = jQuery(selector), last = insert.length - 1, i = 0;\n            for(; i <= last; i++){\n                elems = i === last ? this : this.clone(true);\n                jQuery(insert[i])[original](elems);\n                // Support: Android <=4.0 only, PhantomJS 1 only\n                // .get() because push.apply(_, arraylike) throws on ancient WebKit\n                push.apply(ret, elems.get());\n            }\n            return this.pushStack(ret);\n        };\n    });\n    var rnumnonpx = new RegExp(\"^(\" + pnum + \")(?!px)[a-z%]+$\", \"i\");\n    var rcustomProp = /^--/;\n    var getStyles = function(elem) {\n        // Support: IE <=11 only, Firefox <=30 (trac-15098, trac-14150)\n        // IE throws on elements created in popups\n        // FF meanwhile throws on frame elements through \"defaultView.getComputedStyle\"\n        var view = elem.ownerDocument.defaultView;\n        if (!view || !view.opener) {\n            view = window1;\n        }\n        return view.getComputedStyle(elem);\n    };\n    var swap = function(elem, options, callback) {\n        var ret, name, old = {};\n        // Remember the old values, and insert the new ones\n        for(name in options){\n            old[name] = elem.style[name];\n            elem.style[name] = options[name];\n        }\n        ret = callback.call(elem);\n        // Revert the old values\n        for(name in options){\n            elem.style[name] = old[name];\n        }\n        return ret;\n    };\n    var rboxStyle = new RegExp(cssExpand.join(\"|\"), \"i\");\n    (function() {\n        // Executing both pixelPosition & boxSizingReliable tests require only one layout\n        // so they're executed at the same time to save the second computation.\n        function computeStyleTests() {\n            // This is a singleton, we need to execute it only once\n            if (!div) {\n                return;\n            }\n            container.style.cssText = \"position:absolute;left:-11111px;width:60px;\" + \"margin-top:1px;padding:0;border:0\";\n            div.style.cssText = \"position:relative;display:block;box-sizing:border-box;overflow:scroll;\" + \"margin:auto;border:1px;padding:1px;\" + \"width:60%;top:1%\";\n            documentElement.appendChild(container).appendChild(div);\n            var divStyle = window1.getComputedStyle(div);\n            pixelPositionVal = divStyle.top !== \"1%\";\n            // Support: Android 4.0 - 4.3 only, Firefox <=3 - 44\n            reliableMarginLeftVal = roundPixelMeasures(divStyle.marginLeft) === 12;\n            // Support: Android 4.0 - 4.3 only, Safari <=9.1 - 10.1, iOS <=7.0 - 9.3\n            // Some styles come back with percentage values, even though they shouldn't\n            div.style.right = \"60%\";\n            pixelBoxStylesVal = roundPixelMeasures(divStyle.right) === 36;\n            // Support: IE 9 - 11 only\n            // Detect misreporting of content dimensions for box-sizing:border-box elements\n            boxSizingReliableVal = roundPixelMeasures(divStyle.width) === 36;\n            // Support: IE 9 only\n            // Detect overflow:scroll screwiness (gh-3699)\n            // Support: Chrome <=64\n            // Don't get tricked when zoom affects offsetWidth (gh-4029)\n            div.style.position = \"absolute\";\n            scrollboxSizeVal = roundPixelMeasures(div.offsetWidth / 3) === 12;\n            documentElement.removeChild(container);\n            // Nullify the div so it wouldn't be stored in the memory and\n            // it will also be a sign that checks already performed\n            div = null;\n        }\n        function roundPixelMeasures(measure) {\n            return Math.round(parseFloat(measure));\n        }\n        var pixelPositionVal, boxSizingReliableVal, scrollboxSizeVal, pixelBoxStylesVal, reliableTrDimensionsVal, reliableMarginLeftVal, container = document.createElement(\"div\"), div = document.createElement(\"div\");\n        // Finish early in limited (non-browser) environments\n        if (!div.style) {\n            return;\n        }\n        // Support: IE <=9 - 11 only\n        // Style of cloned element affects source element cloned (trac-8908)\n        div.style.backgroundClip = \"content-box\";\n        div.cloneNode(true).style.backgroundClip = \"\";\n        support.clearCloneStyle = div.style.backgroundClip === \"content-box\";\n        jQuery.extend(support, {\n            boxSizingReliable: function() {\n                computeStyleTests();\n                return boxSizingReliableVal;\n            },\n            pixelBoxStyles: function() {\n                computeStyleTests();\n                return pixelBoxStylesVal;\n            },\n            pixelPosition: function() {\n                computeStyleTests();\n                return pixelPositionVal;\n            },\n            reliableMarginLeft: function() {\n                computeStyleTests();\n                return reliableMarginLeftVal;\n            },\n            scrollboxSize: function() {\n                computeStyleTests();\n                return scrollboxSizeVal;\n            },\n            // Support: IE 9 - 11+, Edge 15 - 18+\n            // IE/Edge misreport `getComputedStyle` of table rows with width/height\n            // set in CSS while `offset*` properties report correct values.\n            // Behavior in IE 9 is more subtle than in newer versions & it passes\n            // some versions of this test; make sure not to make it pass there!\n            //\n            // Support: Firefox 70+\n            // Only Firefox includes border widths\n            // in computed dimensions. (gh-4529)\n            reliableTrDimensions: function() {\n                var table, tr, trChild, trStyle;\n                if (reliableTrDimensionsVal == null) {\n                    table = document.createElement(\"table\");\n                    tr = document.createElement(\"tr\");\n                    trChild = document.createElement(\"div\");\n                    table.style.cssText = \"position:absolute;left:-11111px;border-collapse:separate\";\n                    tr.style.cssText = \"box-sizing:content-box;border:1px solid\";\n                    // Support: Chrome 86+\n                    // Height set through cssText does not get applied.\n                    // Computed height then comes back as 0.\n                    tr.style.height = \"1px\";\n                    trChild.style.height = \"9px\";\n                    // Support: Android 8 Chrome 86+\n                    // In our bodyBackground.html iframe,\n                    // display for all div elements is set to \"inline\",\n                    // which causes a problem only in Android 8 Chrome 86.\n                    // Ensuring the div is `display: block`\n                    // gets around this issue.\n                    trChild.style.display = \"block\";\n                    documentElement.appendChild(table).appendChild(tr).appendChild(trChild);\n                    trStyle = window1.getComputedStyle(tr);\n                    reliableTrDimensionsVal = parseInt(trStyle.height, 10) + parseInt(trStyle.borderTopWidth, 10) + parseInt(trStyle.borderBottomWidth, 10) === tr.offsetHeight;\n                    documentElement.removeChild(table);\n                }\n                return reliableTrDimensionsVal;\n            }\n        });\n    })();\n    function curCSS(elem, name, computed) {\n        var width, minWidth, maxWidth, ret, isCustomProp = rcustomProp.test(name), // Support: Firefox 51+\n        // Retrieving style before computed somehow\n        // fixes an issue with getting wrong values\n        // on detached elements\n        style = elem.style;\n        computed = computed || getStyles(elem);\n        // getPropertyValue is needed for:\n        //   .css('filter') (IE 9 only, trac-12537)\n        //   .css('--customProperty) (gh-3144)\n        if (computed) {\n            // Support: IE <=9 - 11+\n            // IE only supports `\"float\"` in `getPropertyValue`; in computed styles\n            // it's only available as `\"cssFloat\"`. We no longer modify properties\n            // sent to `.css()` apart from camelCasing, so we need to check both.\n            // Normally, this would create difference in behavior: if\n            // `getPropertyValue` returns an empty string, the value returned\n            // by `.css()` would be `undefined`. This is usually the case for\n            // disconnected elements. However, in IE even disconnected elements\n            // with no styles return `\"none\"` for `getPropertyValue( \"float\" )`\n            ret = computed.getPropertyValue(name) || computed[name];\n            if (isCustomProp && ret) {\n                // Support: Firefox 105+, Chrome <=105+\n                // Spec requires trimming whitespace for custom properties (gh-4926).\n                // Firefox only trims leading whitespace. Chrome just collapses\n                // both leading & trailing whitespace to a single space.\n                //\n                // Fall back to `undefined` if empty string returned.\n                // This collapses a missing definition with property defined\n                // and set to an empty string but there's no standard API\n                // allowing us to differentiate them without a performance penalty\n                // and returning `undefined` aligns with older jQuery.\n                //\n                // rtrimCSS treats U+000D CARRIAGE RETURN and U+000C FORM FEED\n                // as whitespace while CSS does not, but this is not a problem\n                // because CSS preprocessing replaces them with U+000A LINE FEED\n                // (which *is* CSS whitespace)\n                // https://www.w3.org/TR/css-syntax-3/#input-preprocessing\n                ret = ret.replace(rtrimCSS, \"$1\") || undefined;\n            }\n            if (ret === \"\" && !isAttached(elem)) {\n                ret = jQuery.style(elem, name);\n            }\n            // A tribute to the \"awesome hack by Dean Edwards\"\n            // Android Browser returns percentage for some values,\n            // but width seems to be reliably pixels.\n            // This is against the CSSOM draft spec:\n            // https://drafts.csswg.org/cssom/#resolved-values\n            if (!support.pixelBoxStyles() && rnumnonpx.test(ret) && rboxStyle.test(name)) {\n                // Remember the original values\n                width = style.width;\n                minWidth = style.minWidth;\n                maxWidth = style.maxWidth;\n                // Put in the new values to get a computed value out\n                style.minWidth = style.maxWidth = style.width = ret;\n                ret = computed.width;\n                // Revert the changed values\n                style.width = width;\n                style.minWidth = minWidth;\n                style.maxWidth = maxWidth;\n            }\n        }\n        return ret !== undefined ? // Support: IE <=9 - 11 only\n        // IE returns zIndex value as an integer.\n        ret + \"\" : ret;\n    }\n    function addGetHookIf(conditionFn, hookFn) {\n        // Define the hook, we'll check on the first run if it's really needed.\n        return {\n            get: function() {\n                if (conditionFn()) {\n                    // Hook not needed (or it's not possible to use it due\n                    // to missing dependency), remove it.\n                    delete this.get;\n                    return;\n                }\n                // Hook needed; redefine it so that the support test is not executed again.\n                return (this.get = hookFn).apply(this, arguments);\n            }\n        };\n    }\n    var cssPrefixes = [\n        \"Webkit\",\n        \"Moz\",\n        \"ms\"\n    ], emptyStyle = document.createElement(\"div\").style, vendorProps = {};\n    // Return a vendor-prefixed property or undefined\n    function vendorPropName(name) {\n        // Check for vendor prefixed names\n        var capName = name[0].toUpperCase() + name.slice(1), i = cssPrefixes.length;\n        while(i--){\n            name = cssPrefixes[i] + capName;\n            if (name in emptyStyle) {\n                return name;\n            }\n        }\n    }\n    // Return a potentially-mapped jQuery.cssProps or vendor prefixed property\n    function finalPropName(name) {\n        var final = jQuery.cssProps[name] || vendorProps[name];\n        if (final) {\n            return final;\n        }\n        if (name in emptyStyle) {\n            return name;\n        }\n        return vendorProps[name] = vendorPropName(name) || name;\n    }\n    var // Swappable if display is none or starts with table\n    // except \"table\", \"table-cell\", or \"table-caption\"\n    // See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display\n    rdisplayswap = /^(none|table(?!-c[ea]).+)/, cssShow = {\n        position: \"absolute\",\n        visibility: \"hidden\",\n        display: \"block\"\n    }, cssNormalTransform = {\n        letterSpacing: \"0\",\n        fontWeight: \"400\"\n    };\n    function setPositiveNumber(_elem, value, subtract) {\n        // Any relative (+/-) values have already been\n        // normalized at this point\n        var matches = rcssNum.exec(value);\n        return matches ? // Guard against undefined \"subtract\", e.g., when used as in cssHooks\n        Math.max(0, matches[2] - (subtract || 0)) + (matches[3] || \"px\") : value;\n    }\n    function boxModelAdjustment(elem, dimension, box, isBorderBox, styles, computedVal) {\n        var i = dimension === \"width\" ? 1 : 0, extra = 0, delta = 0, marginDelta = 0;\n        // Adjustment may not be necessary\n        if (box === (isBorderBox ? \"border\" : \"content\")) {\n            return 0;\n        }\n        for(; i < 4; i += 2){\n            // Both box models exclude margin\n            // Count margin delta separately to only add it after scroll gutter adjustment.\n            // This is needed to make negative margins work with `outerHeight( true )` (gh-3982).\n            if (box === \"margin\") {\n                marginDelta += jQuery.css(elem, box + cssExpand[i], true, styles);\n            }\n            // If we get here with a content-box, we're seeking \"padding\" or \"border\" or \"margin\"\n            if (!isBorderBox) {\n                // Add padding\n                delta += jQuery.css(elem, \"padding\" + cssExpand[i], true, styles);\n                // For \"border\" or \"margin\", add border\n                if (box !== \"padding\") {\n                    delta += jQuery.css(elem, \"border\" + cssExpand[i] + \"Width\", true, styles);\n                // But still keep track of it otherwise\n                } else {\n                    extra += jQuery.css(elem, \"border\" + cssExpand[i] + \"Width\", true, styles);\n                }\n            // If we get here with a border-box (content + padding + border), we're seeking \"content\" or\n            // \"padding\" or \"margin\"\n            } else {\n                // For \"content\", subtract padding\n                if (box === \"content\") {\n                    delta -= jQuery.css(elem, \"padding\" + cssExpand[i], true, styles);\n                }\n                // For \"content\" or \"padding\", subtract border\n                if (box !== \"margin\") {\n                    delta -= jQuery.css(elem, \"border\" + cssExpand[i] + \"Width\", true, styles);\n                }\n            }\n        }\n        // Account for positive content-box scroll gutter when requested by providing computedVal\n        if (!isBorderBox && computedVal >= 0) {\n            // offsetWidth/offsetHeight is a rounded sum of content, padding, scroll gutter, and border\n            // Assuming integer scroll gutter, subtract the rest and round down\n            delta += Math.max(0, Math.ceil(elem[\"offset\" + dimension[0].toUpperCase() + dimension.slice(1)] - computedVal - delta - extra - 0.5)) || 0;\n        }\n        return delta + marginDelta;\n    }\n    function getWidthOrHeight(elem, dimension, extra) {\n        // Start with computed style\n        var styles = getStyles(elem), // To avoid forcing a reflow, only fetch boxSizing if we need it (gh-4322).\n        // Fake content-box until we know it's needed to know the true value.\n        boxSizingNeeded = !support.boxSizingReliable() || extra, isBorderBox = boxSizingNeeded && jQuery.css(elem, \"boxSizing\", false, styles) === \"border-box\", valueIsBorderBox = isBorderBox, val = curCSS(elem, dimension, styles), offsetProp = \"offset\" + dimension[0].toUpperCase() + dimension.slice(1);\n        // Support: Firefox <=54\n        // Return a confounding non-pixel value or feign ignorance, as appropriate.\n        if (rnumnonpx.test(val)) {\n            if (!extra) {\n                return val;\n            }\n            val = \"auto\";\n        }\n        // Support: IE 9 - 11 only\n        // Use offsetWidth/offsetHeight for when box sizing is unreliable.\n        // In those cases, the computed value can be trusted to be border-box.\n        if ((!support.boxSizingReliable() && isBorderBox || // Support: IE 10 - 11+, Edge 15 - 18+\n        // IE/Edge misreport `getComputedStyle` of table rows with width/height\n        // set in CSS while `offset*` properties report correct values.\n        // Interestingly, in some cases IE 9 doesn't suffer from this issue.\n        !support.reliableTrDimensions() && nodeName(elem, \"tr\") || // Fall back to offsetWidth/offsetHeight when value is \"auto\"\n        // This happens for inline elements with no explicit setting (gh-3571)\n        val === \"auto\" || // Support: Android <=4.1 - 4.3 only\n        // Also use offsetWidth/offsetHeight for misreported inline dimensions (gh-3602)\n        !parseFloat(val) && jQuery.css(elem, \"display\", false, styles) === \"inline\") && // Make sure the element is visible & connected\n        elem.getClientRects().length) {\n            isBorderBox = jQuery.css(elem, \"boxSizing\", false, styles) === \"border-box\";\n            // Where available, offsetWidth/offsetHeight approximate border box dimensions.\n            // Where not available (e.g., SVG), assume unreliable box-sizing and interpret the\n            // retrieved value as a content box dimension.\n            valueIsBorderBox = offsetProp in elem;\n            if (valueIsBorderBox) {\n                val = elem[offsetProp];\n            }\n        }\n        // Normalize \"\" and auto\n        val = parseFloat(val) || 0;\n        // Adjust for the element's box model\n        return val + boxModelAdjustment(elem, dimension, extra || (isBorderBox ? \"border\" : \"content\"), valueIsBorderBox, styles, // Provide the current computed size to request scroll gutter calculation (gh-3589)\n        val) + \"px\";\n    }\n    jQuery.extend({\n        // Add in style property hooks for overriding the default\n        // behavior of getting and setting a style property\n        cssHooks: {\n            opacity: {\n                get: function(elem, computed) {\n                    if (computed) {\n                        // We should always get a number back from opacity\n                        var ret = curCSS(elem, \"opacity\");\n                        return ret === \"\" ? \"1\" : ret;\n                    }\n                }\n            }\n        },\n        // Don't automatically add \"px\" to these possibly-unitless properties\n        cssNumber: {\n            animationIterationCount: true,\n            aspectRatio: true,\n            borderImageSlice: true,\n            columnCount: true,\n            flexGrow: true,\n            flexShrink: true,\n            fontWeight: true,\n            gridArea: true,\n            gridColumn: true,\n            gridColumnEnd: true,\n            gridColumnStart: true,\n            gridRow: true,\n            gridRowEnd: true,\n            gridRowStart: true,\n            lineHeight: true,\n            opacity: true,\n            order: true,\n            orphans: true,\n            scale: true,\n            widows: true,\n            zIndex: true,\n            zoom: true,\n            // SVG-related\n            fillOpacity: true,\n            floodOpacity: true,\n            stopOpacity: true,\n            strokeMiterlimit: true,\n            strokeOpacity: true\n        },\n        // Add in properties whose names you wish to fix before\n        // setting or getting the value\n        cssProps: {},\n        // Get and set the style property on a DOM Node\n        style: function(elem, name, value, extra) {\n            // Don't set styles on text and comment nodes\n            if (!elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style) {\n                return;\n            }\n            // Make sure that we're working with the right name\n            var ret, type, hooks, origName = camelCase(name), isCustomProp = rcustomProp.test(name), style = elem.style;\n            // Make sure that we're working with the right name. We don't\n            // want to query the value if it is a CSS custom property\n            // since they are user-defined.\n            if (!isCustomProp) {\n                name = finalPropName(origName);\n            }\n            // Gets hook for the prefixed version, then unprefixed version\n            hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];\n            // Check if we're setting a value\n            if (value !== undefined) {\n                type = typeof value;\n                // Convert \"+=\" or \"-=\" to relative numbers (trac-7345)\n                if (type === \"string\" && (ret = rcssNum.exec(value)) && ret[1]) {\n                    value = adjustCSS(elem, name, ret);\n                    // Fixes bug trac-9237\n                    type = \"number\";\n                }\n                // Make sure that null and NaN values aren't set (trac-7116)\n                if (value == null || value !== value) {\n                    return;\n                }\n                // If a number was passed in, add the unit (except for certain CSS properties)\n                // The isCustomProp check can be removed in jQuery 4.0 when we only auto-append\n                // \"px\" to a few hardcoded values.\n                if (type === \"number\" && !isCustomProp) {\n                    value += ret && ret[3] || (jQuery.cssNumber[origName] ? \"\" : \"px\");\n                }\n                // background-* props affect original clone's values\n                if (!support.clearCloneStyle && value === \"\" && name.indexOf(\"background\") === 0) {\n                    style[name] = \"inherit\";\n                }\n                // If a hook was provided, use that value, otherwise just set the specified value\n                if (!hooks || !(\"set\" in hooks) || (value = hooks.set(elem, value, extra)) !== undefined) {\n                    if (isCustomProp) {\n                        style.setProperty(name, value);\n                    } else {\n                        style[name] = value;\n                    }\n                }\n            } else {\n                // If a hook was provided get the non-computed value from there\n                if (hooks && \"get\" in hooks && (ret = hooks.get(elem, false, extra)) !== undefined) {\n                    return ret;\n                }\n                // Otherwise just get the value from the style object\n                return style[name];\n            }\n        },\n        css: function(elem, name, extra, styles) {\n            var val, num, hooks, origName = camelCase(name), isCustomProp = rcustomProp.test(name);\n            // Make sure that we're working with the right name. We don't\n            // want to modify the value if it is a CSS custom property\n            // since they are user-defined.\n            if (!isCustomProp) {\n                name = finalPropName(origName);\n            }\n            // Try prefixed name followed by the unprefixed name\n            hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];\n            // If a hook was provided get the computed value from there\n            if (hooks && \"get\" in hooks) {\n                val = hooks.get(elem, true, extra);\n            }\n            // Otherwise, if a way to get the computed value exists, use that\n            if (val === undefined) {\n                val = curCSS(elem, name, styles);\n            }\n            // Convert \"normal\" to computed value\n            if (val === \"normal\" && name in cssNormalTransform) {\n                val = cssNormalTransform[name];\n            }\n            // Make numeric if forced or a qualifier was provided and val looks numeric\n            if (extra === \"\" || extra) {\n                num = parseFloat(val);\n                return extra === true || isFinite(num) ? num || 0 : val;\n            }\n            return val;\n        }\n    });\n    jQuery.each([\n        \"height\",\n        \"width\"\n    ], function(_i, dimension) {\n        jQuery.cssHooks[dimension] = {\n            get: function(elem, computed, extra) {\n                if (computed) {\n                    // Certain elements can have dimension info if we invisibly show them\n                    // but it must have a current display style that would benefit\n                    return rdisplayswap.test(jQuery.css(elem, \"display\")) && // Support: Safari 8+\n                    // Table columns in Safari have non-zero offsetWidth & zero\n                    // getBoundingClientRect().width unless display is changed.\n                    // Support: IE <=11 only\n                    // Running getBoundingClientRect on a disconnected node\n                    // in IE throws an error.\n                    (!elem.getClientRects().length || !elem.getBoundingClientRect().width) ? swap(elem, cssShow, function() {\n                        return getWidthOrHeight(elem, dimension, extra);\n                    }) : getWidthOrHeight(elem, dimension, extra);\n                }\n            },\n            set: function(elem, value, extra) {\n                var matches, styles = getStyles(elem), // Only read styles.position if the test has a chance to fail\n                // to avoid forcing a reflow.\n                scrollboxSizeBuggy = !support.scrollboxSize() && styles.position === \"absolute\", // To avoid forcing a reflow, only fetch boxSizing if we need it (gh-3991)\n                boxSizingNeeded = scrollboxSizeBuggy || extra, isBorderBox = boxSizingNeeded && jQuery.css(elem, \"boxSizing\", false, styles) === \"border-box\", subtract = extra ? boxModelAdjustment(elem, dimension, extra, isBorderBox, styles) : 0;\n                // Account for unreliable border-box dimensions by comparing offset* to computed and\n                // faking a content-box to get border and padding (gh-3699)\n                if (isBorderBox && scrollboxSizeBuggy) {\n                    subtract -= Math.ceil(elem[\"offset\" + dimension[0].toUpperCase() + dimension.slice(1)] - parseFloat(styles[dimension]) - boxModelAdjustment(elem, dimension, \"border\", false, styles) - 0.5);\n                }\n                // Convert to pixels if value adjustment is needed\n                if (subtract && (matches = rcssNum.exec(value)) && (matches[3] || \"px\") !== \"px\") {\n                    elem.style[dimension] = value;\n                    value = jQuery.css(elem, dimension);\n                }\n                return setPositiveNumber(elem, value, subtract);\n            }\n        };\n    });\n    jQuery.cssHooks.marginLeft = addGetHookIf(support.reliableMarginLeft, function(elem, computed) {\n        if (computed) {\n            return (parseFloat(curCSS(elem, \"marginLeft\")) || elem.getBoundingClientRect().left - swap(elem, {\n                marginLeft: 0\n            }, function() {\n                return elem.getBoundingClientRect().left;\n            })) + \"px\";\n        }\n    });\n    // These hooks are used by animate to expand properties\n    jQuery.each({\n        margin: \"\",\n        padding: \"\",\n        border: \"Width\"\n    }, function(prefix, suffix) {\n        jQuery.cssHooks[prefix + suffix] = {\n            expand: function(value) {\n                var i = 0, expanded = {}, // Assumes a single number if not a string\n                parts = typeof value === \"string\" ? value.split(\" \") : [\n                    value\n                ];\n                for(; i < 4; i++){\n                    expanded[prefix + cssExpand[i] + suffix] = parts[i] || parts[i - 2] || parts[0];\n                }\n                return expanded;\n            }\n        };\n        if (prefix !== \"margin\") {\n            jQuery.cssHooks[prefix + suffix].set = setPositiveNumber;\n        }\n    });\n    jQuery.fn.extend({\n        css: function(name, value) {\n            return access(this, function(elem, name, value) {\n                var styles, len, map = {}, i = 0;\n                if (Array.isArray(name)) {\n                    styles = getStyles(elem);\n                    len = name.length;\n                    for(; i < len; i++){\n                        map[name[i]] = jQuery.css(elem, name[i], false, styles);\n                    }\n                    return map;\n                }\n                return value !== undefined ? jQuery.style(elem, name, value) : jQuery.css(elem, name);\n            }, name, value, arguments.length > 1);\n        }\n    });\n    function Tween(elem, options, prop, end, easing) {\n        return new Tween.prototype.init(elem, options, prop, end, easing);\n    }\n    jQuery.Tween = Tween;\n    Tween.prototype = {\n        constructor: Tween,\n        init: function(elem, options, prop, end, easing, unit) {\n            this.elem = elem;\n            this.prop = prop;\n            this.easing = easing || jQuery.easing._default;\n            this.options = options;\n            this.start = this.now = this.cur();\n            this.end = end;\n            this.unit = unit || (jQuery.cssNumber[prop] ? \"\" : \"px\");\n        },\n        cur: function() {\n            var hooks = Tween.propHooks[this.prop];\n            return hooks && hooks.get ? hooks.get(this) : Tween.propHooks._default.get(this);\n        },\n        run: function(percent) {\n            var eased, hooks = Tween.propHooks[this.prop];\n            if (this.options.duration) {\n                this.pos = eased = jQuery.easing[this.easing](percent, this.options.duration * percent, 0, 1, this.options.duration);\n            } else {\n                this.pos = eased = percent;\n            }\n            this.now = (this.end - this.start) * eased + this.start;\n            if (this.options.step) {\n                this.options.step.call(this.elem, this.now, this);\n            }\n            if (hooks && hooks.set) {\n                hooks.set(this);\n            } else {\n                Tween.propHooks._default.set(this);\n            }\n            return this;\n        }\n    };\n    Tween.prototype.init.prototype = Tween.prototype;\n    Tween.propHooks = {\n        _default: {\n            get: function(tween) {\n                var result;\n                // Use a property on the element directly when it is not a DOM element,\n                // or when there is no matching style property that exists.\n                if (tween.elem.nodeType !== 1 || tween.elem[tween.prop] != null && tween.elem.style[tween.prop] == null) {\n                    return tween.elem[tween.prop];\n                }\n                // Passing an empty string as a 3rd parameter to .css will automatically\n                // attempt a parseFloat and fallback to a string if the parse fails.\n                // Simple values such as \"10px\" are parsed to Float;\n                // complex values such as \"rotate(1rad)\" are returned as-is.\n                result = jQuery.css(tween.elem, tween.prop, \"\");\n                // Empty strings, null, undefined and \"auto\" are converted to 0.\n                return !result || result === \"auto\" ? 0 : result;\n            },\n            set: function(tween) {\n                // Use step hook for back compat.\n                // Use cssHook if its there.\n                // Use .style if available and use plain properties where available.\n                if (jQuery.fx.step[tween.prop]) {\n                    jQuery.fx.step[tween.prop](tween);\n                } else if (tween.elem.nodeType === 1 && (jQuery.cssHooks[tween.prop] || tween.elem.style[finalPropName(tween.prop)] != null)) {\n                    jQuery.style(tween.elem, tween.prop, tween.now + tween.unit);\n                } else {\n                    tween.elem[tween.prop] = tween.now;\n                }\n            }\n        }\n    };\n    // Support: IE <=9 only\n    // Panic based approach to setting things on disconnected nodes\n    Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {\n        set: function(tween) {\n            if (tween.elem.nodeType && tween.elem.parentNode) {\n                tween.elem[tween.prop] = tween.now;\n            }\n        }\n    };\n    jQuery.easing = {\n        linear: function(p) {\n            return p;\n        },\n        swing: function(p) {\n            return 0.5 - Math.cos(p * Math.PI) / 2;\n        },\n        _default: \"swing\"\n    };\n    jQuery.fx = Tween.prototype.init;\n    // Back compat <1.8 extension point\n    jQuery.fx.step = {};\n    var fxNow, inProgress, rfxtypes = /^(?:toggle|show|hide)$/, rrun = /queueHooks$/;\n    function schedule() {\n        if (inProgress) {\n            if (document.hidden === false && window1.requestAnimationFrame) {\n                window1.requestAnimationFrame(schedule);\n            } else {\n                window1.setTimeout(schedule, jQuery.fx.interval);\n            }\n            jQuery.fx.tick();\n        }\n    }\n    // Animations created synchronously will run synchronously\n    function createFxNow() {\n        window1.setTimeout(function() {\n            fxNow = undefined;\n        });\n        return fxNow = Date.now();\n    }\n    // Generate parameters to create a standard animation\n    function genFx(type, includeWidth) {\n        var which, i = 0, attrs = {\n            height: type\n        };\n        // If we include width, step value is 1 to do all cssExpand values,\n        // otherwise step value is 2 to skip over Left and Right\n        includeWidth = includeWidth ? 1 : 0;\n        for(; i < 4; i += 2 - includeWidth){\n            which = cssExpand[i];\n            attrs[\"margin\" + which] = attrs[\"padding\" + which] = type;\n        }\n        if (includeWidth) {\n            attrs.opacity = attrs.width = type;\n        }\n        return attrs;\n    }\n    function createTween(value, prop, animation) {\n        var tween, collection = (Animation.tweeners[prop] || []).concat(Animation.tweeners[\"*\"]), index = 0, length = collection.length;\n        for(; index < length; index++){\n            if (tween = collection[index].call(animation, prop, value)) {\n                // We're done with this property\n                return tween;\n            }\n        }\n    }\n    function defaultPrefilter(elem, props, opts) {\n        var prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display, isBox = \"width\" in props || \"height\" in props, anim = this, orig = {}, style = elem.style, hidden = elem.nodeType && isHiddenWithinTree(elem), dataShow = dataPriv.get(elem, \"fxshow\");\n        // Queue-skipping animations hijack the fx hooks\n        if (!opts.queue) {\n            hooks = jQuery._queueHooks(elem, \"fx\");\n            if (hooks.unqueued == null) {\n                hooks.unqueued = 0;\n                oldfire = hooks.empty.fire;\n                hooks.empty.fire = function() {\n                    if (!hooks.unqueued) {\n                        oldfire();\n                    }\n                };\n            }\n            hooks.unqueued++;\n            anim.always(function() {\n                // Ensure the complete handler is called before this completes\n                anim.always(function() {\n                    hooks.unqueued--;\n                    if (!jQuery.queue(elem, \"fx\").length) {\n                        hooks.empty.fire();\n                    }\n                });\n            });\n        }\n        // Detect show/hide animations\n        for(prop in props){\n            value = props[prop];\n            if (rfxtypes.test(value)) {\n                delete props[prop];\n                toggle = toggle || value === \"toggle\";\n                if (value === (hidden ? \"hide\" : \"show\")) {\n                    // Pretend to be hidden if this is a \"show\" and\n                    // there is still data from a stopped show/hide\n                    if (value === \"show\" && dataShow && dataShow[prop] !== undefined) {\n                        hidden = true;\n                    // Ignore all other no-op show/hide data\n                    } else {\n                        continue;\n                    }\n                }\n                orig[prop] = dataShow && dataShow[prop] || jQuery.style(elem, prop);\n            }\n        }\n        // Bail out if this is a no-op like .hide().hide()\n        propTween = !jQuery.isEmptyObject(props);\n        if (!propTween && jQuery.isEmptyObject(orig)) {\n            return;\n        }\n        // Restrict \"overflow\" and \"display\" styles during box animations\n        if (isBox && elem.nodeType === 1) {\n            // Support: IE <=9 - 11, Edge 12 - 15\n            // Record all 3 overflow attributes because IE does not infer the shorthand\n            // from identically-valued overflowX and overflowY and Edge just mirrors\n            // the overflowX value there.\n            opts.overflow = [\n                style.overflow,\n                style.overflowX,\n                style.overflowY\n            ];\n            // Identify a display type, preferring old show/hide data over the CSS cascade\n            restoreDisplay = dataShow && dataShow.display;\n            if (restoreDisplay == null) {\n                restoreDisplay = dataPriv.get(elem, \"display\");\n            }\n            display = jQuery.css(elem, \"display\");\n            if (display === \"none\") {\n                if (restoreDisplay) {\n                    display = restoreDisplay;\n                } else {\n                    // Get nonempty value(s) by temporarily forcing visibility\n                    showHide([\n                        elem\n                    ], true);\n                    restoreDisplay = elem.style.display || restoreDisplay;\n                    display = jQuery.css(elem, \"display\");\n                    showHide([\n                        elem\n                    ]);\n                }\n            }\n            // Animate inline elements as inline-block\n            if (display === \"inline\" || display === \"inline-block\" && restoreDisplay != null) {\n                if (jQuery.css(elem, \"float\") === \"none\") {\n                    // Restore the original display value at the end of pure show/hide animations\n                    if (!propTween) {\n                        anim.done(function() {\n                            style.display = restoreDisplay;\n                        });\n                        if (restoreDisplay == null) {\n                            display = style.display;\n                            restoreDisplay = display === \"none\" ? \"\" : display;\n                        }\n                    }\n                    style.display = \"inline-block\";\n                }\n            }\n        }\n        if (opts.overflow) {\n            style.overflow = \"hidden\";\n            anim.always(function() {\n                style.overflow = opts.overflow[0];\n                style.overflowX = opts.overflow[1];\n                style.overflowY = opts.overflow[2];\n            });\n        }\n        // Implement show/hide animations\n        propTween = false;\n        for(prop in orig){\n            // General show/hide setup for this element animation\n            if (!propTween) {\n                if (dataShow) {\n                    if (\"hidden\" in dataShow) {\n                        hidden = dataShow.hidden;\n                    }\n                } else {\n                    dataShow = dataPriv.access(elem, \"fxshow\", {\n                        display: restoreDisplay\n                    });\n                }\n                // Store hidden/visible for toggle so `.stop().toggle()` \"reverses\"\n                if (toggle) {\n                    dataShow.hidden = !hidden;\n                }\n                // Show elements before animating them\n                if (hidden) {\n                    showHide([\n                        elem\n                    ], true);\n                }\n                /* eslint-disable no-loop-func */ anim.done(function() {\n                    /* eslint-enable no-loop-func */ // The final step of a \"hide\" animation is actually hiding the element\n                    if (!hidden) {\n                        showHide([\n                            elem\n                        ]);\n                    }\n                    dataPriv.remove(elem, \"fxshow\");\n                    for(prop in orig){\n                        jQuery.style(elem, prop, orig[prop]);\n                    }\n                });\n            }\n            // Per-property setup\n            propTween = createTween(hidden ? dataShow[prop] : 0, prop, anim);\n            if (!(prop in dataShow)) {\n                dataShow[prop] = propTween.start;\n                if (hidden) {\n                    propTween.end = propTween.start;\n                    propTween.start = 0;\n                }\n            }\n        }\n    }\n    function propFilter(props, specialEasing) {\n        var index, name, easing, value, hooks;\n        // camelCase, specialEasing and expand cssHook pass\n        for(index in props){\n            name = camelCase(index);\n            easing = specialEasing[name];\n            value = props[index];\n            if (Array.isArray(value)) {\n                easing = value[1];\n                value = props[index] = value[0];\n            }\n            if (index !== name) {\n                props[name] = value;\n                delete props[index];\n            }\n            hooks = jQuery.cssHooks[name];\n            if (hooks && \"expand\" in hooks) {\n                value = hooks.expand(value);\n                delete props[name];\n                // Not quite $.extend, this won't overwrite existing keys.\n                // Reusing 'index' because we have the correct \"name\"\n                for(index in value){\n                    if (!(index in props)) {\n                        props[index] = value[index];\n                        specialEasing[index] = easing;\n                    }\n                }\n            } else {\n                specialEasing[name] = easing;\n            }\n        }\n    }\n    function Animation(elem, properties, options) {\n        var result, stopped, index = 0, length = Animation.prefilters.length, deferred = jQuery.Deferred().always(function() {\n            // Don't match elem in the :animated selector\n            delete tick.elem;\n        }), tick = function() {\n            if (stopped) {\n                return false;\n            }\n            var currentTime = fxNow || createFxNow(), remaining = Math.max(0, animation.startTime + animation.duration - currentTime), // Support: Android 2.3 only\n            // Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (trac-12497)\n            temp = remaining / animation.duration || 0, percent = 1 - temp, index = 0, length = animation.tweens.length;\n            for(; index < length; index++){\n                animation.tweens[index].run(percent);\n            }\n            deferred.notifyWith(elem, [\n                animation,\n                percent,\n                remaining\n            ]);\n            // If there's more to do, yield\n            if (percent < 1 && length) {\n                return remaining;\n            }\n            // If this was an empty animation, synthesize a final progress notification\n            if (!length) {\n                deferred.notifyWith(elem, [\n                    animation,\n                    1,\n                    0\n                ]);\n            }\n            // Resolve the animation and report its conclusion\n            deferred.resolveWith(elem, [\n                animation\n            ]);\n            return false;\n        }, animation = deferred.promise({\n            elem: elem,\n            props: jQuery.extend({}, properties),\n            opts: jQuery.extend(true, {\n                specialEasing: {},\n                easing: jQuery.easing._default\n            }, options),\n            originalProperties: properties,\n            originalOptions: options,\n            startTime: fxNow || createFxNow(),\n            duration: options.duration,\n            tweens: [],\n            createTween: function(prop, end) {\n                var tween = jQuery.Tween(elem, animation.opts, prop, end, animation.opts.specialEasing[prop] || animation.opts.easing);\n                animation.tweens.push(tween);\n                return tween;\n            },\n            stop: function(gotoEnd) {\n                var index = 0, // If we are going to the end, we want to run all the tweens\n                // otherwise we skip this part\n                length = gotoEnd ? animation.tweens.length : 0;\n                if (stopped) {\n                    return this;\n                }\n                stopped = true;\n                for(; index < length; index++){\n                    animation.tweens[index].run(1);\n                }\n                // Resolve when we played the last frame; otherwise, reject\n                if (gotoEnd) {\n                    deferred.notifyWith(elem, [\n                        animation,\n                        1,\n                        0\n                    ]);\n                    deferred.resolveWith(elem, [\n                        animation,\n                        gotoEnd\n                    ]);\n                } else {\n                    deferred.rejectWith(elem, [\n                        animation,\n                        gotoEnd\n                    ]);\n                }\n                return this;\n            }\n        }), props = animation.props;\n        propFilter(props, animation.opts.specialEasing);\n        for(; index < length; index++){\n            result = Animation.prefilters[index].call(animation, elem, props, animation.opts);\n            if (result) {\n                if (isFunction(result.stop)) {\n                    jQuery._queueHooks(animation.elem, animation.opts.queue).stop = result.stop.bind(result);\n                }\n                return result;\n            }\n        }\n        jQuery.map(props, createTween, animation);\n        if (isFunction(animation.opts.start)) {\n            animation.opts.start.call(elem, animation);\n        }\n        // Attach callbacks from options\n        animation.progress(animation.opts.progress).done(animation.opts.done, animation.opts.complete).fail(animation.opts.fail).always(animation.opts.always);\n        jQuery.fx.timer(jQuery.extend(tick, {\n            elem: elem,\n            anim: animation,\n            queue: animation.opts.queue\n        }));\n        return animation;\n    }\n    jQuery.Animation = jQuery.extend(Animation, {\n        tweeners: {\n            \"*\": [\n                function(prop, value) {\n                    var tween = this.createTween(prop, value);\n                    adjustCSS(tween.elem, prop, rcssNum.exec(value), tween);\n                    return tween;\n                }\n            ]\n        },\n        tweener: function(props, callback) {\n            if (isFunction(props)) {\n                callback = props;\n                props = [\n                    \"*\"\n                ];\n            } else {\n                props = props.match(rnothtmlwhite);\n            }\n            var prop, index = 0, length = props.length;\n            for(; index < length; index++){\n                prop = props[index];\n                Animation.tweeners[prop] = Animation.tweeners[prop] || [];\n                Animation.tweeners[prop].unshift(callback);\n            }\n        },\n        prefilters: [\n            defaultPrefilter\n        ],\n        prefilter: function(callback, prepend) {\n            if (prepend) {\n                Animation.prefilters.unshift(callback);\n            } else {\n                Animation.prefilters.push(callback);\n            }\n        }\n    });\n    jQuery.speed = function(speed, easing, fn) {\n        var opt = speed && typeof speed === \"object\" ? jQuery.extend({}, speed) : {\n            complete: fn || !fn && easing || isFunction(speed) && speed,\n            duration: speed,\n            easing: fn && easing || easing && !isFunction(easing) && easing\n        };\n        // Go to the end state if fx are off\n        if (jQuery.fx.off) {\n            opt.duration = 0;\n        } else {\n            if (typeof opt.duration !== \"number\") {\n                if (opt.duration in jQuery.fx.speeds) {\n                    opt.duration = jQuery.fx.speeds[opt.duration];\n                } else {\n                    opt.duration = jQuery.fx.speeds._default;\n                }\n            }\n        }\n        // Normalize opt.queue - true/undefined/null -> \"fx\"\n        if (opt.queue == null || opt.queue === true) {\n            opt.queue = \"fx\";\n        }\n        // Queueing\n        opt.old = opt.complete;\n        opt.complete = function() {\n            if (isFunction(opt.old)) {\n                opt.old.call(this);\n            }\n            if (opt.queue) {\n                jQuery.dequeue(this, opt.queue);\n            }\n        };\n        return opt;\n    };\n    jQuery.fn.extend({\n        fadeTo: function(speed, to, easing, callback) {\n            // Show any hidden elements after setting opacity to 0\n            return this.filter(isHiddenWithinTree).css(\"opacity\", 0).show()// Animate to the value specified\n            .end().animate({\n                opacity: to\n            }, speed, easing, callback);\n        },\n        animate: function(prop, speed, easing, callback) {\n            var empty = jQuery.isEmptyObject(prop), optall = jQuery.speed(speed, easing, callback), doAnimation = function() {\n                // Operate on a copy of prop so per-property easing won't be lost\n                var anim = Animation(this, jQuery.extend({}, prop), optall);\n                // Empty animations, or finishing resolves immediately\n                if (empty || dataPriv.get(this, \"finish\")) {\n                    anim.stop(true);\n                }\n            };\n            doAnimation.finish = doAnimation;\n            return empty || optall.queue === false ? this.each(doAnimation) : this.queue(optall.queue, doAnimation);\n        },\n        stop: function(type, clearQueue, gotoEnd) {\n            var stopQueue = function(hooks) {\n                var stop = hooks.stop;\n                delete hooks.stop;\n                stop(gotoEnd);\n            };\n            if (typeof type !== \"string\") {\n                gotoEnd = clearQueue;\n                clearQueue = type;\n                type = undefined;\n            }\n            if (clearQueue) {\n                this.queue(type || \"fx\", []);\n            }\n            return this.each(function() {\n                var dequeue = true, index = type != null && type + \"queueHooks\", timers = jQuery.timers, data = dataPriv.get(this);\n                if (index) {\n                    if (data[index] && data[index].stop) {\n                        stopQueue(data[index]);\n                    }\n                } else {\n                    for(index in data){\n                        if (data[index] && data[index].stop && rrun.test(index)) {\n                            stopQueue(data[index]);\n                        }\n                    }\n                }\n                for(index = timers.length; index--;){\n                    if (timers[index].elem === this && (type == null || timers[index].queue === type)) {\n                        timers[index].anim.stop(gotoEnd);\n                        dequeue = false;\n                        timers.splice(index, 1);\n                    }\n                }\n                // Start the next in the queue if the last step wasn't forced.\n                // Timers currently will call their complete callbacks, which\n                // will dequeue but only if they were gotoEnd.\n                if (dequeue || !gotoEnd) {\n                    jQuery.dequeue(this, type);\n                }\n            });\n        },\n        finish: function(type) {\n            if (type !== false) {\n                type = type || \"fx\";\n            }\n            return this.each(function() {\n                var index, data = dataPriv.get(this), queue = data[type + \"queue\"], hooks = data[type + \"queueHooks\"], timers = jQuery.timers, length = queue ? queue.length : 0;\n                // Enable finishing flag on private data\n                data.finish = true;\n                // Empty the queue first\n                jQuery.queue(this, type, []);\n                if (hooks && hooks.stop) {\n                    hooks.stop.call(this, true);\n                }\n                // Look for any active animations, and finish them\n                for(index = timers.length; index--;){\n                    if (timers[index].elem === this && timers[index].queue === type) {\n                        timers[index].anim.stop(true);\n                        timers.splice(index, 1);\n                    }\n                }\n                // Look for any animations in the old queue and finish them\n                for(index = 0; index < length; index++){\n                    if (queue[index] && queue[index].finish) {\n                        queue[index].finish.call(this);\n                    }\n                }\n                // Turn off finishing flag\n                delete data.finish;\n            });\n        }\n    });\n    jQuery.each([\n        \"toggle\",\n        \"show\",\n        \"hide\"\n    ], function(_i, name) {\n        var cssFn = jQuery.fn[name];\n        jQuery.fn[name] = function(speed, easing, callback) {\n            return speed == null || typeof speed === \"boolean\" ? cssFn.apply(this, arguments) : this.animate(genFx(name, true), speed, easing, callback);\n        };\n    });\n    // Generate shortcuts for custom animations\n    jQuery.each({\n        slideDown: genFx(\"show\"),\n        slideUp: genFx(\"hide\"),\n        slideToggle: genFx(\"toggle\"),\n        fadeIn: {\n            opacity: \"show\"\n        },\n        fadeOut: {\n            opacity: \"hide\"\n        },\n        fadeToggle: {\n            opacity: \"toggle\"\n        }\n    }, function(name, props) {\n        jQuery.fn[name] = function(speed, easing, callback) {\n            return this.animate(props, speed, easing, callback);\n        };\n    });\n    jQuery.timers = [];\n    jQuery.fx.tick = function() {\n        var timer, i = 0, timers = jQuery.timers;\n        fxNow = Date.now();\n        for(; i < timers.length; i++){\n            timer = timers[i];\n            // Run the timer and safely remove it when done (allowing for external removal)\n            if (!timer() && timers[i] === timer) {\n                timers.splice(i--, 1);\n            }\n        }\n        if (!timers.length) {\n            jQuery.fx.stop();\n        }\n        fxNow = undefined;\n    };\n    jQuery.fx.timer = function(timer) {\n        jQuery.timers.push(timer);\n        jQuery.fx.start();\n    };\n    jQuery.fx.interval = 13;\n    jQuery.fx.start = function() {\n        if (inProgress) {\n            return;\n        }\n        inProgress = true;\n        schedule();\n    };\n    jQuery.fx.stop = function() {\n        inProgress = null;\n    };\n    jQuery.fx.speeds = {\n        slow: 600,\n        fast: 200,\n        // Default speed\n        _default: 400\n    };\n    // Based off of the plugin by Clint Helfers, with permission.\n    jQuery.fn.delay = function(time, type) {\n        time = jQuery.fx ? jQuery.fx.speeds[time] || time : time;\n        type = type || \"fx\";\n        return this.queue(type, function(next, hooks) {\n            var timeout = window1.setTimeout(next, time);\n            hooks.stop = function() {\n                window1.clearTimeout(timeout);\n            };\n        });\n    };\n    (function() {\n        var input = document.createElement(\"input\"), select = document.createElement(\"select\"), opt = select.appendChild(document.createElement(\"option\"));\n        input.type = \"checkbox\";\n        // Support: Android <=4.3 only\n        // Default value for a checkbox should be \"on\"\n        support.checkOn = input.value !== \"\";\n        // Support: IE <=11 only\n        // Must access selectedIndex to make default options select\n        support.optSelected = opt.selected;\n        // Support: IE <=11 only\n        // An input loses its value after becoming a radio\n        input = document.createElement(\"input\");\n        input.value = \"t\";\n        input.type = \"radio\";\n        support.radioValue = input.value === \"t\";\n    })();\n    var boolHook, attrHandle = jQuery.expr.attrHandle;\n    jQuery.fn.extend({\n        attr: function(name, value) {\n            return access(this, jQuery.attr, name, value, arguments.length > 1);\n        },\n        removeAttr: function(name) {\n            return this.each(function() {\n                jQuery.removeAttr(this, name);\n            });\n        }\n    });\n    jQuery.extend({\n        attr: function(elem, name, value) {\n            var ret, hooks, nType = elem.nodeType;\n            // Don't get/set attributes on text, comment and attribute nodes\n            if (nType === 3 || nType === 8 || nType === 2) {\n                return;\n            }\n            // Fallback to prop when attributes are not supported\n            if (typeof elem.getAttribute === \"undefined\") {\n                return jQuery.prop(elem, name, value);\n            }\n            // Attribute hooks are determined by the lowercase version\n            // Grab necessary hook if one is defined\n            if (nType !== 1 || !jQuery.isXMLDoc(elem)) {\n                hooks = jQuery.attrHooks[name.toLowerCase()] || (jQuery.expr.match.bool.test(name) ? boolHook : undefined);\n            }\n            if (value !== undefined) {\n                if (value === null) {\n                    jQuery.removeAttr(elem, name);\n                    return;\n                }\n                if (hooks && \"set\" in hooks && (ret = hooks.set(elem, value, name)) !== undefined) {\n                    return ret;\n                }\n                elem.setAttribute(name, value + \"\");\n                return value;\n            }\n            if (hooks && \"get\" in hooks && (ret = hooks.get(elem, name)) !== null) {\n                return ret;\n            }\n            ret = jQuery.find.attr(elem, name);\n            // Non-existent attributes return null, we normalize to undefined\n            return ret == null ? undefined : ret;\n        },\n        attrHooks: {\n            type: {\n                set: function(elem, value) {\n                    if (!support.radioValue && value === \"radio\" && nodeName(elem, \"input\")) {\n                        var val = elem.value;\n                        elem.setAttribute(\"type\", value);\n                        if (val) {\n                            elem.value = val;\n                        }\n                        return value;\n                    }\n                }\n            }\n        },\n        removeAttr: function(elem, value) {\n            var name, i = 0, // Attribute names can contain non-HTML whitespace characters\n            // https://html.spec.whatwg.org/multipage/syntax.html#attributes-2\n            attrNames = value && value.match(rnothtmlwhite);\n            if (attrNames && elem.nodeType === 1) {\n                while(name = attrNames[i++]){\n                    elem.removeAttribute(name);\n                }\n            }\n        }\n    });\n    // Hooks for boolean attributes\n    boolHook = {\n        set: function(elem, value, name) {\n            if (value === false) {\n                // Remove boolean attributes when set to false\n                jQuery.removeAttr(elem, name);\n            } else {\n                elem.setAttribute(name, name);\n            }\n            return name;\n        }\n    };\n    jQuery.each(jQuery.expr.match.bool.source.match(/\\w+/g), function(_i, name) {\n        var getter = attrHandle[name] || jQuery.find.attr;\n        attrHandle[name] = function(elem, name, isXML) {\n            var ret, handle, lowercaseName = name.toLowerCase();\n            if (!isXML) {\n                // Avoid an infinite loop by temporarily removing this function from the getter\n                handle = attrHandle[lowercaseName];\n                attrHandle[lowercaseName] = ret;\n                ret = getter(elem, name, isXML) != null ? lowercaseName : null;\n                attrHandle[lowercaseName] = handle;\n            }\n            return ret;\n        };\n    });\n    var rfocusable = /^(?:input|select|textarea|button)$/i, rclickable = /^(?:a|area)$/i;\n    jQuery.fn.extend({\n        prop: function(name, value) {\n            return access(this, jQuery.prop, name, value, arguments.length > 1);\n        },\n        removeProp: function(name) {\n            return this.each(function() {\n                delete this[jQuery.propFix[name] || name];\n            });\n        }\n    });\n    jQuery.extend({\n        prop: function(elem, name, value) {\n            var ret, hooks, nType = elem.nodeType;\n            // Don't get/set properties on text, comment and attribute nodes\n            if (nType === 3 || nType === 8 || nType === 2) {\n                return;\n            }\n            if (nType !== 1 || !jQuery.isXMLDoc(elem)) {\n                // Fix name and attach hooks\n                name = jQuery.propFix[name] || name;\n                hooks = jQuery.propHooks[name];\n            }\n            if (value !== undefined) {\n                if (hooks && \"set\" in hooks && (ret = hooks.set(elem, value, name)) !== undefined) {\n                    return ret;\n                }\n                return elem[name] = value;\n            }\n            if (hooks && \"get\" in hooks && (ret = hooks.get(elem, name)) !== null) {\n                return ret;\n            }\n            return elem[name];\n        },\n        propHooks: {\n            tabIndex: {\n                get: function(elem) {\n                    // Support: IE <=9 - 11 only\n                    // elem.tabIndex doesn't always return the\n                    // correct value when it hasn't been explicitly set\n                    // Use proper attribute retrieval (trac-12072)\n                    var tabindex = jQuery.find.attr(elem, \"tabindex\");\n                    if (tabindex) {\n                        return parseInt(tabindex, 10);\n                    }\n                    if (rfocusable.test(elem.nodeName) || rclickable.test(elem.nodeName) && elem.href) {\n                        return 0;\n                    }\n                    return -1;\n                }\n            }\n        },\n        propFix: {\n            \"for\": \"htmlFor\",\n            \"class\": \"className\"\n        }\n    });\n    // Support: IE <=11 only\n    // Accessing the selectedIndex property\n    // forces the browser to respect setting selected\n    // on the option\n    // The getter ensures a default option is selected\n    // when in an optgroup\n    // eslint rule \"no-unused-expressions\" is disabled for this code\n    // since it considers such accessions noop\n    if (!support.optSelected) {\n        jQuery.propHooks.selected = {\n            get: function(elem) {\n                /* eslint no-unused-expressions: \"off\" */ var parent = elem.parentNode;\n                if (parent && parent.parentNode) {\n                    parent.parentNode.selectedIndex;\n                }\n                return null;\n            },\n            set: function(elem) {\n                /* eslint no-unused-expressions: \"off\" */ var parent = elem.parentNode;\n                if (parent) {\n                    parent.selectedIndex;\n                    if (parent.parentNode) {\n                        parent.parentNode.selectedIndex;\n                    }\n                }\n            }\n        };\n    }\n    jQuery.each([\n        \"tabIndex\",\n        \"readOnly\",\n        \"maxLength\",\n        \"cellSpacing\",\n        \"cellPadding\",\n        \"rowSpan\",\n        \"colSpan\",\n        \"useMap\",\n        \"frameBorder\",\n        \"contentEditable\"\n    ], function() {\n        jQuery.propFix[this.toLowerCase()] = this;\n    });\n    // Strip and collapse whitespace according to HTML spec\n    // https://infra.spec.whatwg.org/#strip-and-collapse-ascii-whitespace\n    function stripAndCollapse(value) {\n        var tokens = value.match(rnothtmlwhite) || [];\n        return tokens.join(\" \");\n    }\n    function getClass(elem) {\n        return elem.getAttribute && elem.getAttribute(\"class\") || \"\";\n    }\n    function classesToArray(value) {\n        if (Array.isArray(value)) {\n            return value;\n        }\n        if (typeof value === \"string\") {\n            return value.match(rnothtmlwhite) || [];\n        }\n        return [];\n    }\n    jQuery.fn.extend({\n        addClass: function(value) {\n            var classNames, cur, curValue, className, i, finalValue;\n            if (isFunction(value)) {\n                return this.each(function(j) {\n                    jQuery(this).addClass(value.call(this, j, getClass(this)));\n                });\n            }\n            classNames = classesToArray(value);\n            if (classNames.length) {\n                return this.each(function() {\n                    curValue = getClass(this);\n                    cur = this.nodeType === 1 && \" \" + stripAndCollapse(curValue) + \" \";\n                    if (cur) {\n                        for(i = 0; i < classNames.length; i++){\n                            className = classNames[i];\n                            if (cur.indexOf(\" \" + className + \" \") < 0) {\n                                cur += className + \" \";\n                            }\n                        }\n                        // Only assign if different to avoid unneeded rendering.\n                        finalValue = stripAndCollapse(cur);\n                        if (curValue !== finalValue) {\n                            this.setAttribute(\"class\", finalValue);\n                        }\n                    }\n                });\n            }\n            return this;\n        },\n        removeClass: function(value) {\n            var classNames, cur, curValue, className, i, finalValue;\n            if (isFunction(value)) {\n                return this.each(function(j) {\n                    jQuery(this).removeClass(value.call(this, j, getClass(this)));\n                });\n            }\n            if (!arguments.length) {\n                return this.attr(\"class\", \"\");\n            }\n            classNames = classesToArray(value);\n            if (classNames.length) {\n                return this.each(function() {\n                    curValue = getClass(this);\n                    // This expression is here for better compressibility (see addClass)\n                    cur = this.nodeType === 1 && \" \" + stripAndCollapse(curValue) + \" \";\n                    if (cur) {\n                        for(i = 0; i < classNames.length; i++){\n                            className = classNames[i];\n                            // Remove *all* instances\n                            while(cur.indexOf(\" \" + className + \" \") > -1){\n                                cur = cur.replace(\" \" + className + \" \", \" \");\n                            }\n                        }\n                        // Only assign if different to avoid unneeded rendering.\n                        finalValue = stripAndCollapse(cur);\n                        if (curValue !== finalValue) {\n                            this.setAttribute(\"class\", finalValue);\n                        }\n                    }\n                });\n            }\n            return this;\n        },\n        toggleClass: function(value, stateVal) {\n            var classNames, className, i, self, type = typeof value, isValidValue = type === \"string\" || Array.isArray(value);\n            if (isFunction(value)) {\n                return this.each(function(i) {\n                    jQuery(this).toggleClass(value.call(this, i, getClass(this), stateVal), stateVal);\n                });\n            }\n            if (typeof stateVal === \"boolean\" && isValidValue) {\n                return stateVal ? this.addClass(value) : this.removeClass(value);\n            }\n            classNames = classesToArray(value);\n            return this.each(function() {\n                if (isValidValue) {\n                    // Toggle individual class names\n                    self = jQuery(this);\n                    for(i = 0; i < classNames.length; i++){\n                        className = classNames[i];\n                        // Check each className given, space separated list\n                        if (self.hasClass(className)) {\n                            self.removeClass(className);\n                        } else {\n                            self.addClass(className);\n                        }\n                    }\n                // Toggle whole class name\n                } else if (value === undefined || type === \"boolean\") {\n                    className = getClass(this);\n                    if (className) {\n                        // Store className if set\n                        dataPriv.set(this, \"__className__\", className);\n                    }\n                    // If the element has a class name or if we're passed `false`,\n                    // then remove the whole classname (if there was one, the above saved it).\n                    // Otherwise bring back whatever was previously saved (if anything),\n                    // falling back to the empty string if nothing was stored.\n                    if (this.setAttribute) {\n                        this.setAttribute(\"class\", className || value === false ? \"\" : dataPriv.get(this, \"__className__\") || \"\");\n                    }\n                }\n            });\n        },\n        hasClass: function(selector) {\n            var className, elem, i = 0;\n            className = \" \" + selector + \" \";\n            while(elem = this[i++]){\n                if (elem.nodeType === 1 && (\" \" + stripAndCollapse(getClass(elem)) + \" \").indexOf(className) > -1) {\n                    return true;\n                }\n            }\n            return false;\n        }\n    });\n    var rreturn = /\\r/g;\n    jQuery.fn.extend({\n        val: function(value) {\n            var hooks, ret, valueIsFunction, elem = this[0];\n            if (!arguments.length) {\n                if (elem) {\n                    hooks = jQuery.valHooks[elem.type] || jQuery.valHooks[elem.nodeName.toLowerCase()];\n                    if (hooks && \"get\" in hooks && (ret = hooks.get(elem, \"value\")) !== undefined) {\n                        return ret;\n                    }\n                    ret = elem.value;\n                    // Handle most common string cases\n                    if (typeof ret === \"string\") {\n                        return ret.replace(rreturn, \"\");\n                    }\n                    // Handle cases where value is null/undef or number\n                    return ret == null ? \"\" : ret;\n                }\n                return;\n            }\n            valueIsFunction = isFunction(value);\n            return this.each(function(i) {\n                var val;\n                if (this.nodeType !== 1) {\n                    return;\n                }\n                if (valueIsFunction) {\n                    val = value.call(this, i, jQuery(this).val());\n                } else {\n                    val = value;\n                }\n                // Treat null/undefined as \"\"; convert numbers to string\n                if (val == null) {\n                    val = \"\";\n                } else if (typeof val === \"number\") {\n                    val += \"\";\n                } else if (Array.isArray(val)) {\n                    val = jQuery.map(val, function(value) {\n                        return value == null ? \"\" : value + \"\";\n                    });\n                }\n                hooks = jQuery.valHooks[this.type] || jQuery.valHooks[this.nodeName.toLowerCase()];\n                // If set returns undefined, fall back to normal setting\n                if (!hooks || !(\"set\" in hooks) || hooks.set(this, val, \"value\") === undefined) {\n                    this.value = val;\n                }\n            });\n        }\n    });\n    jQuery.extend({\n        valHooks: {\n            option: {\n                get: function(elem) {\n                    var val = jQuery.find.attr(elem, \"value\");\n                    return val != null ? val : // Support: IE <=10 - 11 only\n                    // option.text throws exceptions (trac-14686, trac-14858)\n                    // Strip and collapse whitespace\n                    // https://html.spec.whatwg.org/#strip-and-collapse-whitespace\n                    stripAndCollapse(jQuery.text(elem));\n                }\n            },\n            select: {\n                get: function(elem) {\n                    var value, option, i, options = elem.options, index = elem.selectedIndex, one = elem.type === \"select-one\", values = one ? null : [], max = one ? index + 1 : options.length;\n                    if (index < 0) {\n                        i = max;\n                    } else {\n                        i = one ? index : 0;\n                    }\n                    // Loop through all the selected options\n                    for(; i < max; i++){\n                        option = options[i];\n                        // Support: IE <=9 only\n                        // IE8-9 doesn't update selected after form reset (trac-2551)\n                        if ((option.selected || i === index) && // Don't return options that are disabled or in a disabled optgroup\n                        !option.disabled && (!option.parentNode.disabled || !nodeName(option.parentNode, \"optgroup\"))) {\n                            // Get the specific value for the option\n                            value = jQuery(option).val();\n                            // We don't need an array for one selects\n                            if (one) {\n                                return value;\n                            }\n                            // Multi-Selects return an array\n                            values.push(value);\n                        }\n                    }\n                    return values;\n                },\n                set: function(elem, value) {\n                    var optionSet, option, options = elem.options, values = jQuery.makeArray(value), i = options.length;\n                    while(i--){\n                        option = options[i];\n                        /* eslint-disable no-cond-assign */ if (option.selected = jQuery.inArray(jQuery.valHooks.option.get(option), values) > -1) {\n                            optionSet = true;\n                        }\n                    /* eslint-enable no-cond-assign */ }\n                    // Force browsers to behave consistently when non-matching value is set\n                    if (!optionSet) {\n                        elem.selectedIndex = -1;\n                    }\n                    return values;\n                }\n            }\n        }\n    });\n    // Radios and checkboxes getter/setter\n    jQuery.each([\n        \"radio\",\n        \"checkbox\"\n    ], function() {\n        jQuery.valHooks[this] = {\n            set: function(elem, value) {\n                if (Array.isArray(value)) {\n                    return elem.checked = jQuery.inArray(jQuery(elem).val(), value) > -1;\n                }\n            }\n        };\n        if (!support.checkOn) {\n            jQuery.valHooks[this].get = function(elem) {\n                return elem.getAttribute(\"value\") === null ? \"on\" : elem.value;\n            };\n        }\n    });\n    // Return jQuery for attributes-only inclusion\n    var location = window1.location;\n    var nonce = {\n        guid: Date.now()\n    };\n    var rquery = /\\?/;\n    // Cross-browser xml parsing\n    jQuery.parseXML = function(data) {\n        var xml, parserErrorElem;\n        if (!data || typeof data !== \"string\") {\n            return null;\n        }\n        // Support: IE 9 - 11 only\n        // IE throws on parseFromString with invalid input.\n        try {\n            xml = new window1.DOMParser().parseFromString(data, \"text/xml\");\n        } catch (e) {}\n        parserErrorElem = xml && xml.getElementsByTagName(\"parsererror\")[0];\n        if (!xml || parserErrorElem) {\n            jQuery.error(\"Invalid XML: \" + (parserErrorElem ? jQuery.map(parserErrorElem.childNodes, function(el) {\n                return el.textContent;\n            }).join(\"\\n\") : data));\n        }\n        return xml;\n    };\n    var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/, stopPropagationCallback = function(e) {\n        e.stopPropagation();\n    };\n    jQuery.extend(jQuery.event, {\n        trigger: function(event, data, elem, onlyHandlers) {\n            var i, cur, tmp, bubbleType, ontype, handle, special, lastElement, eventPath = [\n                elem || document\n            ], type = hasOwn.call(event, \"type\") ? event.type : event, namespaces = hasOwn.call(event, \"namespace\") ? event.namespace.split(\".\") : [];\n            cur = lastElement = tmp = elem = elem || document;\n            // Don't do events on text and comment nodes\n            if (elem.nodeType === 3 || elem.nodeType === 8) {\n                return;\n            }\n            // focus/blur morphs to focusin/out; ensure we're not firing them right now\n            if (rfocusMorph.test(type + jQuery.event.triggered)) {\n                return;\n            }\n            if (type.indexOf(\".\") > -1) {\n                // Namespaced trigger; create a regexp to match event type in handle()\n                namespaces = type.split(\".\");\n                type = namespaces.shift();\n                namespaces.sort();\n            }\n            ontype = type.indexOf(\":\") < 0 && \"on\" + type;\n            // Caller can pass in a jQuery.Event object, Object, or just an event type string\n            event = event[jQuery.expando] ? event : new jQuery.Event(type, typeof event === \"object\" && event);\n            // Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)\n            event.isTrigger = onlyHandlers ? 2 : 3;\n            event.namespace = namespaces.join(\".\");\n            event.rnamespace = event.namespace ? new RegExp(\"(^|\\\\.)\" + namespaces.join(\"\\\\.(?:.*\\\\.|)\") + \"(\\\\.|$)\") : null;\n            // Clean up the event in case it is being reused\n            event.result = undefined;\n            if (!event.target) {\n                event.target = elem;\n            }\n            // Clone any incoming data and prepend the event, creating the handler arg list\n            data = data == null ? [\n                event\n            ] : jQuery.makeArray(data, [\n                event\n            ]);\n            // Allow special events to draw outside the lines\n            special = jQuery.event.special[type] || {};\n            if (!onlyHandlers && special.trigger && special.trigger.apply(elem, data) === false) {\n                return;\n            }\n            // Determine event propagation path in advance, per W3C events spec (trac-9951)\n            // Bubble up to document, then to window; watch for a global ownerDocument var (trac-9724)\n            if (!onlyHandlers && !special.noBubble && !isWindow(elem)) {\n                bubbleType = special.delegateType || type;\n                if (!rfocusMorph.test(bubbleType + type)) {\n                    cur = cur.parentNode;\n                }\n                for(; cur; cur = cur.parentNode){\n                    eventPath.push(cur);\n                    tmp = cur;\n                }\n                // Only add window if we got to document (e.g., not plain obj or detached DOM)\n                if (tmp === (elem.ownerDocument || document)) {\n                    eventPath.push(tmp.defaultView || tmp.parentWindow || window1);\n                }\n            }\n            // Fire handlers on the event path\n            i = 0;\n            while((cur = eventPath[i++]) && !event.isPropagationStopped()){\n                lastElement = cur;\n                event.type = i > 1 ? bubbleType : special.bindType || type;\n                // jQuery handler\n                handle = (dataPriv.get(cur, \"events\") || Object.create(null))[event.type] && dataPriv.get(cur, \"handle\");\n                if (handle) {\n                    handle.apply(cur, data);\n                }\n                // Native handler\n                handle = ontype && cur[ontype];\n                if (handle && handle.apply && acceptData(cur)) {\n                    event.result = handle.apply(cur, data);\n                    if (event.result === false) {\n                        event.preventDefault();\n                    }\n                }\n            }\n            event.type = type;\n            // If nobody prevented the default action, do it now\n            if (!onlyHandlers && !event.isDefaultPrevented()) {\n                if ((!special._default || special._default.apply(eventPath.pop(), data) === false) && acceptData(elem)) {\n                    // Call a native DOM method on the target with the same name as the event.\n                    // Don't do default actions on window, that's where global variables be (trac-6170)\n                    if (ontype && isFunction(elem[type]) && !isWindow(elem)) {\n                        // Don't re-trigger an onFOO event when we call its FOO() method\n                        tmp = elem[ontype];\n                        if (tmp) {\n                            elem[ontype] = null;\n                        }\n                        // Prevent re-triggering of the same event, since we already bubbled it above\n                        jQuery.event.triggered = type;\n                        if (event.isPropagationStopped()) {\n                            lastElement.addEventListener(type, stopPropagationCallback);\n                        }\n                        elem[type]();\n                        if (event.isPropagationStopped()) {\n                            lastElement.removeEventListener(type, stopPropagationCallback);\n                        }\n                        jQuery.event.triggered = undefined;\n                        if (tmp) {\n                            elem[ontype] = tmp;\n                        }\n                    }\n                }\n            }\n            return event.result;\n        },\n        // Piggyback on a donor event to simulate a different one\n        // Used only for `focus(in | out)` events\n        simulate: function(type, elem, event) {\n            var e = jQuery.extend(new jQuery.Event(), event, {\n                type: type,\n                isSimulated: true\n            });\n            jQuery.event.trigger(e, null, elem);\n        }\n    });\n    jQuery.fn.extend({\n        trigger: function(type, data) {\n            return this.each(function() {\n                jQuery.event.trigger(type, data, this);\n            });\n        },\n        triggerHandler: function(type, data) {\n            var elem = this[0];\n            if (elem) {\n                return jQuery.event.trigger(type, data, elem, true);\n            }\n        }\n    });\n    var rbracket = /\\[\\]$/, rCRLF = /\\r?\\n/g, rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i, rsubmittable = /^(?:input|select|textarea|keygen)/i;\n    function buildParams(prefix, obj, traditional, add) {\n        var name;\n        if (Array.isArray(obj)) {\n            // Serialize array item.\n            jQuery.each(obj, function(i, v) {\n                if (traditional || rbracket.test(prefix)) {\n                    // Treat each array item as a scalar.\n                    add(prefix, v);\n                } else {\n                    // Item is non-scalar (array or object), encode its numeric index.\n                    buildParams(prefix + \"[\" + (typeof v === \"object\" && v != null ? i : \"\") + \"]\", v, traditional, add);\n                }\n            });\n        } else if (!traditional && toType(obj) === \"object\") {\n            // Serialize object item.\n            for(name in obj){\n                buildParams(prefix + \"[\" + name + \"]\", obj[name], traditional, add);\n            }\n        } else {\n            // Serialize scalar item.\n            add(prefix, obj);\n        }\n    }\n    // Serialize an array of form elements or a set of\n    // key/values into a query string\n    jQuery.param = function(a, traditional) {\n        var prefix, s = [], add = function(key, valueOrFunction) {\n            // If value is a function, invoke it and use its return value\n            var value = isFunction(valueOrFunction) ? valueOrFunction() : valueOrFunction;\n            s[s.length] = encodeURIComponent(key) + \"=\" + encodeURIComponent(value == null ? \"\" : value);\n        };\n        if (a == null) {\n            return \"\";\n        }\n        // If an array was passed in, assume that it is an array of form elements.\n        if (Array.isArray(a) || a.jquery && !jQuery.isPlainObject(a)) {\n            // Serialize the form elements\n            jQuery.each(a, function() {\n                add(this.name, this.value);\n            });\n        } else {\n            // If traditional, encode the \"old\" way (the way 1.3.2 or older\n            // did it), otherwise encode params recursively.\n            for(prefix in a){\n                buildParams(prefix, a[prefix], traditional, add);\n            }\n        }\n        // Return the resulting serialization\n        return s.join(\"&\");\n    };\n    jQuery.fn.extend({\n        serialize: function() {\n            return jQuery.param(this.serializeArray());\n        },\n        serializeArray: function() {\n            return this.map(function() {\n                // Can add propHook for \"elements\" to filter or add form elements\n                var elements = jQuery.prop(this, \"elements\");\n                return elements ? jQuery.makeArray(elements) : this;\n            }).filter(function() {\n                var type = this.type;\n                // Use .is( \":disabled\" ) so that fieldset[disabled] works\n                return this.name && !jQuery(this).is(\":disabled\") && rsubmittable.test(this.nodeName) && !rsubmitterTypes.test(type) && (this.checked || !rcheckableType.test(type));\n            }).map(function(_i, elem) {\n                var val = jQuery(this).val();\n                if (val == null) {\n                    return null;\n                }\n                if (Array.isArray(val)) {\n                    return jQuery.map(val, function(val) {\n                        return {\n                            name: elem.name,\n                            value: val.replace(rCRLF, \"\\r\\n\")\n                        };\n                    });\n                }\n                return {\n                    name: elem.name,\n                    value: val.replace(rCRLF, \"\\r\\n\")\n                };\n            }).get();\n        }\n    });\n    var r20 = /%20/g, rhash = /#.*$/, rantiCache = /([?&])_=[^&]*/, rheaders = /^(.*?):[ \\t]*([^\\r\\n]*)$/mg, // trac-7653, trac-8125, trac-8152: local protocol detection\n    rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/, rnoContent = /^(?:GET|HEAD)$/, rprotocol = /^\\/\\//, /* Prefilters\n\t * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)\n\t * 2) These are called:\n\t *    - BEFORE asking for a transport\n\t *    - AFTER param serialization (s.data is a string if s.processData is true)\n\t * 3) key is the dataType\n\t * 4) the catchall symbol \"*\" can be used\n\t * 5) execution will start with transport dataType and THEN continue down to \"*\" if needed\n\t */ prefilters = {}, /* Transports bindings\n\t * 1) key is the dataType\n\t * 2) the catchall symbol \"*\" can be used\n\t * 3) selection will start with transport dataType and THEN go to \"*\" if needed\n\t */ transports = {}, // Avoid comment-prolog char sequence (trac-10098); must appease lint and evade compression\n    allTypes = \"*/\".concat(\"*\"), // Anchor tag for parsing the document origin\n    originAnchor = document.createElement(\"a\");\n    originAnchor.href = location.href;\n    // Base \"constructor\" for jQuery.ajaxPrefilter and jQuery.ajaxTransport\n    function addToPrefiltersOrTransports(structure) {\n        // dataTypeExpression is optional and defaults to \"*\"\n        return function(dataTypeExpression, func) {\n            if (typeof dataTypeExpression !== \"string\") {\n                func = dataTypeExpression;\n                dataTypeExpression = \"*\";\n            }\n            var dataType, i = 0, dataTypes = dataTypeExpression.toLowerCase().match(rnothtmlwhite) || [];\n            if (isFunction(func)) {\n                // For each dataType in the dataTypeExpression\n                while(dataType = dataTypes[i++]){\n                    // Prepend if requested\n                    if (dataType[0] === \"+\") {\n                        dataType = dataType.slice(1) || \"*\";\n                        (structure[dataType] = structure[dataType] || []).unshift(func);\n                    // Otherwise append\n                    } else {\n                        (structure[dataType] = structure[dataType] || []).push(func);\n                    }\n                }\n            }\n        };\n    }\n    // Base inspection function for prefilters and transports\n    function inspectPrefiltersOrTransports(structure, options, originalOptions, jqXHR) {\n        var inspected = {}, seekingTransport = structure === transports;\n        function inspect(dataType) {\n            var selected;\n            inspected[dataType] = true;\n            jQuery.each(structure[dataType] || [], function(_, prefilterOrFactory) {\n                var dataTypeOrTransport = prefilterOrFactory(options, originalOptions, jqXHR);\n                if (typeof dataTypeOrTransport === \"string\" && !seekingTransport && !inspected[dataTypeOrTransport]) {\n                    options.dataTypes.unshift(dataTypeOrTransport);\n                    inspect(dataTypeOrTransport);\n                    return false;\n                } else if (seekingTransport) {\n                    return !(selected = dataTypeOrTransport);\n                }\n            });\n            return selected;\n        }\n        return inspect(options.dataTypes[0]) || !inspected[\"*\"] && inspect(\"*\");\n    }\n    // A special extend for ajax options\n    // that takes \"flat\" options (not to be deep extended)\n    // Fixes trac-9887\n    function ajaxExtend(target, src) {\n        var key, deep, flatOptions = jQuery.ajaxSettings.flatOptions || {};\n        for(key in src){\n            if (src[key] !== undefined) {\n                (flatOptions[key] ? target : deep || (deep = {}))[key] = src[key];\n            }\n        }\n        if (deep) {\n            jQuery.extend(true, target, deep);\n        }\n        return target;\n    }\n    /* Handles responses to an ajax request:\n * - finds the right dataType (mediates between content-type and expected dataType)\n * - returns the corresponding response\n */ function ajaxHandleResponses(s, jqXHR, responses) {\n        var ct, type, finalDataType, firstDataType, contents = s.contents, dataTypes = s.dataTypes;\n        // Remove auto dataType and get content-type in the process\n        while(dataTypes[0] === \"*\"){\n            dataTypes.shift();\n            if (ct === undefined) {\n                ct = s.mimeType || jqXHR.getResponseHeader(\"Content-Type\");\n            }\n        }\n        // Check if we're dealing with a known content-type\n        if (ct) {\n            for(type in contents){\n                if (contents[type] && contents[type].test(ct)) {\n                    dataTypes.unshift(type);\n                    break;\n                }\n            }\n        }\n        // Check to see if we have a response for the expected dataType\n        if (dataTypes[0] in responses) {\n            finalDataType = dataTypes[0];\n        } else {\n            // Try convertible dataTypes\n            for(type in responses){\n                if (!dataTypes[0] || s.converters[type + \" \" + dataTypes[0]]) {\n                    finalDataType = type;\n                    break;\n                }\n                if (!firstDataType) {\n                    firstDataType = type;\n                }\n            }\n            // Or just use first one\n            finalDataType = finalDataType || firstDataType;\n        }\n        // If we found a dataType\n        // We add the dataType to the list if needed\n        // and return the corresponding response\n        if (finalDataType) {\n            if (finalDataType !== dataTypes[0]) {\n                dataTypes.unshift(finalDataType);\n            }\n            return responses[finalDataType];\n        }\n    }\n    /* Chain conversions given the request and the original response\n * Also sets the responseXXX fields on the jqXHR instance\n */ function ajaxConvert(s, response, jqXHR, isSuccess) {\n        var conv2, current, conv, tmp, prev, converters = {}, // Work with a copy of dataTypes in case we need to modify it for conversion\n        dataTypes = s.dataTypes.slice();\n        // Create converters map with lowercased keys\n        if (dataTypes[1]) {\n            for(conv in s.converters){\n                converters[conv.toLowerCase()] = s.converters[conv];\n            }\n        }\n        current = dataTypes.shift();\n        // Convert to each sequential dataType\n        while(current){\n            if (s.responseFields[current]) {\n                jqXHR[s.responseFields[current]] = response;\n            }\n            // Apply the dataFilter if provided\n            if (!prev && isSuccess && s.dataFilter) {\n                response = s.dataFilter(response, s.dataType);\n            }\n            prev = current;\n            current = dataTypes.shift();\n            if (current) {\n                // There's only work to do if current dataType is non-auto\n                if (current === \"*\") {\n                    current = prev;\n                // Convert response if prev dataType is non-auto and differs from current\n                } else if (prev !== \"*\" && prev !== current) {\n                    // Seek a direct converter\n                    conv = converters[prev + \" \" + current] || converters[\"* \" + current];\n                    // If none found, seek a pair\n                    if (!conv) {\n                        for(conv2 in converters){\n                            // If conv2 outputs current\n                            tmp = conv2.split(\" \");\n                            if (tmp[1] === current) {\n                                // If prev can be converted to accepted input\n                                conv = converters[prev + \" \" + tmp[0]] || converters[\"* \" + tmp[0]];\n                                if (conv) {\n                                    // Condense equivalence converters\n                                    if (conv === true) {\n                                        conv = converters[conv2];\n                                    // Otherwise, insert the intermediate dataType\n                                    } else if (converters[conv2] !== true) {\n                                        current = tmp[0];\n                                        dataTypes.unshift(tmp[1]);\n                                    }\n                                    break;\n                                }\n                            }\n                        }\n                    }\n                    // Apply converter (if not an equivalence)\n                    if (conv !== true) {\n                        // Unless errors are allowed to bubble, catch and return them\n                        if (conv && s.throws) {\n                            response = conv(response);\n                        } else {\n                            try {\n                                response = conv(response);\n                            } catch (e) {\n                                return {\n                                    state: \"parsererror\",\n                                    error: conv ? e : \"No conversion from \" + prev + \" to \" + current\n                                };\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return {\n            state: \"success\",\n            data: response\n        };\n    }\n    jQuery.extend({\n        // Counter for holding the number of active queries\n        active: 0,\n        // Last-Modified header cache for next request\n        lastModified: {},\n        etag: {},\n        ajaxSettings: {\n            url: location.href,\n            type: \"GET\",\n            isLocal: rlocalProtocol.test(location.protocol),\n            global: true,\n            processData: true,\n            async: true,\n            contentType: \"application/x-www-form-urlencoded; charset=UTF-8\",\n            /*\n\t\ttimeout: 0,\n\t\tdata: null,\n\t\tdataType: null,\n\t\tusername: null,\n\t\tpassword: null,\n\t\tcache: null,\n\t\tthrows: false,\n\t\ttraditional: false,\n\t\theaders: {},\n\t\t*/ accepts: {\n                \"*\": allTypes,\n                text: \"text/plain\",\n                html: \"text/html\",\n                xml: \"application/xml, text/xml\",\n                json: \"application/json, text/javascript\"\n            },\n            contents: {\n                xml: /\\bxml\\b/,\n                html: /\\bhtml/,\n                json: /\\bjson\\b/\n            },\n            responseFields: {\n                xml: \"responseXML\",\n                text: \"responseText\",\n                json: \"responseJSON\"\n            },\n            // Data converters\n            // Keys separate source (or catchall \"*\") and destination types with a single space\n            converters: {\n                // Convert anything to text\n                \"* text\": String,\n                // Text to html (true = no transformation)\n                \"text html\": true,\n                // Evaluate text as a json expression\n                \"text json\": JSON.parse,\n                // Parse text as xml\n                \"text xml\": jQuery.parseXML\n            },\n            // For options that shouldn't be deep extended:\n            // you can add your own custom options here if\n            // and when you create one that shouldn't be\n            // deep extended (see ajaxExtend)\n            flatOptions: {\n                url: true,\n                context: true\n            }\n        },\n        // Creates a full fledged settings object into target\n        // with both ajaxSettings and settings fields.\n        // If target is omitted, writes into ajaxSettings.\n        ajaxSetup: function(target, settings) {\n            return settings ? // Building a settings object\n            ajaxExtend(ajaxExtend(target, jQuery.ajaxSettings), settings) : // Extending ajaxSettings\n            ajaxExtend(jQuery.ajaxSettings, target);\n        },\n        ajaxPrefilter: addToPrefiltersOrTransports(prefilters),\n        ajaxTransport: addToPrefiltersOrTransports(transports),\n        // Main method\n        ajax: function(url, options) {\n            // If url is an object, simulate pre-1.5 signature\n            if (typeof url === \"object\") {\n                options = url;\n                url = undefined;\n            }\n            // Force options to be an object\n            options = options || {};\n            var transport, // URL without anti-cache param\n            cacheURL, // Response headers\n            responseHeadersString, responseHeaders, // timeout handle\n            timeoutTimer, // Url cleanup var\n            urlAnchor, // Request state (becomes false upon send and true upon completion)\n            completed, // To know if global events are to be dispatched\n            fireGlobals, // Loop variable\n            i, // uncached part of the url\n            uncached, // Create the final options object\n            s = jQuery.ajaxSetup({}, options), // Callbacks context\n            callbackContext = s.context || s, // Context for global events is callbackContext if it is a DOM node or jQuery collection\n            globalEventContext = s.context && (callbackContext.nodeType || callbackContext.jquery) ? jQuery(callbackContext) : jQuery.event, // Deferreds\n            deferred = jQuery.Deferred(), completeDeferred = jQuery.Callbacks(\"once memory\"), // Status-dependent callbacks\n            statusCode = s.statusCode || {}, // Headers (they are sent all at once)\n            requestHeaders = {}, requestHeadersNames = {}, // Default abort message\n            strAbort = \"canceled\", // Fake xhr\n            jqXHR = {\n                readyState: 0,\n                // Builds headers hashtable if needed\n                getResponseHeader: function(key) {\n                    var match;\n                    if (completed) {\n                        if (!responseHeaders) {\n                            responseHeaders = {};\n                            while(match = rheaders.exec(responseHeadersString)){\n                                responseHeaders[match[1].toLowerCase() + \" \"] = (responseHeaders[match[1].toLowerCase() + \" \"] || []).concat(match[2]);\n                            }\n                        }\n                        match = responseHeaders[key.toLowerCase() + \" \"];\n                    }\n                    return match == null ? null : match.join(\", \");\n                },\n                // Raw string\n                getAllResponseHeaders: function() {\n                    return completed ? responseHeadersString : null;\n                },\n                // Caches the header\n                setRequestHeader: function(name, value) {\n                    if (completed == null) {\n                        name = requestHeadersNames[name.toLowerCase()] = requestHeadersNames[name.toLowerCase()] || name;\n                        requestHeaders[name] = value;\n                    }\n                    return this;\n                },\n                // Overrides response content-type header\n                overrideMimeType: function(type) {\n                    if (completed == null) {\n                        s.mimeType = type;\n                    }\n                    return this;\n                },\n                // Status-dependent callbacks\n                statusCode: function(map) {\n                    var code;\n                    if (map) {\n                        if (completed) {\n                            // Execute the appropriate callbacks\n                            jqXHR.always(map[jqXHR.status]);\n                        } else {\n                            // Lazy-add the new callbacks in a way that preserves old ones\n                            for(code in map){\n                                statusCode[code] = [\n                                    statusCode[code],\n                                    map[code]\n                                ];\n                            }\n                        }\n                    }\n                    return this;\n                },\n                // Cancel the request\n                abort: function(statusText) {\n                    var finalText = statusText || strAbort;\n                    if (transport) {\n                        transport.abort(finalText);\n                    }\n                    done(0, finalText);\n                    return this;\n                }\n            };\n            // Attach deferreds\n            deferred.promise(jqXHR);\n            // Add protocol if not provided (prefilters might expect it)\n            // Handle falsy url in the settings object (trac-10093: consistency with old signature)\n            // We also use the url parameter if available\n            s.url = ((url || s.url || location.href) + \"\").replace(rprotocol, location.protocol + \"//\");\n            // Alias method option to type as per ticket trac-12004\n            s.type = options.method || options.type || s.method || s.type;\n            // Extract dataTypes list\n            s.dataTypes = (s.dataType || \"*\").toLowerCase().match(rnothtmlwhite) || [\n                \"\"\n            ];\n            // A cross-domain request is in order when the origin doesn't match the current origin.\n            if (s.crossDomain == null) {\n                urlAnchor = document.createElement(\"a\");\n                // Support: IE <=8 - 11, Edge 12 - 15\n                // IE throws exception on accessing the href property if url is malformed,\n                // e.g. http://example.com:80x/\n                try {\n                    urlAnchor.href = s.url;\n                    // Support: IE <=8 - 11 only\n                    // Anchor's host property isn't correctly set when s.url is relative\n                    urlAnchor.href = urlAnchor.href;\n                    s.crossDomain = originAnchor.protocol + \"//\" + originAnchor.host !== urlAnchor.protocol + \"//\" + urlAnchor.host;\n                } catch (e) {\n                    // If there is an error parsing the URL, assume it is crossDomain,\n                    // it can be rejected by the transport if it is invalid\n                    s.crossDomain = true;\n                }\n            }\n            // Convert data if not already a string\n            if (s.data && s.processData && typeof s.data !== \"string\") {\n                s.data = jQuery.param(s.data, s.traditional);\n            }\n            // Apply prefilters\n            inspectPrefiltersOrTransports(prefilters, s, options, jqXHR);\n            // If request was aborted inside a prefilter, stop there\n            if (completed) {\n                return jqXHR;\n            }\n            // We can fire global events as of now if asked to\n            // Don't fire events if jQuery.event is undefined in an AMD-usage scenario (trac-15118)\n            fireGlobals = jQuery.event && s.global;\n            // Watch for a new set of requests\n            if (fireGlobals && jQuery.active++ === 0) {\n                jQuery.event.trigger(\"ajaxStart\");\n            }\n            // Uppercase the type\n            s.type = s.type.toUpperCase();\n            // Determine if request has content\n            s.hasContent = !rnoContent.test(s.type);\n            // Save the URL in case we're toying with the If-Modified-Since\n            // and/or If-None-Match header later on\n            // Remove hash to simplify url manipulation\n            cacheURL = s.url.replace(rhash, \"\");\n            // More options handling for requests with no content\n            if (!s.hasContent) {\n                // Remember the hash so we can put it back\n                uncached = s.url.slice(cacheURL.length);\n                // If data is available and should be processed, append data to url\n                if (s.data && (s.processData || typeof s.data === \"string\")) {\n                    cacheURL += (rquery.test(cacheURL) ? \"&\" : \"?\") + s.data;\n                    // trac-9682: remove data so that it's not used in an eventual retry\n                    delete s.data;\n                }\n                // Add or update anti-cache param if needed\n                if (s.cache === false) {\n                    cacheURL = cacheURL.replace(rantiCache, \"$1\");\n                    uncached = (rquery.test(cacheURL) ? \"&\" : \"?\") + \"_=\" + nonce.guid++ + uncached;\n                }\n                // Put hash and anti-cache on the URL that will be requested (gh-1732)\n                s.url = cacheURL + uncached;\n            // Change '%20' to '+' if this is encoded form body content (gh-2658)\n            } else if (s.data && s.processData && (s.contentType || \"\").indexOf(\"application/x-www-form-urlencoded\") === 0) {\n                s.data = s.data.replace(r20, \"+\");\n            }\n            // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.\n            if (s.ifModified) {\n                if (jQuery.lastModified[cacheURL]) {\n                    jqXHR.setRequestHeader(\"If-Modified-Since\", jQuery.lastModified[cacheURL]);\n                }\n                if (jQuery.etag[cacheURL]) {\n                    jqXHR.setRequestHeader(\"If-None-Match\", jQuery.etag[cacheURL]);\n                }\n            }\n            // Set the correct header, if data is being sent\n            if (s.data && s.hasContent && s.contentType !== false || options.contentType) {\n                jqXHR.setRequestHeader(\"Content-Type\", s.contentType);\n            }\n            // Set the Accepts header for the server, depending on the dataType\n            jqXHR.setRequestHeader(\"Accept\", s.dataTypes[0] && s.accepts[s.dataTypes[0]] ? s.accepts[s.dataTypes[0]] + (s.dataTypes[0] !== \"*\" ? \", \" + allTypes + \"; q=0.01\" : \"\") : s.accepts[\"*\"]);\n            // Check for headers option\n            for(i in s.headers){\n                jqXHR.setRequestHeader(i, s.headers[i]);\n            }\n            // Allow custom headers/mimetypes and early abort\n            if (s.beforeSend && (s.beforeSend.call(callbackContext, jqXHR, s) === false || completed)) {\n                // Abort if not done already and return\n                return jqXHR.abort();\n            }\n            // Aborting is no longer a cancellation\n            strAbort = \"abort\";\n            // Install callbacks on deferreds\n            completeDeferred.add(s.complete);\n            jqXHR.done(s.success);\n            jqXHR.fail(s.error);\n            // Get transport\n            transport = inspectPrefiltersOrTransports(transports, s, options, jqXHR);\n            // If no transport, we auto-abort\n            if (!transport) {\n                done(-1, \"No Transport\");\n            } else {\n                jqXHR.readyState = 1;\n                // Send global event\n                if (fireGlobals) {\n                    globalEventContext.trigger(\"ajaxSend\", [\n                        jqXHR,\n                        s\n                    ]);\n                }\n                // If request was aborted inside ajaxSend, stop there\n                if (completed) {\n                    return jqXHR;\n                }\n                // Timeout\n                if (s.async && s.timeout > 0) {\n                    timeoutTimer = window1.setTimeout(function() {\n                        jqXHR.abort(\"timeout\");\n                    }, s.timeout);\n                }\n                try {\n                    completed = false;\n                    transport.send(requestHeaders, done);\n                } catch (e) {\n                    // Rethrow post-completion exceptions\n                    if (completed) {\n                        throw e;\n                    }\n                    // Propagate others as results\n                    done(-1, e);\n                }\n            }\n            // Callback for when everything is done\n            function done(status, nativeStatusText, responses, headers) {\n                var isSuccess, success, error, response, modified, statusText = nativeStatusText;\n                // Ignore repeat invocations\n                if (completed) {\n                    return;\n                }\n                completed = true;\n                // Clear timeout if it exists\n                if (timeoutTimer) {\n                    window1.clearTimeout(timeoutTimer);\n                }\n                // Dereference transport for early garbage collection\n                // (no matter how long the jqXHR object will be used)\n                transport = undefined;\n                // Cache response headers\n                responseHeadersString = headers || \"\";\n                // Set readyState\n                jqXHR.readyState = status > 0 ? 4 : 0;\n                // Determine if successful\n                isSuccess = status >= 200 && status < 300 || status === 304;\n                // Get response data\n                if (responses) {\n                    response = ajaxHandleResponses(s, jqXHR, responses);\n                }\n                // Use a noop converter for missing script but not if jsonp\n                if (!isSuccess && jQuery.inArray(\"script\", s.dataTypes) > -1 && jQuery.inArray(\"json\", s.dataTypes) < 0) {\n                    s.converters[\"text script\"] = function() {};\n                }\n                // Convert no matter what (that way responseXXX fields are always set)\n                response = ajaxConvert(s, response, jqXHR, isSuccess);\n                // If successful, handle type chaining\n                if (isSuccess) {\n                    // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.\n                    if (s.ifModified) {\n                        modified = jqXHR.getResponseHeader(\"Last-Modified\");\n                        if (modified) {\n                            jQuery.lastModified[cacheURL] = modified;\n                        }\n                        modified = jqXHR.getResponseHeader(\"etag\");\n                        if (modified) {\n                            jQuery.etag[cacheURL] = modified;\n                        }\n                    }\n                    // if no content\n                    if (status === 204 || s.type === \"HEAD\") {\n                        statusText = \"nocontent\";\n                    // if not modified\n                    } else if (status === 304) {\n                        statusText = \"notmodified\";\n                    // If we have data, let's convert it\n                    } else {\n                        statusText = response.state;\n                        success = response.data;\n                        error = response.error;\n                        isSuccess = !error;\n                    }\n                } else {\n                    // Extract error from statusText and normalize for non-aborts\n                    error = statusText;\n                    if (status || !statusText) {\n                        statusText = \"error\";\n                        if (status < 0) {\n                            status = 0;\n                        }\n                    }\n                }\n                // Set data for the fake xhr object\n                jqXHR.status = status;\n                jqXHR.statusText = (nativeStatusText || statusText) + \"\";\n                // Success/Error\n                if (isSuccess) {\n                    deferred.resolveWith(callbackContext, [\n                        success,\n                        statusText,\n                        jqXHR\n                    ]);\n                } else {\n                    deferred.rejectWith(callbackContext, [\n                        jqXHR,\n                        statusText,\n                        error\n                    ]);\n                }\n                // Status-dependent callbacks\n                jqXHR.statusCode(statusCode);\n                statusCode = undefined;\n                if (fireGlobals) {\n                    globalEventContext.trigger(isSuccess ? \"ajaxSuccess\" : \"ajaxError\", [\n                        jqXHR,\n                        s,\n                        isSuccess ? success : error\n                    ]);\n                }\n                // Complete\n                completeDeferred.fireWith(callbackContext, [\n                    jqXHR,\n                    statusText\n                ]);\n                if (fireGlobals) {\n                    globalEventContext.trigger(\"ajaxComplete\", [\n                        jqXHR,\n                        s\n                    ]);\n                    // Handle the global AJAX counter\n                    if (!--jQuery.active) {\n                        jQuery.event.trigger(\"ajaxStop\");\n                    }\n                }\n            }\n            return jqXHR;\n        },\n        getJSON: function(url, data, callback) {\n            return jQuery.get(url, data, callback, \"json\");\n        },\n        getScript: function(url, callback) {\n            return jQuery.get(url, undefined, callback, \"script\");\n        }\n    });\n    jQuery.each([\n        \"get\",\n        \"post\"\n    ], function(_i, method) {\n        jQuery[method] = function(url, data, callback, type) {\n            // Shift arguments if data argument was omitted\n            if (isFunction(data)) {\n                type = type || callback;\n                callback = data;\n                data = undefined;\n            }\n            // The url can be an options object (which then must have .url)\n            return jQuery.ajax(jQuery.extend({\n                url: url,\n                type: method,\n                dataType: type,\n                data: data,\n                success: callback\n            }, jQuery.isPlainObject(url) && url));\n        };\n    });\n    jQuery.ajaxPrefilter(function(s) {\n        var i;\n        for(i in s.headers){\n            if (i.toLowerCase() === \"content-type\") {\n                s.contentType = s.headers[i] || \"\";\n            }\n        }\n    });\n    jQuery._evalUrl = function(url, options, doc) {\n        return jQuery.ajax({\n            url: url,\n            // Make this explicit, since user can override this through ajaxSetup (trac-11264)\n            type: \"GET\",\n            dataType: \"script\",\n            cache: true,\n            async: false,\n            global: false,\n            // Only evaluate the response if it is successful (gh-4126)\n            // dataFilter is not invoked for failure responses, so using it instead\n            // of the default converter is kludgy but it works.\n            converters: {\n                \"text script\": function() {}\n            },\n            dataFilter: function(response) {\n                jQuery.globalEval(response, options, doc);\n            }\n        });\n    };\n    jQuery.fn.extend({\n        wrapAll: function(html) {\n            var wrap;\n            if (this[0]) {\n                if (isFunction(html)) {\n                    html = html.call(this[0]);\n                }\n                // The elements to wrap the target around\n                wrap = jQuery(html, this[0].ownerDocument).eq(0).clone(true);\n                if (this[0].parentNode) {\n                    wrap.insertBefore(this[0]);\n                }\n                wrap.map(function() {\n                    var elem = this;\n                    while(elem.firstElementChild){\n                        elem = elem.firstElementChild;\n                    }\n                    return elem;\n                }).append(this);\n            }\n            return this;\n        },\n        wrapInner: function(html) {\n            if (isFunction(html)) {\n                return this.each(function(i) {\n                    jQuery(this).wrapInner(html.call(this, i));\n                });\n            }\n            return this.each(function() {\n                var self = jQuery(this), contents = self.contents();\n                if (contents.length) {\n                    contents.wrapAll(html);\n                } else {\n                    self.append(html);\n                }\n            });\n        },\n        wrap: function(html) {\n            var htmlIsFunction = isFunction(html);\n            return this.each(function(i) {\n                jQuery(this).wrapAll(htmlIsFunction ? html.call(this, i) : html);\n            });\n        },\n        unwrap: function(selector) {\n            this.parent(selector).not(\"body\").each(function() {\n                jQuery(this).replaceWith(this.childNodes);\n            });\n            return this;\n        }\n    });\n    jQuery.expr.pseudos.hidden = function(elem) {\n        return !jQuery.expr.pseudos.visible(elem);\n    };\n    jQuery.expr.pseudos.visible = function(elem) {\n        return !!(elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length);\n    };\n    jQuery.ajaxSettings.xhr = function() {\n        try {\n            return new window1.XMLHttpRequest();\n        } catch (e) {}\n    };\n    var xhrSuccessStatus = {\n        // File protocol always yields status code 0, assume 200\n        0: 200,\n        // Support: IE <=9 only\n        // trac-1450: sometimes IE returns 1223 when it should be 204\n        1223: 204\n    }, xhrSupported = jQuery.ajaxSettings.xhr();\n    support.cors = !!xhrSupported && \"withCredentials\" in xhrSupported;\n    support.ajax = xhrSupported = !!xhrSupported;\n    jQuery.ajaxTransport(function(options) {\n        var callback, errorCallback;\n        // Cross domain only allowed if supported through XMLHttpRequest\n        if (support.cors || xhrSupported && !options.crossDomain) {\n            return {\n                send: function(headers, complete) {\n                    var i, xhr = options.xhr();\n                    xhr.open(options.type, options.url, options.async, options.username, options.password);\n                    // Apply custom fields if provided\n                    if (options.xhrFields) {\n                        for(i in options.xhrFields){\n                            xhr[i] = options.xhrFields[i];\n                        }\n                    }\n                    // Override mime type if needed\n                    if (options.mimeType && xhr.overrideMimeType) {\n                        xhr.overrideMimeType(options.mimeType);\n                    }\n                    // X-Requested-With header\n                    // For cross-domain requests, seeing as conditions for a preflight are\n                    // akin to a jigsaw puzzle, we simply never set it to be sure.\n                    // (it can always be set on a per-request basis or even using ajaxSetup)\n                    // For same-domain requests, won't change header if already provided.\n                    if (!options.crossDomain && !headers[\"X-Requested-With\"]) {\n                        headers[\"X-Requested-With\"] = \"XMLHttpRequest\";\n                    }\n                    // Set headers\n                    for(i in headers){\n                        xhr.setRequestHeader(i, headers[i]);\n                    }\n                    // Callback\n                    callback = function(type) {\n                        return function() {\n                            if (callback) {\n                                callback = errorCallback = xhr.onload = xhr.onerror = xhr.onabort = xhr.ontimeout = xhr.onreadystatechange = null;\n                                if (type === \"abort\") {\n                                    xhr.abort();\n                                } else if (type === \"error\") {\n                                    // Support: IE <=9 only\n                                    // On a manual native abort, IE9 throws\n                                    // errors on any property access that is not readyState\n                                    if (typeof xhr.status !== \"number\") {\n                                        complete(0, \"error\");\n                                    } else {\n                                        complete(// File: protocol always yields status 0; see trac-8605, trac-14207\n                                        xhr.status, xhr.statusText);\n                                    }\n                                } else {\n                                    complete(xhrSuccessStatus[xhr.status] || xhr.status, xhr.statusText, // Support: IE <=9 only\n                                    // IE9 has no XHR2 but throws on binary (trac-11426)\n                                    // For XHR2 non-text, let the caller handle it (gh-2498)\n                                    (xhr.responseType || \"text\") !== \"text\" || typeof xhr.responseText !== \"string\" ? {\n                                        binary: xhr.response\n                                    } : {\n                                        text: xhr.responseText\n                                    }, xhr.getAllResponseHeaders());\n                                }\n                            }\n                        };\n                    };\n                    // Listen to events\n                    xhr.onload = callback();\n                    errorCallback = xhr.onerror = xhr.ontimeout = callback(\"error\");\n                    // Support: IE 9 only\n                    // Use onreadystatechange to replace onabort\n                    // to handle uncaught aborts\n                    if (xhr.onabort !== undefined) {\n                        xhr.onabort = errorCallback;\n                    } else {\n                        xhr.onreadystatechange = function() {\n                            // Check readyState before timeout as it changes\n                            if (xhr.readyState === 4) {\n                                // Allow onerror to be called first,\n                                // but that will not handle a native abort\n                                // Also, save errorCallback to a variable\n                                // as xhr.onerror cannot be accessed\n                                window1.setTimeout(function() {\n                                    if (callback) {\n                                        errorCallback();\n                                    }\n                                });\n                            }\n                        };\n                    }\n                    // Create the abort callback\n                    callback = callback(\"abort\");\n                    try {\n                        // Do send the request (this may raise an exception)\n                        xhr.send(options.hasContent && options.data || null);\n                    } catch (e) {\n                        // trac-14683: Only rethrow if this hasn't been notified as an error yet\n                        if (callback) {\n                            throw e;\n                        }\n                    }\n                },\n                abort: function() {\n                    if (callback) {\n                        callback();\n                    }\n                }\n            };\n        }\n    });\n    // Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432)\n    jQuery.ajaxPrefilter(function(s) {\n        if (s.crossDomain) {\n            s.contents.script = false;\n        }\n    });\n    // Install script dataType\n    jQuery.ajaxSetup({\n        accepts: {\n            script: \"text/javascript, application/javascript, \" + \"application/ecmascript, application/x-ecmascript\"\n        },\n        contents: {\n            script: /\\b(?:java|ecma)script\\b/\n        },\n        converters: {\n            \"text script\": function(text) {\n                jQuery.globalEval(text);\n                return text;\n            }\n        }\n    });\n    // Handle cache's special case and crossDomain\n    jQuery.ajaxPrefilter(\"script\", function(s) {\n        if (s.cache === undefined) {\n            s.cache = false;\n        }\n        if (s.crossDomain) {\n            s.type = \"GET\";\n        }\n    });\n    // Bind script tag hack transport\n    jQuery.ajaxTransport(\"script\", function(s) {\n        // This transport only deals with cross domain or forced-by-attrs requests\n        if (s.crossDomain || s.scriptAttrs) {\n            var script, callback;\n            return {\n                send: function(_, complete) {\n                    script = jQuery(\"<script>\").attr(s.scriptAttrs || {}).prop({\n                        charset: s.scriptCharset,\n                        src: s.url\n                    }).on(\"load error\", callback = function(evt) {\n                        script.remove();\n                        callback = null;\n                        if (evt) {\n                            complete(evt.type === \"error\" ? 404 : 200, evt.type);\n                        }\n                    });\n                    // Use native DOM manipulation to avoid our domManip AJAX trickery\n                    document.head.appendChild(script[0]);\n                },\n                abort: function() {\n                    if (callback) {\n                        callback();\n                    }\n                }\n            };\n        }\n    });\n    var oldCallbacks = [], rjsonp = /(=)\\?(?=&|$)|\\?\\?/;\n    // Default jsonp settings\n    jQuery.ajaxSetup({\n        jsonp: \"callback\",\n        jsonpCallback: function() {\n            var callback = oldCallbacks.pop() || jQuery.expando + \"_\" + nonce.guid++;\n            this[callback] = true;\n            return callback;\n        }\n    });\n    // Detect, normalize options and install callbacks for jsonp requests\n    jQuery.ajaxPrefilter(\"json jsonp\", function(s, originalSettings, jqXHR) {\n        var callbackName, overwritten, responseContainer, jsonProp = s.jsonp !== false && (rjsonp.test(s.url) ? \"url\" : typeof s.data === \"string\" && (s.contentType || \"\").indexOf(\"application/x-www-form-urlencoded\") === 0 && rjsonp.test(s.data) && \"data\");\n        // Handle iff the expected data type is \"jsonp\" or we have a parameter to set\n        if (jsonProp || s.dataTypes[0] === \"jsonp\") {\n            // Get callback name, remembering preexisting value associated with it\n            callbackName = s.jsonpCallback = isFunction(s.jsonpCallback) ? s.jsonpCallback() : s.jsonpCallback;\n            // Insert callback into url or form data\n            if (jsonProp) {\n                s[jsonProp] = s[jsonProp].replace(rjsonp, \"$1\" + callbackName);\n            } else if (s.jsonp !== false) {\n                s.url += (rquery.test(s.url) ? \"&\" : \"?\") + s.jsonp + \"=\" + callbackName;\n            }\n            // Use data converter to retrieve json after script execution\n            s.converters[\"script json\"] = function() {\n                if (!responseContainer) {\n                    jQuery.error(callbackName + \" was not called\");\n                }\n                return responseContainer[0];\n            };\n            // Force json dataType\n            s.dataTypes[0] = \"json\";\n            // Install callback\n            overwritten = window1[callbackName];\n            window1[callbackName] = function() {\n                responseContainer = arguments;\n            };\n            // Clean-up function (fires after converters)\n            jqXHR.always(function() {\n                // If previous value didn't exist - remove it\n                if (overwritten === undefined) {\n                    jQuery(window1).removeProp(callbackName);\n                // Otherwise restore preexisting value\n                } else {\n                    window1[callbackName] = overwritten;\n                }\n                // Save back as free\n                if (s[callbackName]) {\n                    // Make sure that re-using the options doesn't screw things around\n                    s.jsonpCallback = originalSettings.jsonpCallback;\n                    // Save the callback name for future use\n                    oldCallbacks.push(callbackName);\n                }\n                // Call if it was a function and we have a response\n                if (responseContainer && isFunction(overwritten)) {\n                    overwritten(responseContainer[0]);\n                }\n                responseContainer = overwritten = undefined;\n            });\n            // Delegate to script\n            return \"script\";\n        }\n    });\n    // Support: Safari 8 only\n    // In Safari 8 documents created via document.implementation.createHTMLDocument\n    // collapse sibling forms: the second one becomes a child of the first one.\n    // Because of that, this security measure has to be disabled in Safari 8.\n    // https://bugs.webkit.org/show_bug.cgi?id=137337\n    support.createHTMLDocument = function() {\n        var body = document.implementation.createHTMLDocument(\"\").body;\n        body.innerHTML = \"<form></form><form></form>\";\n        return body.childNodes.length === 2;\n    }();\n    // Argument \"data\" should be string of html\n    // context (optional): If specified, the fragment will be created in this context,\n    // defaults to document\n    // keepScripts (optional): If true, will include scripts passed in the html string\n    jQuery.parseHTML = function(data, context, keepScripts) {\n        if (typeof data !== \"string\") {\n            return [];\n        }\n        if (typeof context === \"boolean\") {\n            keepScripts = context;\n            context = false;\n        }\n        var base, parsed, scripts;\n        if (!context) {\n            // Stop scripts or inline event handlers from being executed immediately\n            // by using document.implementation\n            if (support.createHTMLDocument) {\n                context = document.implementation.createHTMLDocument(\"\");\n                // Set the base href for the created document\n                // so any parsed elements with URLs\n                // are based on the document's URL (gh-2965)\n                base = context.createElement(\"base\");\n                base.href = document.location.href;\n                context.head.appendChild(base);\n            } else {\n                context = document;\n            }\n        }\n        parsed = rsingleTag.exec(data);\n        scripts = !keepScripts && [];\n        // Single tag\n        if (parsed) {\n            return [\n                context.createElement(parsed[1])\n            ];\n        }\n        parsed = buildFragment([\n            data\n        ], context, scripts);\n        if (scripts && scripts.length) {\n            jQuery(scripts).remove();\n        }\n        return jQuery.merge([], parsed.childNodes);\n    };\n    /**\n * Load a url into a page\n */ jQuery.fn.load = function(url, params, callback) {\n        var selector, type, response, self = this, off = url.indexOf(\" \");\n        if (off > -1) {\n            selector = stripAndCollapse(url.slice(off));\n            url = url.slice(0, off);\n        }\n        // If it's a function\n        if (isFunction(params)) {\n            // We assume that it's the callback\n            callback = params;\n            params = undefined;\n        // Otherwise, build a param string\n        } else if (params && typeof params === \"object\") {\n            type = \"POST\";\n        }\n        // If we have elements to modify, make the request\n        if (self.length > 0) {\n            jQuery.ajax({\n                url: url,\n                // If \"type\" variable is undefined, then \"GET\" method will be used.\n                // Make value of this field explicit since\n                // user can override it through ajaxSetup method\n                type: type || \"GET\",\n                dataType: \"html\",\n                data: params\n            }).done(function(responseText) {\n                // Save response for use in complete callback\n                response = arguments;\n                self.html(selector ? // If a selector was specified, locate the right elements in a dummy div\n                // Exclude scripts to avoid IE 'Permission Denied' errors\n                jQuery(\"<div>\").append(jQuery.parseHTML(responseText)).find(selector) : // Otherwise use the full result\n                responseText);\n            // If the request succeeds, this function gets \"data\", \"status\", \"jqXHR\"\n            // but they are ignored because response was set above.\n            // If it fails, this function gets \"jqXHR\", \"status\", \"error\"\n            }).always(callback && function(jqXHR, status) {\n                self.each(function() {\n                    callback.apply(this, response || [\n                        jqXHR.responseText,\n                        status,\n                        jqXHR\n                    ]);\n                });\n            });\n        }\n        return this;\n    };\n    jQuery.expr.pseudos.animated = function(elem) {\n        return jQuery.grep(jQuery.timers, function(fn) {\n            return elem === fn.elem;\n        }).length;\n    };\n    jQuery.offset = {\n        setOffset: function(elem, options, i) {\n            var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition, position = jQuery.css(elem, \"position\"), curElem = jQuery(elem), props = {};\n            // Set position first, in-case top/left are set even on static elem\n            if (position === \"static\") {\n                elem.style.position = \"relative\";\n            }\n            curOffset = curElem.offset();\n            curCSSTop = jQuery.css(elem, \"top\");\n            curCSSLeft = jQuery.css(elem, \"left\");\n            calculatePosition = (position === \"absolute\" || position === \"fixed\") && (curCSSTop + curCSSLeft).indexOf(\"auto\") > -1;\n            // Need to be able to calculate position if either\n            // top or left is auto and position is either absolute or fixed\n            if (calculatePosition) {\n                curPosition = curElem.position();\n                curTop = curPosition.top;\n                curLeft = curPosition.left;\n            } else {\n                curTop = parseFloat(curCSSTop) || 0;\n                curLeft = parseFloat(curCSSLeft) || 0;\n            }\n            if (isFunction(options)) {\n                // Use jQuery.extend here to allow modification of coordinates argument (gh-1848)\n                options = options.call(elem, i, jQuery.extend({}, curOffset));\n            }\n            if (options.top != null) {\n                props.top = options.top - curOffset.top + curTop;\n            }\n            if (options.left != null) {\n                props.left = options.left - curOffset.left + curLeft;\n            }\n            if (\"using\" in options) {\n                options.using.call(elem, props);\n            } else {\n                curElem.css(props);\n            }\n        }\n    };\n    jQuery.fn.extend({\n        // offset() relates an element's border box to the document origin\n        offset: function(options) {\n            // Preserve chaining for setter\n            if (arguments.length) {\n                return options === undefined ? this : this.each(function(i) {\n                    jQuery.offset.setOffset(this, options, i);\n                });\n            }\n            var rect, win, elem = this[0];\n            if (!elem) {\n                return;\n            }\n            // Return zeros for disconnected and hidden (display: none) elements (gh-2310)\n            // Support: IE <=11 only\n            // Running getBoundingClientRect on a\n            // disconnected node in IE throws an error\n            if (!elem.getClientRects().length) {\n                return {\n                    top: 0,\n                    left: 0\n                };\n            }\n            // Get document-relative position by adding viewport scroll to viewport-relative gBCR\n            rect = elem.getBoundingClientRect();\n            win = elem.ownerDocument.defaultView;\n            return {\n                top: rect.top + win.pageYOffset,\n                left: rect.left + win.pageXOffset\n            };\n        },\n        // position() relates an element's margin box to its offset parent's padding box\n        // This corresponds to the behavior of CSS absolute positioning\n        position: function() {\n            if (!this[0]) {\n                return;\n            }\n            var offsetParent, offset, doc, elem = this[0], parentOffset = {\n                top: 0,\n                left: 0\n            };\n            // position:fixed elements are offset from the viewport, which itself always has zero offset\n            if (jQuery.css(elem, \"position\") === \"fixed\") {\n                // Assume position:fixed implies availability of getBoundingClientRect\n                offset = elem.getBoundingClientRect();\n            } else {\n                offset = this.offset();\n                // Account for the *real* offset parent, which can be the document or its root element\n                // when a statically positioned element is identified\n                doc = elem.ownerDocument;\n                offsetParent = elem.offsetParent || doc.documentElement;\n                while(offsetParent && (offsetParent === doc.body || offsetParent === doc.documentElement) && jQuery.css(offsetParent, \"position\") === \"static\"){\n                    offsetParent = offsetParent.parentNode;\n                }\n                if (offsetParent && offsetParent !== elem && offsetParent.nodeType === 1) {\n                    // Incorporate borders into its offset, since they are outside its content origin\n                    parentOffset = jQuery(offsetParent).offset();\n                    parentOffset.top += jQuery.css(offsetParent, \"borderTopWidth\", true);\n                    parentOffset.left += jQuery.css(offsetParent, \"borderLeftWidth\", true);\n                }\n            }\n            // Subtract parent offsets and element margins\n            return {\n                top: offset.top - parentOffset.top - jQuery.css(elem, \"marginTop\", true),\n                left: offset.left - parentOffset.left - jQuery.css(elem, \"marginLeft\", true)\n            };\n        },\n        // This method will return documentElement in the following cases:\n        // 1) For the element inside the iframe without offsetParent, this method will return\n        //    documentElement of the parent window\n        // 2) For the hidden or detached element\n        // 3) For body or html element, i.e. in case of the html node - it will return itself\n        //\n        // but those exceptions were never presented as a real life use-cases\n        // and might be considered as more preferable results.\n        //\n        // This logic, however, is not guaranteed and can change at any point in the future\n        offsetParent: function() {\n            return this.map(function() {\n                var offsetParent = this.offsetParent;\n                while(offsetParent && jQuery.css(offsetParent, \"position\") === \"static\"){\n                    offsetParent = offsetParent.offsetParent;\n                }\n                return offsetParent || documentElement;\n            });\n        }\n    });\n    // Create scrollLeft and scrollTop methods\n    jQuery.each({\n        scrollLeft: \"pageXOffset\",\n        scrollTop: \"pageYOffset\"\n    }, function(method, prop) {\n        var top = \"pageYOffset\" === prop;\n        jQuery.fn[method] = function(val) {\n            return access(this, function(elem, method, val) {\n                // Coalesce documents and windows\n                var win;\n                if (isWindow(elem)) {\n                    win = elem;\n                } else if (elem.nodeType === 9) {\n                    win = elem.defaultView;\n                }\n                if (val === undefined) {\n                    return win ? win[prop] : elem[method];\n                }\n                if (win) {\n                    win.scrollTo(!top ? val : win.pageXOffset, top ? val : win.pageYOffset);\n                } else {\n                    elem[method] = val;\n                }\n            }, method, val, arguments.length);\n        };\n    });\n    // Support: Safari <=7 - 9.1, Chrome <=37 - 49\n    // Add the top/left cssHooks using jQuery.fn.position\n    // Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084\n    // Blink bug: https://bugs.chromium.org/p/chromium/issues/detail?id=589347\n    // getComputedStyle returns percent when specified for top/left/bottom/right;\n    // rather than make the css module depend on the offset module, just check for it here\n    jQuery.each([\n        \"top\",\n        \"left\"\n    ], function(_i, prop) {\n        jQuery.cssHooks[prop] = addGetHookIf(support.pixelPosition, function(elem, computed) {\n            if (computed) {\n                computed = curCSS(elem, prop);\n                // If curCSS returns percentage, fallback to offset\n                return rnumnonpx.test(computed) ? jQuery(elem).position()[prop] + \"px\" : computed;\n            }\n        });\n    });\n    // Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods\n    jQuery.each({\n        Height: \"height\",\n        Width: \"width\"\n    }, function(name, type) {\n        jQuery.each({\n            padding: \"inner\" + name,\n            content: type,\n            \"\": \"outer\" + name\n        }, function(defaultExtra, funcName) {\n            // Margin is only for outerHeight, outerWidth\n            jQuery.fn[funcName] = function(margin, value) {\n                var chainable = arguments.length && (defaultExtra || typeof margin !== \"boolean\"), extra = defaultExtra || (margin === true || value === true ? \"margin\" : \"border\");\n                return access(this, function(elem, type, value) {\n                    var doc;\n                    if (isWindow(elem)) {\n                        // $( window ).outerWidth/Height return w/h including scrollbars (gh-1729)\n                        return funcName.indexOf(\"outer\") === 0 ? elem[\"inner\" + name] : elem.document.documentElement[\"client\" + name];\n                    }\n                    // Get document width or height\n                    if (elem.nodeType === 9) {\n                        doc = elem.documentElement;\n                        // Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],\n                        // whichever is greatest\n                        return Math.max(elem.body[\"scroll\" + name], doc[\"scroll\" + name], elem.body[\"offset\" + name], doc[\"offset\" + name], doc[\"client\" + name]);\n                    }\n                    return value === undefined ? // Get width or height on the element, requesting but not forcing parseFloat\n                    jQuery.css(elem, type, extra) : // Set width or height on the element\n                    jQuery.style(elem, type, value, extra);\n                }, type, chainable ? margin : undefined, chainable);\n            };\n        });\n    });\n    jQuery.each([\n        \"ajaxStart\",\n        \"ajaxStop\",\n        \"ajaxComplete\",\n        \"ajaxError\",\n        \"ajaxSuccess\",\n        \"ajaxSend\"\n    ], function(_i, type) {\n        jQuery.fn[type] = function(fn) {\n            return this.on(type, fn);\n        };\n    });\n    jQuery.fn.extend({\n        bind: function(types, data, fn) {\n            return this.on(types, null, data, fn);\n        },\n        unbind: function(types, fn) {\n            return this.off(types, null, fn);\n        },\n        delegate: function(selector, types, data, fn) {\n            return this.on(types, selector, data, fn);\n        },\n        undelegate: function(selector, types, fn) {\n            // ( namespace ) or ( selector, types [, fn] )\n            return arguments.length === 1 ? this.off(selector, \"**\") : this.off(types, selector || \"**\", fn);\n        },\n        hover: function(fnOver, fnOut) {\n            return this.on(\"mouseenter\", fnOver).on(\"mouseleave\", fnOut || fnOver);\n        }\n    });\n    jQuery.each((\"blur focus focusin focusout resize scroll click dblclick \" + \"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave \" + \"change select submit keydown keypress keyup contextmenu\").split(\" \"), function(_i, name) {\n        // Handle event binding\n        jQuery.fn[name] = function(data, fn) {\n            return arguments.length > 0 ? this.on(name, null, data, fn) : this.trigger(name);\n        };\n    });\n    // Support: Android <=4.0 only\n    // Make sure we trim BOM and NBSP\n    // Require that the \"whitespace run\" starts from a non-whitespace\n    // to avoid O(N^2) behavior when the engine would try matching \"\\s+$\" at each space position.\n    var rtrim = /^[\\s\\uFEFF\\xA0]+|([^\\s\\uFEFF\\xA0])[\\s\\uFEFF\\xA0]+$/g;\n    // Bind a function to a context, optionally partially applying any\n    // arguments.\n    // jQuery.proxy is deprecated to promote standards (specifically Function#bind)\n    // However, it is not slated for removal any time soon\n    jQuery.proxy = function(fn, context) {\n        var tmp, args, proxy;\n        if (typeof context === \"string\") {\n            tmp = fn[context];\n            context = fn;\n            fn = tmp;\n        }\n        // Quick check to determine if target is callable, in the spec\n        // this throws a TypeError, but we will just return undefined.\n        if (!isFunction(fn)) {\n            return undefined;\n        }\n        // Simulated bind\n        args = slice.call(arguments, 2);\n        proxy = function() {\n            return fn.apply(context || this, args.concat(slice.call(arguments)));\n        };\n        // Set the guid of unique handler to the same of original handler, so it can be removed\n        proxy.guid = fn.guid = fn.guid || jQuery.guid++;\n        return proxy;\n    };\n    jQuery.holdReady = function(hold) {\n        if (hold) {\n            jQuery.readyWait++;\n        } else {\n            jQuery.ready(true);\n        }\n    };\n    jQuery.isArray = Array.isArray;\n    jQuery.parseJSON = JSON.parse;\n    jQuery.nodeName = nodeName;\n    jQuery.isFunction = isFunction;\n    jQuery.isWindow = isWindow;\n    jQuery.camelCase = camelCase;\n    jQuery.type = toType;\n    jQuery.now = Date.now;\n    jQuery.isNumeric = function(obj) {\n        // As of jQuery 3.0, isNumeric is limited to\n        // strings and numbers (primitives or objects)\n        // that can be coerced to finite numbers (gh-2662)\n        var type = jQuery.type(obj);\n        return (type === \"number\" || type === \"string\") && // parseFloat NaNs numeric-cast false positives (\"\")\n        // ...but misinterprets leading-number strings, particularly hex literals (\"0x...\")\n        // subtraction forces infinities to NaN\n        !isNaN(obj - parseFloat(obj));\n    };\n    jQuery.trim = function(text) {\n        return text == null ? \"\" : (text + \"\").replace(rtrim, \"$1\");\n    };\n    // Register as a named AMD module, since jQuery can be concatenated with other\n    // files that may use define, but not via a proper concatenation script that\n    // understands anonymous AMD modules. A named AMD is safest and most robust\n    // way to register. Lowercase jquery is used because AMD module names are\n    // derived from file names, and jQuery is normally delivered in a lowercase\n    // file name. Do this after creating the global so that if an AMD module wants\n    // to call noConflict to hide this version of jQuery, it will work.\n    // Note that for maximum portability, libraries that are not jQuery should\n    // declare themselves as anonymous modules, and avoid setting a global if an\n    // AMD loader is present. jQuery is a special case. For more information, see\n    // https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon\n    if (true) {\n        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function() {\n            return jQuery;\n        }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    }\n    var // Map over jQuery in case of overwrite\n    _jQuery = window1.jQuery, // Map over the $ in case of overwrite\n    _$ = window1.$;\n    jQuery.noConflict = function(deep) {\n        if (window1.$ === jQuery) {\n            window1.$ = _$;\n        }\n        if (deep && window1.jQuery === jQuery) {\n            window1.jQuery = _jQuery;\n        }\n        return jQuery;\n    };\n    // Expose jQuery and $ identifiers, even in AMD\n    // (trac-7102#comment:10, https://github.com/jquery/jquery/pull/557)\n    // and CommonJS for browser emulators (trac-13566)\n    if (typeof noGlobal === \"undefined\") {\n        window1.jQuery = window1.$ = jQuery;\n    }\n    return jQuery;\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvanF1ZXJ5L2Rpc3QvanF1ZXJ5LmpzIiwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7Q0FTQyxHQUNDLFVBQVVBLE1BQU0sRUFBRUMsT0FBTztJQUUxQjtJQUVBLElBQUssS0FBMEIsSUFBSSxPQUFPQyxPQUFPQyxPQUFPLEtBQUssVUFBVztRQUV2RSxzRUFBc0U7UUFDdEUsa0RBQWtEO1FBQ2xELGlFQUFpRTtRQUNqRSx5REFBeUQ7UUFDekQsaUVBQWlFO1FBQ2pFLCtDQUErQztRQUMvQyx1Q0FBdUM7UUFDdkNELE9BQU9DLE9BQU8sR0FBR0gsT0FBT0ksUUFBUSxHQUMvQkgsUUFBU0QsUUFBUSxRQUNqQixTQUFVSyxDQUFDO1lBQ1YsSUFBSyxDQUFDQSxFQUFFRCxRQUFRLEVBQUc7Z0JBQ2xCLE1BQU0sSUFBSUUsTUFBTztZQUNsQjtZQUNBLE9BQU9MLFFBQVNJO1FBQ2pCO0lBQ0YsT0FBTztRQUNOSixRQUFTRDtJQUNWO0FBRUQseUNBQXlDO0FBQ3pDLEdBQUssTUFBNkIsR0FBR08sQ0FBTUEsR0FBRyxJQUFJLEVBQUUsU0FBVUEsT0FBTSxFQUFFQyxRQUFRO0lBRTlFLGlGQUFpRjtJQUNqRixpRkFBaUY7SUFDakYsa0dBQWtHO0lBQ2xHLDREQUE0RDtJQUM1RDtJQUVBLElBQUlDLE1BQU0sRUFBRTtJQUVaLElBQUlDLFdBQVdDLE9BQU9DLGNBQWM7SUFFcEMsSUFBSUMsUUFBUUosSUFBSUksS0FBSztJQUVyQixJQUFJQyxPQUFPTCxJQUFJSyxJQUFJLEdBQUcsU0FBVUMsS0FBSztRQUNwQyxPQUFPTixJQUFJSyxJQUFJLENBQUNFLElBQUksQ0FBRUQ7SUFDdkIsSUFBSSxTQUFVQSxLQUFLO1FBQ2xCLE9BQU9OLElBQUlRLE1BQU0sQ0FBQ0MsS0FBSyxDQUFFLEVBQUUsRUFBRUg7SUFDOUI7SUFHQSxJQUFJSSxPQUFPVixJQUFJVSxJQUFJO0lBRW5CLElBQUlDLFVBQVVYLElBQUlXLE9BQU87SUFFekIsSUFBSUMsYUFBYSxD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QUM1QjtJQUtBLE9BQU9BO0FBQ1AiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9taGFkcmktZmluYWwtbmV4dGpzLy4vbm9kZV9tb2R1bGVzL2pxdWVyeS9kaXN0L2pxdWVyeS5qcz84MjYyIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogalF1ZXJ5IEphdmFTY3JpcHQgTGlicmFyeSB2My43LjFcbiAqIGh0dHBzOi8vanF1ZXJ5LmNvbS9cbiAqXG4gKiBDb3B5cmlnaHQgT3BlbkpTIEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9yc1xuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKiBodHRwczovL2pxdWVyeS5vcmcvbGljZW5zZVxuICpcbiAqIERhdGU6IDIwMjMtMDgtMjhUMTM6MzdaXG4gKi9cbiggZnVuY3Rpb24oIGdsb2JhbCwgZmFjdG9yeSApIHtcblxuXHRcInVzZSBzdHJpY3RcIjtcblxuXHRpZiAoIHR5cGVvZiBtb2R1bGUgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSBcIm9iamVjdFwiICkge1xuXG5cdFx0Ly8gRm9yIENvbW1vbkpTIGFuZCBDb21tb25KUy1saWtlIGVudmlyb25tZW50cyB3aGVyZSBhIHByb3BlciBgd2luZG93YFxuXHRcdC8vIGlzIHByZXNlbnQsIGV4ZWN1dGUgdGhlIGZhY3RvcnkgYW5kIGdldCBqUXVlcnkuXG5cdFx0Ly8gRm9yIGVudmlyb25tZW50cyB0aGF0IGRvIG5vdCBoYXZlIGEgYHdpbmRvd2Agd2l0aCBhIGBkb2N1bWVudGBcblx0XHQvLyAoc3VjaCBhcyBOb2RlLmpzKSwgZXhwb3NlIGEgZmFjdG9yeSBhcyBtb2R1bGUuZXhwb3J0cy5cblx0XHQvLyBUaGlzIGFjY2VudHVhdGVzIHRoZSBuZWVkIGZvciB0aGUgY3JlYXRpb24gb2YgYSByZWFsIGB3aW5kb3dgLlxuXHRcdC8vIGUuZy4gdmFyIGpRdWVyeSA9IHJlcXVpcmUoXCJqcXVlcnlcIikod2luZG93KTtcblx0XHQvLyBTZWUgdGlja2V0IHRyYWMtMTQ1NDkgZm9yIG1vcmUgaW5mby5cblx0XHRtb2R1bGUuZXhwb3J0cyA9IGdsb2JhbC5kb2N1bWVudCA/XG5cdFx0XHRmYWN0b3J5KCBnbG9iYWwsIHRydWUgKSA6XG5cdFx0XHRmdW5jdGlvbiggdyApIHtcblx0XHRcdFx0aWYgKCAhdy5kb2N1bWVudCApIHtcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoIFwialF1ZXJ5IHJlcXVpcmVzIGEgd2luZG93IHdpdGggYSBkb2N1bWVudFwiICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIGZhY3RvcnkoIHcgKTtcblx0XHRcdH07XG5cdH0gZWxzZSB7XG5cdFx0ZmFjdG9yeSggZ2xvYmFsICk7XG5cdH1cblxuLy8gUGFzcyB0aGlzIGlmIHdpbmRvdyBpcyBub3QgZGVmaW5lZCB5ZXRcbn0gKSggdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHRoaXMsIGZ1bmN0aW9uKCB3aW5kb3csIG5vR2xvYmFsICkge1xuXG4vLyBFZGdlIDw9IDEyIC0gMTMrLCBGaXJlZm94IDw9MTggLSA0NSssIElFIDEwIC0gMTEsIFNhZmFyaSA1LjEgLSA5KywgaU9TIDYgLSA5LjFcbi8vIHRocm93IGV4Y2VwdGlvbnMgd2hlbiBub24tc3RyaWN0IGNvZGUgKGUuZy4sIEFTUC5ORVQgNC41KSBhY2Nlc3NlcyBzdHJpY3QgbW9kZVxuLy8gYXJndW1lbnRzLmNhbGxlZS5jYWxsZXIgKHRyYWMtMTMzMzUpLiBCdXQgYXMgb2YgalF1ZXJ5IDMuMCAoMjAxNiksIHN0cmljdCBtb2RlIHNob3VsZCBiZSBjb21tb25cbi8vIGVub3VnaCB0aGF0IGFsbCBzdWNoIGF0dGVtcHRzIGFyZSBndWFyZGVkIGluIGEgdHJ5IGJsb2NrLlxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBhcnIgPSBbXTtcblxudmFyIGdldFByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xuXG52YXIgc2xpY2UgPSBhcnIuc2xpY2U7XG5cbnZhciBmbGF0ID0gYXJyLmZsYXQgPyBmdW5jdGlvbiggYXJyYXkgKSB7XG5cdHJldHVybiBhcnIuZmxhdC5jYWxsKCBhcnJheSApO1xufSA6IGZ1bmN0aW9uKCBhcnJheSApIHtcblx0cmV0dXJuIGFyci5jb25jYXQuYXBwbHkoIFtdLCBhcnJheSApO1xufTtcblxuXG52YXIgcHVzaCA9IGFyci5wdXNoO1xuXG52YXIgaW5kZXhPZiA9IGFyci5pbmRleE9mO1xuXG52YXIgY2xhc3MydHlwZSA9IHt9O1xuXG52YXIgdG9TdHJpbmcgPSBjbGFzczJ0eXBlLnRvU3RyaW5nO1xuXG52YXIgaGFzT3duID0gY2xhc3MydHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxudmFyIGZuVG9TdHJpbmcgPSBoYXNPd24udG9TdHJpbmc7XG5cbnZhciBPYmplY3RGdW5jdGlvblN0cmluZyA9IGZuVG9TdHJpbmcuY2FsbCggT2JqZWN0ICk7XG5cbnZhciBzdXBwb3J0ID0ge307XG5cbnZhciBpc0Z1bmN0aW9uID0gZnVuY3Rpb24gaXNGdW5jdGlvbiggb2JqICkge1xuXG5cdFx0Ly8gU3VwcG9ydDogQ2hyb21lIDw9NTcsIEZpcmVmb3ggPD01MlxuXHRcdC8vIEluIHNvbWUgYnJvd3NlcnMsIHR5cGVvZiByZXR1cm5zIFwiZnVuY3Rpb25cIiBmb3IgSFRNTCA8b2JqZWN0PiBlbGVtZW50c1xuXHRcdC8vIChpLmUuLCBgdHlwZW9mIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwib2JqZWN0XCIgKSA9PT0gXCJmdW5jdGlvblwiYCkuXG5cdFx0Ly8gV2UgZG9uJ3Qgd2FudCB0byBjbGFzc2lmeSAqYW55KiBET00gbm9kZSBhcyBhIGZ1bmN0aW9uLlxuXHRcdC8vIFN1cHBvcnQ6IFF0V2ViIDw9My44LjUsIFdlYktpdCA8PTUzNC4zNCwgd2todG1sdG9wZGYgdG9vbCA8PTAuMTIuNVxuXHRcdC8vIFBsdXMgZm9yIG9sZCBXZWJLaXQsIHR5cGVvZiByZXR1cm5zIFwiZnVuY3Rpb25cIiBmb3IgSFRNTCBjb2xsZWN0aW9uc1xuXHRcdC8vIChlLmcuLCBgdHlwZW9mIGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiZGl2XCIpID09PSBcImZ1bmN0aW9uXCJgKS4gKGdoLTQ3NTYpXG5cdFx0cmV0dXJuIHR5cGVvZiBvYmogPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2Ygb2JqLm5vZGVUeXBlICE9PSBcIm51bWJlclwiICYmXG5cdFx0XHR0eXBlb2Ygb2JqLml0ZW0gIT09IFwiZnVuY3Rpb25cIjtcblx0fTtcblxuXG52YXIgaXNXaW5kb3cgPSBmdW5jdGlvbiBpc1dpbmRvdyggb2JqICkge1xuXHRcdHJldHVybiBvYmogIT0gbnVsbCAmJiBvYmogPT09IG9iai53aW5kb3c7XG5cdH07XG5cblxudmFyIGRvY3VtZW50ID0gd2luZG93LmRvY3VtZW50O1xuXG5cblxuXHR2YXIgcHJlc2VydmVkU2NyaXB0QXR0cmlidXRlcyA9IHtcblx0XHR0eXBlOiB0cnVlLFxuXHRcdHNyYzogdHJ1ZSxcblx0XHRub25jZTogdHJ1ZSxcblx0XHRub01vZHVsZTogdHJ1ZVxuXHR9O1xuXG5cdGZ1bmN0aW9uIERPTUV2YWwoIGNvZGUsIG5vZGUsIGRvYyApIHtcblx0XHRkb2MgPSBkb2MgfHwgZG9jdW1lbnQ7XG5cblx0XHR2YXIgaSwgdmFsLFxuXHRcdFx0c2NyaXB0ID0gZG9jLmNyZWF0ZUVsZW1lbnQoIFwic2NyaXB0XCIgKTtcblxuXHRcdHNjcmlwdC50ZXh0ID0gY29kZTtcblx0XHRpZiAoIG5vZGUgKSB7XG5cdFx0XHRmb3IgKCBpIGluIHByZXNlcnZlZFNjcmlwdEF0dHJpYnV0ZXMgKSB7XG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogRmlyZWZveCA2NCssIEVkZ2UgMTgrXG5cdFx0XHRcdC8vIFNvbWUgYnJvd3NlcnMgZG9uJ3Qgc3VwcG9ydCB0aGUgXCJub25jZVwiIHByb3BlcnR5IG9uIHNjcmlwdHMuXG5cdFx0XHRcdC8vIE9uIHRoZSBvdGhlciBoYW5kLCBqdXN0IHVzaW5nIGBnZXRBdHRyaWJ1dGVgIGlzIG5vdCBlbm91Z2ggYXNcblx0XHRcdFx0Ly8gdGhlIGBub25jZWAgYXR0cmlidXRlIGlzIHJlc2V0IHRvIGFuIGVtcHR5IHN0cmluZyB3aGVuZXZlciBpdFxuXHRcdFx0XHQvLyBiZWNvbWVzIGJyb3dzaW5nLWNvbnRleHQgY29ubmVjdGVkLlxuXHRcdFx0XHQvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3doYXR3Zy9odG1sL2lzc3Vlcy8yMzY5XG5cdFx0XHRcdC8vIFNlZSBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnLyNub25jZS1hdHRyaWJ1dGVzXG5cdFx0XHRcdC8vIFRoZSBgbm9kZS5nZXRBdHRyaWJ1dGVgIGNoZWNrIHdhcyBhZGRlZCBmb3IgdGhlIHNha2Ugb2Zcblx0XHRcdFx0Ly8gYGpRdWVyeS5nbG9iYWxFdmFsYCBzbyB0aGF0IGl0IGNhbiBmYWtlIGEgbm9uY2UtY29udGFpbmluZyBub2RlXG5cdFx0XHRcdC8vIHZpYSBhbiBvYmplY3QuXG5cdFx0XHRcdHZhbCA9IG5vZGVbIGkgXSB8fCBub2RlLmdldEF0dHJpYnV0ZSAmJiBub2RlLmdldEF0dHJpYnV0ZSggaSApO1xuXHRcdFx0XHRpZiAoIHZhbCApIHtcblx0XHRcdFx0XHRzY3JpcHQuc2V0QXR0cmlidXRlKCBpLCB2YWwgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRkb2MuaGVhZC5hcHBlbmRDaGlsZCggc2NyaXB0ICkucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCggc2NyaXB0ICk7XG5cdH1cblxuXG5mdW5jdGlvbiB0b1R5cGUoIG9iaiApIHtcblx0aWYgKCBvYmogPT0gbnVsbCApIHtcblx0XHRyZXR1cm4gb2JqICsgXCJcIjtcblx0fVxuXG5cdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD0yLjMgb25seSAoZnVuY3Rpb25pc2ggUmVnRXhwKVxuXHRyZXR1cm4gdHlwZW9mIG9iaiA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2Ygb2JqID09PSBcImZ1bmN0aW9uXCIgP1xuXHRcdGNsYXNzMnR5cGVbIHRvU3RyaW5nLmNhbGwoIG9iaiApIF0gfHwgXCJvYmplY3RcIiA6XG5cdFx0dHlwZW9mIG9iajtcbn1cbi8qIGdsb2JhbCBTeW1ib2wgKi9cbi8vIERlZmluaW5nIHRoaXMgZ2xvYmFsIGluIC5lc2xpbnRyYy5qc29uIHdvdWxkIGNyZWF0ZSBhIGRhbmdlciBvZiB1c2luZyB0aGUgZ2xvYmFsXG4vLyB1bmd1YXJkZWQgaW4gYW5vdGhlciBwbGFjZSwgaXQgc2VlbXMgc2FmZXIgdG8gZGVmaW5lIGdsb2JhbCBvbmx5IGZvciB0aGlzIG1vZHVsZVxuXG5cblxudmFyIHZlcnNpb24gPSBcIjMuNy4xXCIsXG5cblx0cmh0bWxTdWZmaXggPSAvSFRNTCQvaSxcblxuXHQvLyBEZWZpbmUgYSBsb2NhbCBjb3B5IG9mIGpRdWVyeVxuXHRqUXVlcnkgPSBmdW5jdGlvbiggc2VsZWN0b3IsIGNvbnRleHQgKSB7XG5cblx0XHQvLyBUaGUgalF1ZXJ5IG9iamVjdCBpcyBhY3R1YWxseSBqdXN0IHRoZSBpbml0IGNvbnN0cnVjdG9yICdlbmhhbmNlZCdcblx0XHQvLyBOZWVkIGluaXQgaWYgalF1ZXJ5IGlzIGNhbGxlZCAoanVzdCBhbGxvdyBlcnJvciB0byBiZSB0aHJvd24gaWYgbm90IGluY2x1ZGVkKVxuXHRcdHJldHVybiBuZXcgalF1ZXJ5LmZuLmluaXQoIHNlbGVjdG9yLCBjb250ZXh0ICk7XG5cdH07XG5cbmpRdWVyeS5mbiA9IGpRdWVyeS5wcm90b3R5cGUgPSB7XG5cblx0Ly8gVGhlIGN1cnJlbnQgdmVyc2lvbiBvZiBqUXVlcnkgYmVpbmcgdXNlZFxuXHRqcXVlcnk6IHZlcnNpb24sXG5cblx0Y29uc3RydWN0b3I6IGpRdWVyeSxcblxuXHQvLyBUaGUgZGVmYXVsdCBsZW5ndGggb2YgYSBqUXVlcnkgb2JqZWN0IGlzIDBcblx0bGVuZ3RoOiAwLFxuXG5cdHRvQXJyYXk6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBzbGljZS5jYWxsKCB0aGlzICk7XG5cdH0sXG5cblx0Ly8gR2V0IHRoZSBOdGggZWxlbWVudCBpbiB0aGUgbWF0Y2hlZCBlbGVtZW50IHNldCBPUlxuXHQvLyBHZXQgdGhlIHdob2xlIG1hdGNoZWQgZWxlbWVudCBzZXQgYXMgYSBjbGVhbiBhcnJheVxuXHRnZXQ6IGZ1bmN0aW9uKCBudW0gKSB7XG5cblx0XHQvLyBSZXR1cm4gYWxsIHRoZSBlbGVtZW50cyBpbiBhIGNsZWFuIGFycmF5XG5cdFx0aWYgKCBudW0gPT0gbnVsbCApIHtcblx0XHRcdHJldHVybiBzbGljZS5jYWxsKCB0aGlzICk7XG5cdFx0fVxuXG5cdFx0Ly8gUmV0dXJuIGp1c3QgdGhlIG9uZSBlbGVtZW50IGZyb20gdGhlIHNldFxuXHRcdHJldHVybiBudW0gPCAwID8gdGhpc1sgbnVtICsgdGhpcy5sZW5ndGggXSA6IHRoaXNbIG51bSBdO1xuXHR9LFxuXG5cdC8vIFRha2UgYW4gYXJyYXkgb2YgZWxlbWVudHMgYW5kIHB1c2ggaXQgb250byB0aGUgc3RhY2tcblx0Ly8gKHJldHVybmluZyB0aGUgbmV3IG1hdGNoZWQgZWxlbWVudCBzZXQpXG5cdHB1c2hTdGFjazogZnVuY3Rpb24oIGVsZW1zICkge1xuXG5cdFx0Ly8gQnVpbGQgYSBuZXcgalF1ZXJ5IG1hdGNoZWQgZWxlbWVudCBzZXRcblx0XHR2YXIgcmV0ID0galF1ZXJ5Lm1lcmdlKCB0aGlzLmNvbnN0cnVjdG9yKCksIGVsZW1zICk7XG5cblx0XHQvLyBBZGQgdGhlIG9sZCBvYmplY3Qgb250byB0aGUgc3RhY2sgKGFzIGEgcmVmZXJlbmNlKVxuXHRcdHJldC5wcmV2T2JqZWN0ID0gdGhpcztcblxuXHRcdC8vIFJldHVybiB0aGUgbmV3bHktZm9ybWVkIGVsZW1lbnQgc2V0XG5cdFx0cmV0dXJuIHJldDtcblx0fSxcblxuXHQvLyBFeGVjdXRlIGEgY2FsbGJhY2sgZm9yIGV2ZXJ5IGVsZW1lbnQgaW4gdGhlIG1hdGNoZWQgc2V0LlxuXHRlYWNoOiBmdW5jdGlvbiggY2FsbGJhY2sgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5lYWNoKCB0aGlzLCBjYWxsYmFjayApO1xuXHR9LFxuXG5cdG1hcDogZnVuY3Rpb24oIGNhbGxiYWNrICkge1xuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggalF1ZXJ5Lm1hcCggdGhpcywgZnVuY3Rpb24oIGVsZW0sIGkgKSB7XG5cdFx0XHRyZXR1cm4gY2FsbGJhY2suY2FsbCggZWxlbSwgaSwgZWxlbSApO1xuXHRcdH0gKSApO1xuXHR9LFxuXG5cdHNsaWNlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIHNsaWNlLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKSApO1xuXHR9LFxuXG5cdGZpcnN0OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5lcSggMCApO1xuXHR9LFxuXG5cdGxhc3Q6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmVxKCAtMSApO1xuXHR9LFxuXG5cdGV2ZW46IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggalF1ZXJ5LmdyZXAoIHRoaXMsIGZ1bmN0aW9uKCBfZWxlbSwgaSApIHtcblx0XHRcdHJldHVybiAoIGkgKyAxICkgJSAyO1xuXHRcdH0gKSApO1xuXHR9LFxuXG5cdG9kZDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBqUXVlcnkuZ3JlcCggdGhpcywgZnVuY3Rpb24oIF9lbGVtLCBpICkge1xuXHRcdFx0cmV0dXJuIGkgJSAyO1xuXHRcdH0gKSApO1xuXHR9LFxuXG5cdGVxOiBmdW5jdGlvbiggaSApIHtcblx0XHR2YXIgbGVuID0gdGhpcy5sZW5ndGgsXG5cdFx0XHRqID0gK2kgKyAoIGkgPCAwID8gbGVuIDogMCApO1xuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggaiA+PSAwICYmIGogPCBsZW4gPyBbIHRoaXNbIGogXSBdIDogW10gKTtcblx0fSxcblxuXHRlbmQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLnByZXZPYmplY3QgfHwgdGhpcy5jb25zdHJ1Y3RvcigpO1xuXHR9LFxuXG5cdC8vIEZvciBpbnRlcm5hbCB1c2Ugb25seS5cblx0Ly8gQmVoYXZlcyBsaWtlIGFuIEFycmF5J3MgbWV0aG9kLCBub3QgbGlrZSBhIGpRdWVyeSBtZXRob2QuXG5cdHB1c2g6IHB1c2gsXG5cdHNvcnQ6IGFyci5zb3J0LFxuXHRzcGxpY2U6IGFyci5zcGxpY2Vcbn07XG5cbmpRdWVyeS5leHRlbmQgPSBqUXVlcnkuZm4uZXh0ZW5kID0gZnVuY3Rpb24oKSB7XG5cdHZhciBvcHRpb25zLCBuYW1lLCBzcmMsIGNvcHksIGNvcHlJc0FycmF5LCBjbG9uZSxcblx0XHR0YXJnZXQgPSBhcmd1bWVudHNbIDAgXSB8fCB7fSxcblx0XHRpID0gMSxcblx0XHRsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoLFxuXHRcdGRlZXAgPSBmYWxzZTtcblxuXHQvLyBIYW5kbGUgYSBkZWVwIGNvcHkgc2l0dWF0aW9uXG5cdGlmICggdHlwZW9mIHRhcmdldCA9PT0gXCJib29sZWFuXCIgKSB7XG5cdFx0ZGVlcCA9IHRhcmdldDtcblxuXHRcdC8vIFNraXAgdGhlIGJvb2xlYW4gYW5kIHRoZSB0YXJnZXRcblx0XHR0YXJnZXQgPSBhcmd1bWVudHNbIGkgXSB8fCB7fTtcblx0XHRpKys7XG5cdH1cblxuXHQvLyBIYW5kbGUgY2FzZSB3aGVuIHRhcmdldCBpcyBhIHN0cmluZyBvciBzb21ldGhpbmcgKHBvc3NpYmxlIGluIGRlZXAgY29weSlcblx0aWYgKCB0eXBlb2YgdGFyZ2V0ICE9PSBcIm9iamVjdFwiICYmICFpc0Z1bmN0aW9uKCB0YXJnZXQgKSApIHtcblx0XHR0YXJnZXQgPSB7fTtcblx0fVxuXG5cdC8vIEV4dGVuZCBqUXVlcnkgaXRzZWxmIGlmIG9ubHkgb25lIGFyZ3VtZW50IGlzIHBhc3NlZFxuXHRpZiAoIGkgPT09IGxlbmd0aCApIHtcblx0XHR0YXJnZXQgPSB0aGlzO1xuXHRcdGktLTtcblx0fVxuXG5cdGZvciAoIDsgaSA8IGxlbmd0aDsgaSsrICkge1xuXG5cdFx0Ly8gT25seSBkZWFsIHdpdGggbm9uLW51bGwvdW5kZWZpbmVkIHZhbHVlc1xuXHRcdGlmICggKCBvcHRpb25zID0gYXJndW1lbnRzWyBpIF0gKSAhPSBudWxsICkge1xuXG5cdFx0XHQvLyBFeHRlbmQgdGhlIGJhc2Ugb2JqZWN0XG5cdFx0XHRmb3IgKCBuYW1lIGluIG9wdGlvbnMgKSB7XG5cdFx0XHRcdGNvcHkgPSBvcHRpb25zWyBuYW1lIF07XG5cblx0XHRcdFx0Ly8gUHJldmVudCBPYmplY3QucHJvdG90eXBlIHBvbGx1dGlvblxuXHRcdFx0XHQvLyBQcmV2ZW50IG5ldmVyLWVuZGluZyBsb29wXG5cdFx0XHRcdGlmICggbmFtZSA9PT0gXCJfX3Byb3RvX19cIiB8fCB0YXJnZXQgPT09IGNvcHkgKSB7XG5cdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBSZWN1cnNlIGlmIHdlJ3JlIG1lcmdpbmcgcGxhaW4gb2JqZWN0cyBvciBhcnJheXNcblx0XHRcdFx0aWYgKCBkZWVwICYmIGNvcHkgJiYgKCBqUXVlcnkuaXNQbGFpbk9iamVjdCggY29weSApIHx8XG5cdFx0XHRcdFx0KCBjb3B5SXNBcnJheSA9IEFycmF5LmlzQXJyYXkoIGNvcHkgKSApICkgKSB7XG5cdFx0XHRcdFx0c3JjID0gdGFyZ2V0WyBuYW1lIF07XG5cblx0XHRcdFx0XHQvLyBFbnN1cmUgcHJvcGVyIHR5cGUgZm9yIHRoZSBzb3VyY2UgdmFsdWVcblx0XHRcdFx0XHRpZiAoIGNvcHlJc0FycmF5ICYmICFBcnJheS5pc0FycmF5KCBzcmMgKSApIHtcblx0XHRcdFx0XHRcdGNsb25lID0gW107XG5cdFx0XHRcdFx0fSBlbHNlIGlmICggIWNvcHlJc0FycmF5ICYmICFqUXVlcnkuaXNQbGFpbk9iamVjdCggc3JjICkgKSB7XG5cdFx0XHRcdFx0XHRjbG9uZSA9IHt9O1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRjbG9uZSA9IHNyYztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Y29weUlzQXJyYXkgPSBmYWxzZTtcblxuXHRcdFx0XHRcdC8vIE5ldmVyIG1vdmUgb3JpZ2luYWwgb2JqZWN0cywgY2xvbmUgdGhlbVxuXHRcdFx0XHRcdHRhcmdldFsgbmFtZSBdID0galF1ZXJ5LmV4dGVuZCggZGVlcCwgY2xvbmUsIGNvcHkgKTtcblxuXHRcdFx0XHQvLyBEb24ndCBicmluZyBpbiB1bmRlZmluZWQgdmFsdWVzXG5cdFx0XHRcdH0gZWxzZSBpZiAoIGNvcHkgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHR0YXJnZXRbIG5hbWUgXSA9IGNvcHk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBSZXR1cm4gdGhlIG1vZGlmaWVkIG9iamVjdFxuXHRyZXR1cm4gdGFyZ2V0O1xufTtcblxualF1ZXJ5LmV4dGVuZCgge1xuXG5cdC8vIFVuaXF1ZSBmb3IgZWFjaCBjb3B5IG9mIGpRdWVyeSBvbiB0aGUgcGFnZVxuXHRleHBhbmRvOiBcImpRdWVyeVwiICsgKCB2ZXJzaW9uICsgTWF0aC5yYW5kb20oKSApLnJlcGxhY2UoIC9cXEQvZywgXCJcIiApLFxuXG5cdC8vIEFzc3VtZSBqUXVlcnkgaXMgcmVhZHkgd2l0aG91dCB0aGUgcmVhZHkgbW9kdWxlXG5cdGlzUmVhZHk6IHRydWUsXG5cblx0ZXJyb3I6IGZ1bmN0aW9uKCBtc2cgKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKCBtc2cgKTtcblx0fSxcblxuXHRub29wOiBmdW5jdGlvbigpIHt9LFxuXG5cdGlzUGxhaW5PYmplY3Q6IGZ1bmN0aW9uKCBvYmogKSB7XG5cdFx0dmFyIHByb3RvLCBDdG9yO1xuXG5cdFx0Ly8gRGV0ZWN0IG9idmlvdXMgbmVnYXRpdmVzXG5cdFx0Ly8gVXNlIHRvU3RyaW5nIGluc3RlYWQgb2YgalF1ZXJ5LnR5cGUgdG8gY2F0Y2ggaG9zdCBvYmplY3RzXG5cdFx0aWYgKCAhb2JqIHx8IHRvU3RyaW5nLmNhbGwoIG9iaiApICE9PSBcIltvYmplY3QgT2JqZWN0XVwiICkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdHByb3RvID0gZ2V0UHJvdG8oIG9iaiApO1xuXG5cdFx0Ly8gT2JqZWN0cyB3aXRoIG5vIHByb3RvdHlwZSAoZS5nLiwgYE9iamVjdC5jcmVhdGUoIG51bGwgKWApIGFyZSBwbGFpblxuXHRcdGlmICggIXByb3RvICkge1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXG5cdFx0Ly8gT2JqZWN0cyB3aXRoIHByb3RvdHlwZSBhcmUgcGxhaW4gaWZmIHRoZXkgd2VyZSBjb25zdHJ1Y3RlZCBieSBhIGdsb2JhbCBPYmplY3QgZnVuY3Rpb25cblx0XHRDdG9yID0gaGFzT3duLmNhbGwoIHByb3RvLCBcImNvbnN0cnVjdG9yXCIgKSAmJiBwcm90by5jb25zdHJ1Y3Rvcjtcblx0XHRyZXR1cm4gdHlwZW9mIEN0b3IgPT09IFwiZnVuY3Rpb25cIiAmJiBmblRvU3RyaW5nLmNhbGwoIEN0b3IgKSA9PT0gT2JqZWN0RnVuY3Rpb25TdHJpbmc7XG5cdH0sXG5cblx0aXNFbXB0eU9iamVjdDogZnVuY3Rpb24oIG9iaiApIHtcblx0XHR2YXIgbmFtZTtcblxuXHRcdGZvciAoIG5hbWUgaW4gb2JqICkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSxcblxuXHQvLyBFdmFsdWF0ZXMgYSBzY3JpcHQgaW4gYSBwcm92aWRlZCBjb250ZXh0OyBmYWxscyBiYWNrIHRvIHRoZSBnbG9iYWwgb25lXG5cdC8vIGlmIG5vdCBzcGVjaWZpZWQuXG5cdGdsb2JhbEV2YWw6IGZ1bmN0aW9uKCBjb2RlLCBvcHRpb25zLCBkb2MgKSB7XG5cdFx0RE9NRXZhbCggY29kZSwgeyBub25jZTogb3B0aW9ucyAmJiBvcHRpb25zLm5vbmNlIH0sIGRvYyApO1xuXHR9LFxuXG5cdGVhY2g6IGZ1bmN0aW9uKCBvYmosIGNhbGxiYWNrICkge1xuXHRcdHZhciBsZW5ndGgsIGkgPSAwO1xuXG5cdFx0aWYgKCBpc0FycmF5TGlrZSggb2JqICkgKSB7XG5cdFx0XHRsZW5ndGggPSBvYmoubGVuZ3RoO1xuXHRcdFx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpKysgKSB7XG5cdFx0XHRcdGlmICggY2FsbGJhY2suY2FsbCggb2JqWyBpIF0sIGksIG9ialsgaSBdICkgPT09IGZhbHNlICkge1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdGZvciAoIGkgaW4gb2JqICkge1xuXHRcdFx0XHRpZiAoIGNhbGxiYWNrLmNhbGwoIG9ialsgaSBdLCBpLCBvYmpbIGkgXSApID09PSBmYWxzZSApIHtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBvYmo7XG5cdH0sXG5cblxuXHQvLyBSZXRyaWV2ZSB0aGUgdGV4dCB2YWx1ZSBvZiBhbiBhcnJheSBvZiBET00gbm9kZXNcblx0dGV4dDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0dmFyIG5vZGUsXG5cdFx0XHRyZXQgPSBcIlwiLFxuXHRcdFx0aSA9IDAsXG5cdFx0XHRub2RlVHlwZSA9IGVsZW0ubm9kZVR5cGU7XG5cblx0XHRpZiAoICFub2RlVHlwZSApIHtcblxuXHRcdFx0Ly8gSWYgbm8gbm9kZVR5cGUsIHRoaXMgaXMgZXhwZWN0ZWQgdG8gYmUgYW4gYXJyYXlcblx0XHRcdHdoaWxlICggKCBub2RlID0gZWxlbVsgaSsrIF0gKSApIHtcblxuXHRcdFx0XHQvLyBEbyBub3QgdHJhdmVyc2UgY29tbWVudCBub2Rlc1xuXHRcdFx0XHRyZXQgKz0galF1ZXJ5LnRleHQoIG5vZGUgKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKCBub2RlVHlwZSA9PT0gMSB8fCBub2RlVHlwZSA9PT0gMTEgKSB7XG5cdFx0XHRyZXR1cm4gZWxlbS50ZXh0Q29udGVudDtcblx0XHR9XG5cdFx0aWYgKCBub2RlVHlwZSA9PT0gOSApIHtcblx0XHRcdHJldHVybiBlbGVtLmRvY3VtZW50RWxlbWVudC50ZXh0Q29udGVudDtcblx0XHR9XG5cdFx0aWYgKCBub2RlVHlwZSA9PT0gMyB8fCBub2RlVHlwZSA9PT0gNCApIHtcblx0XHRcdHJldHVybiBlbGVtLm5vZGVWYWx1ZTtcblx0XHR9XG5cblx0XHQvLyBEbyBub3QgaW5jbHVkZSBjb21tZW50IG9yIHByb2Nlc3NpbmcgaW5zdHJ1Y3Rpb24gbm9kZXNcblxuXHRcdHJldHVybiByZXQ7XG5cdH0sXG5cblx0Ly8gcmVzdWx0cyBpcyBmb3IgaW50ZXJuYWwgdXNhZ2Ugb25seVxuXHRtYWtlQXJyYXk6IGZ1bmN0aW9uKCBhcnIsIHJlc3VsdHMgKSB7XG5cdFx0dmFyIHJldCA9IHJlc3VsdHMgfHwgW107XG5cblx0XHRpZiAoIGFyciAhPSBudWxsICkge1xuXHRcdFx0aWYgKCBpc0FycmF5TGlrZSggT2JqZWN0KCBhcnIgKSApICkge1xuXHRcdFx0XHRqUXVlcnkubWVyZ2UoIHJldCxcblx0XHRcdFx0XHR0eXBlb2YgYXJyID09PSBcInN0cmluZ1wiID9cblx0XHRcdFx0XHRcdFsgYXJyIF0gOiBhcnJcblx0XHRcdFx0KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHB1c2guY2FsbCggcmV0LCBhcnIgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gcmV0O1xuXHR9LFxuXG5cdGluQXJyYXk6IGZ1bmN0aW9uKCBlbGVtLCBhcnIsIGkgKSB7XG5cdFx0cmV0dXJuIGFyciA9PSBudWxsID8gLTEgOiBpbmRleE9mLmNhbGwoIGFyciwgZWxlbSwgaSApO1xuXHR9LFxuXG5cdGlzWE1MRG9jOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHR2YXIgbmFtZXNwYWNlID0gZWxlbSAmJiBlbGVtLm5hbWVzcGFjZVVSSSxcblx0XHRcdGRvY0VsZW0gPSBlbGVtICYmICggZWxlbS5vd25lckRvY3VtZW50IHx8IGVsZW0gKS5kb2N1bWVudEVsZW1lbnQ7XG5cblx0XHQvLyBBc3N1bWUgSFRNTCB3aGVuIGRvY3VtZW50RWxlbWVudCBkb2Vzbid0IHlldCBleGlzdCwgc3VjaCBhcyBpbnNpZGVcblx0XHQvLyBkb2N1bWVudCBmcmFnbWVudHMuXG5cdFx0cmV0dXJuICFyaHRtbFN1ZmZpeC50ZXN0KCBuYW1lc3BhY2UgfHwgZG9jRWxlbSAmJiBkb2NFbGVtLm5vZGVOYW1lIHx8IFwiSFRNTFwiICk7XG5cdH0sXG5cblx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMCBvbmx5LCBQaGFudG9tSlMgMSBvbmx5XG5cdC8vIHB1c2guYXBwbHkoXywgYXJyYXlsaWtlKSB0aHJvd3Mgb24gYW5jaWVudCBXZWJLaXRcblx0bWVyZ2U6IGZ1bmN0aW9uKCBmaXJzdCwgc2Vjb25kICkge1xuXHRcdHZhciBsZW4gPSArc2Vjb25kLmxlbmd0aCxcblx0XHRcdGogPSAwLFxuXHRcdFx0aSA9IGZpcnN0Lmxlbmd0aDtcblxuXHRcdGZvciAoIDsgaiA8IGxlbjsgaisrICkge1xuXHRcdFx0Zmlyc3RbIGkrKyBdID0gc2Vjb25kWyBqIF07XG5cdFx0fVxuXG5cdFx0Zmlyc3QubGVuZ3RoID0gaTtcblxuXHRcdHJldHVybiBmaXJzdDtcblx0fSxcblxuXHRncmVwOiBmdW5jdGlvbiggZWxlbXMsIGNhbGxiYWNrLCBpbnZlcnQgKSB7XG5cdFx0dmFyIGNhbGxiYWNrSW52ZXJzZSxcblx0XHRcdG1hdGNoZXMgPSBbXSxcblx0XHRcdGkgPSAwLFxuXHRcdFx0bGVuZ3RoID0gZWxlbXMubGVuZ3RoLFxuXHRcdFx0Y2FsbGJhY2tFeHBlY3QgPSAhaW52ZXJ0O1xuXG5cdFx0Ly8gR28gdGhyb3VnaCB0aGUgYXJyYXksIG9ubHkgc2F2aW5nIHRoZSBpdGVtc1xuXHRcdC8vIHRoYXQgcGFzcyB0aGUgdmFsaWRhdG9yIGZ1bmN0aW9uXG5cdFx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpKysgKSB7XG5cdFx0XHRjYWxsYmFja0ludmVyc2UgPSAhY2FsbGJhY2soIGVsZW1zWyBpIF0sIGkgKTtcblx0XHRcdGlmICggY2FsbGJhY2tJbnZlcnNlICE9PSBjYWxsYmFja0V4cGVjdCApIHtcblx0XHRcdFx0bWF0Y2hlcy5wdXNoKCBlbGVtc1sgaSBdICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG1hdGNoZXM7XG5cdH0sXG5cblx0Ly8gYXJnIGlzIGZvciBpbnRlcm5hbCB1c2FnZSBvbmx5XG5cdG1hcDogZnVuY3Rpb24oIGVsZW1zLCBjYWxsYmFjaywgYXJnICkge1xuXHRcdHZhciBsZW5ndGgsIHZhbHVlLFxuXHRcdFx0aSA9IDAsXG5cdFx0XHRyZXQgPSBbXTtcblxuXHRcdC8vIEdvIHRocm91Z2ggdGhlIGFycmF5LCB0cmFuc2xhdGluZyBlYWNoIG9mIHRoZSBpdGVtcyB0byB0aGVpciBuZXcgdmFsdWVzXG5cdFx0aWYgKCBpc0FycmF5TGlrZSggZWxlbXMgKSApIHtcblx0XHRcdGxlbmd0aCA9IGVsZW1zLmxlbmd0aDtcblx0XHRcdGZvciAoIDsgaSA8IGxlbmd0aDsgaSsrICkge1xuXHRcdFx0XHR2YWx1ZSA9IGNhbGxiYWNrKCBlbGVtc1sgaSBdLCBpLCBhcmcgKTtcblxuXHRcdFx0XHRpZiAoIHZhbHVlICE9IG51bGwgKSB7XG5cdFx0XHRcdFx0cmV0LnB1c2goIHZhbHVlICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdC8vIEdvIHRocm91Z2ggZXZlcnkga2V5IG9uIHRoZSBvYmplY3QsXG5cdFx0fSBlbHNlIHtcblx0XHRcdGZvciAoIGkgaW4gZWxlbXMgKSB7XG5cdFx0XHRcdHZhbHVlID0gY2FsbGJhY2soIGVsZW1zWyBpIF0sIGksIGFyZyApO1xuXG5cdFx0XHRcdGlmICggdmFsdWUgIT0gbnVsbCApIHtcblx0XHRcdFx0XHRyZXQucHVzaCggdmFsdWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIEZsYXR0ZW4gYW55IG5lc3RlZCBhcnJheXNcblx0XHRyZXR1cm4gZmxhdCggcmV0ICk7XG5cdH0sXG5cblx0Ly8gQSBnbG9iYWwgR1VJRCBjb3VudGVyIGZvciBvYmplY3RzXG5cdGd1aWQ6IDEsXG5cblx0Ly8galF1ZXJ5LnN1cHBvcnQgaXMgbm90IHVzZWQgaW4gQ29yZSBidXQgb3RoZXIgcHJvamVjdHMgYXR0YWNoIHRoZWlyXG5cdC8vIHByb3BlcnRpZXMgdG8gaXQgc28gaXQgbmVlZHMgdG8gZXhpc3QuXG5cdHN1cHBvcnQ6IHN1cHBvcnRcbn0gKTtcblxuaWYgKCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgKSB7XG5cdGpRdWVyeS5mblsgU3ltYm9sLml0ZXJhdG9yIF0gPSBhcnJbIFN5bWJvbC5pdGVyYXRvciBdO1xufVxuXG4vLyBQb3B1bGF0ZSB0aGUgY2xhc3MydHlwZSBtYXBcbmpRdWVyeS5lYWNoKCBcIkJvb2xlYW4gTnVtYmVyIFN0cmluZyBGdW5jdGlvbiBBcnJheSBEYXRlIFJlZ0V4cCBPYmplY3QgRXJyb3IgU3ltYm9sXCIuc3BsaXQoIFwiIFwiICksXG5cdGZ1bmN0aW9uKCBfaSwgbmFtZSApIHtcblx0XHRjbGFzczJ0eXBlWyBcIltvYmplY3QgXCIgKyBuYW1lICsgXCJdXCIgXSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcblx0fSApO1xuXG5mdW5jdGlvbiBpc0FycmF5TGlrZSggb2JqICkge1xuXG5cdC8vIFN1cHBvcnQ6IHJlYWwgaU9TIDguMiBvbmx5IChub3QgcmVwcm9kdWNpYmxlIGluIHNpbXVsYXRvcilcblx0Ly8gYGluYCBjaGVjayB1c2VkIHRvIHByZXZlbnQgSklUIGVycm9yIChnaC0yMTQ1KVxuXHQvLyBoYXNPd24gaXNuJ3QgdXNlZCBoZXJlIGR1ZSB0byBmYWxzZSBuZWdhdGl2ZXNcblx0Ly8gcmVnYXJkaW5nIE5vZGVsaXN0IGxlbmd0aCBpbiBJRVxuXHR2YXIgbGVuZ3RoID0gISFvYmogJiYgXCJsZW5ndGhcIiBpbiBvYmogJiYgb2JqLmxlbmd0aCxcblx0XHR0eXBlID0gdG9UeXBlKCBvYmogKTtcblxuXHRpZiAoIGlzRnVuY3Rpb24oIG9iaiApIHx8IGlzV2luZG93KCBvYmogKSApIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXHRyZXR1cm4gdHlwZSA9PT0gXCJhcnJheVwiIHx8IGxlbmd0aCA9PT0gMCB8fFxuXHRcdHR5cGVvZiBsZW5ndGggPT09IFwibnVtYmVyXCIgJiYgbGVuZ3RoID4gMCAmJiAoIGxlbmd0aCAtIDEgKSBpbiBvYmo7XG59XG5cblxuZnVuY3Rpb24gbm9kZU5hbWUoIGVsZW0sIG5hbWUgKSB7XG5cblx0cmV0dXJuIGVsZW0ubm9kZU5hbWUgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBuYW1lLnRvTG93ZXJDYXNlKCk7XG5cbn1cbnZhciBwb3AgPSBhcnIucG9wO1xuXG5cbnZhciBzb3J0ID0gYXJyLnNvcnQ7XG5cblxudmFyIHNwbGljZSA9IGFyci5zcGxpY2U7XG5cblxudmFyIHdoaXRlc3BhY2UgPSBcIltcXFxceDIwXFxcXHRcXFxcclxcXFxuXFxcXGZdXCI7XG5cblxudmFyIHJ0cmltQ1NTID0gbmV3IFJlZ0V4cChcblx0XCJeXCIgKyB3aGl0ZXNwYWNlICsgXCIrfCgoPzpefFteXFxcXFxcXFxdKSg/OlxcXFxcXFxcLikqKVwiICsgd2hpdGVzcGFjZSArIFwiKyRcIixcblx0XCJnXCJcbik7XG5cblxuXG5cbi8vIE5vdGU6IGFuIGVsZW1lbnQgZG9lcyBub3QgY29udGFpbiBpdHNlbGZcbmpRdWVyeS5jb250YWlucyA9IGZ1bmN0aW9uKCBhLCBiICkge1xuXHR2YXIgYnVwID0gYiAmJiBiLnBhcmVudE5vZGU7XG5cblx0cmV0dXJuIGEgPT09IGJ1cCB8fCAhISggYnVwICYmIGJ1cC5ub2RlVHlwZSA9PT0gMSAmJiAoXG5cblx0XHQvLyBTdXBwb3J0OiBJRSA5IC0gMTErXG5cdFx0Ly8gSUUgZG9lc24ndCBoYXZlIGBjb250YWluc2Agb24gU1ZHLlxuXHRcdGEuY29udGFpbnMgP1xuXHRcdFx0YS5jb250YWlucyggYnVwICkgOlxuXHRcdFx0YS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiAmJiBhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKCBidXAgKSAmIDE2XG5cdCkgKTtcbn07XG5cblxuXG5cbi8vIENTUyBzdHJpbmcvaWRlbnRpZmllciBzZXJpYWxpemF0aW9uXG4vLyBodHRwczovL2RyYWZ0cy5jc3N3Zy5vcmcvY3Nzb20vI2NvbW1vbi1zZXJpYWxpemluZy1pZGlvbXNcbnZhciByY3NzZXNjYXBlID0gLyhbXFwwLVxceDFmXFx4N2ZdfF4tP1xcZCl8Xi0kfFteXFx4ODAtXFx1RkZGRlxcdy1dL2c7XG5cbmZ1bmN0aW9uIGZjc3Nlc2NhcGUoIGNoLCBhc0NvZGVQb2ludCApIHtcblx0aWYgKCBhc0NvZGVQb2ludCApIHtcblxuXHRcdC8vIFUrMDAwMCBOVUxMIGJlY29tZXMgVStGRkZEIFJFUExBQ0VNRU5UIENIQVJBQ1RFUlxuXHRcdGlmICggY2ggPT09IFwiXFwwXCIgKSB7XG5cdFx0XHRyZXR1cm4gXCJcXHVGRkZEXCI7XG5cdFx0fVxuXG5cdFx0Ly8gQ29udHJvbCBjaGFyYWN0ZXJzIGFuZCAoZGVwZW5kZW50IHVwb24gcG9zaXRpb24pIG51bWJlcnMgZ2V0IGVzY2FwZWQgYXMgY29kZSBwb2ludHNcblx0XHRyZXR1cm4gY2guc2xpY2UoIDAsIC0xICkgKyBcIlxcXFxcIiArIGNoLmNoYXJDb2RlQXQoIGNoLmxlbmd0aCAtIDEgKS50b1N0cmluZyggMTYgKSArIFwiIFwiO1xuXHR9XG5cblx0Ly8gT3RoZXIgcG90ZW50aWFsbHktc3BlY2lhbCBBU0NJSSBjaGFyYWN0ZXJzIGdldCBiYWNrc2xhc2gtZXNjYXBlZFxuXHRyZXR1cm4gXCJcXFxcXCIgKyBjaDtcbn1cblxualF1ZXJ5LmVzY2FwZVNlbGVjdG9yID0gZnVuY3Rpb24oIHNlbCApIHtcblx0cmV0dXJuICggc2VsICsgXCJcIiApLnJlcGxhY2UoIHJjc3Nlc2NhcGUsIGZjc3Nlc2NhcGUgKTtcbn07XG5cblxuXG5cbnZhciBwcmVmZXJyZWREb2MgPSBkb2N1bWVudCxcblx0cHVzaE5hdGl2ZSA9IHB1c2g7XG5cbiggZnVuY3Rpb24oKSB7XG5cbnZhciBpLFxuXHRFeHByLFxuXHRvdXRlcm1vc3RDb250ZXh0LFxuXHRzb3J0SW5wdXQsXG5cdGhhc0R1cGxpY2F0ZSxcblx0cHVzaCA9IHB1c2hOYXRpdmUsXG5cblx0Ly8gTG9jYWwgZG9jdW1lbnQgdmFyc1xuXHRkb2N1bWVudCxcblx0ZG9jdW1lbnRFbGVtZW50LFxuXHRkb2N1bWVudElzSFRNTCxcblx0cmJ1Z2d5UVNBLFxuXHRtYXRjaGVzLFxuXG5cdC8vIEluc3RhbmNlLXNwZWNpZmljIGRhdGFcblx0ZXhwYW5kbyA9IGpRdWVyeS5leHBhbmRvLFxuXHRkaXJydW5zID0gMCxcblx0ZG9uZSA9IDAsXG5cdGNsYXNzQ2FjaGUgPSBjcmVhdGVDYWNoZSgpLFxuXHR0b2tlbkNhY2hlID0gY3JlYXRlQ2FjaGUoKSxcblx0Y29tcGlsZXJDYWNoZSA9IGNyZWF0ZUNhY2hlKCksXG5cdG5vbm5hdGl2ZVNlbGVjdG9yQ2FjaGUgPSBjcmVhdGVDYWNoZSgpLFxuXHRzb3J0T3JkZXIgPSBmdW5jdGlvbiggYSwgYiApIHtcblx0XHRpZiAoIGEgPT09IGIgKSB7XG5cdFx0XHRoYXNEdXBsaWNhdGUgPSB0cnVlO1xuXHRcdH1cblx0XHRyZXR1cm4gMDtcblx0fSxcblxuXHRib29sZWFucyA9IFwiY2hlY2tlZHxzZWxlY3RlZHxhc3luY3xhdXRvZm9jdXN8YXV0b3BsYXl8Y29udHJvbHN8ZGVmZXJ8ZGlzYWJsZWR8aGlkZGVufGlzbWFwfFwiICtcblx0XHRcImxvb3B8bXVsdGlwbGV8b3BlbnxyZWFkb25seXxyZXF1aXJlZHxzY29wZWRcIixcblxuXHQvLyBSZWd1bGFyIGV4cHJlc3Npb25zXG5cblx0Ly8gaHR0cHM6Ly93d3cudzMub3JnL1RSL2Nzcy1zeW50YXgtMy8jaWRlbnQtdG9rZW4tZGlhZ3JhbVxuXHRpZGVudGlmaWVyID0gXCIoPzpcXFxcXFxcXFtcXFxcZGEtZkEtRl17MSw2fVwiICsgd2hpdGVzcGFjZSArXG5cdFx0XCI/fFxcXFxcXFxcW15cXFxcclxcXFxuXFxcXGZdfFtcXFxcdy1dfFteXFwwLVxcXFx4N2ZdKStcIixcblxuXHQvLyBBdHRyaWJ1dGUgc2VsZWN0b3JzOiBodHRwczovL3d3dy53My5vcmcvVFIvc2VsZWN0b3JzLyNhdHRyaWJ1dGUtc2VsZWN0b3JzXG5cdGF0dHJpYnV0ZXMgPSBcIlxcXFxbXCIgKyB3aGl0ZXNwYWNlICsgXCIqKFwiICsgaWRlbnRpZmllciArIFwiKSg/OlwiICsgd2hpdGVzcGFjZSArXG5cblx0XHQvLyBPcGVyYXRvciAoY2FwdHVyZSAyKVxuXHRcdFwiKihbKl4kfCF+XT89KVwiICsgd2hpdGVzcGFjZSArXG5cblx0XHQvLyBcIkF0dHJpYnV0ZSB2YWx1ZXMgbXVzdCBiZSBDU1MgaWRlbnRpZmllcnMgW2NhcHR1cmUgNV0gb3Igc3RyaW5ncyBbY2FwdHVyZSAzIG9yIGNhcHR1cmUgNF1cIlxuXHRcdFwiKig/OicoKD86XFxcXFxcXFwufFteXFxcXFxcXFwnXSkqKSd8XFxcIigoPzpcXFxcXFxcXC58W15cXFxcXFxcXFxcXCJdKSopXFxcInwoXCIgKyBpZGVudGlmaWVyICsgXCIpKXwpXCIgK1xuXHRcdHdoaXRlc3BhY2UgKyBcIipcXFxcXVwiLFxuXG5cdHBzZXVkb3MgPSBcIjooXCIgKyBpZGVudGlmaWVyICsgXCIpKD86XFxcXCgoXCIgK1xuXG5cdFx0Ly8gVG8gcmVkdWNlIHRoZSBudW1iZXIgb2Ygc2VsZWN0b3JzIG5lZWRpbmcgdG9rZW5pemUgaW4gdGhlIHByZUZpbHRlciwgcHJlZmVyIGFyZ3VtZW50czpcblx0XHQvLyAxLiBxdW90ZWQgKGNhcHR1cmUgMzsgY2FwdHVyZSA0IG9yIGNhcHR1cmUgNSlcblx0XHRcIignKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcJ10pKiknfFxcXCIoKD86XFxcXFxcXFwufFteXFxcXFxcXFxcXFwiXSkqKVxcXCIpfFwiICtcblxuXHRcdC8vIDIuIHNpbXBsZSAoY2FwdHVyZSA2KVxuXHRcdFwiKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcKClbXFxcXF1dfFwiICsgYXR0cmlidXRlcyArIFwiKSopfFwiICtcblxuXHRcdC8vIDMuIGFueXRoaW5nIGVsc2UgKGNhcHR1cmUgMilcblx0XHRcIi4qXCIgK1xuXHRcdFwiKVxcXFwpfClcIixcblxuXHQvLyBMZWFkaW5nIGFuZCBub24tZXNjYXBlZCB0cmFpbGluZyB3aGl0ZXNwYWNlLCBjYXB0dXJpbmcgc29tZSBub24td2hpdGVzcGFjZSBjaGFyYWN0ZXJzIHByZWNlZGluZyB0aGUgbGF0dGVyXG5cdHJ3aGl0ZXNwYWNlID0gbmV3IFJlZ0V4cCggd2hpdGVzcGFjZSArIFwiK1wiLCBcImdcIiApLFxuXG5cdHJjb21tYSA9IG5ldyBSZWdFeHAoIFwiXlwiICsgd2hpdGVzcGFjZSArIFwiKixcIiArIHdoaXRlc3BhY2UgKyBcIipcIiApLFxuXHRybGVhZGluZ0NvbWJpbmF0b3IgPSBuZXcgUmVnRXhwKCBcIl5cIiArIHdoaXRlc3BhY2UgKyBcIiooWz4rfl18XCIgKyB3aGl0ZXNwYWNlICsgXCIpXCIgK1xuXHRcdHdoaXRlc3BhY2UgKyBcIipcIiApLFxuXHRyZGVzY2VuZCA9IG5ldyBSZWdFeHAoIHdoaXRlc3BhY2UgKyBcInw+XCIgKSxcblxuXHRycHNldWRvID0gbmV3IFJlZ0V4cCggcHNldWRvcyApLFxuXHRyaWRlbnRpZmllciA9IG5ldyBSZWdFeHAoIFwiXlwiICsgaWRlbnRpZmllciArIFwiJFwiICksXG5cblx0bWF0Y2hFeHByID0ge1xuXHRcdElEOiBuZXcgUmVnRXhwKCBcIl4jKFwiICsgaWRlbnRpZmllciArIFwiKVwiICksXG5cdFx0Q0xBU1M6IG5ldyBSZWdFeHAoIFwiXlxcXFwuKFwiICsgaWRlbnRpZmllciArIFwiKVwiICksXG5cdFx0VEFHOiBuZXcgUmVnRXhwKCBcIl4oXCIgKyBpZGVudGlmaWVyICsgXCJ8WypdKVwiICksXG5cdFx0QVRUUjogbmV3IFJlZ0V4cCggXCJeXCIgKyBhdHRyaWJ1dGVzICksXG5cdFx0UFNFVURPOiBuZXcgUmVnRXhwKCBcIl5cIiArIHBzZXVkb3MgKSxcblx0XHRDSElMRDogbmV3IFJlZ0V4cChcblx0XHRcdFwiXjoob25seXxmaXJzdHxsYXN0fG50aHxudGgtbGFzdCktKGNoaWxkfG9mLXR5cGUpKD86XFxcXChcIiArXG5cdFx0XHRcdHdoaXRlc3BhY2UgKyBcIiooZXZlbnxvZGR8KChbKy1dfCkoXFxcXGQqKW58KVwiICsgd2hpdGVzcGFjZSArIFwiKig/OihbKy1dfClcIiArXG5cdFx0XHRcdHdoaXRlc3BhY2UgKyBcIiooXFxcXGQrKXwpKVwiICsgd2hpdGVzcGFjZSArIFwiKlxcXFwpfClcIiwgXCJpXCIgKSxcblx0XHRib29sOiBuZXcgUmVnRXhwKCBcIl4oPzpcIiArIGJvb2xlYW5zICsgXCIpJFwiLCBcImlcIiApLFxuXG5cdFx0Ly8gRm9yIHVzZSBpbiBsaWJyYXJpZXMgaW1wbGVtZW50aW5nIC5pcygpXG5cdFx0Ly8gV2UgdXNlIHRoaXMgZm9yIFBPUyBtYXRjaGluZyBpbiBgc2VsZWN0YFxuXHRcdG5lZWRzQ29udGV4dDogbmV3IFJlZ0V4cCggXCJeXCIgKyB3aGl0ZXNwYWNlICtcblx0XHRcdFwiKls+K35dfDooZXZlbnxvZGR8ZXF8Z3R8bHR8bnRofGZpcnN0fGxhc3QpKD86XFxcXChcIiArIHdoaXRlc3BhY2UgK1xuXHRcdFx0XCIqKCg/Oi1cXFxcZCk/XFxcXGQqKVwiICsgd2hpdGVzcGFjZSArIFwiKlxcXFwpfCkoPz1bXi1dfCQpXCIsIFwiaVwiIClcblx0fSxcblxuXHRyaW5wdXRzID0gL14oPzppbnB1dHxzZWxlY3R8dGV4dGFyZWF8YnV0dG9uKSQvaSxcblx0cmhlYWRlciA9IC9eaFxcZCQvaSxcblxuXHQvLyBFYXNpbHktcGFyc2VhYmxlL3JldHJpZXZhYmxlIElEIG9yIFRBRyBvciBDTEFTUyBzZWxlY3RvcnNcblx0cnF1aWNrRXhwciA9IC9eKD86IyhbXFx3LV0rKXwoXFx3Kyl8XFwuKFtcXHctXSspKSQvLFxuXG5cdHJzaWJsaW5nID0gL1srfl0vLFxuXG5cdC8vIENTUyBlc2NhcGVzXG5cdC8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9DU1MyMS9zeW5kYXRhLmh0bWwjZXNjYXBlZC1jaGFyYWN0ZXJzXG5cdHJ1bmVzY2FwZSA9IG5ldyBSZWdFeHAoIFwiXFxcXFxcXFxbXFxcXGRhLWZBLUZdezEsNn1cIiArIHdoaXRlc3BhY2UgK1xuXHRcdFwiP3xcXFxcXFxcXChbXlxcXFxyXFxcXG5cXFxcZl0pXCIsIFwiZ1wiICksXG5cdGZ1bmVzY2FwZSA9IGZ1bmN0aW9uKCBlc2NhcGUsIG5vbkhleCApIHtcblx0XHR2YXIgaGlnaCA9IFwiMHhcIiArIGVzY2FwZS5zbGljZSggMSApIC0gMHgxMDAwMDtcblxuXHRcdGlmICggbm9uSGV4ICkge1xuXG5cdFx0XHQvLyBTdHJpcCB0aGUgYmFja3NsYXNoIHByZWZpeCBmcm9tIGEgbm9uLWhleCBlc2NhcGUgc2VxdWVuY2Vcblx0XHRcdHJldHVybiBub25IZXg7XG5cdFx0fVxuXG5cdFx0Ly8gUmVwbGFjZSBhIGhleGFkZWNpbWFsIGVzY2FwZSBzZXF1ZW5jZSB3aXRoIHRoZSBlbmNvZGVkIFVuaWNvZGUgY29kZSBwb2ludFxuXHRcdC8vIFN1cHBvcnQ6IElFIDw9MTErXG5cdFx0Ly8gRm9yIHZhbHVlcyBvdXRzaWRlIHRoZSBCYXNpYyBNdWx0aWxpbmd1YWwgUGxhbmUgKEJNUCksIG1hbnVhbGx5IGNvbnN0cnVjdCBhXG5cdFx0Ly8gc3Vycm9nYXRlIHBhaXJcblx0XHRyZXR1cm4gaGlnaCA8IDAgP1xuXHRcdFx0U3RyaW5nLmZyb21DaGFyQ29kZSggaGlnaCArIDB4MTAwMDAgKSA6XG5cdFx0XHRTdHJpbmcuZnJvbUNoYXJDb2RlKCBoaWdoID4+IDEwIHwgMHhEODAwLCBoaWdoICYgMHgzRkYgfCAweERDMDAgKTtcblx0fSxcblxuXHQvLyBVc2VkIGZvciBpZnJhbWVzOyBzZWUgYHNldERvY3VtZW50YC5cblx0Ly8gU3VwcG9ydDogSUUgOSAtIDExKywgRWRnZSAxMiAtIDE4K1xuXHQvLyBSZW1vdmluZyB0aGUgZnVuY3Rpb24gd3JhcHBlciBjYXVzZXMgYSBcIlBlcm1pc3Npb24gRGVuaWVkXCJcblx0Ly8gZXJyb3IgaW4gSUUvRWRnZS5cblx0dW5sb2FkSGFuZGxlciA9IGZ1bmN0aW9uKCkge1xuXHRcdHNldERvY3VtZW50KCk7XG5cdH0sXG5cblx0aW5EaXNhYmxlZEZpZWxkc2V0ID0gYWRkQ29tYmluYXRvcihcblx0XHRmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBlbGVtLmRpc2FibGVkID09PSB0cnVlICYmIG5vZGVOYW1lKCBlbGVtLCBcImZpZWxkc2V0XCIgKTtcblx0XHR9LFxuXHRcdHsgZGlyOiBcInBhcmVudE5vZGVcIiwgbmV4dDogXCJsZWdlbmRcIiB9XG5cdCk7XG5cbi8vIFN1cHBvcnQ6IElFIDw9OSBvbmx5XG4vLyBBY2Nlc3NpbmcgZG9jdW1lbnQuYWN0aXZlRWxlbWVudCBjYW4gdGhyb3cgdW5leHBlY3RlZGx5XG4vLyBodHRwczovL2J1Z3MuanF1ZXJ5LmNvbS90aWNrZXQvMTMzOTNcbmZ1bmN0aW9uIHNhZmVBY3RpdmVFbGVtZW50KCkge1xuXHR0cnkge1xuXHRcdHJldHVybiBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuXHR9IGNhdGNoICggZXJyICkgeyB9XG59XG5cbi8vIE9wdGltaXplIGZvciBwdXNoLmFwcGx5KCBfLCBOb2RlTGlzdCApXG50cnkge1xuXHRwdXNoLmFwcGx5KFxuXHRcdCggYXJyID0gc2xpY2UuY2FsbCggcHJlZmVycmVkRG9jLmNoaWxkTm9kZXMgKSApLFxuXHRcdHByZWZlcnJlZERvYy5jaGlsZE5vZGVzXG5cdCk7XG5cblx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMFxuXHQvLyBEZXRlY3Qgc2lsZW50bHkgZmFpbGluZyBwdXNoLmFwcGx5XG5cdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtZXhwcmVzc2lvbnNcblx0YXJyWyBwcmVmZXJyZWREb2MuY2hpbGROb2Rlcy5sZW5ndGggXS5ub2RlVHlwZTtcbn0gY2F0Y2ggKCBlICkge1xuXHRwdXNoID0ge1xuXHRcdGFwcGx5OiBmdW5jdGlvbiggdGFyZ2V0LCBlbHMgKSB7XG5cdFx0XHRwdXNoTmF0aXZlLmFwcGx5KCB0YXJnZXQsIHNsaWNlLmNhbGwoIGVscyApICk7XG5cdFx0fSxcblx0XHRjYWxsOiBmdW5jdGlvbiggdGFyZ2V0ICkge1xuXHRcdFx0cHVzaE5hdGl2ZS5hcHBseSggdGFyZ2V0LCBzbGljZS5jYWxsKCBhcmd1bWVudHMsIDEgKSApO1xuXHRcdH1cblx0fTtcbn1cblxuZnVuY3Rpb24gZmluZCggc2VsZWN0b3IsIGNvbnRleHQsIHJlc3VsdHMsIHNlZWQgKSB7XG5cdHZhciBtLCBpLCBlbGVtLCBuaWQsIG1hdGNoLCBncm91cHMsIG5ld1NlbGVjdG9yLFxuXHRcdG5ld0NvbnRleHQgPSBjb250ZXh0ICYmIGNvbnRleHQub3duZXJEb2N1bWVudCxcblxuXHRcdC8vIG5vZGVUeXBlIGRlZmF1bHRzIHRvIDksIHNpbmNlIGNvbnRleHQgZGVmYXVsdHMgdG8gZG9jdW1lbnRcblx0XHRub2RlVHlwZSA9IGNvbnRleHQgPyBjb250ZXh0Lm5vZGVUeXBlIDogOTtcblxuXHRyZXN1bHRzID0gcmVzdWx0cyB8fCBbXTtcblxuXHQvLyBSZXR1cm4gZWFybHkgZnJvbSBjYWxscyB3aXRoIGludmFsaWQgc2VsZWN0b3Igb3IgY29udGV4dFxuXHRpZiAoIHR5cGVvZiBzZWxlY3RvciAhPT0gXCJzdHJpbmdcIiB8fCAhc2VsZWN0b3IgfHxcblx0XHRub2RlVHlwZSAhPT0gMSAmJiBub2RlVHlwZSAhPT0gOSAmJiBub2RlVHlwZSAhPT0gMTEgKSB7XG5cblx0XHRyZXR1cm4gcmVzdWx0cztcblx0fVxuXG5cdC8vIFRyeSB0byBzaG9ydGN1dCBmaW5kIG9wZXJhdGlvbnMgKGFzIG9wcG9zZWQgdG8gZmlsdGVycykgaW4gSFRNTCBkb2N1bWVudHNcblx0aWYgKCAhc2VlZCApIHtcblx0XHRzZXREb2N1bWVudCggY29udGV4dCApO1xuXHRcdGNvbnRleHQgPSBjb250ZXh0IHx8IGRvY3VtZW50O1xuXG5cdFx0aWYgKCBkb2N1bWVudElzSFRNTCApIHtcblxuXHRcdFx0Ly8gSWYgdGhlIHNlbGVjdG9yIGlzIHN1ZmZpY2llbnRseSBzaW1wbGUsIHRyeSB1c2luZyBhIFwiZ2V0KkJ5KlwiIERPTSBtZXRob2Rcblx0XHRcdC8vIChleGNlcHRpbmcgRG9jdW1lbnRGcmFnbWVudCBjb250ZXh0LCB3aGVyZSB0aGUgbWV0aG9kcyBkb24ndCBleGlzdClcblx0XHRcdGlmICggbm9kZVR5cGUgIT09IDExICYmICggbWF0Y2ggPSBycXVpY2tFeHByLmV4ZWMoIHNlbGVjdG9yICkgKSApIHtcblxuXHRcdFx0XHQvLyBJRCBzZWxlY3RvclxuXHRcdFx0XHRpZiAoICggbSA9IG1hdGNoWyAxIF0gKSApIHtcblxuXHRcdFx0XHRcdC8vIERvY3VtZW50IGNvbnRleHRcblx0XHRcdFx0XHRpZiAoIG5vZGVUeXBlID09PSA5ICkge1xuXHRcdFx0XHRcdFx0aWYgKCAoIGVsZW0gPSBjb250ZXh0LmdldEVsZW1lbnRCeUlkKCBtICkgKSApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA5IG9ubHlcblx0XHRcdFx0XHRcdFx0Ly8gZ2V0RWxlbWVudEJ5SWQgY2FuIG1hdGNoIGVsZW1lbnRzIGJ5IG5hbWUgaW5zdGVhZCBvZiBJRFxuXHRcdFx0XHRcdFx0XHRpZiAoIGVsZW0uaWQgPT09IG0gKSB7XG5cdFx0XHRcdFx0XHRcdFx0cHVzaC5jYWxsKCByZXN1bHRzLCBlbGVtICk7XG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gRWxlbWVudCBjb250ZXh0XG5cdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgOSBvbmx5XG5cdFx0XHRcdFx0XHQvLyBnZXRFbGVtZW50QnlJZCBjYW4gbWF0Y2ggZWxlbWVudHMgYnkgbmFtZSBpbnN0ZWFkIG9mIElEXG5cdFx0XHRcdFx0XHRpZiAoIG5ld0NvbnRleHQgJiYgKCBlbGVtID0gbmV3Q29udGV4dC5nZXRFbGVtZW50QnlJZCggbSApICkgJiZcblx0XHRcdFx0XHRcdFx0ZmluZC5jb250YWlucyggY29udGV4dCwgZWxlbSApICYmXG5cdFx0XHRcdFx0XHRcdGVsZW0uaWQgPT09IG0gKSB7XG5cblx0XHRcdFx0XHRcdFx0cHVzaC5jYWxsKCByZXN1bHRzLCBlbGVtICk7XG5cdFx0XHRcdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBUeXBlIHNlbGVjdG9yXG5cdFx0XHRcdH0gZWxzZSBpZiAoIG1hdGNoWyAyIF0gKSB7XG5cdFx0XHRcdFx0cHVzaC5hcHBseSggcmVzdWx0cywgY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSggc2VsZWN0b3IgKSApO1xuXHRcdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXG5cdFx0XHRcdC8vIENsYXNzIHNlbGVjdG9yXG5cdFx0XHRcdH0gZWxzZSBpZiAoICggbSA9IG1hdGNoWyAzIF0gKSAmJiBjb250ZXh0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUgKSB7XG5cdFx0XHRcdFx0cHVzaC5hcHBseSggcmVzdWx0cywgY29udGV4dC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCBtICkgKTtcblx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBUYWtlIGFkdmFudGFnZSBvZiBxdWVyeVNlbGVjdG9yQWxsXG5cdFx0XHRpZiAoICFub25uYXRpdmVTZWxlY3RvckNhY2hlWyBzZWxlY3RvciArIFwiIFwiIF0gJiZcblx0XHRcdFx0KCAhcmJ1Z2d5UVNBIHx8ICFyYnVnZ3lRU0EudGVzdCggc2VsZWN0b3IgKSApICkge1xuXG5cdFx0XHRcdG5ld1NlbGVjdG9yID0gc2VsZWN0b3I7XG5cdFx0XHRcdG5ld0NvbnRleHQgPSBjb250ZXh0O1xuXG5cdFx0XHRcdC8vIHFTQSBjb25zaWRlcnMgZWxlbWVudHMgb3V0c2lkZSBhIHNjb3Bpbmcgcm9vdCB3aGVuIGV2YWx1YXRpbmcgY2hpbGQgb3Jcblx0XHRcdFx0Ly8gZGVzY2VuZGFudCBjb21iaW5hdG9ycywgd2hpY2ggaXMgbm90IHdoYXQgd2Ugd2FudC5cblx0XHRcdFx0Ly8gSW4gc3VjaCBjYXNlcywgd2Ugd29yayBhcm91bmQgdGhlIGJlaGF2aW9yIGJ5IHByZWZpeGluZyBldmVyeSBzZWxlY3RvciBpbiB0aGVcblx0XHRcdFx0Ly8gbGlzdCB3aXRoIGFuIElEIHNlbGVjdG9yIHJlZmVyZW5jaW5nIHRoZSBzY29wZSBjb250ZXh0LlxuXHRcdFx0XHQvLyBUaGUgdGVjaG5pcXVlIGhhcyB0byBiZSB1c2VkIGFzIHdlbGwgd2hlbiBhIGxlYWRpbmcgY29tYmluYXRvciBpcyB1c2VkXG5cdFx0XHRcdC8vIGFzIHN1Y2ggc2VsZWN0b3JzIGFyZSBub3QgcmVjb2duaXplZCBieSBxdWVyeVNlbGVjdG9yQWxsLlxuXHRcdFx0XHQvLyBUaGFua3MgdG8gQW5kcmV3IER1cG9udCBmb3IgdGhpcyB0ZWNobmlxdWUuXG5cdFx0XHRcdGlmICggbm9kZVR5cGUgPT09IDEgJiZcblx0XHRcdFx0XHQoIHJkZXNjZW5kLnRlc3QoIHNlbGVjdG9yICkgfHwgcmxlYWRpbmdDb21iaW5hdG9yLnRlc3QoIHNlbGVjdG9yICkgKSApIHtcblxuXHRcdFx0XHRcdC8vIEV4cGFuZCBjb250ZXh0IGZvciBzaWJsaW5nIHNlbGVjdG9yc1xuXHRcdFx0XHRcdG5ld0NvbnRleHQgPSByc2libGluZy50ZXN0KCBzZWxlY3RvciApICYmIHRlc3RDb250ZXh0KCBjb250ZXh0LnBhcmVudE5vZGUgKSB8fFxuXHRcdFx0XHRcdFx0Y29udGV4dDtcblxuXHRcdFx0XHRcdC8vIFdlIGNhbiB1c2UgOnNjb3BlIGluc3RlYWQgb2YgdGhlIElEIGhhY2sgaWYgdGhlIGJyb3dzZXJcblx0XHRcdFx0XHQvLyBzdXBwb3J0cyBpdCAmIGlmIHdlJ3JlIG5vdCBjaGFuZ2luZyB0aGUgY29udGV4dC5cblx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSAxMSssIEVkZ2UgMTcgLSAxOCtcblx0XHRcdFx0XHQvLyBJRS9FZGdlIHNvbWV0aW1lcyB0aHJvdyBhIFwiUGVybWlzc2lvbiBkZW5pZWRcIiBlcnJvciB3aGVuXG5cdFx0XHRcdFx0Ly8gc3RyaWN0LWNvbXBhcmluZyB0d28gZG9jdW1lbnRzOyBzaGFsbG93IGNvbXBhcmlzb25zIHdvcmsuXG5cdFx0XHRcdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVxZXFlcVxuXHRcdFx0XHRcdGlmICggbmV3Q29udGV4dCAhPSBjb250ZXh0IHx8ICFzdXBwb3J0LnNjb3BlICkge1xuXG5cdFx0XHRcdFx0XHQvLyBDYXB0dXJlIHRoZSBjb250ZXh0IElELCBzZXR0aW5nIGl0IGZpcnN0IGlmIG5lY2Vzc2FyeVxuXHRcdFx0XHRcdFx0aWYgKCAoIG5pZCA9IGNvbnRleHQuZ2V0QXR0cmlidXRlKCBcImlkXCIgKSApICkge1xuXHRcdFx0XHRcdFx0XHRuaWQgPSBqUXVlcnkuZXNjYXBlU2VsZWN0b3IoIG5pZCApO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0Y29udGV4dC5zZXRBdHRyaWJ1dGUoIFwiaWRcIiwgKCBuaWQgPSBleHBhbmRvICkgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBQcmVmaXggZXZlcnkgc2VsZWN0b3IgaW4gdGhlIGxpc3Rcblx0XHRcdFx0XHRncm91cHMgPSB0b2tlbml6ZSggc2VsZWN0b3IgKTtcblx0XHRcdFx0XHRpID0gZ3JvdXBzLmxlbmd0aDtcblx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRcdGdyb3Vwc1sgaSBdID0gKCBuaWQgPyBcIiNcIiArIG5pZCA6IFwiOnNjb3BlXCIgKSArIFwiIFwiICtcblx0XHRcdFx0XHRcdFx0dG9TZWxlY3RvciggZ3JvdXBzWyBpIF0gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0bmV3U2VsZWN0b3IgPSBncm91cHMuam9pbiggXCIsXCIgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0cHVzaC5hcHBseSggcmVzdWx0cyxcblx0XHRcdFx0XHRcdG5ld0NvbnRleHQucXVlcnlTZWxlY3RvckFsbCggbmV3U2VsZWN0b3IgKVxuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0XHRcdH0gY2F0Y2ggKCBxc2FFcnJvciApIHtcblx0XHRcdFx0XHRub25uYXRpdmVTZWxlY3RvckNhY2hlKCBzZWxlY3RvciwgdHJ1ZSApO1xuXHRcdFx0XHR9IGZpbmFsbHkge1xuXHRcdFx0XHRcdGlmICggbmlkID09PSBleHBhbmRvICkge1xuXHRcdFx0XHRcdFx0Y29udGV4dC5yZW1vdmVBdHRyaWJ1dGUoIFwiaWRcIiApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIEFsbCBvdGhlcnNcblx0cmV0dXJuIHNlbGVjdCggc2VsZWN0b3IucmVwbGFjZSggcnRyaW1DU1MsIFwiJDFcIiApLCBjb250ZXh0LCByZXN1bHRzLCBzZWVkICk7XG59XG5cbi8qKlxuICogQ3JlYXRlIGtleS12YWx1ZSBjYWNoZXMgb2YgbGltaXRlZCBzaXplXG4gKiBAcmV0dXJucyB7ZnVuY3Rpb24oc3RyaW5nLCBvYmplY3QpfSBSZXR1cm5zIHRoZSBPYmplY3QgZGF0YSBhZnRlciBzdG9yaW5nIGl0IG9uIGl0c2VsZiB3aXRoXG4gKlx0cHJvcGVydHkgbmFtZSB0aGUgKHNwYWNlLXN1ZmZpeGVkKSBzdHJpbmcgYW5kIChpZiB0aGUgY2FjaGUgaXMgbGFyZ2VyIHRoYW4gRXhwci5jYWNoZUxlbmd0aClcbiAqXHRkZWxldGluZyB0aGUgb2xkZXN0IGVudHJ5XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUNhY2hlKCkge1xuXHR2YXIga2V5cyA9IFtdO1xuXG5cdGZ1bmN0aW9uIGNhY2hlKCBrZXksIHZhbHVlICkge1xuXG5cdFx0Ly8gVXNlIChrZXkgKyBcIiBcIikgdG8gYXZvaWQgY29sbGlzaW9uIHdpdGggbmF0aXZlIHByb3RvdHlwZSBwcm9wZXJ0aWVzXG5cdFx0Ly8gKHNlZSBodHRwczovL2dpdGh1Yi5jb20vanF1ZXJ5L3NpenpsZS9pc3N1ZXMvMTU3KVxuXHRcdGlmICgga2V5cy5wdXNoKCBrZXkgKyBcIiBcIiApID4gRXhwci5jYWNoZUxlbmd0aCApIHtcblxuXHRcdFx0Ly8gT25seSBrZWVwIHRoZSBtb3N0IHJlY2VudCBlbnRyaWVzXG5cdFx0XHRkZWxldGUgY2FjaGVbIGtleXMuc2hpZnQoKSBdO1xuXHRcdH1cblx0XHRyZXR1cm4gKCBjYWNoZVsga2V5ICsgXCIgXCIgXSA9IHZhbHVlICk7XG5cdH1cblx0cmV0dXJuIGNhY2hlO1xufVxuXG4vKipcbiAqIE1hcmsgYSBmdW5jdGlvbiBmb3Igc3BlY2lhbCB1c2UgYnkgalF1ZXJ5IHNlbGVjdG9yIG1vZHVsZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGZ1bmN0aW9uIHRvIG1hcmtcbiAqL1xuZnVuY3Rpb24gbWFya0Z1bmN0aW9uKCBmbiApIHtcblx0Zm5bIGV4cGFuZG8gXSA9IHRydWU7XG5cdHJldHVybiBmbjtcbn1cblxuLyoqXG4gKiBTdXBwb3J0IHRlc3RpbmcgdXNpbmcgYW4gZWxlbWVudFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gUGFzc2VkIHRoZSBjcmVhdGVkIGVsZW1lbnQgYW5kIHJldHVybnMgYSBib29sZWFuIHJlc3VsdFxuICovXG5mdW5jdGlvbiBhc3NlcnQoIGZuICkge1xuXHR2YXIgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImZpZWxkc2V0XCIgKTtcblxuXHR0cnkge1xuXHRcdHJldHVybiAhIWZuKCBlbCApO1xuXHR9IGNhdGNoICggZSApIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH0gZmluYWxseSB7XG5cblx0XHQvLyBSZW1vdmUgZnJvbSBpdHMgcGFyZW50IGJ5IGRlZmF1bHRcblx0XHRpZiAoIGVsLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRlbC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKCBlbCApO1xuXHRcdH1cblxuXHRcdC8vIHJlbGVhc2UgbWVtb3J5IGluIElFXG5cdFx0ZWwgPSBudWxsO1xuXHR9XG59XG5cbi8qKlxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHRvIHVzZSBpbiBwc2V1ZG9zIGZvciBpbnB1dCB0eXBlc1xuICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAqL1xuZnVuY3Rpb24gY3JlYXRlSW5wdXRQc2V1ZG8oIHR5cGUgKSB7XG5cdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gbm9kZU5hbWUoIGVsZW0sIFwiaW5wdXRcIiApICYmIGVsZW0udHlwZSA9PT0gdHlwZTtcblx0fTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gdG8gdXNlIGluIHBzZXVkb3MgZm9yIGJ1dHRvbnNcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUJ1dHRvblBzZXVkbyggdHlwZSApIHtcblx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiAoIG5vZGVOYW1lKCBlbGVtLCBcImlucHV0XCIgKSB8fCBub2RlTmFtZSggZWxlbSwgXCJidXR0b25cIiApICkgJiZcblx0XHRcdGVsZW0udHlwZSA9PT0gdHlwZTtcblx0fTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gdG8gdXNlIGluIHBzZXVkb3MgZm9yIDplbmFibGVkLzpkaXNhYmxlZFxuICogQHBhcmFtIHtCb29sZWFufSBkaXNhYmxlZCB0cnVlIGZvciA6ZGlzYWJsZWQ7IGZhbHNlIGZvciA6ZW5hYmxlZFxuICovXG5mdW5jdGlvbiBjcmVhdGVEaXNhYmxlZFBzZXVkbyggZGlzYWJsZWQgKSB7XG5cblx0Ly8gS25vd24gOmRpc2FibGVkIGZhbHNlIHBvc2l0aXZlczogZmllbGRzZXRbZGlzYWJsZWRdID4gbGVnZW5kOm50aC1vZi10eXBlKG4rMikgOmNhbi1kaXNhYmxlXG5cdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblxuXHRcdC8vIE9ubHkgY2VydGFpbiBlbGVtZW50cyBjYW4gbWF0Y2ggOmVuYWJsZWQgb3IgOmRpc2FibGVkXG5cdFx0Ly8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc2NyaXB0aW5nLmh0bWwjc2VsZWN0b3ItZW5hYmxlZFxuXHRcdC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3NjcmlwdGluZy5odG1sI3NlbGVjdG9yLWRpc2FibGVkXG5cdFx0aWYgKCBcImZvcm1cIiBpbiBlbGVtICkge1xuXG5cdFx0XHQvLyBDaGVjayBmb3IgaW5oZXJpdGVkIGRpc2FibGVkbmVzcyBvbiByZWxldmFudCBub24tZGlzYWJsZWQgZWxlbWVudHM6XG5cdFx0XHQvLyAqIGxpc3RlZCBmb3JtLWFzc29jaWF0ZWQgZWxlbWVudHMgaW4gYSBkaXNhYmxlZCBmaWVsZHNldFxuXHRcdFx0Ly8gICBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9mb3Jtcy5odG1sI2NhdGVnb3J5LWxpc3RlZFxuXHRcdFx0Ly8gICBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9mb3Jtcy5odG1sI2NvbmNlcHQtZmUtZGlzYWJsZWRcblx0XHRcdC8vICogb3B0aW9uIGVsZW1lbnRzIGluIGEgZGlzYWJsZWQgb3B0Z3JvdXBcblx0XHRcdC8vICAgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvZm9ybXMuaHRtbCNjb25jZXB0LW9wdGlvbi1kaXNhYmxlZFxuXHRcdFx0Ly8gQWxsIHN1Y2ggZWxlbWVudHMgaGF2ZSBhIFwiZm9ybVwiIHByb3BlcnR5LlxuXHRcdFx0aWYgKCBlbGVtLnBhcmVudE5vZGUgJiYgZWxlbS5kaXNhYmxlZCA9PT0gZmFsc2UgKSB7XG5cblx0XHRcdFx0Ly8gT3B0aW9uIGVsZW1lbnRzIGRlZmVyIHRvIGEgcGFyZW50IG9wdGdyb3VwIGlmIHByZXNlbnRcblx0XHRcdFx0aWYgKCBcImxhYmVsXCIgaW4gZWxlbSApIHtcblx0XHRcdFx0XHRpZiAoIFwibGFiZWxcIiBpbiBlbGVtLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZWxlbS5wYXJlbnROb2RlLmRpc2FibGVkID09PSBkaXNhYmxlZDtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGVsZW0uZGlzYWJsZWQgPT09IGRpc2FibGVkO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDYgLSAxMStcblx0XHRcdFx0Ly8gVXNlIHRoZSBpc0Rpc2FibGVkIHNob3J0Y3V0IHByb3BlcnR5IHRvIGNoZWNrIGZvciBkaXNhYmxlZCBmaWVsZHNldCBhbmNlc3RvcnNcblx0XHRcdFx0cmV0dXJuIGVsZW0uaXNEaXNhYmxlZCA9PT0gZGlzYWJsZWQgfHxcblxuXHRcdFx0XHRcdC8vIFdoZXJlIHRoZXJlIGlzIG5vIGlzRGlzYWJsZWQsIGNoZWNrIG1hbnVhbGx5XG5cdFx0XHRcdFx0ZWxlbS5pc0Rpc2FibGVkICE9PSAhZGlzYWJsZWQgJiZcblx0XHRcdFx0XHRcdGluRGlzYWJsZWRGaWVsZHNldCggZWxlbSApID09PSBkaXNhYmxlZDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGVsZW0uZGlzYWJsZWQgPT09IGRpc2FibGVkO1xuXG5cdFx0Ly8gVHJ5IHRvIHdpbm5vdyBvdXQgZWxlbWVudHMgdGhhdCBjYW4ndCBiZSBkaXNhYmxlZCBiZWZvcmUgdHJ1c3RpbmcgdGhlIGRpc2FibGVkIHByb3BlcnR5LlxuXHRcdC8vIFNvbWUgdmljdGltcyBnZXQgY2F1Z2h0IGluIG91ciBuZXQgKGxhYmVsLCBsZWdlbmQsIG1lbnUsIHRyYWNrKSwgYnV0IGl0IHNob3VsZG4ndFxuXHRcdC8vIGV2ZW4gZXhpc3Qgb24gdGhlbSwgbGV0IGFsb25lIGhhdmUgYSBib29sZWFuIHZhbHVlLlxuXHRcdH0gZWxzZSBpZiAoIFwibGFiZWxcIiBpbiBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGVsZW0uZGlzYWJsZWQgPT09IGRpc2FibGVkO1xuXHRcdH1cblxuXHRcdC8vIFJlbWFpbmluZyBlbGVtZW50cyBhcmUgbmVpdGhlciA6ZW5hYmxlZCBub3IgOmRpc2FibGVkXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9O1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBmdW5jdGlvbiB0byB1c2UgaW4gcHNldWRvcyBmb3IgcG9zaXRpb25hbHNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oIGZuICkge1xuXHRyZXR1cm4gbWFya0Z1bmN0aW9uKCBmdW5jdGlvbiggYXJndW1lbnQgKSB7XG5cdFx0YXJndW1lbnQgPSArYXJndW1lbnQ7XG5cdFx0cmV0dXJuIG1hcmtGdW5jdGlvbiggZnVuY3Rpb24oIHNlZWQsIG1hdGNoZXMgKSB7XG5cdFx0XHR2YXIgaixcblx0XHRcdFx0bWF0Y2hJbmRleGVzID0gZm4oIFtdLCBzZWVkLmxlbmd0aCwgYXJndW1lbnQgKSxcblx0XHRcdFx0aSA9IG1hdGNoSW5kZXhlcy5sZW5ndGg7XG5cblx0XHRcdC8vIE1hdGNoIGVsZW1lbnRzIGZvdW5kIGF0IHRoZSBzcGVjaWZpZWQgaW5kZXhlc1xuXHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdGlmICggc2VlZFsgKCBqID0gbWF0Y2hJbmRleGVzWyBpIF0gKSBdICkge1xuXHRcdFx0XHRcdHNlZWRbIGogXSA9ICEoIG1hdGNoZXNbIGogXSA9IHNlZWRbIGogXSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9ICk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGEgbm9kZSBmb3IgdmFsaWRpdHkgYXMgYSBqUXVlcnkgc2VsZWN0b3IgY29udGV4dFxuICogQHBhcmFtIHtFbGVtZW50fE9iamVjdD19IGNvbnRleHRcbiAqIEByZXR1cm5zIHtFbGVtZW50fE9iamVjdHxCb29sZWFufSBUaGUgaW5wdXQgbm9kZSBpZiBhY2NlcHRhYmxlLCBvdGhlcndpc2UgYSBmYWxzeSB2YWx1ZVxuICovXG5mdW5jdGlvbiB0ZXN0Q29udGV4dCggY29udGV4dCApIHtcblx0cmV0dXJuIGNvbnRleHQgJiYgdHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUgIT09IFwidW5kZWZpbmVkXCIgJiYgY29udGV4dDtcbn1cblxuLyoqXG4gKiBTZXRzIGRvY3VtZW50LXJlbGF0ZWQgdmFyaWFibGVzIG9uY2UgYmFzZWQgb24gdGhlIGN1cnJlbnQgZG9jdW1lbnRcbiAqIEBwYXJhbSB7RWxlbWVudHxPYmplY3R9IFtub2RlXSBBbiBlbGVtZW50IG9yIGRvY3VtZW50IG9iamVjdCB0byB1c2UgdG8gc2V0IHRoZSBkb2N1bWVudFxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY3VycmVudCBkb2N1bWVudFxuICovXG5mdW5jdGlvbiBzZXREb2N1bWVudCggbm9kZSApIHtcblx0dmFyIHN1YldpbmRvdyxcblx0XHRkb2MgPSBub2RlID8gbm9kZS5vd25lckRvY3VtZW50IHx8IG5vZGUgOiBwcmVmZXJyZWREb2M7XG5cblx0Ly8gUmV0dXJuIGVhcmx5IGlmIGRvYyBpcyBpbnZhbGlkIG9yIGFscmVhZHkgc2VsZWN0ZWRcblx0Ly8gU3VwcG9ydDogSUUgMTErLCBFZGdlIDE3IC0gMTgrXG5cdC8vIElFL0VkZ2Ugc29tZXRpbWVzIHRocm93IGEgXCJQZXJtaXNzaW9uIGRlbmllZFwiIGVycm9yIHdoZW4gc3RyaWN0LWNvbXBhcmluZ1xuXHQvLyB0d28gZG9jdW1lbnRzOyBzaGFsbG93IGNvbXBhcmlzb25zIHdvcmsuXG5cdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcWVxZXFcblx0aWYgKCBkb2MgPT0gZG9jdW1lbnQgfHwgZG9jLm5vZGVUeXBlICE9PSA5IHx8ICFkb2MuZG9jdW1lbnRFbGVtZW50ICkge1xuXHRcdHJldHVybiBkb2N1bWVudDtcblx0fVxuXG5cdC8vIFVwZGF0ZSBnbG9iYWwgdmFyaWFibGVzXG5cdGRvY3VtZW50ID0gZG9jO1xuXHRkb2N1bWVudEVsZW1lbnQgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG5cdGRvY3VtZW50SXNIVE1MID0gIWpRdWVyeS5pc1hNTERvYyggZG9jdW1lbnQgKTtcblxuXHQvLyBTdXBwb3J0OiBpT1MgNyBvbmx5LCBJRSA5IC0gMTErXG5cdC8vIE9sZGVyIGJyb3dzZXJzIGRpZG4ndCBzdXBwb3J0IHVucHJlZml4ZWQgYG1hdGNoZXNgLlxuXHRtYXRjaGVzID0gZG9jdW1lbnRFbGVtZW50Lm1hdGNoZXMgfHxcblx0XHRkb2N1bWVudEVsZW1lbnQud2Via2l0TWF0Y2hlc1NlbGVjdG9yIHx8XG5cdFx0ZG9jdW1lbnRFbGVtZW50Lm1zTWF0Y2hlc1NlbGVjdG9yO1xuXG5cdC8vIFN1cHBvcnQ6IElFIDkgLSAxMSssIEVkZ2UgMTIgLSAxOCtcblx0Ly8gQWNjZXNzaW5nIGlmcmFtZSBkb2N1bWVudHMgYWZ0ZXIgdW5sb2FkIHRocm93cyBcInBlcm1pc3Npb24gZGVuaWVkXCIgZXJyb3JzXG5cdC8vIChzZWUgdHJhYy0xMzkzNikuXG5cdC8vIExpbWl0IHRoZSBmaXggdG8gSUUgJiBFZGdlIExlZ2FjeTsgZGVzcGl0ZSBFZGdlIDE1KyBpbXBsZW1lbnRpbmcgYG1hdGNoZXNgLFxuXHQvLyBhbGwgSUUgOSsgYW5kIEVkZ2UgTGVnYWN5IHZlcnNpb25zIGltcGxlbWVudCBgbXNNYXRjaGVzU2VsZWN0b3JgIGFzIHdlbGwuXG5cdGlmICggZG9jdW1lbnRFbGVtZW50Lm1zTWF0Y2hlc1NlbGVjdG9yICYmXG5cblx0XHQvLyBTdXBwb3J0OiBJRSAxMSssIEVkZ2UgMTcgLSAxOCtcblx0XHQvLyBJRS9FZGdlIHNvbWV0aW1lcyB0aHJvdyBhIFwiUGVybWlzc2lvbiBkZW5pZWRcIiBlcnJvciB3aGVuIHN0cmljdC1jb21wYXJpbmdcblx0XHQvLyB0d28gZG9jdW1lbnRzOyBzaGFsbG93IGNvbXBhcmlzb25zIHdvcmsuXG5cdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVxZXFlcVxuXHRcdHByZWZlcnJlZERvYyAhPSBkb2N1bWVudCAmJlxuXHRcdCggc3ViV2luZG93ID0gZG9jdW1lbnQuZGVmYXVsdFZpZXcgKSAmJiBzdWJXaW5kb3cudG9wICE9PSBzdWJXaW5kb3cgKSB7XG5cblx0XHQvLyBTdXBwb3J0OiBJRSA5IC0gMTErLCBFZGdlIDEyIC0gMTgrXG5cdFx0c3ViV2luZG93LmFkZEV2ZW50TGlzdGVuZXIoIFwidW5sb2FkXCIsIHVubG9hZEhhbmRsZXIgKTtcblx0fVxuXG5cdC8vIFN1cHBvcnQ6IElFIDwxMFxuXHQvLyBDaGVjayBpZiBnZXRFbGVtZW50QnlJZCByZXR1cm5zIGVsZW1lbnRzIGJ5IG5hbWVcblx0Ly8gVGhlIGJyb2tlbiBnZXRFbGVtZW50QnlJZCBtZXRob2RzIGRvbid0IHBpY2sgdXAgcHJvZ3JhbW1hdGljYWxseS1zZXQgbmFtZXMsXG5cdC8vIHNvIHVzZSBhIHJvdW5kYWJvdXQgZ2V0RWxlbWVudHNCeU5hbWUgdGVzdFxuXHRzdXBwb3J0LmdldEJ5SWQgPSBhc3NlcnQoIGZ1bmN0aW9uKCBlbCApIHtcblx0XHRkb2N1bWVudEVsZW1lbnQuYXBwZW5kQ2hpbGQoIGVsICkuaWQgPSBqUXVlcnkuZXhwYW5kbztcblx0XHRyZXR1cm4gIWRvY3VtZW50LmdldEVsZW1lbnRzQnlOYW1lIHx8XG5cdFx0XHQhZG9jdW1lbnQuZ2V0RWxlbWVudHNCeU5hbWUoIGpRdWVyeS5leHBhbmRvICkubGVuZ3RoO1xuXHR9ICk7XG5cblx0Ly8gU3VwcG9ydDogSUUgOSBvbmx5XG5cdC8vIENoZWNrIHRvIHNlZSBpZiBpdCdzIHBvc3NpYmxlIHRvIGRvIG1hdGNoZXNTZWxlY3RvclxuXHQvLyBvbiBhIGRpc2Nvbm5lY3RlZCBub2RlLlxuXHRzdXBwb3J0LmRpc2Nvbm5lY3RlZE1hdGNoID0gYXNzZXJ0KCBmdW5jdGlvbiggZWwgKSB7XG5cdFx0cmV0dXJuIG1hdGNoZXMuY2FsbCggZWwsIFwiKlwiICk7XG5cdH0gKTtcblxuXHQvLyBTdXBwb3J0OiBJRSA5IC0gMTErLCBFZGdlIDEyIC0gMTgrXG5cdC8vIElFL0VkZ2UgZG9uJ3Qgc3VwcG9ydCB0aGUgOnNjb3BlIHBzZXVkby1jbGFzcy5cblx0c3VwcG9ydC5zY29wZSA9IGFzc2VydCggZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoIFwiOnNjb3BlXCIgKTtcblx0fSApO1xuXG5cdC8vIFN1cHBvcnQ6IENocm9tZSAxMDUgLSAxMTEgb25seSwgU2FmYXJpIDE1LjQgLSAxNi4zIG9ubHlcblx0Ly8gTWFrZSBzdXJlIHRoZSBgOmhhcygpYCBhcmd1bWVudCBpcyBwYXJzZWQgdW5mb3JnaXZpbmdseS5cblx0Ly8gV2UgaW5jbHVkZSBgKmAgaW4gdGhlIHRlc3QgdG8gZGV0ZWN0IGJ1Z2d5IGltcGxlbWVudGF0aW9ucyB0aGF0IGFyZVxuXHQvLyBfc2VsZWN0aXZlbHlfIGZvcmdpdmluZyAoc3BlY2lmaWNhbGx5IHdoZW4gdGhlIGxpc3QgaW5jbHVkZXMgYXQgbGVhc3Rcblx0Ly8gb25lIHZhbGlkIHNlbGVjdG9yKS5cblx0Ly8gTm90ZSB0aGF0IHdlIHRyZWF0IGNvbXBsZXRlIGxhY2sgb2Ygc3VwcG9ydCBmb3IgYDpoYXMoKWAgYXMgaWYgaXQgd2VyZVxuXHQvLyBzcGVjLWNvbXBsaWFudCBzdXBwb3J0LCB3aGljaCBpcyBmaW5lIGJlY2F1c2UgdXNlIG9mIGA6aGFzKClgIGluIHN1Y2hcblx0Ly8gZW52aXJvbm1lbnRzIHdpbGwgZmFpbCBpbiB0aGUgcVNBIHBhdGggYW5kIGZhbGwgYmFjayB0byBqUXVlcnkgdHJhdmVyc2FsXG5cdC8vIGFueXdheS5cblx0c3VwcG9ydC5jc3NIYXMgPSBhc3NlcnQoIGZ1bmN0aW9uKCkge1xuXHRcdHRyeSB7XG5cdFx0XHRkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCBcIjpoYXMoKiw6anFmYWtlKVwiICk7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fSBjYXRjaCAoIGUgKSB7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cdH0gKTtcblxuXHQvLyBJRCBmaWx0ZXIgYW5kIGZpbmRcblx0aWYgKCBzdXBwb3J0LmdldEJ5SWQgKSB7XG5cdFx0RXhwci5maWx0ZXIuSUQgPSBmdW5jdGlvbiggaWQgKSB7XG5cdFx0XHR2YXIgYXR0cklkID0gaWQucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKTtcblx0XHRcdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0cmV0dXJuIGVsZW0uZ2V0QXR0cmlidXRlKCBcImlkXCIgKSA9PT0gYXR0cklkO1xuXHRcdFx0fTtcblx0XHR9O1xuXHRcdEV4cHIuZmluZC5JRCA9IGZ1bmN0aW9uKCBpZCwgY29udGV4dCApIHtcblx0XHRcdGlmICggdHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudEJ5SWQgIT09IFwidW5kZWZpbmVkXCIgJiYgZG9jdW1lbnRJc0hUTUwgKSB7XG5cdFx0XHRcdHZhciBlbGVtID0gY29udGV4dC5nZXRFbGVtZW50QnlJZCggaWQgKTtcblx0XHRcdFx0cmV0dXJuIGVsZW0gPyBbIGVsZW0gXSA6IFtdO1xuXHRcdFx0fVxuXHRcdH07XG5cdH0gZWxzZSB7XG5cdFx0RXhwci5maWx0ZXIuSUQgPSAgZnVuY3Rpb24oIGlkICkge1xuXHRcdFx0dmFyIGF0dHJJZCA9IGlkLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICk7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHZhciBub2RlID0gdHlwZW9mIGVsZW0uZ2V0QXR0cmlidXRlTm9kZSAhPT0gXCJ1bmRlZmluZWRcIiAmJlxuXHRcdFx0XHRcdGVsZW0uZ2V0QXR0cmlidXRlTm9kZSggXCJpZFwiICk7XG5cdFx0XHRcdHJldHVybiBub2RlICYmIG5vZGUudmFsdWUgPT09IGF0dHJJZDtcblx0XHRcdH07XG5cdFx0fTtcblxuXHRcdC8vIFN1cHBvcnQ6IElFIDYgLSA3IG9ubHlcblx0XHQvLyBnZXRFbGVtZW50QnlJZCBpcyBub3QgcmVsaWFibGUgYXMgYSBmaW5kIHNob3J0Y3V0XG5cdFx0RXhwci5maW5kLklEID0gZnVuY3Rpb24oIGlkLCBjb250ZXh0ICkge1xuXHRcdFx0aWYgKCB0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50QnlJZCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBkb2N1bWVudElzSFRNTCApIHtcblx0XHRcdFx0dmFyIG5vZGUsIGksIGVsZW1zLFxuXHRcdFx0XHRcdGVsZW0gPSBjb250ZXh0LmdldEVsZW1lbnRCeUlkKCBpZCApO1xuXG5cdFx0XHRcdGlmICggZWxlbSApIHtcblxuXHRcdFx0XHRcdC8vIFZlcmlmeSB0aGUgaWQgYXR0cmlidXRlXG5cdFx0XHRcdFx0bm9kZSA9IGVsZW0uZ2V0QXR0cmlidXRlTm9kZSggXCJpZFwiICk7XG5cdFx0XHRcdFx0aWYgKCBub2RlICYmIG5vZGUudmFsdWUgPT09IGlkICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIFsgZWxlbSBdO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIEZhbGwgYmFjayBvbiBnZXRFbGVtZW50c0J5TmFtZVxuXHRcdFx0XHRcdGVsZW1zID0gY29udGV4dC5nZXRFbGVtZW50c0J5TmFtZSggaWQgKTtcblx0XHRcdFx0XHRpID0gMDtcblx0XHRcdFx0XHR3aGlsZSAoICggZWxlbSA9IGVsZW1zWyBpKysgXSApICkge1xuXHRcdFx0XHRcdFx0bm9kZSA9IGVsZW0uZ2V0QXR0cmlidXRlTm9kZSggXCJpZFwiICk7XG5cdFx0XHRcdFx0XHRpZiAoIG5vZGUgJiYgbm9kZS52YWx1ZSA9PT0gaWQgKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiBbIGVsZW0gXTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gW107XG5cdFx0XHR9XG5cdFx0fTtcblx0fVxuXG5cdC8vIFRhZ1xuXHRFeHByLmZpbmQuVEFHID0gZnVuY3Rpb24oIHRhZywgY29udGV4dCApIHtcblx0XHRpZiAoIHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lICE9PSBcInVuZGVmaW5lZFwiICkge1xuXHRcdFx0cmV0dXJuIGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoIHRhZyApO1xuXG5cdFx0Ly8gRG9jdW1lbnRGcmFnbWVudCBub2RlcyBkb24ndCBoYXZlIGdFQlROXG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiBjb250ZXh0LnF1ZXJ5U2VsZWN0b3JBbGwoIHRhZyApO1xuXHRcdH1cblx0fTtcblxuXHQvLyBDbGFzc1xuXHRFeHByLmZpbmQuQ0xBU1MgPSBmdW5jdGlvbiggY2xhc3NOYW1lLCBjb250ZXh0ICkge1xuXHRcdGlmICggdHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBkb2N1bWVudElzSFRNTCApIHtcblx0XHRcdHJldHVybiBjb250ZXh0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoIGNsYXNzTmFtZSApO1xuXHRcdH1cblx0fTtcblxuXHQvKiBRU0EvbWF0Y2hlc1NlbGVjdG9yXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuXHQvLyBRU0EgYW5kIG1hdGNoZXNTZWxlY3RvciBzdXBwb3J0XG5cblx0cmJ1Z2d5UVNBID0gW107XG5cblx0Ly8gQnVpbGQgUVNBIHJlZ2V4XG5cdC8vIFJlZ2V4IHN0cmF0ZWd5IGFkb3B0ZWQgZnJvbSBEaWVnbyBQZXJpbmlcblx0YXNzZXJ0KCBmdW5jdGlvbiggZWwgKSB7XG5cblx0XHR2YXIgaW5wdXQ7XG5cblx0XHRkb2N1bWVudEVsZW1lbnQuYXBwZW5kQ2hpbGQoIGVsICkuaW5uZXJIVE1MID1cblx0XHRcdFwiPGEgaWQ9J1wiICsgZXhwYW5kbyArIFwiJyBocmVmPScnIGRpc2FibGVkPSdkaXNhYmxlZCc+PC9hPlwiICtcblx0XHRcdFwiPHNlbGVjdCBpZD0nXCIgKyBleHBhbmRvICsgXCItXFxyXFxcXCcgZGlzYWJsZWQ9J2Rpc2FibGVkJz5cIiArXG5cdFx0XHRcIjxvcHRpb24gc2VsZWN0ZWQ9Jyc+PC9vcHRpb24+PC9zZWxlY3Q+XCI7XG5cblx0XHQvLyBTdXBwb3J0OiBpT1MgPD03IC0gOCBvbmx5XG5cdFx0Ly8gQm9vbGVhbiBhdHRyaWJ1dGVzIGFuZCBcInZhbHVlXCIgYXJlIG5vdCB0cmVhdGVkIGNvcnJlY3RseSBpbiBzb21lIFhNTCBkb2N1bWVudHNcblx0XHRpZiAoICFlbC5xdWVyeVNlbGVjdG9yQWxsKCBcIltzZWxlY3RlZF1cIiApLmxlbmd0aCApIHtcblx0XHRcdHJidWdneVFTQS5wdXNoKCBcIlxcXFxbXCIgKyB3aGl0ZXNwYWNlICsgXCIqKD86dmFsdWV8XCIgKyBib29sZWFucyArIFwiKVwiICk7XG5cdFx0fVxuXG5cdFx0Ly8gU3VwcG9ydDogaU9TIDw9NyAtIDggb25seVxuXHRcdGlmICggIWVsLnF1ZXJ5U2VsZWN0b3JBbGwoIFwiW2lkfj1cIiArIGV4cGFuZG8gKyBcIi1dXCIgKS5sZW5ndGggKSB7XG5cdFx0XHRyYnVnZ3lRU0EucHVzaCggXCJ+PVwiICk7XG5cdFx0fVxuXG5cdFx0Ly8gU3VwcG9ydDogaU9TIDggb25seVxuXHRcdC8vIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0xMzY4NTFcblx0XHQvLyBJbi1wYWdlIGBzZWxlY3RvciNpZCBzaWJsaW5nLWNvbWJpbmF0b3Igc2VsZWN0b3JgIGZhaWxzXG5cdFx0aWYgKCAhZWwucXVlcnlTZWxlY3RvckFsbCggXCJhI1wiICsgZXhwYW5kbyArIFwiKypcIiApLmxlbmd0aCApIHtcblx0XHRcdHJidWdneVFTQS5wdXNoKCBcIi4jLitbK35dXCIgKTtcblx0XHR9XG5cblx0XHQvLyBTdXBwb3J0OiBDaHJvbWUgPD0xMDUrLCBGaXJlZm94IDw9MTA0KywgU2FmYXJpIDw9MTUuNCtcblx0XHQvLyBJbiBzb21lIG9mIHRoZSBkb2N1bWVudCBraW5kcywgdGhlc2Ugc2VsZWN0b3JzIHdvdWxkbid0IHdvcmsgbmF0aXZlbHkuXG5cdFx0Ly8gVGhpcyBpcyBwcm9iYWJseSBPSyBidXQgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IHdlIHdhbnQgdG8gbWFpbnRhaW5cblx0XHQvLyBoYW5kbGluZyB0aGVtIHRocm91Z2ggalF1ZXJ5IHRyYXZlcnNhbCBpbiBqUXVlcnkgMy54LlxuXHRcdGlmICggIWVsLnF1ZXJ5U2VsZWN0b3JBbGwoIFwiOmNoZWNrZWRcIiApLmxlbmd0aCApIHtcblx0XHRcdHJidWdneVFTQS5wdXNoKCBcIjpjaGVja2VkXCIgKTtcblx0XHR9XG5cblx0XHQvLyBTdXBwb3J0OiBXaW5kb3dzIDggTmF0aXZlIEFwcHNcblx0XHQvLyBUaGUgdHlwZSBhbmQgbmFtZSBhdHRyaWJ1dGVzIGFyZSByZXN0cmljdGVkIGR1cmluZyAuaW5uZXJIVE1MIGFzc2lnbm1lbnRcblx0XHRpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiaW5wdXRcIiApO1xuXHRcdGlucHV0LnNldEF0dHJpYnV0ZSggXCJ0eXBlXCIsIFwiaGlkZGVuXCIgKTtcblx0XHRlbC5hcHBlbmRDaGlsZCggaW5wdXQgKS5zZXRBdHRyaWJ1dGUoIFwibmFtZVwiLCBcIkRcIiApO1xuXG5cdFx0Ly8gU3VwcG9ydDogSUUgOSAtIDExK1xuXHRcdC8vIElFJ3MgOmRpc2FibGVkIHNlbGVjdG9yIGRvZXMgbm90IHBpY2sgdXAgdGhlIGNoaWxkcmVuIG9mIGRpc2FibGVkIGZpZWxkc2V0c1xuXHRcdC8vIFN1cHBvcnQ6IENocm9tZSA8PTEwNSssIEZpcmVmb3ggPD0xMDQrLCBTYWZhcmkgPD0xNS40K1xuXHRcdC8vIEluIHNvbWUgb2YgdGhlIGRvY3VtZW50IGtpbmRzLCB0aGVzZSBzZWxlY3RvcnMgd291bGRuJ3Qgd29yayBuYXRpdmVseS5cblx0XHQvLyBUaGlzIGlzIHByb2JhYmx5IE9LIGJ1dCBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkgd2Ugd2FudCB0byBtYWludGFpblxuXHRcdC8vIGhhbmRsaW5nIHRoZW0gdGhyb3VnaCBqUXVlcnkgdHJhdmVyc2FsIGluIGpRdWVyeSAzLnguXG5cdFx0ZG9jdW1lbnRFbGVtZW50LmFwcGVuZENoaWxkKCBlbCApLmRpc2FibGVkID0gdHJ1ZTtcblx0XHRpZiAoIGVsLnF1ZXJ5U2VsZWN0b3JBbGwoIFwiOmRpc2FibGVkXCIgKS5sZW5ndGggIT09IDIgKSB7XG5cdFx0XHRyYnVnZ3lRU0EucHVzaCggXCI6ZW5hYmxlZFwiLCBcIjpkaXNhYmxlZFwiICk7XG5cdFx0fVxuXG5cdFx0Ly8gU3VwcG9ydDogSUUgMTErLCBFZGdlIDE1IC0gMTgrXG5cdFx0Ly8gSUUgMTEvRWRnZSBkb24ndCBmaW5kIGVsZW1lbnRzIG9uIGEgYFtuYW1lPScnXWAgcXVlcnkgaW4gc29tZSBjYXNlcy5cblx0XHQvLyBBZGRpbmcgYSB0ZW1wb3JhcnkgYXR0cmlidXRlIHRvIHRoZSBkb2N1bWVudCBiZWZvcmUgdGhlIHNlbGVjdGlvbiB3b3Jrc1xuXHRcdC8vIGFyb3VuZCB0aGUgaXNzdWUuXG5cdFx0Ly8gSW50ZXJlc3RpbmdseSwgSUUgMTAgJiBvbGRlciBkb24ndCBzZWVtIHRvIGhhdmUgdGhlIGlzc3VlLlxuXHRcdGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJpbnB1dFwiICk7XG5cdFx0aW5wdXQuc2V0QXR0cmlidXRlKCBcIm5hbWVcIiwgXCJcIiApO1xuXHRcdGVsLmFwcGVuZENoaWxkKCBpbnB1dCApO1xuXHRcdGlmICggIWVsLnF1ZXJ5U2VsZWN0b3JBbGwoIFwiW25hbWU9JyddXCIgKS5sZW5ndGggKSB7XG5cdFx0XHRyYnVnZ3lRU0EucHVzaCggXCJcXFxcW1wiICsgd2hpdGVzcGFjZSArIFwiKm5hbWVcIiArIHdoaXRlc3BhY2UgKyBcIio9XCIgK1xuXHRcdFx0XHR3aGl0ZXNwYWNlICsgXCIqKD86Jyd8XFxcIlxcXCIpXCIgKTtcblx0XHR9XG5cdH0gKTtcblxuXHRpZiAoICFzdXBwb3J0LmNzc0hhcyApIHtcblxuXHRcdC8vIFN1cHBvcnQ6IENocm9tZSAxMDUgLSAxMTArLCBTYWZhcmkgMTUuNCAtIDE2LjMrXG5cdFx0Ly8gT3VyIHJlZ3VsYXIgYHRyeS1jYXRjaGAgbWVjaGFuaXNtIGZhaWxzIHRvIGRldGVjdCBuYXRpdmVseS11bnN1cHBvcnRlZFxuXHRcdC8vIHBzZXVkby1jbGFzc2VzIGluc2lkZSBgOmhhcygpYCAoc3VjaCBhcyBgOmhhcyg6Y29udGFpbnMoXCJGb29cIikpYClcblx0XHQvLyBpbiBicm93c2VycyB0aGF0IHBhcnNlIHRoZSBgOmhhcygpYCBhcmd1bWVudCBhcyBhIGZvcmdpdmluZyBzZWxlY3RvciBsaXN0LlxuXHRcdC8vIGh0dHBzOi8vZHJhZnRzLmNzc3dnLm9yZy9zZWxlY3RvcnMvI3JlbGF0aW9uYWwgbm93IHJlcXVpcmVzIHRoZSBhcmd1bWVudFxuXHRcdC8vIHRvIGJlIHBhcnNlZCB1bmZvcmdpdmluZ2x5LCBidXQgYnJvd3NlcnMgaGF2ZSBub3QgeWV0IGZ1bGx5IGFkanVzdGVkLlxuXHRcdHJidWdneVFTQS5wdXNoKCBcIjpoYXNcIiApO1xuXHR9XG5cblx0cmJ1Z2d5UVNBID0gcmJ1Z2d5UVNBLmxlbmd0aCAmJiBuZXcgUmVnRXhwKCByYnVnZ3lRU0Euam9pbiggXCJ8XCIgKSApO1xuXG5cdC8qIFNvcnRpbmdcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG5cdC8vIERvY3VtZW50IG9yZGVyIHNvcnRpbmdcblx0c29ydE9yZGVyID0gZnVuY3Rpb24oIGEsIGIgKSB7XG5cblx0XHQvLyBGbGFnIGZvciBkdXBsaWNhdGUgcmVtb3ZhbFxuXHRcdGlmICggYSA9PT0gYiApIHtcblx0XHRcdGhhc0R1cGxpY2F0ZSA9IHRydWU7XG5cdFx0XHRyZXR1cm4gMDtcblx0XHR9XG5cblx0XHQvLyBTb3J0IG9uIG1ldGhvZCBleGlzdGVuY2UgaWYgb25seSBvbmUgaW5wdXQgaGFzIGNvbXBhcmVEb2N1bWVudFBvc2l0aW9uXG5cdFx0dmFyIGNvbXBhcmUgPSAhYS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiAtICFiLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uO1xuXHRcdGlmICggY29tcGFyZSApIHtcblx0XHRcdHJldHVybiBjb21wYXJlO1xuXHRcdH1cblxuXHRcdC8vIENhbGN1bGF0ZSBwb3NpdGlvbiBpZiBib3RoIGlucHV0cyBiZWxvbmcgdG8gdGhlIHNhbWUgZG9jdW1lbnRcblx0XHQvLyBTdXBwb3J0OiBJRSAxMSssIEVkZ2UgMTcgLSAxOCtcblx0XHQvLyBJRS9FZGdlIHNvbWV0aW1lcyB0aHJvdyBhIFwiUGVybWlzc2lvbiBkZW5pZWRcIiBlcnJvciB3aGVuIHN0cmljdC1jb21wYXJpbmdcblx0XHQvLyB0d28gZG9jdW1lbnRzOyBzaGFsbG93IGNvbXBhcmlzb25zIHdvcmsuXG5cdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVxZXFlcVxuXHRcdGNvbXBhcmUgPSAoIGEub3duZXJEb2N1bWVudCB8fCBhICkgPT0gKCBiLm93bmVyRG9jdW1lbnQgfHwgYiApID9cblx0XHRcdGEuY29tcGFyZURvY3VtZW50UG9zaXRpb24oIGIgKSA6XG5cblx0XHRcdC8vIE90aGVyd2lzZSB3ZSBrbm93IHRoZXkgYXJlIGRpc2Nvbm5lY3RlZFxuXHRcdFx0MTtcblxuXHRcdC8vIERpc2Nvbm5lY3RlZCBub2Rlc1xuXHRcdGlmICggY29tcGFyZSAmIDEgfHxcblx0XHRcdCggIXN1cHBvcnQuc29ydERldGFjaGVkICYmIGIuY29tcGFyZURvY3VtZW50UG9zaXRpb24oIGEgKSA9PT0gY29tcGFyZSApICkge1xuXG5cdFx0XHQvLyBDaG9vc2UgdGhlIGZpcnN0IGVsZW1lbnQgdGhhdCBpcyByZWxhdGVkIHRvIG91ciBwcmVmZXJyZWQgZG9jdW1lbnRcblx0XHRcdC8vIFN1cHBvcnQ6IElFIDExKywgRWRnZSAxNyAtIDE4K1xuXHRcdFx0Ly8gSUUvRWRnZSBzb21ldGltZXMgdGhyb3cgYSBcIlBlcm1pc3Npb24gZGVuaWVkXCIgZXJyb3Igd2hlbiBzdHJpY3QtY29tcGFyaW5nXG5cdFx0XHQvLyB0d28gZG9jdW1lbnRzOyBzaGFsbG93IGNvbXBhcmlzb25zIHdvcmsuXG5cdFx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXFlcWVxXG5cdFx0XHRpZiAoIGEgPT09IGRvY3VtZW50IHx8IGEub3duZXJEb2N1bWVudCA9PSBwcmVmZXJyZWREb2MgJiZcblx0XHRcdFx0ZmluZC5jb250YWlucyggcHJlZmVycmVkRG9jLCBhICkgKSB7XG5cdFx0XHRcdHJldHVybiAtMTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU3VwcG9ydDogSUUgMTErLCBFZGdlIDE3IC0gMTgrXG5cdFx0XHQvLyBJRS9FZGdlIHNvbWV0aW1lcyB0aHJvdyBhIFwiUGVybWlzc2lvbiBkZW5pZWRcIiBlcnJvciB3aGVuIHN0cmljdC1jb21wYXJpbmdcblx0XHRcdC8vIHR3byBkb2N1bWVudHM7IHNoYWxsb3cgY29tcGFyaXNvbnMgd29yay5cblx0XHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcWVxZXFcblx0XHRcdGlmICggYiA9PT0gZG9jdW1lbnQgfHwgYi5vd25lckRvY3VtZW50ID09IHByZWZlcnJlZERvYyAmJlxuXHRcdFx0XHRmaW5kLmNvbnRhaW5zKCBwcmVmZXJyZWREb2MsIGIgKSApIHtcblx0XHRcdFx0cmV0dXJuIDE7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE1haW50YWluIG9yaWdpbmFsIG9yZGVyXG5cdFx0XHRyZXR1cm4gc29ydElucHV0ID9cblx0XHRcdFx0KCBpbmRleE9mLmNhbGwoIHNvcnRJbnB1dCwgYSApIC0gaW5kZXhPZi5jYWxsKCBzb3J0SW5wdXQsIGIgKSApIDpcblx0XHRcdFx0MDtcblx0XHR9XG5cblx0XHRyZXR1cm4gY29tcGFyZSAmIDQgPyAtMSA6IDE7XG5cdH07XG5cblx0cmV0dXJuIGRvY3VtZW50O1xufVxuXG5maW5kLm1hdGNoZXMgPSBmdW5jdGlvbiggZXhwciwgZWxlbWVudHMgKSB7XG5cdHJldHVybiBmaW5kKCBleHByLCBudWxsLCBudWxsLCBlbGVtZW50cyApO1xufTtcblxuZmluZC5tYXRjaGVzU2VsZWN0b3IgPSBmdW5jdGlvbiggZWxlbSwgZXhwciApIHtcblx0c2V0RG9jdW1lbnQoIGVsZW0gKTtcblxuXHRpZiAoIGRvY3VtZW50SXNIVE1MICYmXG5cdFx0IW5vbm5hdGl2ZVNlbGVjdG9yQ2FjaGVbIGV4cHIgKyBcIiBcIiBdICYmXG5cdFx0KCAhcmJ1Z2d5UVNBIHx8ICFyYnVnZ3lRU0EudGVzdCggZXhwciApICkgKSB7XG5cblx0XHR0cnkge1xuXHRcdFx0dmFyIHJldCA9IG1hdGNoZXMuY2FsbCggZWxlbSwgZXhwciApO1xuXG5cdFx0XHQvLyBJRSA5J3MgbWF0Y2hlc1NlbGVjdG9yIHJldHVybnMgZmFsc2Ugb24gZGlzY29ubmVjdGVkIG5vZGVzXG5cdFx0XHRpZiAoIHJldCB8fCBzdXBwb3J0LmRpc2Nvbm5lY3RlZE1hdGNoIHx8XG5cblx0XHRcdFx0XHQvLyBBcyB3ZWxsLCBkaXNjb25uZWN0ZWQgbm9kZXMgYXJlIHNhaWQgdG8gYmUgaW4gYSBkb2N1bWVudFxuXHRcdFx0XHRcdC8vIGZyYWdtZW50IGluIElFIDlcblx0XHRcdFx0XHRlbGVtLmRvY3VtZW50ICYmIGVsZW0uZG9jdW1lbnQubm9kZVR5cGUgIT09IDExICkge1xuXHRcdFx0XHRyZXR1cm4gcmV0O1xuXHRcdFx0fVxuXHRcdH0gY2F0Y2ggKCBlICkge1xuXHRcdFx0bm9ubmF0aXZlU2VsZWN0b3JDYWNoZSggZXhwciwgdHJ1ZSApO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBmaW5kKCBleHByLCBkb2N1bWVudCwgbnVsbCwgWyBlbGVtIF0gKS5sZW5ndGggPiAwO1xufTtcblxuZmluZC5jb250YWlucyA9IGZ1bmN0aW9uKCBjb250ZXh0LCBlbGVtICkge1xuXG5cdC8vIFNldCBkb2N1bWVudCB2YXJzIGlmIG5lZWRlZFxuXHQvLyBTdXBwb3J0OiBJRSAxMSssIEVkZ2UgMTcgLSAxOCtcblx0Ly8gSUUvRWRnZSBzb21ldGltZXMgdGhyb3cgYSBcIlBlcm1pc3Npb24gZGVuaWVkXCIgZXJyb3Igd2hlbiBzdHJpY3QtY29tcGFyaW5nXG5cdC8vIHR3byBkb2N1bWVudHM7IHNoYWxsb3cgY29tcGFyaXNvbnMgd29yay5cblx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVxZXFlcVxuXHRpZiAoICggY29udGV4dC5vd25lckRvY3VtZW50IHx8IGNvbnRleHQgKSAhPSBkb2N1bWVudCApIHtcblx0XHRzZXREb2N1bWVudCggY29udGV4dCApO1xuXHR9XG5cdHJldHVybiBqUXVlcnkuY29udGFpbnMoIGNvbnRleHQsIGVsZW0gKTtcbn07XG5cblxuZmluZC5hdHRyID0gZnVuY3Rpb24oIGVsZW0sIG5hbWUgKSB7XG5cblx0Ly8gU2V0IGRvY3VtZW50IHZhcnMgaWYgbmVlZGVkXG5cdC8vIFN1cHBvcnQ6IElFIDExKywgRWRnZSAxNyAtIDE4K1xuXHQvLyBJRS9FZGdlIHNvbWV0aW1lcyB0aHJvdyBhIFwiUGVybWlzc2lvbiBkZW5pZWRcIiBlcnJvciB3aGVuIHN0cmljdC1jb21wYXJpbmdcblx0Ly8gdHdvIGRvY3VtZW50czsgc2hhbGxvdyBjb21wYXJpc29ucyB3b3JrLlxuXHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXFlcWVxXG5cdGlmICggKCBlbGVtLm93bmVyRG9jdW1lbnQgfHwgZWxlbSApICE9IGRvY3VtZW50ICkge1xuXHRcdHNldERvY3VtZW50KCBlbGVtICk7XG5cdH1cblxuXHR2YXIgZm4gPSBFeHByLmF0dHJIYW5kbGVbIG5hbWUudG9Mb3dlckNhc2UoKSBdLFxuXG5cdFx0Ly8gRG9uJ3QgZ2V0IGZvb2xlZCBieSBPYmplY3QucHJvdG90eXBlIHByb3BlcnRpZXMgKHNlZSB0cmFjLTEzODA3KVxuXHRcdHZhbCA9IGZuICYmIGhhc093bi5jYWxsKCBFeHByLmF0dHJIYW5kbGUsIG5hbWUudG9Mb3dlckNhc2UoKSApID9cblx0XHRcdGZuKCBlbGVtLCBuYW1lLCAhZG9jdW1lbnRJc0hUTUwgKSA6XG5cdFx0XHR1bmRlZmluZWQ7XG5cblx0aWYgKCB2YWwgIT09IHVuZGVmaW5lZCApIHtcblx0XHRyZXR1cm4gdmFsO1xuXHR9XG5cblx0cmV0dXJuIGVsZW0uZ2V0QXR0cmlidXRlKCBuYW1lICk7XG59O1xuXG5maW5kLmVycm9yID0gZnVuY3Rpb24oIG1zZyApIHtcblx0dGhyb3cgbmV3IEVycm9yKCBcIlN5bnRheCBlcnJvciwgdW5yZWNvZ25pemVkIGV4cHJlc3Npb246IFwiICsgbXNnICk7XG59O1xuXG4vKipcbiAqIERvY3VtZW50IHNvcnRpbmcgYW5kIHJlbW92aW5nIGR1cGxpY2F0ZXNcbiAqIEBwYXJhbSB7QXJyYXlMaWtlfSByZXN1bHRzXG4gKi9cbmpRdWVyeS51bmlxdWVTb3J0ID0gZnVuY3Rpb24oIHJlc3VsdHMgKSB7XG5cdHZhciBlbGVtLFxuXHRcdGR1cGxpY2F0ZXMgPSBbXSxcblx0XHRqID0gMCxcblx0XHRpID0gMDtcblxuXHQvLyBVbmxlc3Mgd2UgKmtub3cqIHdlIGNhbiBkZXRlY3QgZHVwbGljYXRlcywgYXNzdW1lIHRoZWlyIHByZXNlbmNlXG5cdC8vXG5cdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjArXG5cdC8vIFRlc3RpbmcgZm9yIGRldGVjdGluZyBkdXBsaWNhdGVzIGlzIHVucHJlZGljdGFibGUgc28gaW5zdGVhZCBhc3N1bWUgd2UgY2FuJ3Rcblx0Ly8gZGVwZW5kIG9uIGR1cGxpY2F0ZSBkZXRlY3Rpb24gaW4gYWxsIGJyb3dzZXJzIHdpdGhvdXQgYSBzdGFibGUgc29ydC5cblx0aGFzRHVwbGljYXRlID0gIXN1cHBvcnQuc29ydFN0YWJsZTtcblx0c29ydElucHV0ID0gIXN1cHBvcnQuc29ydFN0YWJsZSAmJiBzbGljZS5jYWxsKCByZXN1bHRzLCAwICk7XG5cdHNvcnQuY2FsbCggcmVzdWx0cywgc29ydE9yZGVyICk7XG5cblx0aWYgKCBoYXNEdXBsaWNhdGUgKSB7XG5cdFx0d2hpbGUgKCAoIGVsZW0gPSByZXN1bHRzWyBpKysgXSApICkge1xuXHRcdFx0aWYgKCBlbGVtID09PSByZXN1bHRzWyBpIF0gKSB7XG5cdFx0XHRcdGogPSBkdXBsaWNhdGVzLnB1c2goIGkgKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0d2hpbGUgKCBqLS0gKSB7XG5cdFx0XHRzcGxpY2UuY2FsbCggcmVzdWx0cywgZHVwbGljYXRlc1sgaiBdLCAxICk7XG5cdFx0fVxuXHR9XG5cblx0Ly8gQ2xlYXIgaW5wdXQgYWZ0ZXIgc29ydGluZyB0byByZWxlYXNlIG9iamVjdHNcblx0Ly8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9qcXVlcnkvc2l6emxlL3B1bGwvMjI1XG5cdHNvcnRJbnB1dCA9IG51bGw7XG5cblx0cmV0dXJuIHJlc3VsdHM7XG59O1xuXG5qUXVlcnkuZm4udW5pcXVlU29ydCA9IGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIGpRdWVyeS51bmlxdWVTb3J0KCBzbGljZS5hcHBseSggdGhpcyApICkgKTtcbn07XG5cbkV4cHIgPSBqUXVlcnkuZXhwciA9IHtcblxuXHQvLyBDYW4gYmUgYWRqdXN0ZWQgYnkgdGhlIHVzZXJcblx0Y2FjaGVMZW5ndGg6IDUwLFxuXG5cdGNyZWF0ZVBzZXVkbzogbWFya0Z1bmN0aW9uLFxuXG5cdG1hdGNoOiBtYXRjaEV4cHIsXG5cblx0YXR0ckhhbmRsZToge30sXG5cblx0ZmluZDoge30sXG5cblx0cmVsYXRpdmU6IHtcblx0XHRcIj5cIjogeyBkaXI6IFwicGFyZW50Tm9kZVwiLCBmaXJzdDogdHJ1ZSB9LFxuXHRcdFwiIFwiOiB7IGRpcjogXCJwYXJlbnROb2RlXCIgfSxcblx0XHRcIitcIjogeyBkaXI6IFwicHJldmlvdXNTaWJsaW5nXCIsIGZpcnN0OiB0cnVlIH0sXG5cdFx0XCJ+XCI6IHsgZGlyOiBcInByZXZpb3VzU2libGluZ1wiIH1cblx0fSxcblxuXHRwcmVGaWx0ZXI6IHtcblx0XHRBVFRSOiBmdW5jdGlvbiggbWF0Y2ggKSB7XG5cdFx0XHRtYXRjaFsgMSBdID0gbWF0Y2hbIDEgXS5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApO1xuXG5cdFx0XHQvLyBNb3ZlIHRoZSBnaXZlbiB2YWx1ZSB0byBtYXRjaFszXSB3aGV0aGVyIHF1b3RlZCBvciB1bnF1b3RlZFxuXHRcdFx0bWF0Y2hbIDMgXSA9ICggbWF0Y2hbIDMgXSB8fCBtYXRjaFsgNCBdIHx8IG1hdGNoWyA1IF0gfHwgXCJcIiApXG5cdFx0XHRcdC5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApO1xuXG5cdFx0XHRpZiAoIG1hdGNoWyAyIF0gPT09IFwifj1cIiApIHtcblx0XHRcdFx0bWF0Y2hbIDMgXSA9IFwiIFwiICsgbWF0Y2hbIDMgXSArIFwiIFwiO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gbWF0Y2guc2xpY2UoIDAsIDQgKTtcblx0XHR9LFxuXG5cdFx0Q0hJTEQ6IGZ1bmN0aW9uKCBtYXRjaCApIHtcblxuXHRcdFx0LyogbWF0Y2hlcyBmcm9tIG1hdGNoRXhwcltcIkNISUxEXCJdXG5cdFx0XHRcdDEgdHlwZSAob25seXxudGh8Li4uKVxuXHRcdFx0XHQyIHdoYXQgKGNoaWxkfG9mLXR5cGUpXG5cdFx0XHRcdDMgYXJndW1lbnQgKGV2ZW58b2RkfFxcZCp8XFxkKm4oWystXVxcZCspP3wuLi4pXG5cdFx0XHRcdDQgeG4tY29tcG9uZW50IG9mIHhuK3kgYXJndW1lbnQgKFsrLV0/XFxkKm58KVxuXHRcdFx0XHQ1IHNpZ24gb2YgeG4tY29tcG9uZW50XG5cdFx0XHRcdDYgeCBvZiB4bi1jb21wb25lbnRcblx0XHRcdFx0NyBzaWduIG9mIHktY29tcG9uZW50XG5cdFx0XHRcdDggeSBvZiB5LWNvbXBvbmVudFxuXHRcdFx0Ki9cblx0XHRcdG1hdGNoWyAxIF0gPSBtYXRjaFsgMSBdLnRvTG93ZXJDYXNlKCk7XG5cblx0XHRcdGlmICggbWF0Y2hbIDEgXS5zbGljZSggMCwgMyApID09PSBcIm50aFwiICkge1xuXG5cdFx0XHRcdC8vIG50aC0qIHJlcXVpcmVzIGFyZ3VtZW50XG5cdFx0XHRcdGlmICggIW1hdGNoWyAzIF0gKSB7XG5cdFx0XHRcdFx0ZmluZC5lcnJvciggbWF0Y2hbIDAgXSApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gbnVtZXJpYyB4IGFuZCB5IHBhcmFtZXRlcnMgZm9yIEV4cHIuZmlsdGVyLkNISUxEXG5cdFx0XHRcdC8vIHJlbWVtYmVyIHRoYXQgZmFsc2UvdHJ1ZSBjYXN0IHJlc3BlY3RpdmVseSB0byAwLzFcblx0XHRcdFx0bWF0Y2hbIDQgXSA9ICsoIG1hdGNoWyA0IF0gP1xuXHRcdFx0XHRcdG1hdGNoWyA1IF0gKyAoIG1hdGNoWyA2IF0gfHwgMSApIDpcblx0XHRcdFx0XHQyICogKCBtYXRjaFsgMyBdID09PSBcImV2ZW5cIiB8fCBtYXRjaFsgMyBdID09PSBcIm9kZFwiIClcblx0XHRcdFx0KTtcblx0XHRcdFx0bWF0Y2hbIDUgXSA9ICsoICggbWF0Y2hbIDcgXSArIG1hdGNoWyA4IF0gKSB8fCBtYXRjaFsgMyBdID09PSBcIm9kZFwiICk7XG5cblx0XHRcdC8vIG90aGVyIHR5cGVzIHByb2hpYml0IGFyZ3VtZW50c1xuXHRcdFx0fSBlbHNlIGlmICggbWF0Y2hbIDMgXSApIHtcblx0XHRcdFx0ZmluZC5lcnJvciggbWF0Y2hbIDAgXSApO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gbWF0Y2g7XG5cdFx0fSxcblxuXHRcdFBTRVVETzogZnVuY3Rpb24oIG1hdGNoICkge1xuXHRcdFx0dmFyIGV4Y2Vzcyxcblx0XHRcdFx0dW5xdW90ZWQgPSAhbWF0Y2hbIDYgXSAmJiBtYXRjaFsgMiBdO1xuXG5cdFx0XHRpZiAoIG1hdGNoRXhwci5DSElMRC50ZXN0KCBtYXRjaFsgMCBdICkgKSB7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBBY2NlcHQgcXVvdGVkIGFyZ3VtZW50cyBhcy1pc1xuXHRcdFx0aWYgKCBtYXRjaFsgMyBdICkge1xuXHRcdFx0XHRtYXRjaFsgMiBdID0gbWF0Y2hbIDQgXSB8fCBtYXRjaFsgNSBdIHx8IFwiXCI7XG5cblx0XHRcdC8vIFN0cmlwIGV4Y2VzcyBjaGFyYWN0ZXJzIGZyb20gdW5xdW90ZWQgYXJndW1lbnRzXG5cdFx0XHR9IGVsc2UgaWYgKCB1bnF1b3RlZCAmJiBycHNldWRvLnRlc3QoIHVucXVvdGVkICkgJiZcblxuXHRcdFx0XHQvLyBHZXQgZXhjZXNzIGZyb20gdG9rZW5pemUgKHJlY3Vyc2l2ZWx5KVxuXHRcdFx0XHQoIGV4Y2VzcyA9IHRva2VuaXplKCB1bnF1b3RlZCwgdHJ1ZSApICkgJiZcblxuXHRcdFx0XHQvLyBhZHZhbmNlIHRvIHRoZSBuZXh0IGNsb3NpbmcgcGFyZW50aGVzaXNcblx0XHRcdFx0KCBleGNlc3MgPSB1bnF1b3RlZC5pbmRleE9mKCBcIilcIiwgdW5xdW90ZWQubGVuZ3RoIC0gZXhjZXNzICkgLSB1bnF1b3RlZC5sZW5ndGggKSApIHtcblxuXHRcdFx0XHQvLyBleGNlc3MgaXMgYSBuZWdhdGl2ZSBpbmRleFxuXHRcdFx0XHRtYXRjaFsgMCBdID0gbWF0Y2hbIDAgXS5zbGljZSggMCwgZXhjZXNzICk7XG5cdFx0XHRcdG1hdGNoWyAyIF0gPSB1bnF1b3RlZC5zbGljZSggMCwgZXhjZXNzICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFJldHVybiBvbmx5IGNhcHR1cmVzIG5lZWRlZCBieSB0aGUgcHNldWRvIGZpbHRlciBtZXRob2QgKHR5cGUgYW5kIGFyZ3VtZW50KVxuXHRcdFx0cmV0dXJuIG1hdGNoLnNsaWNlKCAwLCAzICk7XG5cdFx0fVxuXHR9LFxuXG5cdGZpbHRlcjoge1xuXG5cdFx0VEFHOiBmdW5jdGlvbiggbm9kZU5hbWVTZWxlY3RvciApIHtcblx0XHRcdHZhciBleHBlY3RlZE5vZGVOYW1lID0gbm9kZU5hbWVTZWxlY3Rvci5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRyZXR1cm4gbm9kZU5hbWVTZWxlY3RvciA9PT0gXCIqXCIgP1xuXHRcdFx0XHRmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0fSA6XG5cdFx0XHRcdGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRcdHJldHVybiBub2RlTmFtZSggZWxlbSwgZXhwZWN0ZWROb2RlTmFtZSApO1xuXHRcdFx0XHR9O1xuXHRcdH0sXG5cblx0XHRDTEFTUzogZnVuY3Rpb24oIGNsYXNzTmFtZSApIHtcblx0XHRcdHZhciBwYXR0ZXJuID0gY2xhc3NDYWNoZVsgY2xhc3NOYW1lICsgXCIgXCIgXTtcblxuXHRcdFx0cmV0dXJuIHBhdHRlcm4gfHxcblx0XHRcdFx0KCBwYXR0ZXJuID0gbmV3IFJlZ0V4cCggXCIoXnxcIiArIHdoaXRlc3BhY2UgKyBcIilcIiArIGNsYXNzTmFtZSArXG5cdFx0XHRcdFx0XCIoXCIgKyB3aGl0ZXNwYWNlICsgXCJ8JClcIiApICkgJiZcblx0XHRcdFx0Y2xhc3NDYWNoZSggY2xhc3NOYW1lLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0XHRyZXR1cm4gcGF0dGVybi50ZXN0KFxuXHRcdFx0XHRcdFx0dHlwZW9mIGVsZW0uY2xhc3NOYW1lID09PSBcInN0cmluZ1wiICYmIGVsZW0uY2xhc3NOYW1lIHx8XG5cdFx0XHRcdFx0XHRcdHR5cGVvZiBlbGVtLmdldEF0dHJpYnV0ZSAhPT0gXCJ1bmRlZmluZWRcIiAmJlxuXHRcdFx0XHRcdFx0XHRcdGVsZW0uZ2V0QXR0cmlidXRlKCBcImNsYXNzXCIgKSB8fFxuXHRcdFx0XHRcdFx0XHRcIlwiXG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0fSApO1xuXHRcdH0sXG5cblx0XHRBVFRSOiBmdW5jdGlvbiggbmFtZSwgb3BlcmF0b3IsIGNoZWNrICkge1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHR2YXIgcmVzdWx0ID0gZmluZC5hdHRyKCBlbGVtLCBuYW1lICk7XG5cblx0XHRcdFx0aWYgKCByZXN1bHQgPT0gbnVsbCApIHtcblx0XHRcdFx0XHRyZXR1cm4gb3BlcmF0b3IgPT09IFwiIT1cIjtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoICFvcGVyYXRvciApIHtcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJlc3VsdCArPSBcIlwiO1xuXG5cdFx0XHRcdGlmICggb3BlcmF0b3IgPT09IFwiPVwiICkge1xuXHRcdFx0XHRcdHJldHVybiByZXN1bHQgPT09IGNoZWNrO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggb3BlcmF0b3IgPT09IFwiIT1cIiApIHtcblx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0ICE9PSBjaGVjaztcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIG9wZXJhdG9yID09PSBcIl49XCIgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGNoZWNrICYmIHJlc3VsdC5pbmRleE9mKCBjaGVjayApID09PSAwO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggb3BlcmF0b3IgPT09IFwiKj1cIiApIHtcblx0XHRcdFx0XHRyZXR1cm4gY2hlY2sgJiYgcmVzdWx0LmluZGV4T2YoIGNoZWNrICkgPiAtMTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIG9wZXJhdG9yID09PSBcIiQ9XCIgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGNoZWNrICYmIHJlc3VsdC5zbGljZSggLWNoZWNrLmxlbmd0aCApID09PSBjaGVjaztcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIG9wZXJhdG9yID09PSBcIn49XCIgKSB7XG5cdFx0XHRcdFx0cmV0dXJuICggXCIgXCIgKyByZXN1bHQucmVwbGFjZSggcndoaXRlc3BhY2UsIFwiIFwiICkgKyBcIiBcIiApXG5cdFx0XHRcdFx0XHQuaW5kZXhPZiggY2hlY2sgKSA+IC0xO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggb3BlcmF0b3IgPT09IFwifD1cIiApIHtcblx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0ID09PSBjaGVjayB8fCByZXN1bHQuc2xpY2UoIDAsIGNoZWNrLmxlbmd0aCArIDEgKSA9PT0gY2hlY2sgKyBcIi1cIjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH07XG5cdFx0fSxcblxuXHRcdENISUxEOiBmdW5jdGlvbiggdHlwZSwgd2hhdCwgX2FyZ3VtZW50LCBmaXJzdCwgbGFzdCApIHtcblx0XHRcdHZhciBzaW1wbGUgPSB0eXBlLnNsaWNlKCAwLCAzICkgIT09IFwibnRoXCIsXG5cdFx0XHRcdGZvcndhcmQgPSB0eXBlLnNsaWNlKCAtNCApICE9PSBcImxhc3RcIixcblx0XHRcdFx0b2ZUeXBlID0gd2hhdCA9PT0gXCJvZi10eXBlXCI7XG5cblx0XHRcdHJldHVybiBmaXJzdCA9PT0gMSAmJiBsYXN0ID09PSAwID9cblxuXHRcdFx0XHQvLyBTaG9ydGN1dCBmb3IgOm50aC0qKG4pXG5cdFx0XHRcdGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRcdHJldHVybiAhIWVsZW0ucGFyZW50Tm9kZTtcblx0XHRcdFx0fSA6XG5cblx0XHRcdFx0ZnVuY3Rpb24oIGVsZW0sIF9jb250ZXh0LCB4bWwgKSB7XG5cdFx0XHRcdFx0dmFyIGNhY2hlLCBvdXRlckNhY2hlLCBub2RlLCBub2RlSW5kZXgsIHN0YXJ0LFxuXHRcdFx0XHRcdFx0ZGlyID0gc2ltcGxlICE9PSBmb3J3YXJkID8gXCJuZXh0U2libGluZ1wiIDogXCJwcmV2aW91c1NpYmxpbmdcIixcblx0XHRcdFx0XHRcdHBhcmVudCA9IGVsZW0ucGFyZW50Tm9kZSxcblx0XHRcdFx0XHRcdG5hbWUgPSBvZlR5cGUgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpLFxuXHRcdFx0XHRcdFx0dXNlQ2FjaGUgPSAheG1sICYmICFvZlR5cGUsXG5cdFx0XHRcdFx0XHRkaWZmID0gZmFsc2U7XG5cblx0XHRcdFx0XHRpZiAoIHBhcmVudCApIHtcblxuXHRcdFx0XHRcdFx0Ly8gOihmaXJzdHxsYXN0fG9ubHkpLShjaGlsZHxvZi10eXBlKVxuXHRcdFx0XHRcdFx0aWYgKCBzaW1wbGUgKSB7XG5cdFx0XHRcdFx0XHRcdHdoaWxlICggZGlyICkge1xuXHRcdFx0XHRcdFx0XHRcdG5vZGUgPSBlbGVtO1xuXHRcdFx0XHRcdFx0XHRcdHdoaWxlICggKCBub2RlID0gbm9kZVsgZGlyIF0gKSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdGlmICggb2ZUeXBlID9cblx0XHRcdFx0XHRcdFx0XHRcdFx0bm9kZU5hbWUoIG5vZGUsIG5hbWUgKSA6XG5cdFx0XHRcdFx0XHRcdFx0XHRcdG5vZGUubm9kZVR5cGUgPT09IDEgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdC8vIFJldmVyc2UgZGlyZWN0aW9uIGZvciA6b25seS0qIChpZiB3ZSBoYXZlbid0IHlldCBkb25lIHNvKVxuXHRcdFx0XHRcdFx0XHRcdHN0YXJ0ID0gZGlyID0gdHlwZSA9PT0gXCJvbmx5XCIgJiYgIXN0YXJ0ICYmIFwibmV4dFNpYmxpbmdcIjtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0c3RhcnQgPSBbIGZvcndhcmQgPyBwYXJlbnQuZmlyc3RDaGlsZCA6IHBhcmVudC5sYXN0Q2hpbGQgXTtcblxuXHRcdFx0XHRcdFx0Ly8gbm9uLXhtbCA6bnRoLWNoaWxkKC4uLikgc3RvcmVzIGNhY2hlIGRhdGEgb24gYHBhcmVudGBcblx0XHRcdFx0XHRcdGlmICggZm9yd2FyZCAmJiB1c2VDYWNoZSApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBTZWVrIGBlbGVtYCBmcm9tIGEgcHJldmlvdXNseS1jYWNoZWQgaW5kZXhcblx0XHRcdFx0XHRcdFx0b3V0ZXJDYWNoZSA9IHBhcmVudFsgZXhwYW5kbyBdIHx8ICggcGFyZW50WyBleHBhbmRvIF0gPSB7fSApO1xuXHRcdFx0XHRcdFx0XHRjYWNoZSA9IG91dGVyQ2FjaGVbIHR5cGUgXSB8fCBbXTtcblx0XHRcdFx0XHRcdFx0bm9kZUluZGV4ID0gY2FjaGVbIDAgXSA9PT0gZGlycnVucyAmJiBjYWNoZVsgMSBdO1xuXHRcdFx0XHRcdFx0XHRkaWZmID0gbm9kZUluZGV4ICYmIGNhY2hlWyAyIF07XG5cdFx0XHRcdFx0XHRcdG5vZGUgPSBub2RlSW5kZXggJiYgcGFyZW50LmNoaWxkTm9kZXNbIG5vZGVJbmRleCBdO1xuXG5cdFx0XHRcdFx0XHRcdHdoaWxlICggKCBub2RlID0gKytub2RlSW5kZXggJiYgbm9kZSAmJiBub2RlWyBkaXIgXSB8fFxuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gRmFsbGJhY2sgdG8gc2Vla2luZyBgZWxlbWAgZnJvbSB0aGUgc3RhcnRcblx0XHRcdFx0XHRcdFx0XHQoIGRpZmYgPSBub2RlSW5kZXggPSAwICkgfHwgc3RhcnQucG9wKCkgKSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIFdoZW4gZm91bmQsIGNhY2hlIGluZGV4ZXMgb24gYHBhcmVudGAgYW5kIGJyZWFrXG5cdFx0XHRcdFx0XHRcdFx0aWYgKCBub2RlLm5vZGVUeXBlID09PSAxICYmICsrZGlmZiAmJiBub2RlID09PSBlbGVtICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0b3V0ZXJDYWNoZVsgdHlwZSBdID0gWyBkaXJydW5zLCBub2RlSW5kZXgsIGRpZmYgXTtcblx0XHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdC8vIFVzZSBwcmV2aW91c2x5LWNhY2hlZCBlbGVtZW50IGluZGV4IGlmIGF2YWlsYWJsZVxuXHRcdFx0XHRcdFx0XHRpZiAoIHVzZUNhY2hlICkge1xuXHRcdFx0XHRcdFx0XHRcdG91dGVyQ2FjaGUgPSBlbGVtWyBleHBhbmRvIF0gfHwgKCBlbGVtWyBleHBhbmRvIF0gPSB7fSApO1xuXHRcdFx0XHRcdFx0XHRcdGNhY2hlID0gb3V0ZXJDYWNoZVsgdHlwZSBdIHx8IFtdO1xuXHRcdFx0XHRcdFx0XHRcdG5vZGVJbmRleCA9IGNhY2hlWyAwIF0gPT09IGRpcnJ1bnMgJiYgY2FjaGVbIDEgXTtcblx0XHRcdFx0XHRcdFx0XHRkaWZmID0gbm9kZUluZGV4O1xuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0Ly8geG1sIDpudGgtY2hpbGQoLi4uKVxuXHRcdFx0XHRcdFx0XHQvLyBvciA6bnRoLWxhc3QtY2hpbGQoLi4uKSBvciA6bnRoKC1sYXN0KT8tb2YtdHlwZSguLi4pXG5cdFx0XHRcdFx0XHRcdGlmICggZGlmZiA9PT0gZmFsc2UgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBVc2UgdGhlIHNhbWUgbG9vcCBhcyBhYm92ZSB0byBzZWVrIGBlbGVtYCBmcm9tIHRoZSBzdGFydFxuXHRcdFx0XHRcdFx0XHRcdHdoaWxlICggKCBub2RlID0gKytub2RlSW5kZXggJiYgbm9kZSAmJiBub2RlWyBkaXIgXSB8fFxuXHRcdFx0XHRcdFx0XHRcdFx0KCBkaWZmID0gbm9kZUluZGV4ID0gMCApIHx8IHN0YXJ0LnBvcCgpICkgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdGlmICggKCBvZlR5cGUgP1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRub2RlTmFtZSggbm9kZSwgbmFtZSApIDpcblx0XHRcdFx0XHRcdFx0XHRcdFx0bm9kZS5ub2RlVHlwZSA9PT0gMSApICYmXG5cdFx0XHRcdFx0XHRcdFx0XHRcdCsrZGlmZiApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBDYWNoZSB0aGUgaW5kZXggb2YgZWFjaCBlbmNvdW50ZXJlZCBlbGVtZW50XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlmICggdXNlQ2FjaGUgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0b3V0ZXJDYWNoZSA9IG5vZGVbIGV4cGFuZG8gXSB8fFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0KCBub2RlWyBleHBhbmRvIF0gPSB7fSApO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdG91dGVyQ2FjaGVbIHR5cGUgXSA9IFsgZGlycnVucywgZGlmZiBdO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBub2RlID09PSBlbGVtICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdC8vIEluY29ycG9yYXRlIHRoZSBvZmZzZXQsIHRoZW4gY2hlY2sgYWdhaW5zdCBjeWNsZSBzaXplXG5cdFx0XHRcdFx0XHRkaWZmIC09IGxhc3Q7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZGlmZiA9PT0gZmlyc3QgfHwgKCBkaWZmICUgZmlyc3QgPT09IDAgJiYgZGlmZiAvIGZpcnN0ID49IDAgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH07XG5cdFx0fSxcblxuXHRcdFBTRVVETzogZnVuY3Rpb24oIHBzZXVkbywgYXJndW1lbnQgKSB7XG5cblx0XHRcdC8vIHBzZXVkby1jbGFzcyBuYW1lcyBhcmUgY2FzZS1pbnNlbnNpdGl2ZVxuXHRcdFx0Ly8gaHR0cHM6Ly93d3cudzMub3JnL1RSL3NlbGVjdG9ycy8jcHNldWRvLWNsYXNzZXNcblx0XHRcdC8vIFByaW9yaXRpemUgYnkgY2FzZSBzZW5zaXRpdml0eSBpbiBjYXNlIGN1c3RvbSBwc2V1ZG9zIGFyZSBhZGRlZCB3aXRoIHVwcGVyY2FzZSBsZXR0ZXJzXG5cdFx0XHQvLyBSZW1lbWJlciB0aGF0IHNldEZpbHRlcnMgaW5oZXJpdHMgZnJvbSBwc2V1ZG9zXG5cdFx0XHR2YXIgYXJncyxcblx0XHRcdFx0Zm4gPSBFeHByLnBzZXVkb3NbIHBzZXVkbyBdIHx8IEV4cHIuc2V0RmlsdGVyc1sgcHNldWRvLnRvTG93ZXJDYXNlKCkgXSB8fFxuXHRcdFx0XHRcdGZpbmQuZXJyb3IoIFwidW5zdXBwb3J0ZWQgcHNldWRvOiBcIiArIHBzZXVkbyApO1xuXG5cdFx0XHQvLyBUaGUgdXNlciBtYXkgdXNlIGNyZWF0ZVBzZXVkbyB0byBpbmRpY2F0ZSB0aGF0XG5cdFx0XHQvLyBhcmd1bWVudHMgYXJlIG5lZWRlZCB0byBjcmVhdGUgdGhlIGZpbHRlciBmdW5jdGlvblxuXHRcdFx0Ly8ganVzdCBhcyBqUXVlcnkgZG9lc1xuXHRcdFx0aWYgKCBmblsgZXhwYW5kbyBdICkge1xuXHRcdFx0XHRyZXR1cm4gZm4oIGFyZ3VtZW50ICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEJ1dCBtYWludGFpbiBzdXBwb3J0IGZvciBvbGQgc2lnbmF0dXJlc1xuXHRcdFx0aWYgKCBmbi5sZW5ndGggPiAxICkge1xuXHRcdFx0XHRhcmdzID0gWyBwc2V1ZG8sIHBzZXVkbywgXCJcIiwgYXJndW1lbnQgXTtcblx0XHRcdFx0cmV0dXJuIEV4cHIuc2V0RmlsdGVycy5oYXNPd25Qcm9wZXJ0eSggcHNldWRvLnRvTG93ZXJDYXNlKCkgKSA/XG5cdFx0XHRcdFx0bWFya0Z1bmN0aW9uKCBmdW5jdGlvbiggc2VlZCwgbWF0Y2hlcyApIHtcblx0XHRcdFx0XHRcdHZhciBpZHgsXG5cdFx0XHRcdFx0XHRcdG1hdGNoZWQgPSBmbiggc2VlZCwgYXJndW1lbnQgKSxcblx0XHRcdFx0XHRcdFx0aSA9IG1hdGNoZWQubGVuZ3RoO1xuXHRcdFx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0XHRcdGlkeCA9IGluZGV4T2YuY2FsbCggc2VlZCwgbWF0Y2hlZFsgaSBdICk7XG5cdFx0XHRcdFx0XHRcdHNlZWRbIGlkeCBdID0gISggbWF0Y2hlc1sgaWR4IF0gPSBtYXRjaGVkWyBpIF0gKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9ICkgOlxuXHRcdFx0XHRcdGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGZuKCBlbGVtLCAwLCBhcmdzICk7XG5cdFx0XHRcdFx0fTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGZuO1xuXHRcdH1cblx0fSxcblxuXHRwc2V1ZG9zOiB7XG5cblx0XHQvLyBQb3RlbnRpYWxseSBjb21wbGV4IHBzZXVkb3Ncblx0XHRub3Q6IG1hcmtGdW5jdGlvbiggZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXG5cdFx0XHQvLyBUcmltIHRoZSBzZWxlY3RvciBwYXNzZWQgdG8gY29tcGlsZVxuXHRcdFx0Ly8gdG8gYXZvaWQgdHJlYXRpbmcgbGVhZGluZyBhbmQgdHJhaWxpbmdcblx0XHRcdC8vIHNwYWNlcyBhcyBjb21iaW5hdG9yc1xuXHRcdFx0dmFyIGlucHV0ID0gW10sXG5cdFx0XHRcdHJlc3VsdHMgPSBbXSxcblx0XHRcdFx0bWF0Y2hlciA9IGNvbXBpbGUoIHNlbGVjdG9yLnJlcGxhY2UoIHJ0cmltQ1NTLCBcIiQxXCIgKSApO1xuXG5cdFx0XHRyZXR1cm4gbWF0Y2hlclsgZXhwYW5kbyBdID9cblx0XHRcdFx0bWFya0Z1bmN0aW9uKCBmdW5jdGlvbiggc2VlZCwgbWF0Y2hlcywgX2NvbnRleHQsIHhtbCApIHtcblx0XHRcdFx0XHR2YXIgZWxlbSxcblx0XHRcdFx0XHRcdHVubWF0Y2hlZCA9IG1hdGNoZXIoIHNlZWQsIG51bGwsIHhtbCwgW10gKSxcblx0XHRcdFx0XHRcdGkgPSBzZWVkLmxlbmd0aDtcblxuXHRcdFx0XHRcdC8vIE1hdGNoIGVsZW1lbnRzIHVubWF0Y2hlZCBieSBgbWF0Y2hlcmBcblx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRcdGlmICggKCBlbGVtID0gdW5tYXRjaGVkWyBpIF0gKSApIHtcblx0XHRcdFx0XHRcdFx0c2VlZFsgaSBdID0gISggbWF0Y2hlc1sgaSBdID0gZWxlbSApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSApIDpcblx0XHRcdFx0ZnVuY3Rpb24oIGVsZW0sIF9jb250ZXh0LCB4bWwgKSB7XG5cdFx0XHRcdFx0aW5wdXRbIDAgXSA9IGVsZW07XG5cdFx0XHRcdFx0bWF0Y2hlciggaW5wdXQsIG51bGwsIHhtbCwgcmVzdWx0cyApO1xuXG5cdFx0XHRcdFx0Ly8gRG9uJ3Qga2VlcCB0aGUgZWxlbWVudFxuXHRcdFx0XHRcdC8vIChzZWUgaHR0cHM6Ly9naXRodWIuY29tL2pxdWVyeS9zaXp6bGUvaXNzdWVzLzI5OSlcblx0XHRcdFx0XHRpbnB1dFsgMCBdID0gbnVsbDtcblx0XHRcdFx0XHRyZXR1cm4gIXJlc3VsdHMucG9wKCk7XG5cdFx0XHRcdH07XG5cdFx0fSApLFxuXG5cdFx0aGFzOiBtYXJrRnVuY3Rpb24oIGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRcdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0cmV0dXJuIGZpbmQoIHNlbGVjdG9yLCBlbGVtICkubGVuZ3RoID4gMDtcblx0XHRcdH07XG5cdFx0fSApLFxuXG5cdFx0Y29udGFpbnM6IG1hcmtGdW5jdGlvbiggZnVuY3Rpb24oIHRleHQgKSB7XG5cdFx0XHR0ZXh0ID0gdGV4dC5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApO1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRyZXR1cm4gKCBlbGVtLnRleHRDb250ZW50IHx8IGpRdWVyeS50ZXh0KCBlbGVtICkgKS5pbmRleE9mKCB0ZXh0ICkgPiAtMTtcblx0XHRcdH07XG5cdFx0fSApLFxuXG5cdFx0Ly8gXCJXaGV0aGVyIGFuIGVsZW1lbnQgaXMgcmVwcmVzZW50ZWQgYnkgYSA6bGFuZygpIHNlbGVjdG9yXG5cdFx0Ly8gaXMgYmFzZWQgc29sZWx5IG9uIHRoZSBlbGVtZW50J3MgbGFuZ3VhZ2UgdmFsdWVcblx0XHQvLyBiZWluZyBlcXVhbCB0byB0aGUgaWRlbnRpZmllciBDLFxuXHRcdC8vIG9yIGJlZ2lubmluZyB3aXRoIHRoZSBpZGVudGlmaWVyIEMgaW1tZWRpYXRlbHkgZm9sbG93ZWQgYnkgXCItXCIuXG5cdFx0Ly8gVGhlIG1hdGNoaW5nIG9mIEMgYWdhaW5zdCB0aGUgZWxlbWVudCdzIGxhbmd1YWdlIHZhbHVlIGlzIHBlcmZvcm1lZCBjYXNlLWluc2Vuc2l0aXZlbHkuXG5cdFx0Ly8gVGhlIGlkZW50aWZpZXIgQyBkb2VzIG5vdCBoYXZlIHRvIGJlIGEgdmFsaWQgbGFuZ3VhZ2UgbmFtZS5cIlxuXHRcdC8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9zZWxlY3RvcnMvI2xhbmctcHNldWRvXG5cdFx0bGFuZzogbWFya0Z1bmN0aW9uKCBmdW5jdGlvbiggbGFuZyApIHtcblxuXHRcdFx0Ly8gbGFuZyB2YWx1ZSBtdXN0IGJlIGEgdmFsaWQgaWRlbnRpZmllclxuXHRcdFx0aWYgKCAhcmlkZW50aWZpZXIudGVzdCggbGFuZyB8fCBcIlwiICkgKSB7XG5cdFx0XHRcdGZpbmQuZXJyb3IoIFwidW5zdXBwb3J0ZWQgbGFuZzogXCIgKyBsYW5nICk7XG5cdFx0XHR9XG5cdFx0XHRsYW5nID0gbGFuZy5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHZhciBlbGVtTGFuZztcblx0XHRcdFx0ZG8ge1xuXHRcdFx0XHRcdGlmICggKCBlbGVtTGFuZyA9IGRvY3VtZW50SXNIVE1MID9cblx0XHRcdFx0XHRcdGVsZW0ubGFuZyA6XG5cdFx0XHRcdFx0XHRlbGVtLmdldEF0dHJpYnV0ZSggXCJ4bWw6bGFuZ1wiICkgfHwgZWxlbS5nZXRBdHRyaWJ1dGUoIFwibGFuZ1wiICkgKSApIHtcblxuXHRcdFx0XHRcdFx0ZWxlbUxhbmcgPSBlbGVtTGFuZy50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0XHRcdFx0cmV0dXJuIGVsZW1MYW5nID09PSBsYW5nIHx8IGVsZW1MYW5nLmluZGV4T2YoIGxhbmcgKyBcIi1cIiApID09PSAwO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSB3aGlsZSAoICggZWxlbSA9IGVsZW0ucGFyZW50Tm9kZSApICYmIGVsZW0ubm9kZVR5cGUgPT09IDEgKTtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fTtcblx0XHR9ICksXG5cblx0XHQvLyBNaXNjZWxsYW5lb3VzXG5cdFx0dGFyZ2V0OiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHZhciBoYXNoID0gd2luZG93LmxvY2F0aW9uICYmIHdpbmRvdy5sb2NhdGlvbi5oYXNoO1xuXHRcdFx0cmV0dXJuIGhhc2ggJiYgaGFzaC5zbGljZSggMSApID09PSBlbGVtLmlkO1xuXHRcdH0sXG5cblx0XHRyb290OiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBlbGVtID09PSBkb2N1bWVudEVsZW1lbnQ7XG5cdFx0fSxcblxuXHRcdGZvY3VzOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBlbGVtID09PSBzYWZlQWN0aXZlRWxlbWVudCgpICYmXG5cdFx0XHRcdGRvY3VtZW50Lmhhc0ZvY3VzKCkgJiZcblx0XHRcdFx0ISEoIGVsZW0udHlwZSB8fCBlbGVtLmhyZWYgfHwgfmVsZW0udGFiSW5kZXggKTtcblx0XHR9LFxuXG5cdFx0Ly8gQm9vbGVhbiBwcm9wZXJ0aWVzXG5cdFx0ZW5hYmxlZDogY3JlYXRlRGlzYWJsZWRQc2V1ZG8oIGZhbHNlICksXG5cdFx0ZGlzYWJsZWQ6IGNyZWF0ZURpc2FibGVkUHNldWRvKCB0cnVlICksXG5cblx0XHRjaGVja2VkOiBmdW5jdGlvbiggZWxlbSApIHtcblxuXHRcdFx0Ly8gSW4gQ1NTMywgOmNoZWNrZWQgc2hvdWxkIHJldHVybiBib3RoIGNoZWNrZWQgYW5kIHNlbGVjdGVkIGVsZW1lbnRzXG5cdFx0XHQvLyBodHRwczovL3d3dy53My5vcmcvVFIvMjAxMS9SRUMtY3NzMy1zZWxlY3RvcnMtMjAxMTA5MjkvI2NoZWNrZWRcblx0XHRcdHJldHVybiAoIG5vZGVOYW1lKCBlbGVtLCBcImlucHV0XCIgKSAmJiAhIWVsZW0uY2hlY2tlZCApIHx8XG5cdFx0XHRcdCggbm9kZU5hbWUoIGVsZW0sIFwib3B0aW9uXCIgKSAmJiAhIWVsZW0uc2VsZWN0ZWQgKTtcblx0XHR9LFxuXG5cdFx0c2VsZWN0ZWQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXG5cdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTExK1xuXHRcdFx0Ly8gQWNjZXNzaW5nIHRoZSBzZWxlY3RlZEluZGV4IHByb3BlcnR5XG5cdFx0XHQvLyBmb3JjZXMgdGhlIGJyb3dzZXIgdG8gdHJlYXQgdGhlIGRlZmF1bHQgb3B0aW9uIGFzXG5cdFx0XHQvLyBzZWxlY3RlZCB3aGVuIGluIGFuIG9wdGdyb3VwLlxuXHRcdFx0aWYgKCBlbGVtLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtZXhwcmVzc2lvbnNcblx0XHRcdFx0ZWxlbS5wYXJlbnROb2RlLnNlbGVjdGVkSW5kZXg7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBlbGVtLnNlbGVjdGVkID09PSB0cnVlO1xuXHRcdH0sXG5cblx0XHQvLyBDb250ZW50c1xuXHRcdGVtcHR5OiBmdW5jdGlvbiggZWxlbSApIHtcblxuXHRcdFx0Ly8gaHR0cHM6Ly93d3cudzMub3JnL1RSL3NlbGVjdG9ycy8jZW1wdHktcHNldWRvXG5cdFx0XHQvLyA6ZW1wdHkgaXMgbmVnYXRlZCBieSBlbGVtZW50ICgxKSBvciBjb250ZW50IG5vZGVzICh0ZXh0OiAzOyBjZGF0YTogNDsgZW50aXR5IHJlZjogNSksXG5cdFx0XHQvLyAgIGJ1dCBub3QgYnkgb3RoZXJzIChjb21tZW50OiA4OyBwcm9jZXNzaW5nIGluc3RydWN0aW9uOiA3OyBldGMuKVxuXHRcdFx0Ly8gbm9kZVR5cGUgPCA2IHdvcmtzIGJlY2F1c2UgYXR0cmlidXRlcyAoMikgZG8gbm90IGFwcGVhciBhcyBjaGlsZHJlblxuXHRcdFx0Zm9yICggZWxlbSA9IGVsZW0uZmlyc3RDaGlsZDsgZWxlbTsgZWxlbSA9IGVsZW0ubmV4dFNpYmxpbmcgKSB7XG5cdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA8IDYgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9LFxuXG5cdFx0cGFyZW50OiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiAhRXhwci5wc2V1ZG9zLmVtcHR5KCBlbGVtICk7XG5cdFx0fSxcblxuXHRcdC8vIEVsZW1lbnQvaW5wdXQgdHlwZXNcblx0XHRoZWFkZXI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIHJoZWFkZXIudGVzdCggZWxlbS5ub2RlTmFtZSApO1xuXHRcdH0sXG5cblx0XHRpbnB1dDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gcmlucHV0cy50ZXN0KCBlbGVtLm5vZGVOYW1lICk7XG5cdFx0fSxcblxuXHRcdGJ1dHRvbjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gbm9kZU5hbWUoIGVsZW0sIFwiaW5wdXRcIiApICYmIGVsZW0udHlwZSA9PT0gXCJidXR0b25cIiB8fFxuXHRcdFx0XHRub2RlTmFtZSggZWxlbSwgXCJidXR0b25cIiApO1xuXHRcdH0sXG5cblx0XHR0ZXh0OiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHZhciBhdHRyO1xuXHRcdFx0cmV0dXJuIG5vZGVOYW1lKCBlbGVtLCBcImlucHV0XCIgKSAmJiBlbGVtLnR5cGUgPT09IFwidGV4dFwiICYmXG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPDEwIG9ubHlcblx0XHRcdFx0Ly8gTmV3IEhUTUw1IGF0dHJpYnV0ZSB2YWx1ZXMgKGUuZy4sIFwic2VhcmNoXCIpIGFwcGVhclxuXHRcdFx0XHQvLyB3aXRoIGVsZW0udHlwZSA9PT0gXCJ0ZXh0XCJcblx0XHRcdFx0KCAoIGF0dHIgPSBlbGVtLmdldEF0dHJpYnV0ZSggXCJ0eXBlXCIgKSApID09IG51bGwgfHxcblx0XHRcdFx0XHRhdHRyLnRvTG93ZXJDYXNlKCkgPT09IFwidGV4dFwiICk7XG5cdFx0fSxcblxuXHRcdC8vIFBvc2l0aW9uLWluLWNvbGxlY3Rpb25cblx0XHRmaXJzdDogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyggZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gWyAwIF07XG5cdFx0fSApLFxuXG5cdFx0bGFzdDogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyggZnVuY3Rpb24oIF9tYXRjaEluZGV4ZXMsIGxlbmd0aCApIHtcblx0XHRcdHJldHVybiBbIGxlbmd0aCAtIDEgXTtcblx0XHR9ICksXG5cblx0XHRlcTogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyggZnVuY3Rpb24oIF9tYXRjaEluZGV4ZXMsIGxlbmd0aCwgYXJndW1lbnQgKSB7XG5cdFx0XHRyZXR1cm4gWyBhcmd1bWVudCA8IDAgPyBhcmd1bWVudCArIGxlbmd0aCA6IGFyZ3VtZW50IF07XG5cdFx0fSApLFxuXG5cdFx0ZXZlbjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyggZnVuY3Rpb24oIG1hdGNoSW5kZXhlcywgbGVuZ3RoICkge1xuXHRcdFx0dmFyIGkgPSAwO1xuXHRcdFx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpICs9IDIgKSB7XG5cdFx0XHRcdG1hdGNoSW5kZXhlcy5wdXNoKCBpICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbWF0Y2hJbmRleGVzO1xuXHRcdH0gKSxcblxuXHRcdG9kZDogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyggZnVuY3Rpb24oIG1hdGNoSW5kZXhlcywgbGVuZ3RoICkge1xuXHRcdFx0dmFyIGkgPSAxO1xuXHRcdFx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpICs9IDIgKSB7XG5cdFx0XHRcdG1hdGNoSW5kZXhlcy5wdXNoKCBpICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbWF0Y2hJbmRleGVzO1xuXHRcdH0gKSxcblxuXHRcdGx0OiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKCBmdW5jdGlvbiggbWF0Y2hJbmRleGVzLCBsZW5ndGgsIGFyZ3VtZW50ICkge1xuXHRcdFx0dmFyIGk7XG5cblx0XHRcdGlmICggYXJndW1lbnQgPCAwICkge1xuXHRcdFx0XHRpID0gYXJndW1lbnQgKyBsZW5ndGg7XG5cdFx0XHR9IGVsc2UgaWYgKCBhcmd1bWVudCA+IGxlbmd0aCApIHtcblx0XHRcdFx0aSA9IGxlbmd0aDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGkgPSBhcmd1bWVudDtcblx0XHRcdH1cblxuXHRcdFx0Zm9yICggOyAtLWkgPj0gMDsgKSB7XG5cdFx0XHRcdG1hdGNoSW5kZXhlcy5wdXNoKCBpICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbWF0Y2hJbmRleGVzO1xuXHRcdH0gKSxcblxuXHRcdGd0OiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKCBmdW5jdGlvbiggbWF0Y2hJbmRleGVzLCBsZW5ndGgsIGFyZ3VtZW50ICkge1xuXHRcdFx0dmFyIGkgPSBhcmd1bWVudCA8IDAgPyBhcmd1bWVudCArIGxlbmd0aCA6IGFyZ3VtZW50O1xuXHRcdFx0Zm9yICggOyArK2kgPCBsZW5ndGg7ICkge1xuXHRcdFx0XHRtYXRjaEluZGV4ZXMucHVzaCggaSApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG1hdGNoSW5kZXhlcztcblx0XHR9IClcblx0fVxufTtcblxuRXhwci5wc2V1ZG9zLm50aCA9IEV4cHIucHNldWRvcy5lcTtcblxuLy8gQWRkIGJ1dHRvbi9pbnB1dCB0eXBlIHBzZXVkb3NcbmZvciAoIGkgaW4geyByYWRpbzogdHJ1ZSwgY2hlY2tib3g6IHRydWUsIGZpbGU6IHRydWUsIHBhc3N3b3JkOiB0cnVlLCBpbWFnZTogdHJ1ZSB9ICkge1xuXHRFeHByLnBzZXVkb3NbIGkgXSA9IGNyZWF0ZUlucHV0UHNldWRvKCBpICk7XG59XG5mb3IgKCBpIGluIHsgc3VibWl0OiB0cnVlLCByZXNldDogdHJ1ZSB9ICkge1xuXHRFeHByLnBzZXVkb3NbIGkgXSA9IGNyZWF0ZUJ1dHRvblBzZXVkbyggaSApO1xufVxuXG4vLyBFYXN5IEFQSSBmb3IgY3JlYXRpbmcgbmV3IHNldEZpbHRlcnNcbmZ1bmN0aW9uIHNldEZpbHRlcnMoKSB7fVxuc2V0RmlsdGVycy5wcm90b3R5cGUgPSBFeHByLmZpbHRlcnMgPSBFeHByLnBzZXVkb3M7XG5FeHByLnNldEZpbHRlcnMgPSBuZXcgc2V0RmlsdGVycygpO1xuXG5mdW5jdGlvbiB0b2tlbml6ZSggc2VsZWN0b3IsIHBhcnNlT25seSApIHtcblx0dmFyIG1hdGNoZWQsIG1hdGNoLCB0b2tlbnMsIHR5cGUsXG5cdFx0c29GYXIsIGdyb3VwcywgcHJlRmlsdGVycyxcblx0XHRjYWNoZWQgPSB0b2tlbkNhY2hlWyBzZWxlY3RvciArIFwiIFwiIF07XG5cblx0aWYgKCBjYWNoZWQgKSB7XG5cdFx0cmV0dXJuIHBhcnNlT25seSA/IDAgOiBjYWNoZWQuc2xpY2UoIDAgKTtcblx0fVxuXG5cdHNvRmFyID0gc2VsZWN0b3I7XG5cdGdyb3VwcyA9IFtdO1xuXHRwcmVGaWx0ZXJzID0gRXhwci5wcmVGaWx0ZXI7XG5cblx0d2hpbGUgKCBzb0ZhciApIHtcblxuXHRcdC8vIENvbW1hIGFuZCBmaXJzdCBydW5cblx0XHRpZiAoICFtYXRjaGVkIHx8ICggbWF0Y2ggPSByY29tbWEuZXhlYyggc29GYXIgKSApICkge1xuXHRcdFx0aWYgKCBtYXRjaCApIHtcblxuXHRcdFx0XHQvLyBEb24ndCBjb25zdW1lIHRyYWlsaW5nIGNvbW1hcyBhcyB2YWxpZFxuXHRcdFx0XHRzb0ZhciA9IHNvRmFyLnNsaWNlKCBtYXRjaFsgMCBdLmxlbmd0aCApIHx8IHNvRmFyO1xuXHRcdFx0fVxuXHRcdFx0Z3JvdXBzLnB1c2goICggdG9rZW5zID0gW10gKSApO1xuXHRcdH1cblxuXHRcdG1hdGNoZWQgPSBmYWxzZTtcblxuXHRcdC8vIENvbWJpbmF0b3JzXG5cdFx0aWYgKCAoIG1hdGNoID0gcmxlYWRpbmdDb21iaW5hdG9yLmV4ZWMoIHNvRmFyICkgKSApIHtcblx0XHRcdG1hdGNoZWQgPSBtYXRjaC5zaGlmdCgpO1xuXHRcdFx0dG9rZW5zLnB1c2goIHtcblx0XHRcdFx0dmFsdWU6IG1hdGNoZWQsXG5cblx0XHRcdFx0Ly8gQ2FzdCBkZXNjZW5kYW50IGNvbWJpbmF0b3JzIHRvIHNwYWNlXG5cdFx0XHRcdHR5cGU6IG1hdGNoWyAwIF0ucmVwbGFjZSggcnRyaW1DU1MsIFwiIFwiIClcblx0XHRcdH0gKTtcblx0XHRcdHNvRmFyID0gc29GYXIuc2xpY2UoIG1hdGNoZWQubGVuZ3RoICk7XG5cdFx0fVxuXG5cdFx0Ly8gRmlsdGVyc1xuXHRcdGZvciAoIHR5cGUgaW4gRXhwci5maWx0ZXIgKSB7XG5cdFx0XHRpZiAoICggbWF0Y2ggPSBtYXRjaEV4cHJbIHR5cGUgXS5leGVjKCBzb0ZhciApICkgJiYgKCAhcHJlRmlsdGVyc1sgdHlwZSBdIHx8XG5cdFx0XHRcdCggbWF0Y2ggPSBwcmVGaWx0ZXJzWyB0eXBlIF0oIG1hdGNoICkgKSApICkge1xuXHRcdFx0XHRtYXRjaGVkID0gbWF0Y2guc2hpZnQoKTtcblx0XHRcdFx0dG9rZW5zLnB1c2goIHtcblx0XHRcdFx0XHR2YWx1ZTogbWF0Y2hlZCxcblx0XHRcdFx0XHR0eXBlOiB0eXBlLFxuXHRcdFx0XHRcdG1hdGNoZXM6IG1hdGNoXG5cdFx0XHRcdH0gKTtcblx0XHRcdFx0c29GYXIgPSBzb0Zhci5zbGljZSggbWF0Y2hlZC5sZW5ndGggKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoICFtYXRjaGVkICkge1xuXHRcdFx0YnJlYWs7XG5cdFx0fVxuXHR9XG5cblx0Ly8gUmV0dXJuIHRoZSBsZW5ndGggb2YgdGhlIGludmFsaWQgZXhjZXNzXG5cdC8vIGlmIHdlJ3JlIGp1c3QgcGFyc2luZ1xuXHQvLyBPdGhlcndpc2UsIHRocm93IGFuIGVycm9yIG9yIHJldHVybiB0b2tlbnNcblx0aWYgKCBwYXJzZU9ubHkgKSB7XG5cdFx0cmV0dXJuIHNvRmFyLmxlbmd0aDtcblx0fVxuXG5cdHJldHVybiBzb0ZhciA/XG5cdFx0ZmluZC5lcnJvciggc2VsZWN0b3IgKSA6XG5cblx0XHQvLyBDYWNoZSB0aGUgdG9rZW5zXG5cdFx0dG9rZW5DYWNoZSggc2VsZWN0b3IsIGdyb3VwcyApLnNsaWNlKCAwICk7XG59XG5cbmZ1bmN0aW9uIHRvU2VsZWN0b3IoIHRva2VucyApIHtcblx0dmFyIGkgPSAwLFxuXHRcdGxlbiA9IHRva2Vucy5sZW5ndGgsXG5cdFx0c2VsZWN0b3IgPSBcIlwiO1xuXHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRzZWxlY3RvciArPSB0b2tlbnNbIGkgXS52YWx1ZTtcblx0fVxuXHRyZXR1cm4gc2VsZWN0b3I7XG59XG5cbmZ1bmN0aW9uIGFkZENvbWJpbmF0b3IoIG1hdGNoZXIsIGNvbWJpbmF0b3IsIGJhc2UgKSB7XG5cdHZhciBkaXIgPSBjb21iaW5hdG9yLmRpcixcblx0XHRza2lwID0gY29tYmluYXRvci5uZXh0LFxuXHRcdGtleSA9IHNraXAgfHwgZGlyLFxuXHRcdGNoZWNrTm9uRWxlbWVudHMgPSBiYXNlICYmIGtleSA9PT0gXCJwYXJlbnROb2RlXCIsXG5cdFx0ZG9uZU5hbWUgPSBkb25lKys7XG5cblx0cmV0dXJuIGNvbWJpbmF0b3IuZmlyc3QgP1xuXG5cdFx0Ly8gQ2hlY2sgYWdhaW5zdCBjbG9zZXN0IGFuY2VzdG9yL3ByZWNlZGluZyBlbGVtZW50XG5cdFx0ZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcblx0XHRcdHdoaWxlICggKCBlbGVtID0gZWxlbVsgZGlyIF0gKSApIHtcblx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxIHx8IGNoZWNrTm9uRWxlbWVudHMgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG1hdGNoZXIoIGVsZW0sIGNvbnRleHQsIHhtbCApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fSA6XG5cblx0XHQvLyBDaGVjayBhZ2FpbnN0IGFsbCBhbmNlc3Rvci9wcmVjZWRpbmcgZWxlbWVudHNcblx0XHRmdW5jdGlvbiggZWxlbSwgY29udGV4dCwgeG1sICkge1xuXHRcdFx0dmFyIG9sZENhY2hlLCBvdXRlckNhY2hlLFxuXHRcdFx0XHRuZXdDYWNoZSA9IFsgZGlycnVucywgZG9uZU5hbWUgXTtcblxuXHRcdFx0Ly8gV2UgY2FuJ3Qgc2V0IGFyYml0cmFyeSBkYXRhIG9uIFhNTCBub2Rlcywgc28gdGhleSBkb24ndCBiZW5lZml0IGZyb20gY29tYmluYXRvciBjYWNoaW5nXG5cdFx0XHRpZiAoIHhtbCApIHtcblx0XHRcdFx0d2hpbGUgKCAoIGVsZW0gPSBlbGVtWyBkaXIgXSApICkge1xuXHRcdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSB8fCBjaGVja05vbkVsZW1lbnRzICkge1xuXHRcdFx0XHRcdFx0aWYgKCBtYXRjaGVyKCBlbGVtLCBjb250ZXh0LCB4bWwgKSApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR3aGlsZSAoICggZWxlbSA9IGVsZW1bIGRpciBdICkgKSB7XG5cdFx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxIHx8IGNoZWNrTm9uRWxlbWVudHMgKSB7XG5cdFx0XHRcdFx0XHRvdXRlckNhY2hlID0gZWxlbVsgZXhwYW5kbyBdIHx8ICggZWxlbVsgZXhwYW5kbyBdID0ge30gKTtcblxuXHRcdFx0XHRcdFx0aWYgKCBza2lwICYmIG5vZGVOYW1lKCBlbGVtLCBza2lwICkgKSB7XG5cdFx0XHRcdFx0XHRcdGVsZW0gPSBlbGVtWyBkaXIgXSB8fCBlbGVtO1xuXHRcdFx0XHRcdFx0fSBlbHNlIGlmICggKCBvbGRDYWNoZSA9IG91dGVyQ2FjaGVbIGtleSBdICkgJiZcblx0XHRcdFx0XHRcdFx0b2xkQ2FjaGVbIDAgXSA9PT0gZGlycnVucyAmJiBvbGRDYWNoZVsgMSBdID09PSBkb25lTmFtZSApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBBc3NpZ24gdG8gbmV3Q2FjaGUgc28gcmVzdWx0cyBiYWNrLXByb3BhZ2F0ZSB0byBwcmV2aW91cyBlbGVtZW50c1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gKCBuZXdDYWNoZVsgMiBdID0gb2xkQ2FjaGVbIDIgXSApO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBSZXVzZSBuZXdjYWNoZSBzbyByZXN1bHRzIGJhY2stcHJvcGFnYXRlIHRvIHByZXZpb3VzIGVsZW1lbnRzXG5cdFx0XHRcdFx0XHRcdG91dGVyQ2FjaGVbIGtleSBdID0gbmV3Q2FjaGU7XG5cblx0XHRcdFx0XHRcdFx0Ly8gQSBtYXRjaCBtZWFucyB3ZSdyZSBkb25lOyBhIGZhaWwgbWVhbnMgd2UgaGF2ZSB0byBrZWVwIGNoZWNraW5nXG5cdFx0XHRcdFx0XHRcdGlmICggKCBuZXdDYWNoZVsgMiBdID0gbWF0Y2hlciggZWxlbSwgY29udGV4dCwgeG1sICkgKSApIHtcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH07XG59XG5cbmZ1bmN0aW9uIGVsZW1lbnRNYXRjaGVyKCBtYXRjaGVycyApIHtcblx0cmV0dXJuIG1hdGNoZXJzLmxlbmd0aCA+IDEgP1xuXHRcdGZ1bmN0aW9uKCBlbGVtLCBjb250ZXh0LCB4bWwgKSB7XG5cdFx0XHR2YXIgaSA9IG1hdGNoZXJzLmxlbmd0aDtcblx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRpZiAoICFtYXRjaGVyc1sgaSBdKCBlbGVtLCBjb250ZXh0LCB4bWwgKSApIHtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH0gOlxuXHRcdG1hdGNoZXJzWyAwIF07XG59XG5cbmZ1bmN0aW9uIG11bHRpcGxlQ29udGV4dHMoIHNlbGVjdG9yLCBjb250ZXh0cywgcmVzdWx0cyApIHtcblx0dmFyIGkgPSAwLFxuXHRcdGxlbiA9IGNvbnRleHRzLmxlbmd0aDtcblx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0ZmluZCggc2VsZWN0b3IsIGNvbnRleHRzWyBpIF0sIHJlc3VsdHMgKTtcblx0fVxuXHRyZXR1cm4gcmVzdWx0cztcbn1cblxuZnVuY3Rpb24gY29uZGVuc2UoIHVubWF0Y2hlZCwgbWFwLCBmaWx0ZXIsIGNvbnRleHQsIHhtbCApIHtcblx0dmFyIGVsZW0sXG5cdFx0bmV3VW5tYXRjaGVkID0gW10sXG5cdFx0aSA9IDAsXG5cdFx0bGVuID0gdW5tYXRjaGVkLmxlbmd0aCxcblx0XHRtYXBwZWQgPSBtYXAgIT0gbnVsbDtcblxuXHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRpZiAoICggZWxlbSA9IHVubWF0Y2hlZFsgaSBdICkgKSB7XG5cdFx0XHRpZiAoICFmaWx0ZXIgfHwgZmlsdGVyKCBlbGVtLCBjb250ZXh0LCB4bWwgKSApIHtcblx0XHRcdFx0bmV3VW5tYXRjaGVkLnB1c2goIGVsZW0gKTtcblx0XHRcdFx0aWYgKCBtYXBwZWQgKSB7XG5cdFx0XHRcdFx0bWFwLnB1c2goIGkgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiBuZXdVbm1hdGNoZWQ7XG59XG5cbmZ1bmN0aW9uIHNldE1hdGNoZXIoIHByZUZpbHRlciwgc2VsZWN0b3IsIG1hdGNoZXIsIHBvc3RGaWx0ZXIsIHBvc3RGaW5kZXIsIHBvc3RTZWxlY3RvciApIHtcblx0aWYgKCBwb3N0RmlsdGVyICYmICFwb3N0RmlsdGVyWyBleHBhbmRvIF0gKSB7XG5cdFx0cG9zdEZpbHRlciA9IHNldE1hdGNoZXIoIHBvc3RGaWx0ZXIgKTtcblx0fVxuXHRpZiAoIHBvc3RGaW5kZXIgJiYgIXBvc3RGaW5kZXJbIGV4cGFuZG8gXSApIHtcblx0XHRwb3N0RmluZGVyID0gc2V0TWF0Y2hlciggcG9zdEZpbmRlciwgcG9zdFNlbGVjdG9yICk7XG5cdH1cblx0cmV0dXJuIG1hcmtGdW5jdGlvbiggZnVuY3Rpb24oIHNlZWQsIHJlc3VsdHMsIGNvbnRleHQsIHhtbCApIHtcblx0XHR2YXIgdGVtcCwgaSwgZWxlbSwgbWF0Y2hlck91dCxcblx0XHRcdHByZU1hcCA9IFtdLFxuXHRcdFx0cG9zdE1hcCA9IFtdLFxuXHRcdFx0cHJlZXhpc3RpbmcgPSByZXN1bHRzLmxlbmd0aCxcblxuXHRcdFx0Ly8gR2V0IGluaXRpYWwgZWxlbWVudHMgZnJvbSBzZWVkIG9yIGNvbnRleHRcblx0XHRcdGVsZW1zID0gc2VlZCB8fFxuXHRcdFx0XHRtdWx0aXBsZUNvbnRleHRzKCBzZWxlY3RvciB8fCBcIipcIixcblx0XHRcdFx0XHRjb250ZXh0Lm5vZGVUeXBlID8gWyBjb250ZXh0IF0gOiBjb250ZXh0LCBbXSApLFxuXG5cdFx0XHQvLyBQcmVmaWx0ZXIgdG8gZ2V0IG1hdGNoZXIgaW5wdXQsIHByZXNlcnZpbmcgYSBtYXAgZm9yIHNlZWQtcmVzdWx0cyBzeW5jaHJvbml6YXRpb25cblx0XHRcdG1hdGNoZXJJbiA9IHByZUZpbHRlciAmJiAoIHNlZWQgfHwgIXNlbGVjdG9yICkgP1xuXHRcdFx0XHRjb25kZW5zZSggZWxlbXMsIHByZU1hcCwgcHJlRmlsdGVyLCBjb250ZXh0LCB4bWwgKSA6XG5cdFx0XHRcdGVsZW1zO1xuXG5cdFx0aWYgKCBtYXRjaGVyICkge1xuXG5cdFx0XHQvLyBJZiB3ZSBoYXZlIGEgcG9zdEZpbmRlciwgb3IgZmlsdGVyZWQgc2VlZCwgb3Igbm9uLXNlZWQgcG9zdEZpbHRlclxuXHRcdFx0Ly8gb3IgcHJlZXhpc3RpbmcgcmVzdWx0cyxcblx0XHRcdG1hdGNoZXJPdXQgPSBwb3N0RmluZGVyIHx8ICggc2VlZCA/IHByZUZpbHRlciA6IHByZWV4aXN0aW5nIHx8IHBvc3RGaWx0ZXIgKSA/XG5cblx0XHRcdFx0Ly8gLi4uaW50ZXJtZWRpYXRlIHByb2Nlc3NpbmcgaXMgbmVjZXNzYXJ5XG5cdFx0XHRcdFtdIDpcblxuXHRcdFx0XHQvLyAuLi5vdGhlcndpc2UgdXNlIHJlc3VsdHMgZGlyZWN0bHlcblx0XHRcdFx0cmVzdWx0cztcblxuXHRcdFx0Ly8gRmluZCBwcmltYXJ5IG1hdGNoZXNcblx0XHRcdG1hdGNoZXIoIG1hdGNoZXJJbiwgbWF0Y2hlck91dCwgY29udGV4dCwgeG1sICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdG1hdGNoZXJPdXQgPSBtYXRjaGVySW47XG5cdFx0fVxuXG5cdFx0Ly8gQXBwbHkgcG9zdEZpbHRlclxuXHRcdGlmICggcG9zdEZpbHRlciApIHtcblx0XHRcdHRlbXAgPSBjb25kZW5zZSggbWF0Y2hlck91dCwgcG9zdE1hcCApO1xuXHRcdFx0cG9zdEZpbHRlciggdGVtcCwgW10sIGNvbnRleHQsIHhtbCApO1xuXG5cdFx0XHQvLyBVbi1tYXRjaCBmYWlsaW5nIGVsZW1lbnRzIGJ5IG1vdmluZyB0aGVtIGJhY2sgdG8gbWF0Y2hlckluXG5cdFx0XHRpID0gdGVtcC5sZW5ndGg7XG5cdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0aWYgKCAoIGVsZW0gPSB0ZW1wWyBpIF0gKSApIHtcblx0XHRcdFx0XHRtYXRjaGVyT3V0WyBwb3N0TWFwWyBpIF0gXSA9ICEoIG1hdGNoZXJJblsgcG9zdE1hcFsgaSBdIF0gPSBlbGVtICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoIHNlZWQgKSB7XG5cdFx0XHRpZiAoIHBvc3RGaW5kZXIgfHwgcHJlRmlsdGVyICkge1xuXHRcdFx0XHRpZiAoIHBvc3RGaW5kZXIgKSB7XG5cblx0XHRcdFx0XHQvLyBHZXQgdGhlIGZpbmFsIG1hdGNoZXJPdXQgYnkgY29uZGVuc2luZyB0aGlzIGludGVybWVkaWF0ZSBpbnRvIHBvc3RGaW5kZXIgY29udGV4dHNcblx0XHRcdFx0XHR0ZW1wID0gW107XG5cdFx0XHRcdFx0aSA9IG1hdGNoZXJPdXQubGVuZ3RoO1xuXHRcdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdFx0aWYgKCAoIGVsZW0gPSBtYXRjaGVyT3V0WyBpIF0gKSApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBSZXN0b3JlIG1hdGNoZXJJbiBzaW5jZSBlbGVtIGlzIG5vdCB5ZXQgYSBmaW5hbCBtYXRjaFxuXHRcdFx0XHRcdFx0XHR0ZW1wLnB1c2goICggbWF0Y2hlckluWyBpIF0gPSBlbGVtICkgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cG9zdEZpbmRlciggbnVsbCwgKCBtYXRjaGVyT3V0ID0gW10gKSwgdGVtcCwgeG1sICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBNb3ZlIG1hdGNoZWQgZWxlbWVudHMgZnJvbSBzZWVkIHRvIHJlc3VsdHMgdG8ga2VlcCB0aGVtIHN5bmNocm9uaXplZFxuXHRcdFx0XHRpID0gbWF0Y2hlck91dC5sZW5ndGg7XG5cdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdGlmICggKCBlbGVtID0gbWF0Y2hlck91dFsgaSBdICkgJiZcblx0XHRcdFx0XHRcdCggdGVtcCA9IHBvc3RGaW5kZXIgPyBpbmRleE9mLmNhbGwoIHNlZWQsIGVsZW0gKSA6IHByZU1hcFsgaSBdICkgPiAtMSApIHtcblxuXHRcdFx0XHRcdFx0c2VlZFsgdGVtcCBdID0gISggcmVzdWx0c1sgdGVtcCBdID0gZWxlbSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0Ly8gQWRkIGVsZW1lbnRzIHRvIHJlc3VsdHMsIHRocm91Z2ggcG9zdEZpbmRlciBpZiBkZWZpbmVkXG5cdFx0fSBlbHNlIHtcblx0XHRcdG1hdGNoZXJPdXQgPSBjb25kZW5zZShcblx0XHRcdFx0bWF0Y2hlck91dCA9PT0gcmVzdWx0cyA/XG5cdFx0XHRcdFx0bWF0Y2hlck91dC5zcGxpY2UoIHByZWV4aXN0aW5nLCBtYXRjaGVyT3V0Lmxlbmd0aCApIDpcblx0XHRcdFx0XHRtYXRjaGVyT3V0XG5cdFx0XHQpO1xuXHRcdFx0aWYgKCBwb3N0RmluZGVyICkge1xuXHRcdFx0XHRwb3N0RmluZGVyKCBudWxsLCByZXN1bHRzLCBtYXRjaGVyT3V0LCB4bWwgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHB1c2guYXBwbHkoIHJlc3VsdHMsIG1hdGNoZXJPdXQgKTtcblx0XHRcdH1cblx0XHR9XG5cdH0gKTtcbn1cblxuZnVuY3Rpb24gbWF0Y2hlckZyb21Ub2tlbnMoIHRva2VucyApIHtcblx0dmFyIGNoZWNrQ29udGV4dCwgbWF0Y2hlciwgaixcblx0XHRsZW4gPSB0b2tlbnMubGVuZ3RoLFxuXHRcdGxlYWRpbmdSZWxhdGl2ZSA9IEV4cHIucmVsYXRpdmVbIHRva2Vuc1sgMCBdLnR5cGUgXSxcblx0XHRpbXBsaWNpdFJlbGF0aXZlID0gbGVhZGluZ1JlbGF0aXZlIHx8IEV4cHIucmVsYXRpdmVbIFwiIFwiIF0sXG5cdFx0aSA9IGxlYWRpbmdSZWxhdGl2ZSA/IDEgOiAwLFxuXG5cdFx0Ly8gVGhlIGZvdW5kYXRpb25hbCBtYXRjaGVyIGVuc3VyZXMgdGhhdCBlbGVtZW50cyBhcmUgcmVhY2hhYmxlIGZyb20gdG9wLWxldmVsIGNvbnRleHQocylcblx0XHRtYXRjaENvbnRleHQgPSBhZGRDb21iaW5hdG9yKCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBlbGVtID09PSBjaGVja0NvbnRleHQ7XG5cdFx0fSwgaW1wbGljaXRSZWxhdGl2ZSwgdHJ1ZSApLFxuXHRcdG1hdGNoQW55Q29udGV4dCA9IGFkZENvbWJpbmF0b3IoIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGluZGV4T2YuY2FsbCggY2hlY2tDb250ZXh0LCBlbGVtICkgPiAtMTtcblx0XHR9LCBpbXBsaWNpdFJlbGF0aXZlLCB0cnVlICksXG5cdFx0bWF0Y2hlcnMgPSBbIGZ1bmN0aW9uKCBlbGVtLCBjb250ZXh0LCB4bWwgKSB7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFIDExKywgRWRnZSAxNyAtIDE4K1xuXHRcdFx0Ly8gSUUvRWRnZSBzb21ldGltZXMgdGhyb3cgYSBcIlBlcm1pc3Npb24gZGVuaWVkXCIgZXJyb3Igd2hlbiBzdHJpY3QtY29tcGFyaW5nXG5cdFx0XHQvLyB0d28gZG9jdW1lbnRzOyBzaGFsbG93IGNvbXBhcmlzb25zIHdvcmsuXG5cdFx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXFlcWVxXG5cdFx0XHR2YXIgcmV0ID0gKCAhbGVhZGluZ1JlbGF0aXZlICYmICggeG1sIHx8IGNvbnRleHQgIT0gb3V0ZXJtb3N0Q29udGV4dCApICkgfHwgKFxuXHRcdFx0XHQoIGNoZWNrQ29udGV4dCA9IGNvbnRleHQgKS5ub2RlVHlwZSA/XG5cdFx0XHRcdFx0bWF0Y2hDb250ZXh0KCBlbGVtLCBjb250ZXh0LCB4bWwgKSA6XG5cdFx0XHRcdFx0bWF0Y2hBbnlDb250ZXh0KCBlbGVtLCBjb250ZXh0LCB4bWwgKSApO1xuXG5cdFx0XHQvLyBBdm9pZCBoYW5naW5nIG9udG8gZWxlbWVudFxuXHRcdFx0Ly8gKHNlZSBodHRwczovL2dpdGh1Yi5jb20vanF1ZXJ5L3NpenpsZS9pc3N1ZXMvMjk5KVxuXHRcdFx0Y2hlY2tDb250ZXh0ID0gbnVsbDtcblx0XHRcdHJldHVybiByZXQ7XG5cdFx0fSBdO1xuXG5cdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdGlmICggKCBtYXRjaGVyID0gRXhwci5yZWxhdGl2ZVsgdG9rZW5zWyBpIF0udHlwZSBdICkgKSB7XG5cdFx0XHRtYXRjaGVycyA9IFsgYWRkQ29tYmluYXRvciggZWxlbWVudE1hdGNoZXIoIG1hdGNoZXJzICksIG1hdGNoZXIgKSBdO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRtYXRjaGVyID0gRXhwci5maWx0ZXJbIHRva2Vuc1sgaSBdLnR5cGUgXS5hcHBseSggbnVsbCwgdG9rZW5zWyBpIF0ubWF0Y2hlcyApO1xuXG5cdFx0XHQvLyBSZXR1cm4gc3BlY2lhbCB1cG9uIHNlZWluZyBhIHBvc2l0aW9uYWwgbWF0Y2hlclxuXHRcdFx0aWYgKCBtYXRjaGVyWyBleHBhbmRvIF0gKSB7XG5cblx0XHRcdFx0Ly8gRmluZCB0aGUgbmV4dCByZWxhdGl2ZSBvcGVyYXRvciAoaWYgYW55KSBmb3IgcHJvcGVyIGhhbmRsaW5nXG5cdFx0XHRcdGogPSArK2k7XG5cdFx0XHRcdGZvciAoIDsgaiA8IGxlbjsgaisrICkge1xuXHRcdFx0XHRcdGlmICggRXhwci5yZWxhdGl2ZVsgdG9rZW5zWyBqIF0udHlwZSBdICkge1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBzZXRNYXRjaGVyKFxuXHRcdFx0XHRcdGkgPiAxICYmIGVsZW1lbnRNYXRjaGVyKCBtYXRjaGVycyApLFxuXHRcdFx0XHRcdGkgPiAxICYmIHRvU2VsZWN0b3IoXG5cblx0XHRcdFx0XHRcdC8vIElmIHRoZSBwcmVjZWRpbmcgdG9rZW4gd2FzIGEgZGVzY2VuZGFudCBjb21iaW5hdG9yLCBpbnNlcnQgYW4gaW1wbGljaXQgYW55LWVsZW1lbnQgYCpgXG5cdFx0XHRcdFx0XHR0b2tlbnMuc2xpY2UoIDAsIGkgLSAxIClcblx0XHRcdFx0XHRcdFx0LmNvbmNhdCggeyB2YWx1ZTogdG9rZW5zWyBpIC0gMiBdLnR5cGUgPT09IFwiIFwiID8gXCIqXCIgOiBcIlwiIH0gKVxuXHRcdFx0XHRcdCkucmVwbGFjZSggcnRyaW1DU1MsIFwiJDFcIiApLFxuXHRcdFx0XHRcdG1hdGNoZXIsXG5cdFx0XHRcdFx0aSA8IGogJiYgbWF0Y2hlckZyb21Ub2tlbnMoIHRva2Vucy5zbGljZSggaSwgaiApICksXG5cdFx0XHRcdFx0aiA8IGxlbiAmJiBtYXRjaGVyRnJvbVRva2VucyggKCB0b2tlbnMgPSB0b2tlbnMuc2xpY2UoIGogKSApICksXG5cdFx0XHRcdFx0aiA8IGxlbiAmJiB0b1NlbGVjdG9yKCB0b2tlbnMgKVxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXHRcdFx0bWF0Y2hlcnMucHVzaCggbWF0Y2hlciApO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBlbGVtZW50TWF0Y2hlciggbWF0Y2hlcnMgKTtcbn1cblxuZnVuY3Rpb24gbWF0Y2hlckZyb21Hcm91cE1hdGNoZXJzKCBlbGVtZW50TWF0Y2hlcnMsIHNldE1hdGNoZXJzICkge1xuXHR2YXIgYnlTZXQgPSBzZXRNYXRjaGVycy5sZW5ndGggPiAwLFxuXHRcdGJ5RWxlbWVudCA9IGVsZW1lbnRNYXRjaGVycy5sZW5ndGggPiAwLFxuXHRcdHN1cGVyTWF0Y2hlciA9IGZ1bmN0aW9uKCBzZWVkLCBjb250ZXh0LCB4bWwsIHJlc3VsdHMsIG91dGVybW9zdCApIHtcblx0XHRcdHZhciBlbGVtLCBqLCBtYXRjaGVyLFxuXHRcdFx0XHRtYXRjaGVkQ291bnQgPSAwLFxuXHRcdFx0XHRpID0gXCIwXCIsXG5cdFx0XHRcdHVubWF0Y2hlZCA9IHNlZWQgJiYgW10sXG5cdFx0XHRcdHNldE1hdGNoZWQgPSBbXSxcblx0XHRcdFx0Y29udGV4dEJhY2t1cCA9IG91dGVybW9zdENvbnRleHQsXG5cblx0XHRcdFx0Ly8gV2UgbXVzdCBhbHdheXMgaGF2ZSBlaXRoZXIgc2VlZCBlbGVtZW50cyBvciBvdXRlcm1vc3QgY29udGV4dFxuXHRcdFx0XHRlbGVtcyA9IHNlZWQgfHwgYnlFbGVtZW50ICYmIEV4cHIuZmluZC5UQUcoIFwiKlwiLCBvdXRlcm1vc3QgKSxcblxuXHRcdFx0XHQvLyBVc2UgaW50ZWdlciBkaXJydW5zIGlmZiB0aGlzIGlzIHRoZSBvdXRlcm1vc3QgbWF0Y2hlclxuXHRcdFx0XHRkaXJydW5zVW5pcXVlID0gKCBkaXJydW5zICs9IGNvbnRleHRCYWNrdXAgPT0gbnVsbCA/IDEgOiBNYXRoLnJhbmRvbSgpIHx8IDAuMSApLFxuXHRcdFx0XHRsZW4gPSBlbGVtcy5sZW5ndGg7XG5cblx0XHRcdGlmICggb3V0ZXJtb3N0ICkge1xuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDExKywgRWRnZSAxNyAtIDE4K1xuXHRcdFx0XHQvLyBJRS9FZGdlIHNvbWV0aW1lcyB0aHJvdyBhIFwiUGVybWlzc2lvbiBkZW5pZWRcIiBlcnJvciB3aGVuIHN0cmljdC1jb21wYXJpbmdcblx0XHRcdFx0Ly8gdHdvIGRvY3VtZW50czsgc2hhbGxvdyBjb21wYXJpc29ucyB3b3JrLlxuXHRcdFx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXFlcWVxXG5cdFx0XHRcdG91dGVybW9zdENvbnRleHQgPSBjb250ZXh0ID09IGRvY3VtZW50IHx8IGNvbnRleHQgfHwgb3V0ZXJtb3N0O1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBBZGQgZWxlbWVudHMgcGFzc2luZyBlbGVtZW50TWF0Y2hlcnMgZGlyZWN0bHkgdG8gcmVzdWx0c1xuXHRcdFx0Ly8gU3VwcG9ydDogaU9TIDw9NyAtIDkgb25seVxuXHRcdFx0Ly8gVG9sZXJhdGUgTm9kZUxpc3QgcHJvcGVydGllcyAoSUU6IFwibGVuZ3RoXCI7IFNhZmFyaTogPG51bWJlcj4pIG1hdGNoaW5nXG5cdFx0XHQvLyBlbGVtZW50cyBieSBpZC4gKHNlZSB0cmFjLTE0MTQyKVxuXHRcdFx0Zm9yICggOyBpICE9PSBsZW4gJiYgKCBlbGVtID0gZWxlbXNbIGkgXSApICE9IG51bGw7IGkrKyApIHtcblx0XHRcdFx0aWYgKCBieUVsZW1lbnQgJiYgZWxlbSApIHtcblx0XHRcdFx0XHRqID0gMDtcblxuXHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDExKywgRWRnZSAxNyAtIDE4K1xuXHRcdFx0XHRcdC8vIElFL0VkZ2Ugc29tZXRpbWVzIHRocm93IGEgXCJQZXJtaXNzaW9uIGRlbmllZFwiIGVycm9yIHdoZW4gc3RyaWN0LWNvbXBhcmluZ1xuXHRcdFx0XHRcdC8vIHR3byBkb2N1bWVudHM7IHNoYWxsb3cgY29tcGFyaXNvbnMgd29yay5cblx0XHRcdFx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXFlcWVxXG5cdFx0XHRcdFx0aWYgKCAhY29udGV4dCAmJiBlbGVtLm93bmVyRG9jdW1lbnQgIT0gZG9jdW1lbnQgKSB7XG5cdFx0XHRcdFx0XHRzZXREb2N1bWVudCggZWxlbSApO1xuXHRcdFx0XHRcdFx0eG1sID0gIWRvY3VtZW50SXNIVE1MO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR3aGlsZSAoICggbWF0Y2hlciA9IGVsZW1lbnRNYXRjaGVyc1sgaisrIF0gKSApIHtcblx0XHRcdFx0XHRcdGlmICggbWF0Y2hlciggZWxlbSwgY29udGV4dCB8fCBkb2N1bWVudCwgeG1sICkgKSB7XG5cdFx0XHRcdFx0XHRcdHB1c2guY2FsbCggcmVzdWx0cywgZWxlbSApO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKCBvdXRlcm1vc3QgKSB7XG5cdFx0XHRcdFx0XHRkaXJydW5zID0gZGlycnVuc1VuaXF1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBUcmFjayB1bm1hdGNoZWQgZWxlbWVudHMgZm9yIHNldCBmaWx0ZXJzXG5cdFx0XHRcdGlmICggYnlTZXQgKSB7XG5cblx0XHRcdFx0XHQvLyBUaGV5IHdpbGwgaGF2ZSBnb25lIHRocm91Z2ggYWxsIHBvc3NpYmxlIG1hdGNoZXJzXG5cdFx0XHRcdFx0aWYgKCAoIGVsZW0gPSAhbWF0Y2hlciAmJiBlbGVtICkgKSB7XG5cdFx0XHRcdFx0XHRtYXRjaGVkQ291bnQtLTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBMZW5ndGhlbiB0aGUgYXJyYXkgZm9yIGV2ZXJ5IGVsZW1lbnQsIG1hdGNoZWQgb3Igbm90XG5cdFx0XHRcdFx0aWYgKCBzZWVkICkge1xuXHRcdFx0XHRcdFx0dW5tYXRjaGVkLnB1c2goIGVsZW0gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gYGlgIGlzIG5vdyB0aGUgY291bnQgb2YgZWxlbWVudHMgdmlzaXRlZCBhYm92ZSwgYW5kIGFkZGluZyBpdCB0byBgbWF0Y2hlZENvdW50YFxuXHRcdFx0Ly8gbWFrZXMgdGhlIGxhdHRlciBub25uZWdhdGl2ZS5cblx0XHRcdG1hdGNoZWRDb3VudCArPSBpO1xuXG5cdFx0XHQvLyBBcHBseSBzZXQgZmlsdGVycyB0byB1bm1hdGNoZWQgZWxlbWVudHNcblx0XHRcdC8vIE5PVEU6IFRoaXMgY2FuIGJlIHNraXBwZWQgaWYgdGhlcmUgYXJlIG5vIHVubWF0Y2hlZCBlbGVtZW50cyAoaS5lLiwgYG1hdGNoZWRDb3VudGBcblx0XHRcdC8vIGVxdWFscyBgaWApLCB1bmxlc3Mgd2UgZGlkbid0IHZpc2l0IF9hbnlfIGVsZW1lbnRzIGluIHRoZSBhYm92ZSBsb29wIGJlY2F1c2Ugd2UgaGF2ZVxuXHRcdFx0Ly8gbm8gZWxlbWVudCBtYXRjaGVycyBhbmQgbm8gc2VlZC5cblx0XHRcdC8vIEluY3JlbWVudGluZyBhbiBpbml0aWFsbHktc3RyaW5nIFwiMFwiIGBpYCBhbGxvd3MgYGlgIHRvIHJlbWFpbiBhIHN0cmluZyBvbmx5IGluIHRoYXRcblx0XHRcdC8vIGNhc2UsIHdoaWNoIHdpbGwgcmVzdWx0IGluIGEgXCIwMFwiIGBtYXRjaGVkQ291bnRgIHRoYXQgZGlmZmVycyBmcm9tIGBpYCBidXQgaXMgYWxzb1xuXHRcdFx0Ly8gbnVtZXJpY2FsbHkgemVyby5cblx0XHRcdGlmICggYnlTZXQgJiYgaSAhPT0gbWF0Y2hlZENvdW50ICkge1xuXHRcdFx0XHRqID0gMDtcblx0XHRcdFx0d2hpbGUgKCAoIG1hdGNoZXIgPSBzZXRNYXRjaGVyc1sgaisrIF0gKSApIHtcblx0XHRcdFx0XHRtYXRjaGVyKCB1bm1hdGNoZWQsIHNldE1hdGNoZWQsIGNvbnRleHQsIHhtbCApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBzZWVkICkge1xuXG5cdFx0XHRcdFx0Ly8gUmVpbnRlZ3JhdGUgZWxlbWVudCBtYXRjaGVzIHRvIGVsaW1pbmF0ZSB0aGUgbmVlZCBmb3Igc29ydGluZ1xuXHRcdFx0XHRcdGlmICggbWF0Y2hlZENvdW50ID4gMCApIHtcblx0XHRcdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdFx0XHRpZiAoICEoIHVubWF0Y2hlZFsgaSBdIHx8IHNldE1hdGNoZWRbIGkgXSApICkge1xuXHRcdFx0XHRcdFx0XHRcdHNldE1hdGNoZWRbIGkgXSA9IHBvcC5jYWxsKCByZXN1bHRzICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBEaXNjYXJkIGluZGV4IHBsYWNlaG9sZGVyIHZhbHVlcyB0byBnZXQgb25seSBhY3R1YWwgbWF0Y2hlc1xuXHRcdFx0XHRcdHNldE1hdGNoZWQgPSBjb25kZW5zZSggc2V0TWF0Y2hlZCApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gQWRkIG1hdGNoZXMgdG8gcmVzdWx0c1xuXHRcdFx0XHRwdXNoLmFwcGx5KCByZXN1bHRzLCBzZXRNYXRjaGVkICk7XG5cblx0XHRcdFx0Ly8gU2VlZGxlc3Mgc2V0IG1hdGNoZXMgc3VjY2VlZGluZyBtdWx0aXBsZSBzdWNjZXNzZnVsIG1hdGNoZXJzIHN0aXB1bGF0ZSBzb3J0aW5nXG5cdFx0XHRcdGlmICggb3V0ZXJtb3N0ICYmICFzZWVkICYmIHNldE1hdGNoZWQubGVuZ3RoID4gMCAmJlxuXHRcdFx0XHRcdCggbWF0Y2hlZENvdW50ICsgc2V0TWF0Y2hlcnMubGVuZ3RoICkgPiAxICkge1xuXG5cdFx0XHRcdFx0alF1ZXJ5LnVuaXF1ZVNvcnQoIHJlc3VsdHMgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBPdmVycmlkZSBtYW5pcHVsYXRpb24gb2YgZ2xvYmFscyBieSBuZXN0ZWQgbWF0Y2hlcnNcblx0XHRcdGlmICggb3V0ZXJtb3N0ICkge1xuXHRcdFx0XHRkaXJydW5zID0gZGlycnVuc1VuaXF1ZTtcblx0XHRcdFx0b3V0ZXJtb3N0Q29udGV4dCA9IGNvbnRleHRCYWNrdXA7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB1bm1hdGNoZWQ7XG5cdFx0fTtcblxuXHRyZXR1cm4gYnlTZXQgP1xuXHRcdG1hcmtGdW5jdGlvbiggc3VwZXJNYXRjaGVyICkgOlxuXHRcdHN1cGVyTWF0Y2hlcjtcbn1cblxuZnVuY3Rpb24gY29tcGlsZSggc2VsZWN0b3IsIG1hdGNoIC8qIEludGVybmFsIFVzZSBPbmx5ICovICkge1xuXHR2YXIgaSxcblx0XHRzZXRNYXRjaGVycyA9IFtdLFxuXHRcdGVsZW1lbnRNYXRjaGVycyA9IFtdLFxuXHRcdGNhY2hlZCA9IGNvbXBpbGVyQ2FjaGVbIHNlbGVjdG9yICsgXCIgXCIgXTtcblxuXHRpZiAoICFjYWNoZWQgKSB7XG5cblx0XHQvLyBHZW5lcmF0ZSBhIGZ1bmN0aW9uIG9mIHJlY3Vyc2l2ZSBmdW5jdGlvbnMgdGhhdCBjYW4gYmUgdXNlZCB0byBjaGVjayBlYWNoIGVsZW1lbnRcblx0XHRpZiAoICFtYXRjaCApIHtcblx0XHRcdG1hdGNoID0gdG9rZW5pemUoIHNlbGVjdG9yICk7XG5cdFx0fVxuXHRcdGkgPSBtYXRjaC5sZW5ndGg7XG5cdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRjYWNoZWQgPSBtYXRjaGVyRnJvbVRva2VucyggbWF0Y2hbIGkgXSApO1xuXHRcdFx0aWYgKCBjYWNoZWRbIGV4cGFuZG8gXSApIHtcblx0XHRcdFx0c2V0TWF0Y2hlcnMucHVzaCggY2FjaGVkICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRlbGVtZW50TWF0Y2hlcnMucHVzaCggY2FjaGVkICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQ2FjaGUgdGhlIGNvbXBpbGVkIGZ1bmN0aW9uXG5cdFx0Y2FjaGVkID0gY29tcGlsZXJDYWNoZSggc2VsZWN0b3IsXG5cdFx0XHRtYXRjaGVyRnJvbUdyb3VwTWF0Y2hlcnMoIGVsZW1lbnRNYXRjaGVycywgc2V0TWF0Y2hlcnMgKSApO1xuXG5cdFx0Ly8gU2F2ZSBzZWxlY3RvciBhbmQgdG9rZW5pemF0aW9uXG5cdFx0Y2FjaGVkLnNlbGVjdG9yID0gc2VsZWN0b3I7XG5cdH1cblx0cmV0dXJuIGNhY2hlZDtcbn1cblxuLyoqXG4gKiBBIGxvdy1sZXZlbCBzZWxlY3Rpb24gZnVuY3Rpb24gdGhhdCB3b3JrcyB3aXRoIGpRdWVyeSdzIGNvbXBpbGVkXG4gKiAgc2VsZWN0b3IgZnVuY3Rpb25zXG4gKiBAcGFyYW0ge1N0cmluZ3xGdW5jdGlvbn0gc2VsZWN0b3IgQSBzZWxlY3RvciBvciBhIHByZS1jb21waWxlZFxuICogIHNlbGVjdG9yIGZ1bmN0aW9uIGJ1aWx0IHdpdGggalF1ZXJ5IHNlbGVjdG9yIGNvbXBpbGVcbiAqIEBwYXJhbSB7RWxlbWVudH0gY29udGV4dFxuICogQHBhcmFtIHtBcnJheX0gW3Jlc3VsdHNdXG4gKiBAcGFyYW0ge0FycmF5fSBbc2VlZF0gQSBzZXQgb2YgZWxlbWVudHMgdG8gbWF0Y2ggYWdhaW5zdFxuICovXG5mdW5jdGlvbiBzZWxlY3QoIHNlbGVjdG9yLCBjb250ZXh0LCByZXN1bHRzLCBzZWVkICkge1xuXHR2YXIgaSwgdG9rZW5zLCB0b2tlbiwgdHlwZSwgZmluZCxcblx0XHRjb21waWxlZCA9IHR5cGVvZiBzZWxlY3RvciA9PT0gXCJmdW5jdGlvblwiICYmIHNlbGVjdG9yLFxuXHRcdG1hdGNoID0gIXNlZWQgJiYgdG9rZW5pemUoICggc2VsZWN0b3IgPSBjb21waWxlZC5zZWxlY3RvciB8fCBzZWxlY3RvciApICk7XG5cblx0cmVzdWx0cyA9IHJlc3VsdHMgfHwgW107XG5cblx0Ly8gVHJ5IHRvIG1pbmltaXplIG9wZXJhdGlvbnMgaWYgdGhlcmUgaXMgb25seSBvbmUgc2VsZWN0b3IgaW4gdGhlIGxpc3QgYW5kIG5vIHNlZWRcblx0Ly8gKHRoZSBsYXR0ZXIgb2Ygd2hpY2ggZ3VhcmFudGVlcyB1cyBjb250ZXh0KVxuXHRpZiAoIG1hdGNoLmxlbmd0aCA9PT0gMSApIHtcblxuXHRcdC8vIFJlZHVjZSBjb250ZXh0IGlmIHRoZSBsZWFkaW5nIGNvbXBvdW5kIHNlbGVjdG9yIGlzIGFuIElEXG5cdFx0dG9rZW5zID0gbWF0Y2hbIDAgXSA9IG1hdGNoWyAwIF0uc2xpY2UoIDAgKTtcblx0XHRpZiAoIHRva2Vucy5sZW5ndGggPiAyICYmICggdG9rZW4gPSB0b2tlbnNbIDAgXSApLnR5cGUgPT09IFwiSURcIiAmJlxuXHRcdFx0XHRjb250ZXh0Lm5vZGVUeXBlID09PSA5ICYmIGRvY3VtZW50SXNIVE1MICYmIEV4cHIucmVsYXRpdmVbIHRva2Vuc1sgMSBdLnR5cGUgXSApIHtcblxuXHRcdFx0Y29udGV4dCA9ICggRXhwci5maW5kLklEKFxuXHRcdFx0XHR0b2tlbi5tYXRjaGVzWyAwIF0ucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKSxcblx0XHRcdFx0Y29udGV4dFxuXHRcdFx0KSB8fCBbXSApWyAwIF07XG5cdFx0XHRpZiAoICFjb250ZXh0ICkge1xuXHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblxuXHRcdFx0Ly8gUHJlY29tcGlsZWQgbWF0Y2hlcnMgd2lsbCBzdGlsbCB2ZXJpZnkgYW5jZXN0cnksIHNvIHN0ZXAgdXAgYSBsZXZlbFxuXHRcdFx0fSBlbHNlIGlmICggY29tcGlsZWQgKSB7XG5cdFx0XHRcdGNvbnRleHQgPSBjb250ZXh0LnBhcmVudE5vZGU7XG5cdFx0XHR9XG5cblx0XHRcdHNlbGVjdG9yID0gc2VsZWN0b3Iuc2xpY2UoIHRva2Vucy5zaGlmdCgpLnZhbHVlLmxlbmd0aCApO1xuXHRcdH1cblxuXHRcdC8vIEZldGNoIGEgc2VlZCBzZXQgZm9yIHJpZ2h0LXRvLWxlZnQgbWF0Y2hpbmdcblx0XHRpID0gbWF0Y2hFeHByLm5lZWRzQ29udGV4dC50ZXN0KCBzZWxlY3RvciApID8gMCA6IHRva2Vucy5sZW5ndGg7XG5cdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHR0b2tlbiA9IHRva2Vuc1sgaSBdO1xuXG5cdFx0XHQvLyBBYm9ydCBpZiB3ZSBoaXQgYSBjb21iaW5hdG9yXG5cdFx0XHRpZiAoIEV4cHIucmVsYXRpdmVbICggdHlwZSA9IHRva2VuLnR5cGUgKSBdICkge1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHRcdGlmICggKCBmaW5kID0gRXhwci5maW5kWyB0eXBlIF0gKSApIHtcblxuXHRcdFx0XHQvLyBTZWFyY2gsIGV4cGFuZGluZyBjb250ZXh0IGZvciBsZWFkaW5nIHNpYmxpbmcgY29tYmluYXRvcnNcblx0XHRcdFx0aWYgKCAoIHNlZWQgPSBmaW5kKFxuXHRcdFx0XHRcdHRva2VuLm1hdGNoZXNbIDAgXS5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApLFxuXHRcdFx0XHRcdHJzaWJsaW5nLnRlc3QoIHRva2Vuc1sgMCBdLnR5cGUgKSAmJlxuXHRcdFx0XHRcdFx0dGVzdENvbnRleHQoIGNvbnRleHQucGFyZW50Tm9kZSApIHx8IGNvbnRleHRcblx0XHRcdFx0KSApICkge1xuXG5cdFx0XHRcdFx0Ly8gSWYgc2VlZCBpcyBlbXB0eSBvciBubyB0b2tlbnMgcmVtYWluLCB3ZSBjYW4gcmV0dXJuIGVhcmx5XG5cdFx0XHRcdFx0dG9rZW5zLnNwbGljZSggaSwgMSApO1xuXHRcdFx0XHRcdHNlbGVjdG9yID0gc2VlZC5sZW5ndGggJiYgdG9TZWxlY3RvciggdG9rZW5zICk7XG5cdFx0XHRcdFx0aWYgKCAhc2VsZWN0b3IgKSB7XG5cdFx0XHRcdFx0XHRwdXNoLmFwcGx5KCByZXN1bHRzLCBzZWVkICk7XG5cdFx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIENvbXBpbGUgYW5kIGV4ZWN1dGUgYSBmaWx0ZXJpbmcgZnVuY3Rpb24gaWYgb25lIGlzIG5vdCBwcm92aWRlZFxuXHQvLyBQcm92aWRlIGBtYXRjaGAgdG8gYXZvaWQgcmV0b2tlbml6YXRpb24gaWYgd2UgbW9kaWZpZWQgdGhlIHNlbGVjdG9yIGFib3ZlXG5cdCggY29tcGlsZWQgfHwgY29tcGlsZSggc2VsZWN0b3IsIG1hdGNoICkgKShcblx0XHRzZWVkLFxuXHRcdGNvbnRleHQsXG5cdFx0IWRvY3VtZW50SXNIVE1MLFxuXHRcdHJlc3VsdHMsXG5cdFx0IWNvbnRleHQgfHwgcnNpYmxpbmcudGVzdCggc2VsZWN0b3IgKSAmJiB0ZXN0Q29udGV4dCggY29udGV4dC5wYXJlbnROb2RlICkgfHwgY29udGV4dFxuXHQpO1xuXHRyZXR1cm4gcmVzdWx0cztcbn1cblxuLy8gT25lLXRpbWUgYXNzaWdubWVudHNcblxuLy8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMCAtIDQuMStcbi8vIFNvcnQgc3RhYmlsaXR5XG5zdXBwb3J0LnNvcnRTdGFibGUgPSBleHBhbmRvLnNwbGl0KCBcIlwiICkuc29ydCggc29ydE9yZGVyICkuam9pbiggXCJcIiApID09PSBleHBhbmRvO1xuXG4vLyBJbml0aWFsaXplIGFnYWluc3QgdGhlIGRlZmF1bHQgZG9jdW1lbnRcbnNldERvY3VtZW50KCk7XG5cbi8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjAgLSA0LjErXG4vLyBEZXRhY2hlZCBub2RlcyBjb25mb3VuZGluZ2x5IGZvbGxvdyAqZWFjaCBvdGhlcipcbnN1cHBvcnQuc29ydERldGFjaGVkID0gYXNzZXJ0KCBmdW5jdGlvbiggZWwgKSB7XG5cblx0Ly8gU2hvdWxkIHJldHVybiAxLCBidXQgcmV0dXJucyA0IChmb2xsb3dpbmcpXG5cdHJldHVybiBlbC5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiggZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJmaWVsZHNldFwiICkgKSAmIDE7XG59ICk7XG5cbmpRdWVyeS5maW5kID0gZmluZDtcblxuLy8gRGVwcmVjYXRlZFxualF1ZXJ5LmV4cHJbIFwiOlwiIF0gPSBqUXVlcnkuZXhwci5wc2V1ZG9zO1xualF1ZXJ5LnVuaXF1ZSA9IGpRdWVyeS51bmlxdWVTb3J0O1xuXG4vLyBUaGVzZSBoYXZlIGFsd2F5cyBiZWVuIHByaXZhdGUsIGJ1dCB0aGV5IHVzZWQgdG8gYmUgZG9jdW1lbnRlZCBhcyBwYXJ0IG9mXG4vLyBTaXp6bGUgc28gbGV0J3MgbWFpbnRhaW4gdGhlbSBmb3Igbm93IGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSBwdXJwb3Nlcy5cbmZpbmQuY29tcGlsZSA9IGNvbXBpbGU7XG5maW5kLnNlbGVjdCA9IHNlbGVjdDtcbmZpbmQuc2V0RG9jdW1lbnQgPSBzZXREb2N1bWVudDtcbmZpbmQudG9rZW5pemUgPSB0b2tlbml6ZTtcblxuZmluZC5lc2NhcGUgPSBqUXVlcnkuZXNjYXBlU2VsZWN0b3I7XG5maW5kLmdldFRleHQgPSBqUXVlcnkudGV4dDtcbmZpbmQuaXNYTUwgPSBqUXVlcnkuaXNYTUxEb2M7XG5maW5kLnNlbGVjdG9ycyA9IGpRdWVyeS5leHByO1xuZmluZC5zdXBwb3J0ID0galF1ZXJ5LnN1cHBvcnQ7XG5maW5kLnVuaXF1ZVNvcnQgPSBqUXVlcnkudW5pcXVlU29ydDtcblxuXHQvKiBlc2xpbnQtZW5hYmxlICovXG5cbn0gKSgpO1xuXG5cbnZhciBkaXIgPSBmdW5jdGlvbiggZWxlbSwgZGlyLCB1bnRpbCApIHtcblx0dmFyIG1hdGNoZWQgPSBbXSxcblx0XHR0cnVuY2F0ZSA9IHVudGlsICE9PSB1bmRlZmluZWQ7XG5cblx0d2hpbGUgKCAoIGVsZW0gPSBlbGVtWyBkaXIgXSApICYmIGVsZW0ubm9kZVR5cGUgIT09IDkgKSB7XG5cdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXHRcdFx0aWYgKCB0cnVuY2F0ZSAmJiBqUXVlcnkoIGVsZW0gKS5pcyggdW50aWwgKSApIHtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0XHRtYXRjaGVkLnB1c2goIGVsZW0gKTtcblx0XHR9XG5cdH1cblx0cmV0dXJuIG1hdGNoZWQ7XG59O1xuXG5cbnZhciBzaWJsaW5ncyA9IGZ1bmN0aW9uKCBuLCBlbGVtICkge1xuXHR2YXIgbWF0Y2hlZCA9IFtdO1xuXG5cdGZvciAoIDsgbjsgbiA9IG4ubmV4dFNpYmxpbmcgKSB7XG5cdFx0aWYgKCBuLm5vZGVUeXBlID09PSAxICYmIG4gIT09IGVsZW0gKSB7XG5cdFx0XHRtYXRjaGVkLnB1c2goIG4gKTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gbWF0Y2hlZDtcbn07XG5cblxudmFyIHJuZWVkc0NvbnRleHQgPSBqUXVlcnkuZXhwci5tYXRjaC5uZWVkc0NvbnRleHQ7XG5cbnZhciByc2luZ2xlVGFnID0gKCAvXjwoW2Etel1bXlxcL1xcMD46XFx4MjBcXHRcXHJcXG5cXGZdKilbXFx4MjBcXHRcXHJcXG5cXGZdKlxcLz8+KD86PFxcL1xcMT58KSQvaSApO1xuXG5cblxuLy8gSW1wbGVtZW50IHRoZSBpZGVudGljYWwgZnVuY3Rpb25hbGl0eSBmb3IgZmlsdGVyIGFuZCBub3RcbmZ1bmN0aW9uIHdpbm5vdyggZWxlbWVudHMsIHF1YWxpZmllciwgbm90ICkge1xuXHRpZiAoIGlzRnVuY3Rpb24oIHF1YWxpZmllciApICkge1xuXHRcdHJldHVybiBqUXVlcnkuZ3JlcCggZWxlbWVudHMsIGZ1bmN0aW9uKCBlbGVtLCBpICkge1xuXHRcdFx0cmV0dXJuICEhcXVhbGlmaWVyLmNhbGwoIGVsZW0sIGksIGVsZW0gKSAhPT0gbm90O1xuXHRcdH0gKTtcblx0fVxuXG5cdC8vIFNpbmdsZSBlbGVtZW50XG5cdGlmICggcXVhbGlmaWVyLm5vZGVUeXBlICkge1xuXHRcdHJldHVybiBqUXVlcnkuZ3JlcCggZWxlbWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuICggZWxlbSA9PT0gcXVhbGlmaWVyICkgIT09IG5vdDtcblx0XHR9ICk7XG5cdH1cblxuXHQvLyBBcnJheWxpa2Ugb2YgZWxlbWVudHMgKGpRdWVyeSwgYXJndW1lbnRzLCBBcnJheSlcblx0aWYgKCB0eXBlb2YgcXVhbGlmaWVyICE9PSBcInN0cmluZ1wiICkge1xuXHRcdHJldHVybiBqUXVlcnkuZ3JlcCggZWxlbWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuICggaW5kZXhPZi5jYWxsKCBxdWFsaWZpZXIsIGVsZW0gKSA+IC0xICkgIT09IG5vdDtcblx0XHR9ICk7XG5cdH1cblxuXHQvLyBGaWx0ZXJlZCBkaXJlY3RseSBmb3IgYm90aCBzaW1wbGUgYW5kIGNvbXBsZXggc2VsZWN0b3JzXG5cdHJldHVybiBqUXVlcnkuZmlsdGVyKCBxdWFsaWZpZXIsIGVsZW1lbnRzLCBub3QgKTtcbn1cblxualF1ZXJ5LmZpbHRlciA9IGZ1bmN0aW9uKCBleHByLCBlbGVtcywgbm90ICkge1xuXHR2YXIgZWxlbSA9IGVsZW1zWyAwIF07XG5cblx0aWYgKCBub3QgKSB7XG5cdFx0ZXhwciA9IFwiOm5vdChcIiArIGV4cHIgKyBcIilcIjtcblx0fVxuXG5cdGlmICggZWxlbXMubGVuZ3RoID09PSAxICYmIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5maW5kLm1hdGNoZXNTZWxlY3RvciggZWxlbSwgZXhwciApID8gWyBlbGVtIF0gOiBbXTtcblx0fVxuXG5cdHJldHVybiBqUXVlcnkuZmluZC5tYXRjaGVzKCBleHByLCBqUXVlcnkuZ3JlcCggZWxlbXMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBlbGVtLm5vZGVUeXBlID09PSAxO1xuXHR9ICkgKTtcbn07XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0ZmluZDogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHZhciBpLCByZXQsXG5cdFx0XHRsZW4gPSB0aGlzLmxlbmd0aCxcblx0XHRcdHNlbGYgPSB0aGlzO1xuXG5cdFx0aWYgKCB0eXBlb2Ygc2VsZWN0b3IgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIGpRdWVyeSggc2VsZWN0b3IgKS5maWx0ZXIoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRmb3IgKCBpID0gMDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdFx0XHRcdGlmICggalF1ZXJ5LmNvbnRhaW5zKCBzZWxmWyBpIF0sIHRoaXMgKSApIHtcblx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSApICk7XG5cdFx0fVxuXG5cdFx0cmV0ID0gdGhpcy5wdXNoU3RhY2soIFtdICk7XG5cblx0XHRmb3IgKCBpID0gMDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdFx0alF1ZXJ5LmZpbmQoIHNlbGVjdG9yLCBzZWxmWyBpIF0sIHJldCApO1xuXHRcdH1cblxuXHRcdHJldHVybiBsZW4gPiAxID8galF1ZXJ5LnVuaXF1ZVNvcnQoIHJldCApIDogcmV0O1xuXHR9LFxuXHRmaWx0ZXI6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIHdpbm5vdyggdGhpcywgc2VsZWN0b3IgfHwgW10sIGZhbHNlICkgKTtcblx0fSxcblx0bm90OiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCB3aW5ub3coIHRoaXMsIHNlbGVjdG9yIHx8IFtdLCB0cnVlICkgKTtcblx0fSxcblx0aXM6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRyZXR1cm4gISF3aW5ub3coXG5cdFx0XHR0aGlzLFxuXG5cdFx0XHQvLyBJZiB0aGlzIGlzIGEgcG9zaXRpb25hbC9yZWxhdGl2ZSBzZWxlY3RvciwgY2hlY2sgbWVtYmVyc2hpcCBpbiB0aGUgcmV0dXJuZWQgc2V0XG5cdFx0XHQvLyBzbyAkKFwicDpmaXJzdFwiKS5pcyhcInA6bGFzdFwiKSB3b24ndCByZXR1cm4gdHJ1ZSBmb3IgYSBkb2Mgd2l0aCB0d28gXCJwXCIuXG5cdFx0XHR0eXBlb2Ygc2VsZWN0b3IgPT09IFwic3RyaW5nXCIgJiYgcm5lZWRzQ29udGV4dC50ZXN0KCBzZWxlY3RvciApID9cblx0XHRcdFx0alF1ZXJ5KCBzZWxlY3RvciApIDpcblx0XHRcdFx0c2VsZWN0b3IgfHwgW10sXG5cdFx0XHRmYWxzZVxuXHRcdCkubGVuZ3RoO1xuXHR9XG59ICk7XG5cblxuLy8gSW5pdGlhbGl6ZSBhIGpRdWVyeSBvYmplY3RcblxuXG4vLyBBIGNlbnRyYWwgcmVmZXJlbmNlIHRvIHRoZSByb290IGpRdWVyeShkb2N1bWVudClcbnZhciByb290alF1ZXJ5LFxuXG5cdC8vIEEgc2ltcGxlIHdheSB0byBjaGVjayBmb3IgSFRNTCBzdHJpbmdzXG5cdC8vIFByaW9yaXRpemUgI2lkIG92ZXIgPHRhZz4gdG8gYXZvaWQgWFNTIHZpYSBsb2NhdGlvbi5oYXNoICh0cmFjLTk1MjEpXG5cdC8vIFN0cmljdCBIVE1MIHJlY29nbml0aW9uICh0cmFjLTExMjkwOiBtdXN0IHN0YXJ0IHdpdGggPClcblx0Ly8gU2hvcnRjdXQgc2ltcGxlICNpZCBjYXNlIGZvciBzcGVlZFxuXHRycXVpY2tFeHByID0gL14oPzpcXHMqKDxbXFx3XFxXXSs+KVtePl0qfCMoW1xcdy1dKykpJC8sXG5cblx0aW5pdCA9IGpRdWVyeS5mbi5pbml0ID0gZnVuY3Rpb24oIHNlbGVjdG9yLCBjb250ZXh0LCByb290ICkge1xuXHRcdHZhciBtYXRjaCwgZWxlbTtcblxuXHRcdC8vIEhBTkRMRTogJChcIlwiKSwgJChudWxsKSwgJCh1bmRlZmluZWQpLCAkKGZhbHNlKVxuXHRcdGlmICggIXNlbGVjdG9yICkge1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0Ly8gTWV0aG9kIGluaXQoKSBhY2NlcHRzIGFuIGFsdGVybmF0ZSByb290alF1ZXJ5XG5cdFx0Ly8gc28gbWlncmF0ZSBjYW4gc3VwcG9ydCBqUXVlcnkuc3ViIChnaC0yMTAxKVxuXHRcdHJvb3QgPSByb290IHx8IHJvb3RqUXVlcnk7XG5cblx0XHQvLyBIYW5kbGUgSFRNTCBzdHJpbmdzXG5cdFx0aWYgKCB0eXBlb2Ygc2VsZWN0b3IgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRpZiAoIHNlbGVjdG9yWyAwIF0gPT09IFwiPFwiICYmXG5cdFx0XHRcdHNlbGVjdG9yWyBzZWxlY3Rvci5sZW5ndGggLSAxIF0gPT09IFwiPlwiICYmXG5cdFx0XHRcdHNlbGVjdG9yLmxlbmd0aCA+PSAzICkge1xuXG5cdFx0XHRcdC8vIEFzc3VtZSB0aGF0IHN0cmluZ3MgdGhhdCBzdGFydCBhbmQgZW5kIHdpdGggPD4gYXJlIEhUTUwgYW5kIHNraXAgdGhlIHJlZ2V4IGNoZWNrXG5cdFx0XHRcdG1hdGNoID0gWyBudWxsLCBzZWxlY3RvciwgbnVsbCBdO1xuXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRtYXRjaCA9IHJxdWlja0V4cHIuZXhlYyggc2VsZWN0b3IgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gTWF0Y2ggaHRtbCBvciBtYWtlIHN1cmUgbm8gY29udGV4dCBpcyBzcGVjaWZpZWQgZm9yICNpZFxuXHRcdFx0aWYgKCBtYXRjaCAmJiAoIG1hdGNoWyAxIF0gfHwgIWNvbnRleHQgKSApIHtcblxuXHRcdFx0XHQvLyBIQU5ETEU6ICQoaHRtbCkgLT4gJChhcnJheSlcblx0XHRcdFx0aWYgKCBtYXRjaFsgMSBdICkge1xuXHRcdFx0XHRcdGNvbnRleHQgPSBjb250ZXh0IGluc3RhbmNlb2YgalF1ZXJ5ID8gY29udGV4dFsgMCBdIDogY29udGV4dDtcblxuXHRcdFx0XHRcdC8vIE9wdGlvbiB0byBydW4gc2NyaXB0cyBpcyB0cnVlIGZvciBiYWNrLWNvbXBhdFxuXHRcdFx0XHRcdC8vIEludGVudGlvbmFsbHkgbGV0IHRoZSBlcnJvciBiZSB0aHJvd24gaWYgcGFyc2VIVE1MIGlzIG5vdCBwcmVzZW50XG5cdFx0XHRcdFx0alF1ZXJ5Lm1lcmdlKCB0aGlzLCBqUXVlcnkucGFyc2VIVE1MKFxuXHRcdFx0XHRcdFx0bWF0Y2hbIDEgXSxcblx0XHRcdFx0XHRcdGNvbnRleHQgJiYgY29udGV4dC5ub2RlVHlwZSA/IGNvbnRleHQub3duZXJEb2N1bWVudCB8fCBjb250ZXh0IDogZG9jdW1lbnQsXG5cdFx0XHRcdFx0XHR0cnVlXG5cdFx0XHRcdFx0KSApO1xuXG5cdFx0XHRcdFx0Ly8gSEFORExFOiAkKGh0bWwsIHByb3BzKVxuXHRcdFx0XHRcdGlmICggcnNpbmdsZVRhZy50ZXN0KCBtYXRjaFsgMSBdICkgJiYgalF1ZXJ5LmlzUGxhaW5PYmplY3QoIGNvbnRleHQgKSApIHtcblx0XHRcdFx0XHRcdGZvciAoIG1hdGNoIGluIGNvbnRleHQgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gUHJvcGVydGllcyBvZiBjb250ZXh0IGFyZSBjYWxsZWQgYXMgbWV0aG9kcyBpZiBwb3NzaWJsZVxuXHRcdFx0XHRcdFx0XHRpZiAoIGlzRnVuY3Rpb24oIHRoaXNbIG1hdGNoIF0gKSApIHtcblx0XHRcdFx0XHRcdFx0XHR0aGlzWyBtYXRjaCBdKCBjb250ZXh0WyBtYXRjaCBdICk7XG5cblx0XHRcdFx0XHRcdFx0Ly8gLi4uYW5kIG90aGVyd2lzZSBzZXQgYXMgYXR0cmlidXRlc1xuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdHRoaXMuYXR0ciggbWF0Y2gsIGNvbnRleHRbIG1hdGNoIF0gKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0XHRcdC8vIEhBTkRMRTogJCgjaWQpXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0ZWxlbSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCBtYXRjaFsgMiBdICk7XG5cblx0XHRcdFx0XHRpZiAoIGVsZW0gKSB7XG5cblx0XHRcdFx0XHRcdC8vIEluamVjdCB0aGUgZWxlbWVudCBkaXJlY3RseSBpbnRvIHRoZSBqUXVlcnkgb2JqZWN0XG5cdFx0XHRcdFx0XHR0aGlzWyAwIF0gPSBlbGVtO1xuXHRcdFx0XHRcdFx0dGhpcy5sZW5ndGggPSAxO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fVxuXG5cdFx0XHQvLyBIQU5ETEU6ICQoZXhwciwgJCguLi4pKVxuXHRcdFx0fSBlbHNlIGlmICggIWNvbnRleHQgfHwgY29udGV4dC5qcXVlcnkgKSB7XG5cdFx0XHRcdHJldHVybiAoIGNvbnRleHQgfHwgcm9vdCApLmZpbmQoIHNlbGVjdG9yICk7XG5cblx0XHRcdC8vIEhBTkRMRTogJChleHByLCBjb250ZXh0KVxuXHRcdFx0Ly8gKHdoaWNoIGlzIGp1c3QgZXF1aXZhbGVudCB0bzogJChjb250ZXh0KS5maW5kKGV4cHIpXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5jb25zdHJ1Y3RvciggY29udGV4dCApLmZpbmQoIHNlbGVjdG9yICk7XG5cdFx0XHR9XG5cblx0XHQvLyBIQU5ETEU6ICQoRE9NRWxlbWVudClcblx0XHR9IGVsc2UgaWYgKCBzZWxlY3Rvci5ub2RlVHlwZSApIHtcblx0XHRcdHRoaXNbIDAgXSA9IHNlbGVjdG9yO1xuXHRcdFx0dGhpcy5sZW5ndGggPSAxO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHQvLyBIQU5ETEU6ICQoZnVuY3Rpb24pXG5cdFx0Ly8gU2hvcnRjdXQgZm9yIGRvY3VtZW50IHJlYWR5XG5cdFx0fSBlbHNlIGlmICggaXNGdW5jdGlvbiggc2VsZWN0b3IgKSApIHtcblx0XHRcdHJldHVybiByb290LnJlYWR5ICE9PSB1bmRlZmluZWQgP1xuXHRcdFx0XHRyb290LnJlYWR5KCBzZWxlY3RvciApIDpcblxuXHRcdFx0XHQvLyBFeGVjdXRlIGltbWVkaWF0ZWx5IGlmIHJlYWR5IGlzIG5vdCBwcmVzZW50XG5cdFx0XHRcdHNlbGVjdG9yKCBqUXVlcnkgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4galF1ZXJ5Lm1ha2VBcnJheSggc2VsZWN0b3IsIHRoaXMgKTtcblx0fTtcblxuLy8gR2l2ZSB0aGUgaW5pdCBmdW5jdGlvbiB0aGUgalF1ZXJ5IHByb3RvdHlwZSBmb3IgbGF0ZXIgaW5zdGFudGlhdGlvblxuaW5pdC5wcm90b3R5cGUgPSBqUXVlcnkuZm47XG5cbi8vIEluaXRpYWxpemUgY2VudHJhbCByZWZlcmVuY2VcbnJvb3RqUXVlcnkgPSBqUXVlcnkoIGRvY3VtZW50ICk7XG5cblxudmFyIHJwYXJlbnRzcHJldiA9IC9eKD86cGFyZW50c3xwcmV2KD86VW50aWx8QWxsKSkvLFxuXG5cdC8vIE1ldGhvZHMgZ3VhcmFudGVlZCB0byBwcm9kdWNlIGEgdW5pcXVlIHNldCB3aGVuIHN0YXJ0aW5nIGZyb20gYSB1bmlxdWUgc2V0XG5cdGd1YXJhbnRlZWRVbmlxdWUgPSB7XG5cdFx0Y2hpbGRyZW46IHRydWUsXG5cdFx0Y29udGVudHM6IHRydWUsXG5cdFx0bmV4dDogdHJ1ZSxcblx0XHRwcmV2OiB0cnVlXG5cdH07XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0aGFzOiBmdW5jdGlvbiggdGFyZ2V0ICkge1xuXHRcdHZhciB0YXJnZXRzID0galF1ZXJ5KCB0YXJnZXQsIHRoaXMgKSxcblx0XHRcdGwgPSB0YXJnZXRzLmxlbmd0aDtcblxuXHRcdHJldHVybiB0aGlzLmZpbHRlciggZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgaSA9IDA7XG5cdFx0XHRmb3IgKCA7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdGlmICggalF1ZXJ5LmNvbnRhaW5zKCB0aGlzLCB0YXJnZXRzWyBpIF0gKSApIHtcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHRjbG9zZXN0OiBmdW5jdGlvbiggc2VsZWN0b3JzLCBjb250ZXh0ICkge1xuXHRcdHZhciBjdXIsXG5cdFx0XHRpID0gMCxcblx0XHRcdGwgPSB0aGlzLmxlbmd0aCxcblx0XHRcdG1hdGNoZWQgPSBbXSxcblx0XHRcdHRhcmdldHMgPSB0eXBlb2Ygc2VsZWN0b3JzICE9PSBcInN0cmluZ1wiICYmIGpRdWVyeSggc2VsZWN0b3JzICk7XG5cblx0XHQvLyBQb3NpdGlvbmFsIHNlbGVjdG9ycyBuZXZlciBtYXRjaCwgc2luY2UgdGhlcmUncyBubyBfc2VsZWN0aW9uXyBjb250ZXh0XG5cdFx0aWYgKCAhcm5lZWRzQ29udGV4dC50ZXN0KCBzZWxlY3RvcnMgKSApIHtcblx0XHRcdGZvciAoIDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0Zm9yICggY3VyID0gdGhpc1sgaSBdOyBjdXIgJiYgY3VyICE9PSBjb250ZXh0OyBjdXIgPSBjdXIucGFyZW50Tm9kZSApIHtcblxuXHRcdFx0XHRcdC8vIEFsd2F5cyBza2lwIGRvY3VtZW50IGZyYWdtZW50c1xuXHRcdFx0XHRcdGlmICggY3VyLm5vZGVUeXBlIDwgMTEgJiYgKCB0YXJnZXRzID9cblx0XHRcdFx0XHRcdHRhcmdldHMuaW5kZXgoIGN1ciApID4gLTEgOlxuXG5cdFx0XHRcdFx0XHQvLyBEb24ndCBwYXNzIG5vbi1lbGVtZW50cyB0byBqUXVlcnkjZmluZFxuXHRcdFx0XHRcdFx0Y3VyLm5vZGVUeXBlID09PSAxICYmXG5cdFx0XHRcdFx0XHRcdGpRdWVyeS5maW5kLm1hdGNoZXNTZWxlY3RvciggY3VyLCBzZWxlY3RvcnMgKSApICkge1xuXG5cdFx0XHRcdFx0XHRtYXRjaGVkLnB1c2goIGN1ciApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBtYXRjaGVkLmxlbmd0aCA+IDEgPyBqUXVlcnkudW5pcXVlU29ydCggbWF0Y2hlZCApIDogbWF0Y2hlZCApO1xuXHR9LFxuXG5cdC8vIERldGVybWluZSB0aGUgcG9zaXRpb24gb2YgYW4gZWxlbWVudCB3aXRoaW4gdGhlIHNldFxuXHRpbmRleDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cblx0XHQvLyBObyBhcmd1bWVudCwgcmV0dXJuIGluZGV4IGluIHBhcmVudFxuXHRcdGlmICggIWVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gKCB0aGlzWyAwIF0gJiYgdGhpc1sgMCBdLnBhcmVudE5vZGUgKSA/IHRoaXMuZmlyc3QoKS5wcmV2QWxsKCkubGVuZ3RoIDogLTE7XG5cdFx0fVxuXG5cdFx0Ly8gSW5kZXggaW4gc2VsZWN0b3Jcblx0XHRpZiAoIHR5cGVvZiBlbGVtID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0cmV0dXJuIGluZGV4T2YuY2FsbCggalF1ZXJ5KCBlbGVtICksIHRoaXNbIDAgXSApO1xuXHRcdH1cblxuXHRcdC8vIExvY2F0ZSB0aGUgcG9zaXRpb24gb2YgdGhlIGRlc2lyZWQgZWxlbWVudFxuXHRcdHJldHVybiBpbmRleE9mLmNhbGwoIHRoaXMsXG5cblx0XHRcdC8vIElmIGl0IHJlY2VpdmVzIGEgalF1ZXJ5IG9iamVjdCwgdGhlIGZpcnN0IGVsZW1lbnQgaXMgdXNlZFxuXHRcdFx0ZWxlbS5qcXVlcnkgPyBlbGVtWyAwIF0gOiBlbGVtXG5cdFx0KTtcblx0fSxcblxuXHRhZGQ6IGZ1bmN0aW9uKCBzZWxlY3RvciwgY29udGV4dCApIHtcblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soXG5cdFx0XHRqUXVlcnkudW5pcXVlU29ydChcblx0XHRcdFx0alF1ZXJ5Lm1lcmdlKCB0aGlzLmdldCgpLCBqUXVlcnkoIHNlbGVjdG9yLCBjb250ZXh0ICkgKVxuXHRcdFx0KVxuXHRcdCk7XG5cdH0sXG5cblx0YWRkQmFjazogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHJldHVybiB0aGlzLmFkZCggc2VsZWN0b3IgPT0gbnVsbCA/XG5cdFx0XHR0aGlzLnByZXZPYmplY3QgOiB0aGlzLnByZXZPYmplY3QuZmlsdGVyKCBzZWxlY3RvciApXG5cdFx0KTtcblx0fVxufSApO1xuXG5mdW5jdGlvbiBzaWJsaW5nKCBjdXIsIGRpciApIHtcblx0d2hpbGUgKCAoIGN1ciA9IGN1clsgZGlyIF0gKSAmJiBjdXIubm9kZVR5cGUgIT09IDEgKSB7fVxuXHRyZXR1cm4gY3VyO1xufVxuXG5qUXVlcnkuZWFjaCgge1xuXHRwYXJlbnQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHZhciBwYXJlbnQgPSBlbGVtLnBhcmVudE5vZGU7XG5cdFx0cmV0dXJuIHBhcmVudCAmJiBwYXJlbnQubm9kZVR5cGUgIT09IDExID8gcGFyZW50IDogbnVsbDtcblx0fSxcblx0cGFyZW50czogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIGRpciggZWxlbSwgXCJwYXJlbnROb2RlXCIgKTtcblx0fSxcblx0cGFyZW50c1VudGlsOiBmdW5jdGlvbiggZWxlbSwgX2ksIHVudGlsICkge1xuXHRcdHJldHVybiBkaXIoIGVsZW0sIFwicGFyZW50Tm9kZVwiLCB1bnRpbCApO1xuXHR9LFxuXHRuZXh0OiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gc2libGluZyggZWxlbSwgXCJuZXh0U2libGluZ1wiICk7XG5cdH0sXG5cdHByZXY6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBzaWJsaW5nKCBlbGVtLCBcInByZXZpb3VzU2libGluZ1wiICk7XG5cdH0sXG5cdG5leHRBbGw6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBkaXIoIGVsZW0sIFwibmV4dFNpYmxpbmdcIiApO1xuXHR9LFxuXHRwcmV2QWxsOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gZGlyKCBlbGVtLCBcInByZXZpb3VzU2libGluZ1wiICk7XG5cdH0sXG5cdG5leHRVbnRpbDogZnVuY3Rpb24oIGVsZW0sIF9pLCB1bnRpbCApIHtcblx0XHRyZXR1cm4gZGlyKCBlbGVtLCBcIm5leHRTaWJsaW5nXCIsIHVudGlsICk7XG5cdH0sXG5cdHByZXZVbnRpbDogZnVuY3Rpb24oIGVsZW0sIF9pLCB1bnRpbCApIHtcblx0XHRyZXR1cm4gZGlyKCBlbGVtLCBcInByZXZpb3VzU2libGluZ1wiLCB1bnRpbCApO1xuXHR9LFxuXHRzaWJsaW5nczogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIHNpYmxpbmdzKCAoIGVsZW0ucGFyZW50Tm9kZSB8fCB7fSApLmZpcnN0Q2hpbGQsIGVsZW0gKTtcblx0fSxcblx0Y2hpbGRyZW46IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBzaWJsaW5ncyggZWxlbS5maXJzdENoaWxkICk7XG5cdH0sXG5cdGNvbnRlbnRzOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRpZiAoIGVsZW0uY29udGVudERvY3VtZW50ICE9IG51bGwgJiZcblxuXHRcdFx0Ly8gU3VwcG9ydDogSUUgMTErXG5cdFx0XHQvLyA8b2JqZWN0PiBlbGVtZW50cyB3aXRoIG5vIGBkYXRhYCBhdHRyaWJ1dGUgaGFzIGFuIG9iamVjdFxuXHRcdFx0Ly8gYGNvbnRlbnREb2N1bWVudGAgd2l0aCBhIGBudWxsYCBwcm90b3R5cGUuXG5cdFx0XHRnZXRQcm90byggZWxlbS5jb250ZW50RG9jdW1lbnQgKSApIHtcblxuXHRcdFx0cmV0dXJuIGVsZW0uY29udGVudERvY3VtZW50O1xuXHRcdH1cblxuXHRcdC8vIFN1cHBvcnQ6IElFIDkgLSAxMSBvbmx5LCBpT1MgNyBvbmx5LCBBbmRyb2lkIEJyb3dzZXIgPD00LjMgb25seVxuXHRcdC8vIFRyZWF0IHRoZSB0ZW1wbGF0ZSBlbGVtZW50IGFzIGEgcmVndWxhciBvbmUgaW4gYnJvd3NlcnMgdGhhdFxuXHRcdC8vIGRvbid0IHN1cHBvcnQgaXQuXG5cdFx0aWYgKCBub2RlTmFtZSggZWxlbSwgXCJ0ZW1wbGF0ZVwiICkgKSB7XG5cdFx0XHRlbGVtID0gZWxlbS5jb250ZW50IHx8IGVsZW07XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGpRdWVyeS5tZXJnZSggW10sIGVsZW0uY2hpbGROb2RlcyApO1xuXHR9XG59LCBmdW5jdGlvbiggbmFtZSwgZm4gKSB7XG5cdGpRdWVyeS5mblsgbmFtZSBdID0gZnVuY3Rpb24oIHVudGlsLCBzZWxlY3RvciApIHtcblx0XHR2YXIgbWF0Y2hlZCA9IGpRdWVyeS5tYXAoIHRoaXMsIGZuLCB1bnRpbCApO1xuXG5cdFx0aWYgKCBuYW1lLnNsaWNlKCAtNSApICE9PSBcIlVudGlsXCIgKSB7XG5cdFx0XHRzZWxlY3RvciA9IHVudGlsO1xuXHRcdH1cblxuXHRcdGlmICggc2VsZWN0b3IgJiYgdHlwZW9mIHNlbGVjdG9yID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0bWF0Y2hlZCA9IGpRdWVyeS5maWx0ZXIoIHNlbGVjdG9yLCBtYXRjaGVkICk7XG5cdFx0fVxuXG5cdFx0aWYgKCB0aGlzLmxlbmd0aCA+IDEgKSB7XG5cblx0XHRcdC8vIFJlbW92ZSBkdXBsaWNhdGVzXG5cdFx0XHRpZiAoICFndWFyYW50ZWVkVW5pcXVlWyBuYW1lIF0gKSB7XG5cdFx0XHRcdGpRdWVyeS51bmlxdWVTb3J0KCBtYXRjaGVkICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFJldmVyc2Ugb3JkZXIgZm9yIHBhcmVudHMqIGFuZCBwcmV2LWRlcml2YXRpdmVzXG5cdFx0XHRpZiAoIHJwYXJlbnRzcHJldi50ZXN0KCBuYW1lICkgKSB7XG5cdFx0XHRcdG1hdGNoZWQucmV2ZXJzZSgpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggbWF0Y2hlZCApO1xuXHR9O1xufSApO1xudmFyIHJub3RodG1sd2hpdGUgPSAoIC9bXlxceDIwXFx0XFxyXFxuXFxmXSsvZyApO1xuXG5cblxuLy8gQ29udmVydCBTdHJpbmctZm9ybWF0dGVkIG9wdGlvbnMgaW50byBPYmplY3QtZm9ybWF0dGVkIG9uZXNcbmZ1bmN0aW9uIGNyZWF0ZU9wdGlvbnMoIG9wdGlvbnMgKSB7XG5cdHZhciBvYmplY3QgPSB7fTtcblx0alF1ZXJ5LmVhY2goIG9wdGlvbnMubWF0Y2goIHJub3RodG1sd2hpdGUgKSB8fCBbXSwgZnVuY3Rpb24oIF8sIGZsYWcgKSB7XG5cdFx0b2JqZWN0WyBmbGFnIF0gPSB0cnVlO1xuXHR9ICk7XG5cdHJldHVybiBvYmplY3Q7XG59XG5cbi8qXG4gKiBDcmVhdGUgYSBjYWxsYmFjayBsaXN0IHVzaW5nIHRoZSBmb2xsb3dpbmcgcGFyYW1ldGVyczpcbiAqXG4gKlx0b3B0aW9uczogYW4gb3B0aW9uYWwgbGlzdCBvZiBzcGFjZS1zZXBhcmF0ZWQgb3B0aW9ucyB0aGF0IHdpbGwgY2hhbmdlIGhvd1xuICpcdFx0XHR0aGUgY2FsbGJhY2sgbGlzdCBiZWhhdmVzIG9yIGEgbW9yZSB0cmFkaXRpb25hbCBvcHRpb24gb2JqZWN0XG4gKlxuICogQnkgZGVmYXVsdCBhIGNhbGxiYWNrIGxpc3Qgd2lsbCBhY3QgbGlrZSBhbiBldmVudCBjYWxsYmFjayBsaXN0IGFuZCBjYW4gYmVcbiAqIFwiZmlyZWRcIiBtdWx0aXBsZSB0aW1lcy5cbiAqXG4gKiBQb3NzaWJsZSBvcHRpb25zOlxuICpcbiAqXHRvbmNlOlx0XHRcdHdpbGwgZW5zdXJlIHRoZSBjYWxsYmFjayBsaXN0IGNhbiBvbmx5IGJlIGZpcmVkIG9uY2UgKGxpa2UgYSBEZWZlcnJlZClcbiAqXG4gKlx0bWVtb3J5Olx0XHRcdHdpbGwga2VlcCB0cmFjayBvZiBwcmV2aW91cyB2YWx1ZXMgYW5kIHdpbGwgY2FsbCBhbnkgY2FsbGJhY2sgYWRkZWRcbiAqXHRcdFx0XHRcdGFmdGVyIHRoZSBsaXN0IGhhcyBiZWVuIGZpcmVkIHJpZ2h0IGF3YXkgd2l0aCB0aGUgbGF0ZXN0IFwibWVtb3JpemVkXCJcbiAqXHRcdFx0XHRcdHZhbHVlcyAobGlrZSBhIERlZmVycmVkKVxuICpcbiAqXHR1bmlxdWU6XHRcdFx0d2lsbCBlbnN1cmUgYSBjYWxsYmFjayBjYW4gb25seSBiZSBhZGRlZCBvbmNlIChubyBkdXBsaWNhdGUgaW4gdGhlIGxpc3QpXG4gKlxuICpcdHN0b3BPbkZhbHNlOlx0aW50ZXJydXB0IGNhbGxpbmdzIHdoZW4gYSBjYWxsYmFjayByZXR1cm5zIGZhbHNlXG4gKlxuICovXG5qUXVlcnkuQ2FsbGJhY2tzID0gZnVuY3Rpb24oIG9wdGlvbnMgKSB7XG5cblx0Ly8gQ29udmVydCBvcHRpb25zIGZyb20gU3RyaW5nLWZvcm1hdHRlZCB0byBPYmplY3QtZm9ybWF0dGVkIGlmIG5lZWRlZFxuXHQvLyAod2UgY2hlY2sgaW4gY2FjaGUgZmlyc3QpXG5cdG9wdGlvbnMgPSB0eXBlb2Ygb3B0aW9ucyA9PT0gXCJzdHJpbmdcIiA/XG5cdFx0Y3JlYXRlT3B0aW9ucyggb3B0aW9ucyApIDpcblx0XHRqUXVlcnkuZXh0ZW5kKCB7fSwgb3B0aW9ucyApO1xuXG5cdHZhciAvLyBGbGFnIHRvIGtub3cgaWYgbGlzdCBpcyBjdXJyZW50bHkgZmlyaW5nXG5cdFx0ZmlyaW5nLFxuXG5cdFx0Ly8gTGFzdCBmaXJlIHZhbHVlIGZvciBub24tZm9yZ2V0dGFibGUgbGlzdHNcblx0XHRtZW1vcnksXG5cblx0XHQvLyBGbGFnIHRvIGtub3cgaWYgbGlzdCB3YXMgYWxyZWFkeSBmaXJlZFxuXHRcdGZpcmVkLFxuXG5cdFx0Ly8gRmxhZyB0byBwcmV2ZW50IGZpcmluZ1xuXHRcdGxvY2tlZCxcblxuXHRcdC8vIEFjdHVhbCBjYWxsYmFjayBsaXN0XG5cdFx0bGlzdCA9IFtdLFxuXG5cdFx0Ly8gUXVldWUgb2YgZXhlY3V0aW9uIGRhdGEgZm9yIHJlcGVhdGFibGUgbGlzdHNcblx0XHRxdWV1ZSA9IFtdLFxuXG5cdFx0Ly8gSW5kZXggb2YgY3VycmVudGx5IGZpcmluZyBjYWxsYmFjayAobW9kaWZpZWQgYnkgYWRkL3JlbW92ZSBhcyBuZWVkZWQpXG5cdFx0ZmlyaW5nSW5kZXggPSAtMSxcblxuXHRcdC8vIEZpcmUgY2FsbGJhY2tzXG5cdFx0ZmlyZSA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0XHQvLyBFbmZvcmNlIHNpbmdsZS1maXJpbmdcblx0XHRcdGxvY2tlZCA9IGxvY2tlZCB8fCBvcHRpb25zLm9uY2U7XG5cblx0XHRcdC8vIEV4ZWN1dGUgY2FsbGJhY2tzIGZvciBhbGwgcGVuZGluZyBleGVjdXRpb25zLFxuXHRcdFx0Ly8gcmVzcGVjdGluZyBmaXJpbmdJbmRleCBvdmVycmlkZXMgYW5kIHJ1bnRpbWUgY2hhbmdlc1xuXHRcdFx0ZmlyZWQgPSBmaXJpbmcgPSB0cnVlO1xuXHRcdFx0Zm9yICggOyBxdWV1ZS5sZW5ndGg7IGZpcmluZ0luZGV4ID0gLTEgKSB7XG5cdFx0XHRcdG1lbW9yeSA9IHF1ZXVlLnNoaWZ0KCk7XG5cdFx0XHRcdHdoaWxlICggKytmaXJpbmdJbmRleCA8IGxpc3QubGVuZ3RoICkge1xuXG5cdFx0XHRcdFx0Ly8gUnVuIGNhbGxiYWNrIGFuZCBjaGVjayBmb3IgZWFybHkgdGVybWluYXRpb25cblx0XHRcdFx0XHRpZiAoIGxpc3RbIGZpcmluZ0luZGV4IF0uYXBwbHkoIG1lbW9yeVsgMCBdLCBtZW1vcnlbIDEgXSApID09PSBmYWxzZSAmJlxuXHRcdFx0XHRcdFx0b3B0aW9ucy5zdG9wT25GYWxzZSApIHtcblxuXHRcdFx0XHRcdFx0Ly8gSnVtcCB0byBlbmQgYW5kIGZvcmdldCB0aGUgZGF0YSBzbyAuYWRkIGRvZXNuJ3QgcmUtZmlyZVxuXHRcdFx0XHRcdFx0ZmlyaW5nSW5kZXggPSBsaXN0Lmxlbmd0aDtcblx0XHRcdFx0XHRcdG1lbW9yeSA9IGZhbHNlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBGb3JnZXQgdGhlIGRhdGEgaWYgd2UncmUgZG9uZSB3aXRoIGl0XG5cdFx0XHRpZiAoICFvcHRpb25zLm1lbW9yeSApIHtcblx0XHRcdFx0bWVtb3J5ID0gZmFsc2U7XG5cdFx0XHR9XG5cblx0XHRcdGZpcmluZyA9IGZhbHNlO1xuXG5cdFx0XHQvLyBDbGVhbiB1cCBpZiB3ZSdyZSBkb25lIGZpcmluZyBmb3IgZ29vZFxuXHRcdFx0aWYgKCBsb2NrZWQgKSB7XG5cblx0XHRcdFx0Ly8gS2VlcCBhbiBlbXB0eSBsaXN0IGlmIHdlIGhhdmUgZGF0YSBmb3IgZnV0dXJlIGFkZCBjYWxsc1xuXHRcdFx0XHRpZiAoIG1lbW9yeSApIHtcblx0XHRcdFx0XHRsaXN0ID0gW107XG5cblx0XHRcdFx0Ly8gT3RoZXJ3aXNlLCB0aGlzIG9iamVjdCBpcyBzcGVudFxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGxpc3QgPSBcIlwiO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdC8vIEFjdHVhbCBDYWxsYmFja3Mgb2JqZWN0XG5cdFx0c2VsZiA9IHtcblxuXHRcdFx0Ly8gQWRkIGEgY2FsbGJhY2sgb3IgYSBjb2xsZWN0aW9uIG9mIGNhbGxiYWNrcyB0byB0aGUgbGlzdFxuXHRcdFx0YWRkOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCBsaXN0ICkge1xuXG5cdFx0XHRcdFx0Ly8gSWYgd2UgaGF2ZSBtZW1vcnkgZnJvbSBhIHBhc3QgcnVuLCB3ZSBzaG91bGQgZmlyZSBhZnRlciBhZGRpbmdcblx0XHRcdFx0XHRpZiAoIG1lbW9yeSAmJiAhZmlyaW5nICkge1xuXHRcdFx0XHRcdFx0ZmlyaW5nSW5kZXggPSBsaXN0Lmxlbmd0aCAtIDE7XG5cdFx0XHRcdFx0XHRxdWV1ZS5wdXNoKCBtZW1vcnkgKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQoIGZ1bmN0aW9uIGFkZCggYXJncyApIHtcblx0XHRcdFx0XHRcdGpRdWVyeS5lYWNoKCBhcmdzLCBmdW5jdGlvbiggXywgYXJnICkge1xuXHRcdFx0XHRcdFx0XHRpZiAoIGlzRnVuY3Rpb24oIGFyZyApICkge1xuXHRcdFx0XHRcdFx0XHRcdGlmICggIW9wdGlvbnMudW5pcXVlIHx8ICFzZWxmLmhhcyggYXJnICkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRsaXN0LnB1c2goIGFyZyApO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSBlbHNlIGlmICggYXJnICYmIGFyZy5sZW5ndGggJiYgdG9UeXBlKCBhcmcgKSAhPT0gXCJzdHJpbmdcIiApIHtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIEluc3BlY3QgcmVjdXJzaXZlbHlcblx0XHRcdFx0XHRcdFx0XHRhZGQoIGFyZyApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdFx0fSApKCBhcmd1bWVudHMgKTtcblxuXHRcdFx0XHRcdGlmICggbWVtb3J5ICYmICFmaXJpbmcgKSB7XG5cdFx0XHRcdFx0XHRmaXJlKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gUmVtb3ZlIGEgY2FsbGJhY2sgZnJvbSB0aGUgbGlzdFxuXHRcdFx0cmVtb3ZlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0alF1ZXJ5LmVhY2goIGFyZ3VtZW50cywgZnVuY3Rpb24oIF8sIGFyZyApIHtcblx0XHRcdFx0XHR2YXIgaW5kZXg7XG5cdFx0XHRcdFx0d2hpbGUgKCAoIGluZGV4ID0galF1ZXJ5LmluQXJyYXkoIGFyZywgbGlzdCwgaW5kZXggKSApID4gLTEgKSB7XG5cdFx0XHRcdFx0XHRsaXN0LnNwbGljZSggaW5kZXgsIDEgKTtcblxuXHRcdFx0XHRcdFx0Ly8gSGFuZGxlIGZpcmluZyBpbmRleGVzXG5cdFx0XHRcdFx0XHRpZiAoIGluZGV4IDw9IGZpcmluZ0luZGV4ICkge1xuXHRcdFx0XHRcdFx0XHRmaXJpbmdJbmRleC0tO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSApO1xuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cblx0XHRcdC8vIENoZWNrIGlmIGEgZ2l2ZW4gY2FsbGJhY2sgaXMgaW4gdGhlIGxpc3QuXG5cdFx0XHQvLyBJZiBubyBhcmd1bWVudCBpcyBnaXZlbiwgcmV0dXJuIHdoZXRoZXIgb3Igbm90IGxpc3QgaGFzIGNhbGxiYWNrcyBhdHRhY2hlZC5cblx0XHRcdGhhczogZnVuY3Rpb24oIGZuICkge1xuXHRcdFx0XHRyZXR1cm4gZm4gP1xuXHRcdFx0XHRcdGpRdWVyeS5pbkFycmF5KCBmbiwgbGlzdCApID4gLTEgOlxuXHRcdFx0XHRcdGxpc3QubGVuZ3RoID4gMDtcblx0XHRcdH0sXG5cblx0XHRcdC8vIFJlbW92ZSBhbGwgY2FsbGJhY2tzIGZyb20gdGhlIGxpc3Rcblx0XHRcdGVtcHR5OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCBsaXN0ICkge1xuXHRcdFx0XHRcdGxpc3QgPSBbXTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cblx0XHRcdC8vIERpc2FibGUgLmZpcmUgYW5kIC5hZGRcblx0XHRcdC8vIEFib3J0IGFueSBjdXJyZW50L3BlbmRpbmcgZXhlY3V0aW9uc1xuXHRcdFx0Ly8gQ2xlYXIgYWxsIGNhbGxiYWNrcyBhbmQgdmFsdWVzXG5cdFx0XHRkaXNhYmxlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0bG9ja2VkID0gcXVldWUgPSBbXTtcblx0XHRcdFx0bGlzdCA9IG1lbW9yeSA9IFwiXCI7XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblx0XHRcdGRpc2FibGVkOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuICFsaXN0O1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gRGlzYWJsZSAuZmlyZVxuXHRcdFx0Ly8gQWxzbyBkaXNhYmxlIC5hZGQgdW5sZXNzIHdlIGhhdmUgbWVtb3J5IChzaW5jZSBpdCB3b3VsZCBoYXZlIG5vIGVmZmVjdClcblx0XHRcdC8vIEFib3J0IGFueSBwZW5kaW5nIGV4ZWN1dGlvbnNcblx0XHRcdGxvY2s6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRsb2NrZWQgPSBxdWV1ZSA9IFtdO1xuXHRcdFx0XHRpZiAoICFtZW1vcnkgJiYgIWZpcmluZyApIHtcblx0XHRcdFx0XHRsaXN0ID0gbWVtb3J5ID0gXCJcIjtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cdFx0XHRsb2NrZWQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gISFsb2NrZWQ7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBDYWxsIGFsbCBjYWxsYmFja3Mgd2l0aCB0aGUgZ2l2ZW4gY29udGV4dCBhbmQgYXJndW1lbnRzXG5cdFx0XHRmaXJlV2l0aDogZnVuY3Rpb24oIGNvbnRleHQsIGFyZ3MgKSB7XG5cdFx0XHRcdGlmICggIWxvY2tlZCApIHtcblx0XHRcdFx0XHRhcmdzID0gYXJncyB8fCBbXTtcblx0XHRcdFx0XHRhcmdzID0gWyBjb250ZXh0LCBhcmdzLnNsaWNlID8gYXJncy5zbGljZSgpIDogYXJncyBdO1xuXHRcdFx0XHRcdHF1ZXVlLnB1c2goIGFyZ3MgKTtcblx0XHRcdFx0XHRpZiAoICFmaXJpbmcgKSB7XG5cdFx0XHRcdFx0XHRmaXJlKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gQ2FsbCBhbGwgdGhlIGNhbGxiYWNrcyB3aXRoIHRoZSBnaXZlbiBhcmd1bWVudHNcblx0XHRcdGZpcmU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRzZWxmLmZpcmVXaXRoKCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBUbyBrbm93IGlmIHRoZSBjYWxsYmFja3MgaGF2ZSBhbHJlYWR5IGJlZW4gY2FsbGVkIGF0IGxlYXN0IG9uY2Vcblx0XHRcdGZpcmVkOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuICEhZmlyZWQ7XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRyZXR1cm4gc2VsZjtcbn07XG5cblxuZnVuY3Rpb24gSWRlbnRpdHkoIHYgKSB7XG5cdHJldHVybiB2O1xufVxuZnVuY3Rpb24gVGhyb3dlciggZXggKSB7XG5cdHRocm93IGV4O1xufVxuXG5mdW5jdGlvbiBhZG9wdFZhbHVlKCB2YWx1ZSwgcmVzb2x2ZSwgcmVqZWN0LCBub1ZhbHVlICkge1xuXHR2YXIgbWV0aG9kO1xuXG5cdHRyeSB7XG5cblx0XHQvLyBDaGVjayBmb3IgcHJvbWlzZSBhc3BlY3QgZmlyc3QgdG8gcHJpdmlsZWdlIHN5bmNocm9ub3VzIGJlaGF2aW9yXG5cdFx0aWYgKCB2YWx1ZSAmJiBpc0Z1bmN0aW9uKCAoIG1ldGhvZCA9IHZhbHVlLnByb21pc2UgKSApICkge1xuXHRcdFx0bWV0aG9kLmNhbGwoIHZhbHVlICkuZG9uZSggcmVzb2x2ZSApLmZhaWwoIHJlamVjdCApO1xuXG5cdFx0Ly8gT3RoZXIgdGhlbmFibGVzXG5cdFx0fSBlbHNlIGlmICggdmFsdWUgJiYgaXNGdW5jdGlvbiggKCBtZXRob2QgPSB2YWx1ZS50aGVuICkgKSApIHtcblx0XHRcdG1ldGhvZC5jYWxsKCB2YWx1ZSwgcmVzb2x2ZSwgcmVqZWN0ICk7XG5cblx0XHQvLyBPdGhlciBub24tdGhlbmFibGVzXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Ly8gQ29udHJvbCBgcmVzb2x2ZWAgYXJndW1lbnRzIGJ5IGxldHRpbmcgQXJyYXkjc2xpY2UgY2FzdCBib29sZWFuIGBub1ZhbHVlYCB0byBpbnRlZ2VyOlxuXHRcdFx0Ly8gKiBmYWxzZTogWyB2YWx1ZSBdLnNsaWNlKCAwICkgPT4gcmVzb2x2ZSggdmFsdWUgKVxuXHRcdFx0Ly8gKiB0cnVlOiBbIHZhbHVlIF0uc2xpY2UoIDEgKSA9PiByZXNvbHZlKClcblx0XHRcdHJlc29sdmUuYXBwbHkoIHVuZGVmaW5lZCwgWyB2YWx1ZSBdLnNsaWNlKCBub1ZhbHVlICkgKTtcblx0XHR9XG5cblx0Ly8gRm9yIFByb21pc2VzL0ErLCBjb252ZXJ0IGV4Y2VwdGlvbnMgaW50byByZWplY3Rpb25zXG5cdC8vIFNpbmNlIGpRdWVyeS53aGVuIGRvZXNuJ3QgdW53cmFwIHRoZW5hYmxlcywgd2UgY2FuIHNraXAgdGhlIGV4dHJhIGNoZWNrcyBhcHBlYXJpbmcgaW5cblx0Ly8gRGVmZXJyZWQjdGhlbiB0byBjb25kaXRpb25hbGx5IHN1cHByZXNzIHJlamVjdGlvbi5cblx0fSBjYXRjaCAoIHZhbHVlICkge1xuXG5cdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA0LjAgb25seVxuXHRcdC8vIFN0cmljdCBtb2RlIGZ1bmN0aW9ucyBpbnZva2VkIHdpdGhvdXQgLmNhbGwvLmFwcGx5IGdldCBnbG9iYWwtb2JqZWN0IGNvbnRleHRcblx0XHRyZWplY3QuYXBwbHkoIHVuZGVmaW5lZCwgWyB2YWx1ZSBdICk7XG5cdH1cbn1cblxualF1ZXJ5LmV4dGVuZCgge1xuXG5cdERlZmVycmVkOiBmdW5jdGlvbiggZnVuYyApIHtcblx0XHR2YXIgdHVwbGVzID0gW1xuXG5cdFx0XHRcdC8vIGFjdGlvbiwgYWRkIGxpc3RlbmVyLCBjYWxsYmFja3MsXG5cdFx0XHRcdC8vIC4uLiAudGhlbiBoYW5kbGVycywgYXJndW1lbnQgaW5kZXgsIFtmaW5hbCBzdGF0ZV1cblx0XHRcdFx0WyBcIm5vdGlmeVwiLCBcInByb2dyZXNzXCIsIGpRdWVyeS5DYWxsYmFja3MoIFwibWVtb3J5XCIgKSxcblx0XHRcdFx0XHRqUXVlcnkuQ2FsbGJhY2tzKCBcIm1lbW9yeVwiICksIDIgXSxcblx0XHRcdFx0WyBcInJlc29sdmVcIiwgXCJkb25lXCIsIGpRdWVyeS5DYWxsYmFja3MoIFwib25jZSBtZW1vcnlcIiApLFxuXHRcdFx0XHRcdGpRdWVyeS5DYWxsYmFja3MoIFwib25jZSBtZW1vcnlcIiApLCAwLCBcInJlc29sdmVkXCIgXSxcblx0XHRcdFx0WyBcInJlamVjdFwiLCBcImZhaWxcIiwgalF1ZXJ5LkNhbGxiYWNrcyggXCJvbmNlIG1lbW9yeVwiICksXG5cdFx0XHRcdFx0alF1ZXJ5LkNhbGxiYWNrcyggXCJvbmNlIG1lbW9yeVwiICksIDEsIFwicmVqZWN0ZWRcIiBdXG5cdFx0XHRdLFxuXHRcdFx0c3RhdGUgPSBcInBlbmRpbmdcIixcblx0XHRcdHByb21pc2UgPSB7XG5cdFx0XHRcdHN0YXRlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRyZXR1cm4gc3RhdGU7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdGFsd2F5czogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0ZGVmZXJyZWQuZG9uZSggYXJndW1lbnRzICkuZmFpbCggYXJndW1lbnRzICk7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdFwiY2F0Y2hcIjogZnVuY3Rpb24oIGZuICkge1xuXHRcdFx0XHRcdHJldHVybiBwcm9taXNlLnRoZW4oIG51bGwsIGZuICk7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gS2VlcCBwaXBlIGZvciBiYWNrLWNvbXBhdFxuXHRcdFx0XHRwaXBlOiBmdW5jdGlvbiggLyogZm5Eb25lLCBmbkZhaWwsIGZuUHJvZ3Jlc3MgKi8gKSB7XG5cdFx0XHRcdFx0dmFyIGZucyA9IGFyZ3VtZW50cztcblxuXHRcdFx0XHRcdHJldHVybiBqUXVlcnkuRGVmZXJyZWQoIGZ1bmN0aW9uKCBuZXdEZWZlciApIHtcblx0XHRcdFx0XHRcdGpRdWVyeS5lYWNoKCB0dXBsZXMsIGZ1bmN0aW9uKCBfaSwgdHVwbGUgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gTWFwIHR1cGxlcyAocHJvZ3Jlc3MsIGRvbmUsIGZhaWwpIHRvIGFyZ3VtZW50cyAoZG9uZSwgZmFpbCwgcHJvZ3Jlc3MpXG5cdFx0XHRcdFx0XHRcdHZhciBmbiA9IGlzRnVuY3Rpb24oIGZuc1sgdHVwbGVbIDQgXSBdICkgJiYgZm5zWyB0dXBsZVsgNCBdIF07XG5cblx0XHRcdFx0XHRcdFx0Ly8gZGVmZXJyZWQucHJvZ3Jlc3MoZnVuY3Rpb24oKSB7IGJpbmQgdG8gbmV3RGVmZXIgb3IgbmV3RGVmZXIubm90aWZ5IH0pXG5cdFx0XHRcdFx0XHRcdC8vIGRlZmVycmVkLmRvbmUoZnVuY3Rpb24oKSB7IGJpbmQgdG8gbmV3RGVmZXIgb3IgbmV3RGVmZXIucmVzb2x2ZSB9KVxuXHRcdFx0XHRcdFx0XHQvLyBkZWZlcnJlZC5mYWlsKGZ1bmN0aW9uKCkgeyBiaW5kIHRvIG5ld0RlZmVyIG9yIG5ld0RlZmVyLnJlamVjdCB9KVxuXHRcdFx0XHRcdFx0XHRkZWZlcnJlZFsgdHVwbGVbIDEgXSBdKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0XHR2YXIgcmV0dXJuZWQgPSBmbiAmJiBmbi5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKCByZXR1cm5lZCAmJiBpc0Z1bmN0aW9uKCByZXR1cm5lZC5wcm9taXNlICkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm5lZC5wcm9taXNlKClcblx0XHRcdFx0XHRcdFx0XHRcdFx0LnByb2dyZXNzKCBuZXdEZWZlci5ub3RpZnkgKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQuZG9uZSggbmV3RGVmZXIucmVzb2x2ZSApXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC5mYWlsKCBuZXdEZWZlci5yZWplY3QgKTtcblx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdFx0bmV3RGVmZXJbIHR1cGxlWyAwIF0gKyBcIldpdGhcIiBdKFxuXHRcdFx0XHRcdFx0XHRcdFx0XHR0aGlzLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRmbiA/IFsgcmV0dXJuZWQgXSA6IGFyZ3VtZW50c1xuXHRcdFx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHRcdGZucyA9IG51bGw7XG5cdFx0XHRcdFx0fSApLnByb21pc2UoKTtcblx0XHRcdFx0fSxcblx0XHRcdFx0dGhlbjogZnVuY3Rpb24oIG9uRnVsZmlsbGVkLCBvblJlamVjdGVkLCBvblByb2dyZXNzICkge1xuXHRcdFx0XHRcdHZhciBtYXhEZXB0aCA9IDA7XG5cdFx0XHRcdFx0ZnVuY3Rpb24gcmVzb2x2ZSggZGVwdGgsIGRlZmVycmVkLCBoYW5kbGVyLCBzcGVjaWFsICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHR2YXIgdGhhdCA9IHRoaXMsXG5cdFx0XHRcdFx0XHRcdFx0YXJncyA9IGFyZ3VtZW50cyxcblx0XHRcdFx0XHRcdFx0XHRtaWdodFRocm93ID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHR2YXIgcmV0dXJuZWQsIHRoZW47XG5cblx0XHRcdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IFByb21pc2VzL0ErIHNlY3Rpb24gMi4zLjMuMy4zXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBodHRwczovL3Byb21pc2VzYXBsdXMuY29tLyNwb2ludC01OVxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gSWdub3JlIGRvdWJsZS1yZXNvbHV0aW9uIGF0dGVtcHRzXG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoIGRlcHRoIDwgbWF4RGVwdGggKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuZWQgPSBoYW5kbGVyLmFwcGx5KCB0aGF0LCBhcmdzICk7XG5cblx0XHRcdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IFByb21pc2VzL0ErIHNlY3Rpb24gMi4zLjFcblx0XHRcdFx0XHRcdFx0XHRcdC8vIGh0dHBzOi8vcHJvbWlzZXNhcGx1cy5jb20vI3BvaW50LTQ4XG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoIHJldHVybmVkID09PSBkZWZlcnJlZC5wcm9taXNlKCkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoIFwiVGhlbmFibGUgc2VsZi1yZXNvbHV0aW9uXCIgKTtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogUHJvbWlzZXMvQSsgc2VjdGlvbnMgMi4zLjMuMSwgMy41XG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBodHRwczovL3Byb21pc2VzYXBsdXMuY29tLyNwb2ludC01NFxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gaHR0cHM6Ly9wcm9taXNlc2FwbHVzLmNvbS8jcG9pbnQtNzVcblx0XHRcdFx0XHRcdFx0XHRcdC8vIFJldHJpZXZlIGB0aGVuYCBvbmx5IG9uY2Vcblx0XHRcdFx0XHRcdFx0XHRcdHRoZW4gPSByZXR1cm5lZCAmJlxuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IFByb21pc2VzL0ErIHNlY3Rpb24gMi4zLjRcblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gaHR0cHM6Ly9wcm9taXNlc2FwbHVzLmNvbS8jcG9pbnQtNjRcblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gT25seSBjaGVjayBvYmplY3RzIGFuZCBmdW5jdGlvbnMgZm9yIHRoZW5hYmlsaXR5XG5cdFx0XHRcdFx0XHRcdFx0XHRcdCggdHlwZW9mIHJldHVybmVkID09PSBcIm9iamVjdFwiIHx8XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZW9mIHJldHVybmVkID09PSBcImZ1bmN0aW9uXCIgKSAmJlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm5lZC50aGVuO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBIYW5kbGUgYSByZXR1cm5lZCB0aGVuYWJsZVxuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBpc0Z1bmN0aW9uKCB0aGVuICkgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gU3BlY2lhbCBwcm9jZXNzb3JzIChub3RpZnkpIGp1c3Qgd2FpdCBmb3IgcmVzb2x1dGlvblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoIHNwZWNpYWwgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0dGhlbi5jYWxsKFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuZWQsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRyZXNvbHZlKCBtYXhEZXB0aCwgZGVmZXJyZWQsIElkZW50aXR5LCBzcGVjaWFsICksXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRyZXNvbHZlKCBtYXhEZXB0aCwgZGVmZXJyZWQsIFRocm93ZXIsIHNwZWNpYWwgKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gTm9ybWFsIHByb2Nlc3NvcnMgKHJlc29sdmUpIGFsc28gaG9vayBpbnRvIHByb2dyZXNzXG5cdFx0XHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyAuLi5hbmQgZGlzcmVnYXJkIG9sZGVyIHJlc29sdXRpb24gdmFsdWVzXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0bWF4RGVwdGgrKztcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHRoZW4uY2FsbChcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHJldHVybmVkLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cmVzb2x2ZSggbWF4RGVwdGgsIGRlZmVycmVkLCBJZGVudGl0eSwgc3BlY2lhbCApLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cmVzb2x2ZSggbWF4RGVwdGgsIGRlZmVycmVkLCBUaHJvd2VyLCBzcGVjaWFsICksXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRyZXNvbHZlKCBtYXhEZXB0aCwgZGVmZXJyZWQsIElkZW50aXR5LFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRkZWZlcnJlZC5ub3RpZnlXaXRoIClcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdC8vIEhhbmRsZSBhbGwgb3RoZXIgcmV0dXJuZWQgdmFsdWVzXG5cdFx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIE9ubHkgc3Vic3RpdHV0ZSBoYW5kbGVycyBwYXNzIG9uIGNvbnRleHRcblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gYW5kIG11bHRpcGxlIHZhbHVlcyAobm9uLXNwZWMgYmVoYXZpb3IpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlmICggaGFuZGxlciAhPT0gSWRlbnRpdHkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0dGhhdCA9IHVuZGVmaW5lZDtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRhcmdzID0gWyByZXR1cm5lZCBdO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gUHJvY2VzcyB0aGUgdmFsdWUocylcblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gRGVmYXVsdCBwcm9jZXNzIGlzIHJlc29sdmVcblx0XHRcdFx0XHRcdFx0XHRcdFx0KCBzcGVjaWFsIHx8IGRlZmVycmVkLnJlc29sdmVXaXRoICkoIHRoYXQsIGFyZ3MgKTtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9LFxuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gT25seSBub3JtYWwgcHJvY2Vzc29ycyAocmVzb2x2ZSkgY2F0Y2ggYW5kIHJlamVjdCBleGNlcHRpb25zXG5cdFx0XHRcdFx0XHRcdFx0cHJvY2VzcyA9IHNwZWNpYWwgP1xuXHRcdFx0XHRcdFx0XHRcdFx0bWlnaHRUaHJvdyA6XG5cdFx0XHRcdFx0XHRcdFx0XHRmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRtaWdodFRocm93KCk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH0gY2F0Y2ggKCBlICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBqUXVlcnkuRGVmZXJyZWQuZXhjZXB0aW9uSG9vayApIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGpRdWVyeS5EZWZlcnJlZC5leGNlcHRpb25Ib29rKCBlLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRwcm9jZXNzLmVycm9yICk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogUHJvbWlzZXMvQSsgc2VjdGlvbiAyLjMuMy4zLjQuMVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIGh0dHBzOi8vcHJvbWlzZXNhcGx1cy5jb20vI3BvaW50LTYxXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gSWdub3JlIHBvc3QtcmVzb2x1dGlvbiBleGNlcHRpb25zXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBkZXB0aCArIDEgPj0gbWF4RGVwdGggKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIE9ubHkgc3Vic3RpdHV0ZSBoYW5kbGVycyBwYXNzIG9uIGNvbnRleHRcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIGFuZCBtdWx0aXBsZSB2YWx1ZXMgKG5vbi1zcGVjIGJlaGF2aW9yKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBoYW5kbGVyICE9PSBUaHJvd2VyICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0aGF0ID0gdW5kZWZpbmVkO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRhcmdzID0gWyBlIF07XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGRlZmVycmVkLnJlamVjdFdpdGgoIHRoYXQsIGFyZ3MgKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdH07XG5cblx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogUHJvbWlzZXMvQSsgc2VjdGlvbiAyLjMuMy4zLjFcblx0XHRcdFx0XHRcdFx0Ly8gaHR0cHM6Ly9wcm9taXNlc2FwbHVzLmNvbS8jcG9pbnQtNTdcblx0XHRcdFx0XHRcdFx0Ly8gUmUtcmVzb2x2ZSBwcm9taXNlcyBpbW1lZGlhdGVseSB0byBkb2RnZSBmYWxzZSByZWplY3Rpb24gZnJvbVxuXHRcdFx0XHRcdFx0XHQvLyBzdWJzZXF1ZW50IGVycm9yc1xuXHRcdFx0XHRcdFx0XHRpZiAoIGRlcHRoICkge1xuXHRcdFx0XHRcdFx0XHRcdHByb2Nlc3MoKTtcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIENhbGwgYW4gb3B0aW9uYWwgaG9vayB0byByZWNvcmQgdGhlIGVycm9yLCBpbiBjYXNlIG9mIGV4Y2VwdGlvblxuXHRcdFx0XHRcdFx0XHRcdC8vIHNpbmNlIGl0J3Mgb3RoZXJ3aXNlIGxvc3Qgd2hlbiBleGVjdXRpb24gZ29lcyBhc3luY1xuXHRcdFx0XHRcdFx0XHRcdGlmICggalF1ZXJ5LkRlZmVycmVkLmdldEVycm9ySG9vayApIHtcblx0XHRcdFx0XHRcdFx0XHRcdHByb2Nlc3MuZXJyb3IgPSBqUXVlcnkuRGVmZXJyZWQuZ2V0RXJyb3JIb29rKCk7XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBUaGUgZGVwcmVjYXRlZCBhbGlhcyBvZiB0aGUgYWJvdmUuIFdoaWxlIHRoZSBuYW1lIHN1Z2dlc3RzXG5cdFx0XHRcdFx0XHRcdFx0Ly8gcmV0dXJuaW5nIHRoZSBzdGFjaywgbm90IGFuIGVycm9yIGluc3RhbmNlLCBqUXVlcnkganVzdCBwYXNzZXNcblx0XHRcdFx0XHRcdFx0XHQvLyBpdCBkaXJlY3RseSB0byBgY29uc29sZS53YXJuYCBzbyBib3RoIHdpbGwgd29yazsgYW4gaW5zdGFuY2Vcblx0XHRcdFx0XHRcdFx0XHQvLyBqdXN0IGJldHRlciBjb29wZXJhdGVzIHdpdGggc291cmNlIG1hcHMuXG5cdFx0XHRcdFx0XHRcdFx0fSBlbHNlIGlmICggalF1ZXJ5LkRlZmVycmVkLmdldFN0YWNrSG9vayApIHtcblx0XHRcdFx0XHRcdFx0XHRcdHByb2Nlc3MuZXJyb3IgPSBqUXVlcnkuRGVmZXJyZWQuZ2V0U3RhY2tIb29rKCk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdHdpbmRvdy5zZXRUaW1lb3V0KCBwcm9jZXNzICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0cmV0dXJuIGpRdWVyeS5EZWZlcnJlZCggZnVuY3Rpb24oIG5ld0RlZmVyICkge1xuXG5cdFx0XHRcdFx0XHQvLyBwcm9ncmVzc19oYW5kbGVycy5hZGQoIC4uLiApXG5cdFx0XHRcdFx0XHR0dXBsZXNbIDAgXVsgMyBdLmFkZChcblx0XHRcdFx0XHRcdFx0cmVzb2x2ZShcblx0XHRcdFx0XHRcdFx0XHQwLFxuXHRcdFx0XHRcdFx0XHRcdG5ld0RlZmVyLFxuXHRcdFx0XHRcdFx0XHRcdGlzRnVuY3Rpb24oIG9uUHJvZ3Jlc3MgKSA/XG5cdFx0XHRcdFx0XHRcdFx0XHRvblByb2dyZXNzIDpcblx0XHRcdFx0XHRcdFx0XHRcdElkZW50aXR5LFxuXHRcdFx0XHRcdFx0XHRcdG5ld0RlZmVyLm5vdGlmeVdpdGhcblx0XHRcdFx0XHRcdFx0KVxuXHRcdFx0XHRcdFx0KTtcblxuXHRcdFx0XHRcdFx0Ly8gZnVsZmlsbGVkX2hhbmRsZXJzLmFkZCggLi4uIClcblx0XHRcdFx0XHRcdHR1cGxlc1sgMSBdWyAzIF0uYWRkKFxuXHRcdFx0XHRcdFx0XHRyZXNvbHZlKFxuXHRcdFx0XHRcdFx0XHRcdDAsXG5cdFx0XHRcdFx0XHRcdFx0bmV3RGVmZXIsXG5cdFx0XHRcdFx0XHRcdFx0aXNGdW5jdGlvbiggb25GdWxmaWxsZWQgKSA/XG5cdFx0XHRcdFx0XHRcdFx0XHRvbkZ1bGZpbGxlZCA6XG5cdFx0XHRcdFx0XHRcdFx0XHRJZGVudGl0eVxuXHRcdFx0XHRcdFx0XHQpXG5cdFx0XHRcdFx0XHQpO1xuXG5cdFx0XHRcdFx0XHQvLyByZWplY3RlZF9oYW5kbGVycy5hZGQoIC4uLiApXG5cdFx0XHRcdFx0XHR0dXBsZXNbIDIgXVsgMyBdLmFkZChcblx0XHRcdFx0XHRcdFx0cmVzb2x2ZShcblx0XHRcdFx0XHRcdFx0XHQwLFxuXHRcdFx0XHRcdFx0XHRcdG5ld0RlZmVyLFxuXHRcdFx0XHRcdFx0XHRcdGlzRnVuY3Rpb24oIG9uUmVqZWN0ZWQgKSA/XG5cdFx0XHRcdFx0XHRcdFx0XHRvblJlamVjdGVkIDpcblx0XHRcdFx0XHRcdFx0XHRcdFRocm93ZXJcblx0XHRcdFx0XHRcdFx0KVxuXHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHR9ICkucHJvbWlzZSgpO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdC8vIEdldCBhIHByb21pc2UgZm9yIHRoaXMgZGVmZXJyZWRcblx0XHRcdFx0Ly8gSWYgb2JqIGlzIHByb3ZpZGVkLCB0aGUgcHJvbWlzZSBhc3BlY3QgaXMgYWRkZWQgdG8gdGhlIG9iamVjdFxuXHRcdFx0XHRwcm9taXNlOiBmdW5jdGlvbiggb2JqICkge1xuXHRcdFx0XHRcdHJldHVybiBvYmogIT0gbnVsbCA/IGpRdWVyeS5leHRlbmQoIG9iaiwgcHJvbWlzZSApIDogcHJvbWlzZTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdGRlZmVycmVkID0ge307XG5cblx0XHQvLyBBZGQgbGlzdC1zcGVjaWZpYyBtZXRob2RzXG5cdFx0alF1ZXJ5LmVhY2goIHR1cGxlcywgZnVuY3Rpb24oIGksIHR1cGxlICkge1xuXHRcdFx0dmFyIGxpc3QgPSB0dXBsZVsgMiBdLFxuXHRcdFx0XHRzdGF0ZVN0cmluZyA9IHR1cGxlWyA1IF07XG5cblx0XHRcdC8vIHByb21pc2UucHJvZ3Jlc3MgPSBsaXN0LmFkZFxuXHRcdFx0Ly8gcHJvbWlzZS5kb25lID0gbGlzdC5hZGRcblx0XHRcdC8vIHByb21pc2UuZmFpbCA9IGxpc3QuYWRkXG5cdFx0XHRwcm9taXNlWyB0dXBsZVsgMSBdIF0gPSBsaXN0LmFkZDtcblxuXHRcdFx0Ly8gSGFuZGxlIHN0YXRlXG5cdFx0XHRpZiAoIHN0YXRlU3RyaW5nICkge1xuXHRcdFx0XHRsaXN0LmFkZChcblx0XHRcdFx0XHRmdW5jdGlvbigpIHtcblxuXHRcdFx0XHRcdFx0Ly8gc3RhdGUgPSBcInJlc29sdmVkXCIgKGkuZS4sIGZ1bGZpbGxlZClcblx0XHRcdFx0XHRcdC8vIHN0YXRlID0gXCJyZWplY3RlZFwiXG5cdFx0XHRcdFx0XHRzdGF0ZSA9IHN0YXRlU3RyaW5nO1xuXHRcdFx0XHRcdH0sXG5cblx0XHRcdFx0XHQvLyByZWplY3RlZF9jYWxsYmFja3MuZGlzYWJsZVxuXHRcdFx0XHRcdC8vIGZ1bGZpbGxlZF9jYWxsYmFja3MuZGlzYWJsZVxuXHRcdFx0XHRcdHR1cGxlc1sgMyAtIGkgXVsgMiBdLmRpc2FibGUsXG5cblx0XHRcdFx0XHQvLyByZWplY3RlZF9oYW5kbGVycy5kaXNhYmxlXG5cdFx0XHRcdFx0Ly8gZnVsZmlsbGVkX2hhbmRsZXJzLmRpc2FibGVcblx0XHRcdFx0XHR0dXBsZXNbIDMgLSBpIF1bIDMgXS5kaXNhYmxlLFxuXG5cdFx0XHRcdFx0Ly8gcHJvZ3Jlc3NfY2FsbGJhY2tzLmxvY2tcblx0XHRcdFx0XHR0dXBsZXNbIDAgXVsgMiBdLmxvY2ssXG5cblx0XHRcdFx0XHQvLyBwcm9ncmVzc19oYW5kbGVycy5sb2NrXG5cdFx0XHRcdFx0dHVwbGVzWyAwIF1bIDMgXS5sb2NrXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIHByb2dyZXNzX2hhbmRsZXJzLmZpcmVcblx0XHRcdC8vIGZ1bGZpbGxlZF9oYW5kbGVycy5maXJlXG5cdFx0XHQvLyByZWplY3RlZF9oYW5kbGVycy5maXJlXG5cdFx0XHRsaXN0LmFkZCggdHVwbGVbIDMgXS5maXJlICk7XG5cblx0XHRcdC8vIGRlZmVycmVkLm5vdGlmeSA9IGZ1bmN0aW9uKCkgeyBkZWZlcnJlZC5ub3RpZnlXaXRoKC4uLikgfVxuXHRcdFx0Ly8gZGVmZXJyZWQucmVzb2x2ZSA9IGZ1bmN0aW9uKCkgeyBkZWZlcnJlZC5yZXNvbHZlV2l0aCguLi4pIH1cblx0XHRcdC8vIGRlZmVycmVkLnJlamVjdCA9IGZ1bmN0aW9uKCkgeyBkZWZlcnJlZC5yZWplY3RXaXRoKC4uLikgfVxuXHRcdFx0ZGVmZXJyZWRbIHR1cGxlWyAwIF0gXSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRkZWZlcnJlZFsgdHVwbGVbIDAgXSArIFwiV2l0aFwiIF0oIHRoaXMgPT09IGRlZmVycmVkID8gdW5kZWZpbmVkIDogdGhpcywgYXJndW1lbnRzICk7XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fTtcblxuXHRcdFx0Ly8gZGVmZXJyZWQubm90aWZ5V2l0aCA9IGxpc3QuZmlyZVdpdGhcblx0XHRcdC8vIGRlZmVycmVkLnJlc29sdmVXaXRoID0gbGlzdC5maXJlV2l0aFxuXHRcdFx0Ly8gZGVmZXJyZWQucmVqZWN0V2l0aCA9IGxpc3QuZmlyZVdpdGhcblx0XHRcdGRlZmVycmVkWyB0dXBsZVsgMCBdICsgXCJXaXRoXCIgXSA9IGxpc3QuZmlyZVdpdGg7XG5cdFx0fSApO1xuXG5cdFx0Ly8gTWFrZSB0aGUgZGVmZXJyZWQgYSBwcm9taXNlXG5cdFx0cHJvbWlzZS5wcm9taXNlKCBkZWZlcnJlZCApO1xuXG5cdFx0Ly8gQ2FsbCBnaXZlbiBmdW5jIGlmIGFueVxuXHRcdGlmICggZnVuYyApIHtcblx0XHRcdGZ1bmMuY2FsbCggZGVmZXJyZWQsIGRlZmVycmVkICk7XG5cdFx0fVxuXG5cdFx0Ly8gQWxsIGRvbmUhXG5cdFx0cmV0dXJuIGRlZmVycmVkO1xuXHR9LFxuXG5cdC8vIERlZmVycmVkIGhlbHBlclxuXHR3aGVuOiBmdW5jdGlvbiggc2luZ2xlVmFsdWUgKSB7XG5cdFx0dmFyXG5cblx0XHRcdC8vIGNvdW50IG9mIHVuY29tcGxldGVkIHN1Ym9yZGluYXRlc1xuXHRcdFx0cmVtYWluaW5nID0gYXJndW1lbnRzLmxlbmd0aCxcblxuXHRcdFx0Ly8gY291bnQgb2YgdW5wcm9jZXNzZWQgYXJndW1lbnRzXG5cdFx0XHRpID0gcmVtYWluaW5nLFxuXG5cdFx0XHQvLyBzdWJvcmRpbmF0ZSBmdWxmaWxsbWVudCBkYXRhXG5cdFx0XHRyZXNvbHZlQ29udGV4dHMgPSBBcnJheSggaSApLFxuXHRcdFx0cmVzb2x2ZVZhbHVlcyA9IHNsaWNlLmNhbGwoIGFyZ3VtZW50cyApLFxuXG5cdFx0XHQvLyB0aGUgcHJpbWFyeSBEZWZlcnJlZFxuXHRcdFx0cHJpbWFyeSA9IGpRdWVyeS5EZWZlcnJlZCgpLFxuXG5cdFx0XHQvLyBzdWJvcmRpbmF0ZSBjYWxsYmFjayBmYWN0b3J5XG5cdFx0XHR1cGRhdGVGdW5jID0gZnVuY3Rpb24oIGkgKSB7XG5cdFx0XHRcdHJldHVybiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHRcdFx0cmVzb2x2ZUNvbnRleHRzWyBpIF0gPSB0aGlzO1xuXHRcdFx0XHRcdHJlc29sdmVWYWx1ZXNbIGkgXSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxID8gc2xpY2UuY2FsbCggYXJndW1lbnRzICkgOiB2YWx1ZTtcblx0XHRcdFx0XHRpZiAoICEoIC0tcmVtYWluaW5nICkgKSB7XG5cdFx0XHRcdFx0XHRwcmltYXJ5LnJlc29sdmVXaXRoKCByZXNvbHZlQ29udGV4dHMsIHJlc29sdmVWYWx1ZXMgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH07XG5cdFx0XHR9O1xuXG5cdFx0Ly8gU2luZ2xlLSBhbmQgZW1wdHkgYXJndW1lbnRzIGFyZSBhZG9wdGVkIGxpa2UgUHJvbWlzZS5yZXNvbHZlXG5cdFx0aWYgKCByZW1haW5pbmcgPD0gMSApIHtcblx0XHRcdGFkb3B0VmFsdWUoIHNpbmdsZVZhbHVlLCBwcmltYXJ5LmRvbmUoIHVwZGF0ZUZ1bmMoIGkgKSApLnJlc29sdmUsIHByaW1hcnkucmVqZWN0LFxuXHRcdFx0XHQhcmVtYWluaW5nICk7XG5cblx0XHRcdC8vIFVzZSAudGhlbigpIHRvIHVud3JhcCBzZWNvbmRhcnkgdGhlbmFibGVzIChjZi4gZ2gtMzAwMClcblx0XHRcdGlmICggcHJpbWFyeS5zdGF0ZSgpID09PSBcInBlbmRpbmdcIiB8fFxuXHRcdFx0XHRpc0Z1bmN0aW9uKCByZXNvbHZlVmFsdWVzWyBpIF0gJiYgcmVzb2x2ZVZhbHVlc1sgaSBdLnRoZW4gKSApIHtcblxuXHRcdFx0XHRyZXR1cm4gcHJpbWFyeS50aGVuKCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gTXVsdGlwbGUgYXJndW1lbnRzIGFyZSBhZ2dyZWdhdGVkIGxpa2UgUHJvbWlzZS5hbGwgYXJyYXkgZWxlbWVudHNcblx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdGFkb3B0VmFsdWUoIHJlc29sdmVWYWx1ZXNbIGkgXSwgdXBkYXRlRnVuYyggaSApLCBwcmltYXJ5LnJlamVjdCApO1xuXHRcdH1cblxuXHRcdHJldHVybiBwcmltYXJ5LnByb21pc2UoKTtcblx0fVxufSApO1xuXG5cbi8vIFRoZXNlIHVzdWFsbHkgaW5kaWNhdGUgYSBwcm9ncmFtbWVyIG1pc3Rha2UgZHVyaW5nIGRldmVsb3BtZW50LFxuLy8gd2FybiBhYm91dCB0aGVtIEFTQVAgcmF0aGVyIHRoYW4gc3dhbGxvd2luZyB0aGVtIGJ5IGRlZmF1bHQuXG52YXIgcmVycm9yTmFtZXMgPSAvXihFdmFsfEludGVybmFsfFJhbmdlfFJlZmVyZW5jZXxTeW50YXh8VHlwZXxVUkkpRXJyb3IkLztcblxuLy8gSWYgYGpRdWVyeS5EZWZlcnJlZC5nZXRFcnJvckhvb2tgIGlzIGRlZmluZWQsIGBhc3luY0Vycm9yYCBpcyBhbiBlcnJvclxuLy8gY2FwdHVyZWQgYmVmb3JlIHRoZSBhc3luYyBiYXJyaWVyIHRvIGdldCB0aGUgb3JpZ2luYWwgZXJyb3IgY2F1c2Vcbi8vIHdoaWNoIG1heSBvdGhlcndpc2UgYmUgaGlkZGVuLlxualF1ZXJ5LkRlZmVycmVkLmV4Y2VwdGlvbkhvb2sgPSBmdW5jdGlvbiggZXJyb3IsIGFzeW5jRXJyb3IgKSB7XG5cblx0Ly8gU3VwcG9ydDogSUUgOCAtIDkgb25seVxuXHQvLyBDb25zb2xlIGV4aXN0cyB3aGVuIGRldiB0b29scyBhcmUgb3Blbiwgd2hpY2ggY2FuIGhhcHBlbiBhdCBhbnkgdGltZVxuXHRpZiAoIHdpbmRvdy5jb25zb2xlICYmIHdpbmRvdy5jb25zb2xlLndhcm4gJiYgZXJyb3IgJiYgcmVycm9yTmFtZXMudGVzdCggZXJyb3IubmFtZSApICkge1xuXHRcdHdpbmRvdy5jb25zb2xlLndhcm4oIFwialF1ZXJ5LkRlZmVycmVkIGV4Y2VwdGlvbjogXCIgKyBlcnJvci5tZXNzYWdlLFxuXHRcdFx0ZXJyb3Iuc3RhY2ssIGFzeW5jRXJyb3IgKTtcblx0fVxufTtcblxuXG5cblxualF1ZXJ5LnJlYWR5RXhjZXB0aW9uID0gZnVuY3Rpb24oIGVycm9yICkge1xuXHR3aW5kb3cuc2V0VGltZW91dCggZnVuY3Rpb24oKSB7XG5cdFx0dGhyb3cgZXJyb3I7XG5cdH0gKTtcbn07XG5cblxuXG5cbi8vIFRoZSBkZWZlcnJlZCB1c2VkIG9uIERPTSByZWFkeVxudmFyIHJlYWR5TGlzdCA9IGpRdWVyeS5EZWZlcnJlZCgpO1xuXG5qUXVlcnkuZm4ucmVhZHkgPSBmdW5jdGlvbiggZm4gKSB7XG5cblx0cmVhZHlMaXN0XG5cdFx0LnRoZW4oIGZuIClcblxuXHRcdC8vIFdyYXAgalF1ZXJ5LnJlYWR5RXhjZXB0aW9uIGluIGEgZnVuY3Rpb24gc28gdGhhdCB0aGUgbG9va3VwXG5cdFx0Ly8gaGFwcGVucyBhdCB0aGUgdGltZSBvZiBlcnJvciBoYW5kbGluZyBpbnN0ZWFkIG9mIGNhbGxiYWNrXG5cdFx0Ly8gcmVnaXN0cmF0aW9uLlxuXHRcdC5jYXRjaCggZnVuY3Rpb24oIGVycm9yICkge1xuXHRcdFx0alF1ZXJ5LnJlYWR5RXhjZXB0aW9uKCBlcnJvciApO1xuXHRcdH0gKTtcblxuXHRyZXR1cm4gdGhpcztcbn07XG5cbmpRdWVyeS5leHRlbmQoIHtcblxuXHQvLyBJcyB0aGUgRE9NIHJlYWR5IHRvIGJlIHVzZWQ/IFNldCB0byB0cnVlIG9uY2UgaXQgb2NjdXJzLlxuXHRpc1JlYWR5OiBmYWxzZSxcblxuXHQvLyBBIGNvdW50ZXIgdG8gdHJhY2sgaG93IG1hbnkgaXRlbXMgdG8gd2FpdCBmb3IgYmVmb3JlXG5cdC8vIHRoZSByZWFkeSBldmVudCBmaXJlcy4gU2VlIHRyYWMtNjc4MVxuXHRyZWFkeVdhaXQ6IDEsXG5cblx0Ly8gSGFuZGxlIHdoZW4gdGhlIERPTSBpcyByZWFkeVxuXHRyZWFkeTogZnVuY3Rpb24oIHdhaXQgKSB7XG5cblx0XHQvLyBBYm9ydCBpZiB0aGVyZSBhcmUgcGVuZGluZyBob2xkcyBvciB3ZSdyZSBhbHJlYWR5IHJlYWR5XG5cdFx0aWYgKCB3YWl0ID09PSB0cnVlID8gLS1qUXVlcnkucmVhZHlXYWl0IDogalF1ZXJ5LmlzUmVhZHkgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gUmVtZW1iZXIgdGhhdCB0aGUgRE9NIGlzIHJlYWR5XG5cdFx0alF1ZXJ5LmlzUmVhZHkgPSB0cnVlO1xuXG5cdFx0Ly8gSWYgYSBub3JtYWwgRE9NIFJlYWR5IGV2ZW50IGZpcmVkLCBkZWNyZW1lbnQsIGFuZCB3YWl0IGlmIG5lZWQgYmVcblx0XHRpZiAoIHdhaXQgIT09IHRydWUgJiYgLS1qUXVlcnkucmVhZHlXYWl0ID4gMCApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBJZiB0aGVyZSBhcmUgZnVuY3Rpb25zIGJvdW5kLCB0byBleGVjdXRlXG5cdFx0cmVhZHlMaXN0LnJlc29sdmVXaXRoKCBkb2N1bWVudCwgWyBqUXVlcnkgXSApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5yZWFkeS50aGVuID0gcmVhZHlMaXN0LnRoZW47XG5cbi8vIFRoZSByZWFkeSBldmVudCBoYW5kbGVyIGFuZCBzZWxmIGNsZWFudXAgbWV0aG9kXG5mdW5jdGlvbiBjb21wbGV0ZWQoKSB7XG5cdGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoIFwiRE9NQ29udGVudExvYWRlZFwiLCBjb21wbGV0ZWQgKTtcblx0d2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoIFwibG9hZFwiLCBjb21wbGV0ZWQgKTtcblx0alF1ZXJ5LnJlYWR5KCk7XG59XG5cbi8vIENhdGNoIGNhc2VzIHdoZXJlICQoZG9jdW1lbnQpLnJlYWR5KCkgaXMgY2FsbGVkXG4vLyBhZnRlciB0aGUgYnJvd3NlciBldmVudCBoYXMgYWxyZWFkeSBvY2N1cnJlZC5cbi8vIFN1cHBvcnQ6IElFIDw9OSAtIDEwIG9ubHlcbi8vIE9sZGVyIElFIHNvbWV0aW1lcyBzaWduYWxzIFwiaW50ZXJhY3RpdmVcIiB0b28gc29vblxuaWYgKCBkb2N1bWVudC5yZWFkeVN0YXRlID09PSBcImNvbXBsZXRlXCIgfHxcblx0KCBkb2N1bWVudC5yZWFkeVN0YXRlICE9PSBcImxvYWRpbmdcIiAmJiAhZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmRvU2Nyb2xsICkgKSB7XG5cblx0Ly8gSGFuZGxlIGl0IGFzeW5jaHJvbm91c2x5IHRvIGFsbG93IHNjcmlwdHMgdGhlIG9wcG9ydHVuaXR5IHRvIGRlbGF5IHJlYWR5XG5cdHdpbmRvdy5zZXRUaW1lb3V0KCBqUXVlcnkucmVhZHkgKTtcblxufSBlbHNlIHtcblxuXHQvLyBVc2UgdGhlIGhhbmR5IGV2ZW50IGNhbGxiYWNrXG5cdGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoIFwiRE9NQ29udGVudExvYWRlZFwiLCBjb21wbGV0ZWQgKTtcblxuXHQvLyBBIGZhbGxiYWNrIHRvIHdpbmRvdy5vbmxvYWQsIHRoYXQgd2lsbCBhbHdheXMgd29ya1xuXHR3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lciggXCJsb2FkXCIsIGNvbXBsZXRlZCApO1xufVxuXG5cblxuXG4vLyBNdWx0aWZ1bmN0aW9uYWwgbWV0aG9kIHRvIGdldCBhbmQgc2V0IHZhbHVlcyBvZiBhIGNvbGxlY3Rpb25cbi8vIFRoZSB2YWx1ZS9zIGNhbiBvcHRpb25hbGx5IGJlIGV4ZWN1dGVkIGlmIGl0J3MgYSBmdW5jdGlvblxudmFyIGFjY2VzcyA9IGZ1bmN0aW9uKCBlbGVtcywgZm4sIGtleSwgdmFsdWUsIGNoYWluYWJsZSwgZW1wdHlHZXQsIHJhdyApIHtcblx0dmFyIGkgPSAwLFxuXHRcdGxlbiA9IGVsZW1zLmxlbmd0aCxcblx0XHRidWxrID0ga2V5ID09IG51bGw7XG5cblx0Ly8gU2V0cyBtYW55IHZhbHVlc1xuXHRpZiAoIHRvVHlwZSgga2V5ICkgPT09IFwib2JqZWN0XCIgKSB7XG5cdFx0Y2hhaW5hYmxlID0gdHJ1ZTtcblx0XHRmb3IgKCBpIGluIGtleSApIHtcblx0XHRcdGFjY2VzcyggZWxlbXMsIGZuLCBpLCBrZXlbIGkgXSwgdHJ1ZSwgZW1wdHlHZXQsIHJhdyApO1xuXHRcdH1cblxuXHQvLyBTZXRzIG9uZSB2YWx1ZVxuXHR9IGVsc2UgaWYgKCB2YWx1ZSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdGNoYWluYWJsZSA9IHRydWU7XG5cblx0XHRpZiAoICFpc0Z1bmN0aW9uKCB2YWx1ZSApICkge1xuXHRcdFx0cmF3ID0gdHJ1ZTtcblx0XHR9XG5cblx0XHRpZiAoIGJ1bGsgKSB7XG5cblx0XHRcdC8vIEJ1bGsgb3BlcmF0aW9ucyBydW4gYWdhaW5zdCB0aGUgZW50aXJlIHNldFxuXHRcdFx0aWYgKCByYXcgKSB7XG5cdFx0XHRcdGZuLmNhbGwoIGVsZW1zLCB2YWx1ZSApO1xuXHRcdFx0XHRmbiA9IG51bGw7XG5cblx0XHRcdC8vIC4uLmV4Y2VwdCB3aGVuIGV4ZWN1dGluZyBmdW5jdGlvbiB2YWx1ZXNcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGJ1bGsgPSBmbjtcblx0XHRcdFx0Zm4gPSBmdW5jdGlvbiggZWxlbSwgX2tleSwgdmFsdWUgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGJ1bGsuY2FsbCggalF1ZXJ5KCBlbGVtICksIHZhbHVlICk7XG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKCBmbiApIHtcblx0XHRcdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdFx0XHRmbihcblx0XHRcdFx0XHRlbGVtc1sgaSBdLCBrZXksIHJhdyA/XG5cdFx0XHRcdFx0XHR2YWx1ZSA6XG5cdFx0XHRcdFx0XHR2YWx1ZS5jYWxsKCBlbGVtc1sgaSBdLCBpLCBmbiggZWxlbXNbIGkgXSwga2V5ICkgKVxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdGlmICggY2hhaW5hYmxlICkge1xuXHRcdHJldHVybiBlbGVtcztcblx0fVxuXG5cdC8vIEdldHNcblx0aWYgKCBidWxrICkge1xuXHRcdHJldHVybiBmbi5jYWxsKCBlbGVtcyApO1xuXHR9XG5cblx0cmV0dXJuIGxlbiA/IGZuKCBlbGVtc1sgMCBdLCBrZXkgKSA6IGVtcHR5R2V0O1xufTtcblxuXG4vLyBNYXRjaGVzIGRhc2hlZCBzdHJpbmcgZm9yIGNhbWVsaXppbmdcbnZhciBybXNQcmVmaXggPSAvXi1tcy0vLFxuXHRyZGFzaEFscGhhID0gLy0oW2Etel0pL2c7XG5cbi8vIFVzZWQgYnkgY2FtZWxDYXNlIGFzIGNhbGxiYWNrIHRvIHJlcGxhY2UoKVxuZnVuY3Rpb24gZmNhbWVsQ2FzZSggX2FsbCwgbGV0dGVyICkge1xuXHRyZXR1cm4gbGV0dGVyLnRvVXBwZXJDYXNlKCk7XG59XG5cbi8vIENvbnZlcnQgZGFzaGVkIHRvIGNhbWVsQ2FzZTsgdXNlZCBieSB0aGUgY3NzIGFuZCBkYXRhIG1vZHVsZXNcbi8vIFN1cHBvcnQ6IElFIDw9OSAtIDExLCBFZGdlIDEyIC0gMTVcbi8vIE1pY3Jvc29mdCBmb3Jnb3QgdG8gaHVtcCB0aGVpciB2ZW5kb3IgcHJlZml4ICh0cmFjLTk1NzIpXG5mdW5jdGlvbiBjYW1lbENhc2UoIHN0cmluZyApIHtcblx0cmV0dXJuIHN0cmluZy5yZXBsYWNlKCBybXNQcmVmaXgsIFwibXMtXCIgKS5yZXBsYWNlKCByZGFzaEFscGhhLCBmY2FtZWxDYXNlICk7XG59XG52YXIgYWNjZXB0RGF0YSA9IGZ1bmN0aW9uKCBvd25lciApIHtcblxuXHQvLyBBY2NlcHRzIG9ubHk6XG5cdC8vICAtIE5vZGVcblx0Ly8gICAgLSBOb2RlLkVMRU1FTlRfTk9ERVxuXHQvLyAgICAtIE5vZGUuRE9DVU1FTlRfTk9ERVxuXHQvLyAgLSBPYmplY3Rcblx0Ly8gICAgLSBBbnlcblx0cmV0dXJuIG93bmVyLm5vZGVUeXBlID09PSAxIHx8IG93bmVyLm5vZGVUeXBlID09PSA5IHx8ICEoICtvd25lci5ub2RlVHlwZSApO1xufTtcblxuXG5cblxuZnVuY3Rpb24gRGF0YSgpIHtcblx0dGhpcy5leHBhbmRvID0galF1ZXJ5LmV4cGFuZG8gKyBEYXRhLnVpZCsrO1xufVxuXG5EYXRhLnVpZCA9IDE7XG5cbkRhdGEucHJvdG90eXBlID0ge1xuXG5cdGNhY2hlOiBmdW5jdGlvbiggb3duZXIgKSB7XG5cblx0XHQvLyBDaGVjayBpZiB0aGUgb3duZXIgb2JqZWN0IGFscmVhZHkgaGFzIGEgY2FjaGVcblx0XHR2YXIgdmFsdWUgPSBvd25lclsgdGhpcy5leHBhbmRvIF07XG5cblx0XHQvLyBJZiBub3QsIGNyZWF0ZSBvbmVcblx0XHRpZiAoICF2YWx1ZSApIHtcblx0XHRcdHZhbHVlID0ge307XG5cblx0XHRcdC8vIFdlIGNhbiBhY2NlcHQgZGF0YSBmb3Igbm9uLWVsZW1lbnQgbm9kZXMgaW4gbW9kZXJuIGJyb3dzZXJzLFxuXHRcdFx0Ly8gYnV0IHdlIHNob3VsZCBub3QsIHNlZSB0cmFjLTgzMzUuXG5cdFx0XHQvLyBBbHdheXMgcmV0dXJuIGFuIGVtcHR5IG9iamVjdC5cblx0XHRcdGlmICggYWNjZXB0RGF0YSggb3duZXIgKSApIHtcblxuXHRcdFx0XHQvLyBJZiBpdCBpcyBhIG5vZGUgdW5saWtlbHkgdG8gYmUgc3RyaW5naWZ5LWVkIG9yIGxvb3BlZCBvdmVyXG5cdFx0XHRcdC8vIHVzZSBwbGFpbiBhc3NpZ25tZW50XG5cdFx0XHRcdGlmICggb3duZXIubm9kZVR5cGUgKSB7XG5cdFx0XHRcdFx0b3duZXJbIHRoaXMuZXhwYW5kbyBdID0gdmFsdWU7XG5cblx0XHRcdFx0Ly8gT3RoZXJ3aXNlIHNlY3VyZSBpdCBpbiBhIG5vbi1lbnVtZXJhYmxlIHByb3BlcnR5XG5cdFx0XHRcdC8vIGNvbmZpZ3VyYWJsZSBtdXN0IGJlIHRydWUgdG8gYWxsb3cgdGhlIHByb3BlcnR5IHRvIGJlXG5cdFx0XHRcdC8vIGRlbGV0ZWQgd2hlbiBkYXRhIGlzIHJlbW92ZWRcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoIG93bmVyLCB0aGlzLmV4cGFuZG8sIHtcblx0XHRcdFx0XHRcdHZhbHVlOiB2YWx1ZSxcblx0XHRcdFx0XHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZVxuXHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB2YWx1ZTtcblx0fSxcblx0c2V0OiBmdW5jdGlvbiggb3duZXIsIGRhdGEsIHZhbHVlICkge1xuXHRcdHZhciBwcm9wLFxuXHRcdFx0Y2FjaGUgPSB0aGlzLmNhY2hlKCBvd25lciApO1xuXG5cdFx0Ly8gSGFuZGxlOiBbIG93bmVyLCBrZXksIHZhbHVlIF0gYXJnc1xuXHRcdC8vIEFsd2F5cyB1c2UgY2FtZWxDYXNlIGtleSAoZ2gtMjI1Nylcblx0XHRpZiAoIHR5cGVvZiBkYXRhID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0Y2FjaGVbIGNhbWVsQ2FzZSggZGF0YSApIF0gPSB2YWx1ZTtcblxuXHRcdC8vIEhhbmRsZTogWyBvd25lciwgeyBwcm9wZXJ0aWVzIH0gXSBhcmdzXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Ly8gQ29weSB0aGUgcHJvcGVydGllcyBvbmUtYnktb25lIHRvIHRoZSBjYWNoZSBvYmplY3Rcblx0XHRcdGZvciAoIHByb3AgaW4gZGF0YSApIHtcblx0XHRcdFx0Y2FjaGVbIGNhbWVsQ2FzZSggcHJvcCApIF0gPSBkYXRhWyBwcm9wIF07XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBjYWNoZTtcblx0fSxcblx0Z2V0OiBmdW5jdGlvbiggb3duZXIsIGtleSApIHtcblx0XHRyZXR1cm4ga2V5ID09PSB1bmRlZmluZWQgP1xuXHRcdFx0dGhpcy5jYWNoZSggb3duZXIgKSA6XG5cblx0XHRcdC8vIEFsd2F5cyB1c2UgY2FtZWxDYXNlIGtleSAoZ2gtMjI1Nylcblx0XHRcdG93bmVyWyB0aGlzLmV4cGFuZG8gXSAmJiBvd25lclsgdGhpcy5leHBhbmRvIF1bIGNhbWVsQ2FzZSgga2V5ICkgXTtcblx0fSxcblx0YWNjZXNzOiBmdW5jdGlvbiggb3duZXIsIGtleSwgdmFsdWUgKSB7XG5cblx0XHQvLyBJbiBjYXNlcyB3aGVyZSBlaXRoZXI6XG5cdFx0Ly9cblx0XHQvLyAgIDEuIE5vIGtleSB3YXMgc3BlY2lmaWVkXG5cdFx0Ly8gICAyLiBBIHN0cmluZyBrZXkgd2FzIHNwZWNpZmllZCwgYnV0IG5vIHZhbHVlIHByb3ZpZGVkXG5cdFx0Ly9cblx0XHQvLyBUYWtlIHRoZSBcInJlYWRcIiBwYXRoIGFuZCBhbGxvdyB0aGUgZ2V0IG1ldGhvZCB0byBkZXRlcm1pbmVcblx0XHQvLyB3aGljaCB2YWx1ZSB0byByZXR1cm4sIHJlc3BlY3RpdmVseSBlaXRoZXI6XG5cdFx0Ly9cblx0XHQvLyAgIDEuIFRoZSBlbnRpcmUgY2FjaGUgb2JqZWN0XG5cdFx0Ly8gICAyLiBUaGUgZGF0YSBzdG9yZWQgYXQgdGhlIGtleVxuXHRcdC8vXG5cdFx0aWYgKCBrZXkgPT09IHVuZGVmaW5lZCB8fFxuXHRcdFx0XHQoICgga2V5ICYmIHR5cGVvZiBrZXkgPT09IFwic3RyaW5nXCIgKSAmJiB2YWx1ZSA9PT0gdW5kZWZpbmVkICkgKSB7XG5cblx0XHRcdHJldHVybiB0aGlzLmdldCggb3duZXIsIGtleSApO1xuXHRcdH1cblxuXHRcdC8vIFdoZW4gdGhlIGtleSBpcyBub3QgYSBzdHJpbmcsIG9yIGJvdGggYSBrZXkgYW5kIHZhbHVlXG5cdFx0Ly8gYXJlIHNwZWNpZmllZCwgc2V0IG9yIGV4dGVuZCAoZXhpc3Rpbmcgb2JqZWN0cykgd2l0aCBlaXRoZXI6XG5cdFx0Ly9cblx0XHQvLyAgIDEuIEFuIG9iamVjdCBvZiBwcm9wZXJ0aWVzXG5cdFx0Ly8gICAyLiBBIGtleSBhbmQgdmFsdWVcblx0XHQvL1xuXHRcdHRoaXMuc2V0KCBvd25lciwga2V5LCB2YWx1ZSApO1xuXG5cdFx0Ly8gU2luY2UgdGhlIFwic2V0XCIgcGF0aCBjYW4gaGF2ZSB0d28gcG9zc2libGUgZW50cnkgcG9pbnRzXG5cdFx0Ly8gcmV0dXJuIHRoZSBleHBlY3RlZCBkYXRhIGJhc2VkIG9uIHdoaWNoIHBhdGggd2FzIHRha2VuWypdXG5cdFx0cmV0dXJuIHZhbHVlICE9PSB1bmRlZmluZWQgPyB2YWx1ZSA6IGtleTtcblx0fSxcblx0cmVtb3ZlOiBmdW5jdGlvbiggb3duZXIsIGtleSApIHtcblx0XHR2YXIgaSxcblx0XHRcdGNhY2hlID0gb3duZXJbIHRoaXMuZXhwYW5kbyBdO1xuXG5cdFx0aWYgKCBjYWNoZSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmICgga2V5ICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdC8vIFN1cHBvcnQgYXJyYXkgb3Igc3BhY2Ugc2VwYXJhdGVkIHN0cmluZyBvZiBrZXlzXG5cdFx0XHRpZiAoIEFycmF5LmlzQXJyYXkoIGtleSApICkge1xuXG5cdFx0XHRcdC8vIElmIGtleSBpcyBhbiBhcnJheSBvZiBrZXlzLi4uXG5cdFx0XHRcdC8vIFdlIGFsd2F5cyBzZXQgY2FtZWxDYXNlIGtleXMsIHNvIHJlbW92ZSB0aGF0LlxuXHRcdFx0XHRrZXkgPSBrZXkubWFwKCBjYW1lbENhc2UgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGtleSA9IGNhbWVsQ2FzZSgga2V5ICk7XG5cblx0XHRcdFx0Ly8gSWYgYSBrZXkgd2l0aCB0aGUgc3BhY2VzIGV4aXN0cywgdXNlIGl0LlxuXHRcdFx0XHQvLyBPdGhlcndpc2UsIGNyZWF0ZSBhbiBhcnJheSBieSBtYXRjaGluZyBub24td2hpdGVzcGFjZVxuXHRcdFx0XHRrZXkgPSBrZXkgaW4gY2FjaGUgP1xuXHRcdFx0XHRcdFsga2V5IF0gOlxuXHRcdFx0XHRcdCgga2V5Lm1hdGNoKCBybm90aHRtbHdoaXRlICkgfHwgW10gKTtcblx0XHRcdH1cblxuXHRcdFx0aSA9IGtleS5sZW5ndGg7XG5cblx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRkZWxldGUgY2FjaGVbIGtleVsgaSBdIF07XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gUmVtb3ZlIHRoZSBleHBhbmRvIGlmIHRoZXJlJ3Mgbm8gbW9yZSBkYXRhXG5cdFx0aWYgKCBrZXkgPT09IHVuZGVmaW5lZCB8fCBqUXVlcnkuaXNFbXB0eU9iamVjdCggY2FjaGUgKSApIHtcblxuXHRcdFx0Ly8gU3VwcG9ydDogQ2hyb21lIDw9MzUgLSA0NVxuXHRcdFx0Ly8gV2Via2l0ICYgQmxpbmsgcGVyZm9ybWFuY2Ugc3VmZmVycyB3aGVuIGRlbGV0aW5nIHByb3BlcnRpZXNcblx0XHRcdC8vIGZyb20gRE9NIG5vZGVzLCBzbyBzZXQgdG8gdW5kZWZpbmVkIGluc3RlYWRcblx0XHRcdC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTM3ODYwNyAoYnVnIHJlc3RyaWN0ZWQpXG5cdFx0XHRpZiAoIG93bmVyLm5vZGVUeXBlICkge1xuXHRcdFx0XHRvd25lclsgdGhpcy5leHBhbmRvIF0gPSB1bmRlZmluZWQ7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRkZWxldGUgb3duZXJbIHRoaXMuZXhwYW5kbyBdO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblx0aGFzRGF0YTogZnVuY3Rpb24oIG93bmVyICkge1xuXHRcdHZhciBjYWNoZSA9IG93bmVyWyB0aGlzLmV4cGFuZG8gXTtcblx0XHRyZXR1cm4gY2FjaGUgIT09IHVuZGVmaW5lZCAmJiAhalF1ZXJ5LmlzRW1wdHlPYmplY3QoIGNhY2hlICk7XG5cdH1cbn07XG52YXIgZGF0YVByaXYgPSBuZXcgRGF0YSgpO1xuXG52YXIgZGF0YVVzZXIgPSBuZXcgRGF0YSgpO1xuXG5cblxuLy9cdEltcGxlbWVudGF0aW9uIFN1bW1hcnlcbi8vXG4vL1x0MS4gRW5mb3JjZSBBUEkgc3VyZmFjZSBhbmQgc2VtYW50aWMgY29tcGF0aWJpbGl0eSB3aXRoIDEuOS54IGJyYW5jaFxuLy9cdDIuIEltcHJvdmUgdGhlIG1vZHVsZSdzIG1haW50YWluYWJpbGl0eSBieSByZWR1Y2luZyB0aGUgc3RvcmFnZVxuLy9cdFx0cGF0aHMgdG8gYSBzaW5nbGUgbWVjaGFuaXNtLlxuLy9cdDMuIFVzZSB0aGUgc2FtZSBzaW5nbGUgbWVjaGFuaXNtIHRvIHN1cHBvcnQgXCJwcml2YXRlXCIgYW5kIFwidXNlclwiIGRhdGEuXG4vL1x0NC4gX05ldmVyXyBleHBvc2UgXCJwcml2YXRlXCIgZGF0YSB0byB1c2VyIGNvZGUgKFRPRE86IERyb3AgX2RhdGEsIF9yZW1vdmVEYXRhKVxuLy9cdDUuIEF2b2lkIGV4cG9zaW5nIGltcGxlbWVudGF0aW9uIGRldGFpbHMgb24gdXNlciBvYmplY3RzIChlZy4gZXhwYW5kbyBwcm9wZXJ0aWVzKVxuLy9cdDYuIFByb3ZpZGUgYSBjbGVhciBwYXRoIGZvciBpbXBsZW1lbnRhdGlvbiB1cGdyYWRlIHRvIFdlYWtNYXAgaW4gMjAxNFxuXG52YXIgcmJyYWNlID0gL14oPzpcXHtbXFx3XFxXXSpcXH18XFxbW1xcd1xcV10qXFxdKSQvLFxuXHRybXVsdGlEYXNoID0gL1tBLVpdL2c7XG5cbmZ1bmN0aW9uIGdldERhdGEoIGRhdGEgKSB7XG5cdGlmICggZGF0YSA9PT0gXCJ0cnVlXCIgKSB7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblxuXHRpZiAoIGRhdGEgPT09IFwiZmFsc2VcIiApIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXHRpZiAoIGRhdGEgPT09IFwibnVsbFwiICkge1xuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cblx0Ly8gT25seSBjb252ZXJ0IHRvIGEgbnVtYmVyIGlmIGl0IGRvZXNuJ3QgY2hhbmdlIHRoZSBzdHJpbmdcblx0aWYgKCBkYXRhID09PSArZGF0YSArIFwiXCIgKSB7XG5cdFx0cmV0dXJuICtkYXRhO1xuXHR9XG5cblx0aWYgKCByYnJhY2UudGVzdCggZGF0YSApICkge1xuXHRcdHJldHVybiBKU09OLnBhcnNlKCBkYXRhICk7XG5cdH1cblxuXHRyZXR1cm4gZGF0YTtcbn1cblxuZnVuY3Rpb24gZGF0YUF0dHIoIGVsZW0sIGtleSwgZGF0YSApIHtcblx0dmFyIG5hbWU7XG5cblx0Ly8gSWYgbm90aGluZyB3YXMgZm91bmQgaW50ZXJuYWxseSwgdHJ5IHRvIGZldGNoIGFueVxuXHQvLyBkYXRhIGZyb20gdGhlIEhUTUw1IGRhdGEtKiBhdHRyaWJ1dGVcblx0aWYgKCBkYXRhID09PSB1bmRlZmluZWQgJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRuYW1lID0gXCJkYXRhLVwiICsga2V5LnJlcGxhY2UoIHJtdWx0aURhc2gsIFwiLSQmXCIgKS50b0xvd2VyQ2FzZSgpO1xuXHRcdGRhdGEgPSBlbGVtLmdldEF0dHJpYnV0ZSggbmFtZSApO1xuXG5cdFx0aWYgKCB0eXBlb2YgZGF0YSA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdGRhdGEgPSBnZXREYXRhKCBkYXRhICk7XG5cdFx0XHR9IGNhdGNoICggZSApIHt9XG5cblx0XHRcdC8vIE1ha2Ugc3VyZSB3ZSBzZXQgdGhlIGRhdGEgc28gaXQgaXNuJ3QgY2hhbmdlZCBsYXRlclxuXHRcdFx0ZGF0YVVzZXIuc2V0KCBlbGVtLCBrZXksIGRhdGEgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZGF0YSA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdH1cblx0cmV0dXJuIGRhdGE7XG59XG5cbmpRdWVyeS5leHRlbmQoIHtcblx0aGFzRGF0YTogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIGRhdGFVc2VyLmhhc0RhdGEoIGVsZW0gKSB8fCBkYXRhUHJpdi5oYXNEYXRhKCBlbGVtICk7XG5cdH0sXG5cblx0ZGF0YTogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGRhdGEgKSB7XG5cdFx0cmV0dXJuIGRhdGFVc2VyLmFjY2VzcyggZWxlbSwgbmFtZSwgZGF0YSApO1xuXHR9LFxuXG5cdHJlbW92ZURhdGE6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lICkge1xuXHRcdGRhdGFVc2VyLnJlbW92ZSggZWxlbSwgbmFtZSApO1xuXHR9LFxuXG5cdC8vIFRPRE86IE5vdyB0aGF0IGFsbCBjYWxscyB0byBfZGF0YSBhbmQgX3JlbW92ZURhdGEgaGF2ZSBiZWVuIHJlcGxhY2VkXG5cdC8vIHdpdGggZGlyZWN0IGNhbGxzIHRvIGRhdGFQcml2IG1ldGhvZHMsIHRoZXNlIGNhbiBiZSBkZXByZWNhdGVkLlxuXHRfZGF0YTogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGRhdGEgKSB7XG5cdFx0cmV0dXJuIGRhdGFQcml2LmFjY2VzcyggZWxlbSwgbmFtZSwgZGF0YSApO1xuXHR9LFxuXG5cdF9yZW1vdmVEYXRhOiBmdW5jdGlvbiggZWxlbSwgbmFtZSApIHtcblx0XHRkYXRhUHJpdi5yZW1vdmUoIGVsZW0sIG5hbWUgKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdGRhdGE6IGZ1bmN0aW9uKCBrZXksIHZhbHVlICkge1xuXHRcdHZhciBpLCBuYW1lLCBkYXRhLFxuXHRcdFx0ZWxlbSA9IHRoaXNbIDAgXSxcblx0XHRcdGF0dHJzID0gZWxlbSAmJiBlbGVtLmF0dHJpYnV0ZXM7XG5cblx0XHQvLyBHZXRzIGFsbCB2YWx1ZXNcblx0XHRpZiAoIGtleSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0aWYgKCB0aGlzLmxlbmd0aCApIHtcblx0XHRcdFx0ZGF0YSA9IGRhdGFVc2VyLmdldCggZWxlbSApO1xuXG5cdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSAmJiAhZGF0YVByaXYuZ2V0KCBlbGVtLCBcImhhc0RhdGFBdHRyc1wiICkgKSB7XG5cdFx0XHRcdFx0aSA9IGF0dHJzLmxlbmd0aDtcblx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblxuXHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgMTEgb25seVxuXHRcdFx0XHRcdFx0Ly8gVGhlIGF0dHJzIGVsZW1lbnRzIGNhbiBiZSBudWxsICh0cmFjLTE0ODk0KVxuXHRcdFx0XHRcdFx0aWYgKCBhdHRyc1sgaSBdICkge1xuXHRcdFx0XHRcdFx0XHRuYW1lID0gYXR0cnNbIGkgXS5uYW1lO1xuXHRcdFx0XHRcdFx0XHRpZiAoIG5hbWUuaW5kZXhPZiggXCJkYXRhLVwiICkgPT09IDAgKSB7XG5cdFx0XHRcdFx0XHRcdFx0bmFtZSA9IGNhbWVsQ2FzZSggbmFtZS5zbGljZSggNSApICk7XG5cdFx0XHRcdFx0XHRcdFx0ZGF0YUF0dHIoIGVsZW0sIG5hbWUsIGRhdGFbIG5hbWUgXSApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGRhdGFQcml2LnNldCggZWxlbSwgXCJoYXNEYXRhQXR0cnNcIiwgdHJ1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBkYXRhO1xuXHRcdH1cblxuXHRcdC8vIFNldHMgbXVsdGlwbGUgdmFsdWVzXG5cdFx0aWYgKCB0eXBlb2Yga2V5ID09PSBcIm9iamVjdFwiICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGRhdGFVc2VyLnNldCggdGhpcywga2V5ICk7XG5cdFx0XHR9ICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0dmFyIGRhdGE7XG5cblx0XHRcdC8vIFRoZSBjYWxsaW5nIGpRdWVyeSBvYmplY3QgKGVsZW1lbnQgbWF0Y2hlcykgaXMgbm90IGVtcHR5XG5cdFx0XHQvLyAoYW5kIHRoZXJlZm9yZSBoYXMgYW4gZWxlbWVudCBhcHBlYXJzIGF0IHRoaXNbIDAgXSkgYW5kIHRoZVxuXHRcdFx0Ly8gYHZhbHVlYCBwYXJhbWV0ZXIgd2FzIG5vdCB1bmRlZmluZWQuIEFuIGVtcHR5IGpRdWVyeSBvYmplY3Rcblx0XHRcdC8vIHdpbGwgcmVzdWx0IGluIGB1bmRlZmluZWRgIGZvciBlbGVtID0gdGhpc1sgMCBdIHdoaWNoIHdpbGxcblx0XHRcdC8vIHRocm93IGFuIGV4Y2VwdGlvbiBpZiBhbiBhdHRlbXB0IHRvIHJlYWQgYSBkYXRhIGNhY2hlIGlzIG1hZGUuXG5cdFx0XHRpZiAoIGVsZW0gJiYgdmFsdWUgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHQvLyBBdHRlbXB0IHRvIGdldCBkYXRhIGZyb20gdGhlIGNhY2hlXG5cdFx0XHRcdC8vIFRoZSBrZXkgd2lsbCBhbHdheXMgYmUgY2FtZWxDYXNlZCBpbiBEYXRhXG5cdFx0XHRcdGRhdGEgPSBkYXRhVXNlci5nZXQoIGVsZW0sIGtleSApO1xuXHRcdFx0XHRpZiAoIGRhdGEgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRyZXR1cm4gZGF0YTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEF0dGVtcHQgdG8gXCJkaXNjb3ZlclwiIHRoZSBkYXRhIGluXG5cdFx0XHRcdC8vIEhUTUw1IGN1c3RvbSBkYXRhLSogYXR0cnNcblx0XHRcdFx0ZGF0YSA9IGRhdGFBdHRyKCBlbGVtLCBrZXkgKTtcblx0XHRcdFx0aWYgKCBkYXRhICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGRhdGE7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBXZSB0cmllZCByZWFsbHkgaGFyZCwgYnV0IHRoZSBkYXRhIGRvZXNuJ3QgZXhpc3QuXG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU2V0IHRoZSBkYXRhLi4uXG5cdFx0XHR0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXG5cdFx0XHRcdC8vIFdlIGFsd2F5cyBzdG9yZSB0aGUgY2FtZWxDYXNlZCBrZXlcblx0XHRcdFx0ZGF0YVVzZXIuc2V0KCB0aGlzLCBrZXksIHZhbHVlICk7XG5cdFx0XHR9ICk7XG5cdFx0fSwgbnVsbCwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggPiAxLCBudWxsLCB0cnVlICk7XG5cdH0sXG5cblx0cmVtb3ZlRGF0YTogZnVuY3Rpb24oIGtleSApIHtcblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGRhdGFVc2VyLnJlbW92ZSggdGhpcywga2V5ICk7XG5cdFx0fSApO1xuXHR9XG59ICk7XG5cblxualF1ZXJ5LmV4dGVuZCgge1xuXHRxdWV1ZTogZnVuY3Rpb24oIGVsZW0sIHR5cGUsIGRhdGEgKSB7XG5cdFx0dmFyIHF1ZXVlO1xuXG5cdFx0aWYgKCBlbGVtICkge1xuXHRcdFx0dHlwZSA9ICggdHlwZSB8fCBcImZ4XCIgKSArIFwicXVldWVcIjtcblx0XHRcdHF1ZXVlID0gZGF0YVByaXYuZ2V0KCBlbGVtLCB0eXBlICk7XG5cblx0XHRcdC8vIFNwZWVkIHVwIGRlcXVldWUgYnkgZ2V0dGluZyBvdXQgcXVpY2tseSBpZiB0aGlzIGlzIGp1c3QgYSBsb29rdXBcblx0XHRcdGlmICggZGF0YSApIHtcblx0XHRcdFx0aWYgKCAhcXVldWUgfHwgQXJyYXkuaXNBcnJheSggZGF0YSApICkge1xuXHRcdFx0XHRcdHF1ZXVlID0gZGF0YVByaXYuYWNjZXNzKCBlbGVtLCB0eXBlLCBqUXVlcnkubWFrZUFycmF5KCBkYXRhICkgKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRxdWV1ZS5wdXNoKCBkYXRhICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBxdWV1ZSB8fCBbXTtcblx0XHR9XG5cdH0sXG5cblx0ZGVxdWV1ZTogZnVuY3Rpb24oIGVsZW0sIHR5cGUgKSB7XG5cdFx0dHlwZSA9IHR5cGUgfHwgXCJmeFwiO1xuXG5cdFx0dmFyIHF1ZXVlID0galF1ZXJ5LnF1ZXVlKCBlbGVtLCB0eXBlICksXG5cdFx0XHRzdGFydExlbmd0aCA9IHF1ZXVlLmxlbmd0aCxcblx0XHRcdGZuID0gcXVldWUuc2hpZnQoKSxcblx0XHRcdGhvb2tzID0galF1ZXJ5Ll9xdWV1ZUhvb2tzKCBlbGVtLCB0eXBlICksXG5cdFx0XHRuZXh0ID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGpRdWVyeS5kZXF1ZXVlKCBlbGVtLCB0eXBlICk7XG5cdFx0XHR9O1xuXG5cdFx0Ly8gSWYgdGhlIGZ4IHF1ZXVlIGlzIGRlcXVldWVkLCBhbHdheXMgcmVtb3ZlIHRoZSBwcm9ncmVzcyBzZW50aW5lbFxuXHRcdGlmICggZm4gPT09IFwiaW5wcm9ncmVzc1wiICkge1xuXHRcdFx0Zm4gPSBxdWV1ZS5zaGlmdCgpO1xuXHRcdFx0c3RhcnRMZW5ndGgtLTtcblx0XHR9XG5cblx0XHRpZiAoIGZuICkge1xuXG5cdFx0XHQvLyBBZGQgYSBwcm9ncmVzcyBzZW50aW5lbCB0byBwcmV2ZW50IHRoZSBmeCBxdWV1ZSBmcm9tIGJlaW5nXG5cdFx0XHQvLyBhdXRvbWF0aWNhbGx5IGRlcXVldWVkXG5cdFx0XHRpZiAoIHR5cGUgPT09IFwiZnhcIiApIHtcblx0XHRcdFx0cXVldWUudW5zaGlmdCggXCJpbnByb2dyZXNzXCIgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ2xlYXIgdXAgdGhlIGxhc3QgcXVldWUgc3RvcCBmdW5jdGlvblxuXHRcdFx0ZGVsZXRlIGhvb2tzLnN0b3A7XG5cdFx0XHRmbi5jYWxsKCBlbGVtLCBuZXh0LCBob29rcyApO1xuXHRcdH1cblxuXHRcdGlmICggIXN0YXJ0TGVuZ3RoICYmIGhvb2tzICkge1xuXHRcdFx0aG9va3MuZW1wdHkuZmlyZSgpO1xuXHRcdH1cblx0fSxcblxuXHQvLyBOb3QgcHVibGljIC0gZ2VuZXJhdGUgYSBxdWV1ZUhvb2tzIG9iamVjdCwgb3IgcmV0dXJuIHRoZSBjdXJyZW50IG9uZVxuXHRfcXVldWVIb29rczogZnVuY3Rpb24oIGVsZW0sIHR5cGUgKSB7XG5cdFx0dmFyIGtleSA9IHR5cGUgKyBcInF1ZXVlSG9va3NcIjtcblx0XHRyZXR1cm4gZGF0YVByaXYuZ2V0KCBlbGVtLCBrZXkgKSB8fCBkYXRhUHJpdi5hY2Nlc3MoIGVsZW0sIGtleSwge1xuXHRcdFx0ZW1wdHk6IGpRdWVyeS5DYWxsYmFja3MoIFwib25jZSBtZW1vcnlcIiApLmFkZCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGRhdGFQcml2LnJlbW92ZSggZWxlbSwgWyB0eXBlICsgXCJxdWV1ZVwiLCBrZXkgXSApO1xuXHRcdFx0fSApXG5cdFx0fSApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0cXVldWU6IGZ1bmN0aW9uKCB0eXBlLCBkYXRhICkge1xuXHRcdHZhciBzZXR0ZXIgPSAyO1xuXG5cdFx0aWYgKCB0eXBlb2YgdHlwZSAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdGRhdGEgPSB0eXBlO1xuXHRcdFx0dHlwZSA9IFwiZnhcIjtcblx0XHRcdHNldHRlci0tO1xuXHRcdH1cblxuXHRcdGlmICggYXJndW1lbnRzLmxlbmd0aCA8IHNldHRlciApIHtcblx0XHRcdHJldHVybiBqUXVlcnkucXVldWUoIHRoaXNbIDAgXSwgdHlwZSApO1xuXHRcdH1cblxuXHRcdHJldHVybiBkYXRhID09PSB1bmRlZmluZWQgP1xuXHRcdFx0dGhpcyA6XG5cdFx0XHR0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgcXVldWUgPSBqUXVlcnkucXVldWUoIHRoaXMsIHR5cGUsIGRhdGEgKTtcblxuXHRcdFx0XHQvLyBFbnN1cmUgYSBob29rcyBmb3IgdGhpcyBxdWV1ZVxuXHRcdFx0XHRqUXVlcnkuX3F1ZXVlSG9va3MoIHRoaXMsIHR5cGUgKTtcblxuXHRcdFx0XHRpZiAoIHR5cGUgPT09IFwiZnhcIiAmJiBxdWV1ZVsgMCBdICE9PSBcImlucHJvZ3Jlc3NcIiApIHtcblx0XHRcdFx0XHRqUXVlcnkuZGVxdWV1ZSggdGhpcywgdHlwZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9ICk7XG5cdH0sXG5cdGRlcXVldWU6IGZ1bmN0aW9uKCB0eXBlICkge1xuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0alF1ZXJ5LmRlcXVldWUoIHRoaXMsIHR5cGUgKTtcblx0XHR9ICk7XG5cdH0sXG5cdGNsZWFyUXVldWU6IGZ1bmN0aW9uKCB0eXBlICkge1xuXHRcdHJldHVybiB0aGlzLnF1ZXVlKCB0eXBlIHx8IFwiZnhcIiwgW10gKTtcblx0fSxcblxuXHQvLyBHZXQgYSBwcm9taXNlIHJlc29sdmVkIHdoZW4gcXVldWVzIG9mIGEgY2VydGFpbiB0eXBlXG5cdC8vIGFyZSBlbXB0aWVkIChmeCBpcyB0aGUgdHlwZSBieSBkZWZhdWx0KVxuXHRwcm9taXNlOiBmdW5jdGlvbiggdHlwZSwgb2JqICkge1xuXHRcdHZhciB0bXAsXG5cdFx0XHRjb3VudCA9IDEsXG5cdFx0XHRkZWZlciA9IGpRdWVyeS5EZWZlcnJlZCgpLFxuXHRcdFx0ZWxlbWVudHMgPSB0aGlzLFxuXHRcdFx0aSA9IHRoaXMubGVuZ3RoLFxuXHRcdFx0cmVzb2x2ZSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoICEoIC0tY291bnQgKSApIHtcblx0XHRcdFx0XHRkZWZlci5yZXNvbHZlV2l0aCggZWxlbWVudHMsIFsgZWxlbWVudHMgXSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXG5cdFx0aWYgKCB0eXBlb2YgdHlwZSAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdG9iaiA9IHR5cGU7XG5cdFx0XHR0eXBlID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0XHR0eXBlID0gdHlwZSB8fCBcImZ4XCI7XG5cblx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdHRtcCA9IGRhdGFQcml2LmdldCggZWxlbWVudHNbIGkgXSwgdHlwZSArIFwicXVldWVIb29rc1wiICk7XG5cdFx0XHRpZiAoIHRtcCAmJiB0bXAuZW1wdHkgKSB7XG5cdFx0XHRcdGNvdW50Kys7XG5cdFx0XHRcdHRtcC5lbXB0eS5hZGQoIHJlc29sdmUgKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmVzb2x2ZSgpO1xuXHRcdHJldHVybiBkZWZlci5wcm9taXNlKCBvYmogKTtcblx0fVxufSApO1xudmFyIHBudW0gPSAoIC9bKy1dPyg/OlxcZCpcXC58KVxcZCsoPzpbZUVdWystXT9cXGQrfCkvICkuc291cmNlO1xuXG52YXIgcmNzc051bSA9IG5ldyBSZWdFeHAoIFwiXig/OihbKy1dKT18KShcIiArIHBudW0gKyBcIikoW2EteiVdKikkXCIsIFwiaVwiICk7XG5cblxudmFyIGNzc0V4cGFuZCA9IFsgXCJUb3BcIiwgXCJSaWdodFwiLCBcIkJvdHRvbVwiLCBcIkxlZnRcIiBdO1xuXG52YXIgZG9jdW1lbnRFbGVtZW50ID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuXG5cblxuXHR2YXIgaXNBdHRhY2hlZCA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGpRdWVyeS5jb250YWlucyggZWxlbS5vd25lckRvY3VtZW50LCBlbGVtICk7XG5cdFx0fSxcblx0XHRjb21wb3NlZCA9IHsgY29tcG9zZWQ6IHRydWUgfTtcblxuXHQvLyBTdXBwb3J0OiBJRSA5IC0gMTErLCBFZGdlIDEyIC0gMTgrLCBpT1MgMTAuMCAtIDEwLjIgb25seVxuXHQvLyBDaGVjayBhdHRhY2htZW50IGFjcm9zcyBzaGFkb3cgRE9NIGJvdW5kYXJpZXMgd2hlbiBwb3NzaWJsZSAoZ2gtMzUwNClcblx0Ly8gU3VwcG9ydDogaU9TIDEwLjAtMTAuMiBvbmx5XG5cdC8vIEVhcmx5IGlPUyAxMCB2ZXJzaW9ucyBzdXBwb3J0IGBhdHRhY2hTaGFkb3dgIGJ1dCBub3QgYGdldFJvb3ROb2RlYCxcblx0Ly8gbGVhZGluZyB0byBlcnJvcnMuIFdlIG5lZWQgdG8gY2hlY2sgZm9yIGBnZXRSb290Tm9kZWAuXG5cdGlmICggZG9jdW1lbnRFbGVtZW50LmdldFJvb3ROb2RlICkge1xuXHRcdGlzQXR0YWNoZWQgPSBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBqUXVlcnkuY29udGFpbnMoIGVsZW0ub3duZXJEb2N1bWVudCwgZWxlbSApIHx8XG5cdFx0XHRcdGVsZW0uZ2V0Um9vdE5vZGUoIGNvbXBvc2VkICkgPT09IGVsZW0ub3duZXJEb2N1bWVudDtcblx0XHR9O1xuXHR9XG52YXIgaXNIaWRkZW5XaXRoaW5UcmVlID0gZnVuY3Rpb24oIGVsZW0sIGVsICkge1xuXG5cdFx0Ly8gaXNIaWRkZW5XaXRoaW5UcmVlIG1pZ2h0IGJlIGNhbGxlZCBmcm9tIGpRdWVyeSNmaWx0ZXIgZnVuY3Rpb247XG5cdFx0Ly8gaW4gdGhhdCBjYXNlLCBlbGVtZW50IHdpbGwgYmUgc2Vjb25kIGFyZ3VtZW50XG5cdFx0ZWxlbSA9IGVsIHx8IGVsZW07XG5cblx0XHQvLyBJbmxpbmUgc3R5bGUgdHJ1bXBzIGFsbFxuXHRcdHJldHVybiBlbGVtLnN0eWxlLmRpc3BsYXkgPT09IFwibm9uZVwiIHx8XG5cdFx0XHRlbGVtLnN0eWxlLmRpc3BsYXkgPT09IFwiXCIgJiZcblxuXHRcdFx0Ly8gT3RoZXJ3aXNlLCBjaGVjayBjb21wdXRlZCBzdHlsZVxuXHRcdFx0Ly8gU3VwcG9ydDogRmlyZWZveCA8PTQzIC0gNDVcblx0XHRcdC8vIERpc2Nvbm5lY3RlZCBlbGVtZW50cyBjYW4gaGF2ZSBjb21wdXRlZCBkaXNwbGF5OiBub25lLCBzbyBmaXJzdCBjb25maXJtIHRoYXQgZWxlbSBpc1xuXHRcdFx0Ly8gaW4gdGhlIGRvY3VtZW50LlxuXHRcdFx0aXNBdHRhY2hlZCggZWxlbSApICYmXG5cblx0XHRcdGpRdWVyeS5jc3MoIGVsZW0sIFwiZGlzcGxheVwiICkgPT09IFwibm9uZVwiO1xuXHR9O1xuXG5cblxuZnVuY3Rpb24gYWRqdXN0Q1NTKCBlbGVtLCBwcm9wLCB2YWx1ZVBhcnRzLCB0d2VlbiApIHtcblx0dmFyIGFkanVzdGVkLCBzY2FsZSxcblx0XHRtYXhJdGVyYXRpb25zID0gMjAsXG5cdFx0Y3VycmVudFZhbHVlID0gdHdlZW4gP1xuXHRcdFx0ZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiB0d2Vlbi5jdXIoKTtcblx0XHRcdH0gOlxuXHRcdFx0ZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiBqUXVlcnkuY3NzKCBlbGVtLCBwcm9wLCBcIlwiICk7XG5cdFx0XHR9LFxuXHRcdGluaXRpYWwgPSBjdXJyZW50VmFsdWUoKSxcblx0XHR1bml0ID0gdmFsdWVQYXJ0cyAmJiB2YWx1ZVBhcnRzWyAzIF0gfHwgKCBqUXVlcnkuY3NzTnVtYmVyWyBwcm9wIF0gPyBcIlwiIDogXCJweFwiICksXG5cblx0XHQvLyBTdGFydGluZyB2YWx1ZSBjb21wdXRhdGlvbiBpcyByZXF1aXJlZCBmb3IgcG90ZW50aWFsIHVuaXQgbWlzbWF0Y2hlc1xuXHRcdGluaXRpYWxJblVuaXQgPSBlbGVtLm5vZGVUeXBlICYmXG5cdFx0XHQoIGpRdWVyeS5jc3NOdW1iZXJbIHByb3AgXSB8fCB1bml0ICE9PSBcInB4XCIgJiYgK2luaXRpYWwgKSAmJlxuXHRcdFx0cmNzc051bS5leGVjKCBqUXVlcnkuY3NzKCBlbGVtLCBwcm9wICkgKTtcblxuXHRpZiAoIGluaXRpYWxJblVuaXQgJiYgaW5pdGlhbEluVW5pdFsgMyBdICE9PSB1bml0ICkge1xuXG5cdFx0Ly8gU3VwcG9ydDogRmlyZWZveCA8PTU0XG5cdFx0Ly8gSGFsdmUgdGhlIGl0ZXJhdGlvbiB0YXJnZXQgdmFsdWUgdG8gcHJldmVudCBpbnRlcmZlcmVuY2UgZnJvbSBDU1MgdXBwZXIgYm91bmRzIChnaC0yMTQ0KVxuXHRcdGluaXRpYWwgPSBpbml0aWFsIC8gMjtcblxuXHRcdC8vIFRydXN0IHVuaXRzIHJlcG9ydGVkIGJ5IGpRdWVyeS5jc3Ncblx0XHR1bml0ID0gdW5pdCB8fCBpbml0aWFsSW5Vbml0WyAzIF07XG5cblx0XHQvLyBJdGVyYXRpdmVseSBhcHByb3hpbWF0ZSBmcm9tIGEgbm9uemVybyBzdGFydGluZyBwb2ludFxuXHRcdGluaXRpYWxJblVuaXQgPSAraW5pdGlhbCB8fCAxO1xuXG5cdFx0d2hpbGUgKCBtYXhJdGVyYXRpb25zLS0gKSB7XG5cblx0XHRcdC8vIEV2YWx1YXRlIGFuZCB1cGRhdGUgb3VyIGJlc3QgZ3Vlc3MgKGRvdWJsaW5nIGd1ZXNzZXMgdGhhdCB6ZXJvIG91dCkuXG5cdFx0XHQvLyBGaW5pc2ggaWYgdGhlIHNjYWxlIGVxdWFscyBvciBjcm9zc2VzIDEgKG1ha2luZyB0aGUgb2xkKm5ldyBwcm9kdWN0IG5vbi1wb3NpdGl2ZSkuXG5cdFx0XHRqUXVlcnkuc3R5bGUoIGVsZW0sIHByb3AsIGluaXRpYWxJblVuaXQgKyB1bml0ICk7XG5cdFx0XHRpZiAoICggMSAtIHNjYWxlICkgKiAoIDEgLSAoIHNjYWxlID0gY3VycmVudFZhbHVlKCkgLyBpbml0aWFsIHx8IDAuNSApICkgPD0gMCApIHtcblx0XHRcdFx0bWF4SXRlcmF0aW9ucyA9IDA7XG5cdFx0XHR9XG5cdFx0XHRpbml0aWFsSW5Vbml0ID0gaW5pdGlhbEluVW5pdCAvIHNjYWxlO1xuXG5cdFx0fVxuXG5cdFx0aW5pdGlhbEluVW5pdCA9IGluaXRpYWxJblVuaXQgKiAyO1xuXHRcdGpRdWVyeS5zdHlsZSggZWxlbSwgcHJvcCwgaW5pdGlhbEluVW5pdCArIHVuaXQgKTtcblxuXHRcdC8vIE1ha2Ugc3VyZSB3ZSB1cGRhdGUgdGhlIHR3ZWVuIHByb3BlcnRpZXMgbGF0ZXIgb25cblx0XHR2YWx1ZVBhcnRzID0gdmFsdWVQYXJ0cyB8fCBbXTtcblx0fVxuXG5cdGlmICggdmFsdWVQYXJ0cyApIHtcblx0XHRpbml0aWFsSW5Vbml0ID0gK2luaXRpYWxJblVuaXQgfHwgK2luaXRpYWwgfHwgMDtcblxuXHRcdC8vIEFwcGx5IHJlbGF0aXZlIG9mZnNldCAoKz0vLT0pIGlmIHNwZWNpZmllZFxuXHRcdGFkanVzdGVkID0gdmFsdWVQYXJ0c1sgMSBdID9cblx0XHRcdGluaXRpYWxJblVuaXQgKyAoIHZhbHVlUGFydHNbIDEgXSArIDEgKSAqIHZhbHVlUGFydHNbIDIgXSA6XG5cdFx0XHQrdmFsdWVQYXJ0c1sgMiBdO1xuXHRcdGlmICggdHdlZW4gKSB7XG5cdFx0XHR0d2Vlbi51bml0ID0gdW5pdDtcblx0XHRcdHR3ZWVuLnN0YXJ0ID0gaW5pdGlhbEluVW5pdDtcblx0XHRcdHR3ZWVuLmVuZCA9IGFkanVzdGVkO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gYWRqdXN0ZWQ7XG59XG5cblxudmFyIGRlZmF1bHREaXNwbGF5TWFwID0ge307XG5cbmZ1bmN0aW9uIGdldERlZmF1bHREaXNwbGF5KCBlbGVtICkge1xuXHR2YXIgdGVtcCxcblx0XHRkb2MgPSBlbGVtLm93bmVyRG9jdW1lbnQsXG5cdFx0bm9kZU5hbWUgPSBlbGVtLm5vZGVOYW1lLFxuXHRcdGRpc3BsYXkgPSBkZWZhdWx0RGlzcGxheU1hcFsgbm9kZU5hbWUgXTtcblxuXHRpZiAoIGRpc3BsYXkgKSB7XG5cdFx0cmV0dXJuIGRpc3BsYXk7XG5cdH1cblxuXHR0ZW1wID0gZG9jLmJvZHkuYXBwZW5kQ2hpbGQoIGRvYy5jcmVhdGVFbGVtZW50KCBub2RlTmFtZSApICk7XG5cdGRpc3BsYXkgPSBqUXVlcnkuY3NzKCB0ZW1wLCBcImRpc3BsYXlcIiApO1xuXG5cdHRlbXAucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCggdGVtcCApO1xuXG5cdGlmICggZGlzcGxheSA9PT0gXCJub25lXCIgKSB7XG5cdFx0ZGlzcGxheSA9IFwiYmxvY2tcIjtcblx0fVxuXHRkZWZhdWx0RGlzcGxheU1hcFsgbm9kZU5hbWUgXSA9IGRpc3BsYXk7XG5cblx0cmV0dXJuIGRpc3BsYXk7XG59XG5cbmZ1bmN0aW9uIHNob3dIaWRlKCBlbGVtZW50cywgc2hvdyApIHtcblx0dmFyIGRpc3BsYXksIGVsZW0sXG5cdFx0dmFsdWVzID0gW10sXG5cdFx0aW5kZXggPSAwLFxuXHRcdGxlbmd0aCA9IGVsZW1lbnRzLmxlbmd0aDtcblxuXHQvLyBEZXRlcm1pbmUgbmV3IGRpc3BsYXkgdmFsdWUgZm9yIGVsZW1lbnRzIHRoYXQgbmVlZCB0byBjaGFuZ2Vcblx0Zm9yICggOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRlbGVtID0gZWxlbWVudHNbIGluZGV4IF07XG5cdFx0aWYgKCAhZWxlbS5zdHlsZSApIHtcblx0XHRcdGNvbnRpbnVlO1xuXHRcdH1cblxuXHRcdGRpc3BsYXkgPSBlbGVtLnN0eWxlLmRpc3BsYXk7XG5cdFx0aWYgKCBzaG93ICkge1xuXG5cdFx0XHQvLyBTaW5jZSB3ZSBmb3JjZSB2aXNpYmlsaXR5IHVwb24gY2FzY2FkZS1oaWRkZW4gZWxlbWVudHMsIGFuIGltbWVkaWF0ZSAoYW5kIHNsb3cpXG5cdFx0XHQvLyBjaGVjayBpcyByZXF1aXJlZCBpbiB0aGlzIGZpcnN0IGxvb3AgdW5sZXNzIHdlIGhhdmUgYSBub25lbXB0eSBkaXNwbGF5IHZhbHVlIChlaXRoZXJcblx0XHRcdC8vIGlubGluZSBvciBhYm91dC10by1iZS1yZXN0b3JlZClcblx0XHRcdGlmICggZGlzcGxheSA9PT0gXCJub25lXCIgKSB7XG5cdFx0XHRcdHZhbHVlc1sgaW5kZXggXSA9IGRhdGFQcml2LmdldCggZWxlbSwgXCJkaXNwbGF5XCIgKSB8fCBudWxsO1xuXHRcdFx0XHRpZiAoICF2YWx1ZXNbIGluZGV4IF0gKSB7XG5cdFx0XHRcdFx0ZWxlbS5zdHlsZS5kaXNwbGF5ID0gXCJcIjtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKCBlbGVtLnN0eWxlLmRpc3BsYXkgPT09IFwiXCIgJiYgaXNIaWRkZW5XaXRoaW5UcmVlKCBlbGVtICkgKSB7XG5cdFx0XHRcdHZhbHVlc1sgaW5kZXggXSA9IGdldERlZmF1bHREaXNwbGF5KCBlbGVtICk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdGlmICggZGlzcGxheSAhPT0gXCJub25lXCIgKSB7XG5cdFx0XHRcdHZhbHVlc1sgaW5kZXggXSA9IFwibm9uZVwiO1xuXG5cdFx0XHRcdC8vIFJlbWVtYmVyIHdoYXQgd2UncmUgb3ZlcndyaXRpbmdcblx0XHRcdFx0ZGF0YVByaXYuc2V0KCBlbGVtLCBcImRpc3BsYXlcIiwgZGlzcGxheSApO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIFNldCB0aGUgZGlzcGxheSBvZiB0aGUgZWxlbWVudHMgaW4gYSBzZWNvbmQgbG9vcCB0byBhdm9pZCBjb25zdGFudCByZWZsb3dcblx0Zm9yICggaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRpZiAoIHZhbHVlc1sgaW5kZXggXSAhPSBudWxsICkge1xuXHRcdFx0ZWxlbWVudHNbIGluZGV4IF0uc3R5bGUuZGlzcGxheSA9IHZhbHVlc1sgaW5kZXggXTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gZWxlbWVudHM7XG59XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0c2hvdzogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHNob3dIaWRlKCB0aGlzLCB0cnVlICk7XG5cdH0sXG5cdGhpZGU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBzaG93SGlkZSggdGhpcyApO1xuXHR9LFxuXHR0b2dnbGU6IGZ1bmN0aW9uKCBzdGF0ZSApIHtcblx0XHRpZiAoIHR5cGVvZiBzdGF0ZSA9PT0gXCJib29sZWFuXCIgKSB7XG5cdFx0XHRyZXR1cm4gc3RhdGUgPyB0aGlzLnNob3coKSA6IHRoaXMuaGlkZSgpO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKCBpc0hpZGRlbldpdGhpblRyZWUoIHRoaXMgKSApIHtcblx0XHRcdFx0alF1ZXJ5KCB0aGlzICkuc2hvdygpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0alF1ZXJ5KCB0aGlzICkuaGlkZSgpO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fVxufSApO1xudmFyIHJjaGVja2FibGVUeXBlID0gKCAvXig/OmNoZWNrYm94fHJhZGlvKSQvaSApO1xuXG52YXIgcnRhZ05hbWUgPSAoIC88KFthLXpdW15cXC9cXDA+XFx4MjBcXHRcXHJcXG5cXGZdKikvaSApO1xuXG52YXIgcnNjcmlwdFR5cGUgPSAoIC9eJHxebW9kdWxlJHxcXC8oPzpqYXZhfGVjbWEpc2NyaXB0L2kgKTtcblxuXG5cbiggZnVuY3Rpb24oKSB7XG5cdHZhciBmcmFnbWVudCA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKSxcblx0XHRkaXYgPSBmcmFnbWVudC5hcHBlbmRDaGlsZCggZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJkaXZcIiApICksXG5cdFx0aW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImlucHV0XCIgKTtcblxuXHQvLyBTdXBwb3J0OiBBbmRyb2lkIDQuMCAtIDQuMyBvbmx5XG5cdC8vIENoZWNrIHN0YXRlIGxvc3QgaWYgdGhlIG5hbWUgaXMgc2V0ICh0cmFjLTExMjE3KVxuXHQvLyBTdXBwb3J0OiBXaW5kb3dzIFdlYiBBcHBzIChXV0EpXG5cdC8vIGBuYW1lYCBhbmQgYHR5cGVgIG11c3QgdXNlIC5zZXRBdHRyaWJ1dGUgZm9yIFdXQSAodHJhYy0xNDkwMSlcblx0aW5wdXQuc2V0QXR0cmlidXRlKCBcInR5cGVcIiwgXCJyYWRpb1wiICk7XG5cdGlucHV0LnNldEF0dHJpYnV0ZSggXCJjaGVja2VkXCIsIFwiY2hlY2tlZFwiICk7XG5cdGlucHV0LnNldEF0dHJpYnV0ZSggXCJuYW1lXCIsIFwidFwiICk7XG5cblx0ZGl2LmFwcGVuZENoaWxkKCBpbnB1dCApO1xuXG5cdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjEgb25seVxuXHQvLyBPbGRlciBXZWJLaXQgZG9lc24ndCBjbG9uZSBjaGVja2VkIHN0YXRlIGNvcnJlY3RseSBpbiBmcmFnbWVudHNcblx0c3VwcG9ydC5jaGVja0Nsb25lID0gZGl2LmNsb25lTm9kZSggdHJ1ZSApLmNsb25lTm9kZSggdHJ1ZSApLmxhc3RDaGlsZC5jaGVja2VkO1xuXG5cdC8vIFN1cHBvcnQ6IElFIDw9MTEgb25seVxuXHQvLyBNYWtlIHN1cmUgdGV4dGFyZWEgKGFuZCBjaGVja2JveCkgZGVmYXVsdFZhbHVlIGlzIHByb3Blcmx5IGNsb25lZFxuXHRkaXYuaW5uZXJIVE1MID0gXCI8dGV4dGFyZWE+eDwvdGV4dGFyZWE+XCI7XG5cdHN1cHBvcnQubm9DbG9uZUNoZWNrZWQgPSAhIWRpdi5jbG9uZU5vZGUoIHRydWUgKS5sYXN0Q2hpbGQuZGVmYXVsdFZhbHVlO1xuXG5cdC8vIFN1cHBvcnQ6IElFIDw9OSBvbmx5XG5cdC8vIElFIDw9OSByZXBsYWNlcyA8b3B0aW9uPiB0YWdzIHdpdGggdGhlaXIgY29udGVudHMgd2hlbiBpbnNlcnRlZCBvdXRzaWRlIG9mXG5cdC8vIHRoZSBzZWxlY3QgZWxlbWVudC5cblx0ZGl2LmlubmVySFRNTCA9IFwiPG9wdGlvbj48L29wdGlvbj5cIjtcblx0c3VwcG9ydC5vcHRpb24gPSAhIWRpdi5sYXN0Q2hpbGQ7XG59ICkoKTtcblxuXG4vLyBXZSBoYXZlIHRvIGNsb3NlIHRoZXNlIHRhZ3MgdG8gc3VwcG9ydCBYSFRNTCAodHJhYy0xMzIwMClcbnZhciB3cmFwTWFwID0ge1xuXG5cdC8vIFhIVE1MIHBhcnNlcnMgZG8gbm90IG1hZ2ljYWxseSBpbnNlcnQgZWxlbWVudHMgaW4gdGhlXG5cdC8vIHNhbWUgd2F5IHRoYXQgdGFnIHNvdXAgcGFyc2VycyBkby4gU28gd2UgY2Fubm90IHNob3J0ZW5cblx0Ly8gdGhpcyBieSBvbWl0dGluZyA8dGJvZHk+IG9yIG90aGVyIHJlcXVpcmVkIGVsZW1lbnRzLlxuXHR0aGVhZDogWyAxLCBcIjx0YWJsZT5cIiwgXCI8L3RhYmxlPlwiIF0sXG5cdGNvbDogWyAyLCBcIjx0YWJsZT48Y29sZ3JvdXA+XCIsIFwiPC9jb2xncm91cD48L3RhYmxlPlwiIF0sXG5cdHRyOiBbIDIsIFwiPHRhYmxlPjx0Ym9keT5cIiwgXCI8L3Rib2R5PjwvdGFibGU+XCIgXSxcblx0dGQ6IFsgMywgXCI8dGFibGU+PHRib2R5Pjx0cj5cIiwgXCI8L3RyPjwvdGJvZHk+PC90YWJsZT5cIiBdLFxuXG5cdF9kZWZhdWx0OiBbIDAsIFwiXCIsIFwiXCIgXVxufTtcblxud3JhcE1hcC50Ym9keSA9IHdyYXBNYXAudGZvb3QgPSB3cmFwTWFwLmNvbGdyb3VwID0gd3JhcE1hcC5jYXB0aW9uID0gd3JhcE1hcC50aGVhZDtcbndyYXBNYXAudGggPSB3cmFwTWFwLnRkO1xuXG4vLyBTdXBwb3J0OiBJRSA8PTkgb25seVxuaWYgKCAhc3VwcG9ydC5vcHRpb24gKSB7XG5cdHdyYXBNYXAub3B0Z3JvdXAgPSB3cmFwTWFwLm9wdGlvbiA9IFsgMSwgXCI8c2VsZWN0IG11bHRpcGxlPSdtdWx0aXBsZSc+XCIsIFwiPC9zZWxlY3Q+XCIgXTtcbn1cblxuXG5mdW5jdGlvbiBnZXRBbGwoIGNvbnRleHQsIHRhZyApIHtcblxuXHQvLyBTdXBwb3J0OiBJRSA8PTkgLSAxMSBvbmx5XG5cdC8vIFVzZSB0eXBlb2YgdG8gYXZvaWQgemVyby1hcmd1bWVudCBtZXRob2QgaW52b2NhdGlvbiBvbiBob3N0IG9iamVjdHMgKHRyYWMtMTUxNTEpXG5cdHZhciByZXQ7XG5cblx0aWYgKCB0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSAhPT0gXCJ1bmRlZmluZWRcIiApIHtcblx0XHRyZXQgPSBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lKCB0YWcgfHwgXCIqXCIgKTtcblxuXHR9IGVsc2UgaWYgKCB0eXBlb2YgY29udGV4dC5xdWVyeVNlbGVjdG9yQWxsICE9PSBcInVuZGVmaW5lZFwiICkge1xuXHRcdHJldCA9IGNvbnRleHQucXVlcnlTZWxlY3RvckFsbCggdGFnIHx8IFwiKlwiICk7XG5cblx0fSBlbHNlIHtcblx0XHRyZXQgPSBbXTtcblx0fVxuXG5cdGlmICggdGFnID09PSB1bmRlZmluZWQgfHwgdGFnICYmIG5vZGVOYW1lKCBjb250ZXh0LCB0YWcgKSApIHtcblx0XHRyZXR1cm4galF1ZXJ5Lm1lcmdlKCBbIGNvbnRleHQgXSwgcmV0ICk7XG5cdH1cblxuXHRyZXR1cm4gcmV0O1xufVxuXG5cbi8vIE1hcmsgc2NyaXB0cyBhcyBoYXZpbmcgYWxyZWFkeSBiZWVuIGV2YWx1YXRlZFxuZnVuY3Rpb24gc2V0R2xvYmFsRXZhbCggZWxlbXMsIHJlZkVsZW1lbnRzICkge1xuXHR2YXIgaSA9IDAsXG5cdFx0bCA9IGVsZW1zLmxlbmd0aDtcblxuXHRmb3IgKCA7IGkgPCBsOyBpKysgKSB7XG5cdFx0ZGF0YVByaXYuc2V0KFxuXHRcdFx0ZWxlbXNbIGkgXSxcblx0XHRcdFwiZ2xvYmFsRXZhbFwiLFxuXHRcdFx0IXJlZkVsZW1lbnRzIHx8IGRhdGFQcml2LmdldCggcmVmRWxlbWVudHNbIGkgXSwgXCJnbG9iYWxFdmFsXCIgKVxuXHRcdCk7XG5cdH1cbn1cblxuXG52YXIgcmh0bWwgPSAvPHwmIz9cXHcrOy87XG5cbmZ1bmN0aW9uIGJ1aWxkRnJhZ21lbnQoIGVsZW1zLCBjb250ZXh0LCBzY3JpcHRzLCBzZWxlY3Rpb24sIGlnbm9yZWQgKSB7XG5cdHZhciBlbGVtLCB0bXAsIHRhZywgd3JhcCwgYXR0YWNoZWQsIGosXG5cdFx0ZnJhZ21lbnQgPSBjb250ZXh0LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKSxcblx0XHRub2RlcyA9IFtdLFxuXHRcdGkgPSAwLFxuXHRcdGwgPSBlbGVtcy5sZW5ndGg7XG5cblx0Zm9yICggOyBpIDwgbDsgaSsrICkge1xuXHRcdGVsZW0gPSBlbGVtc1sgaSBdO1xuXG5cdFx0aWYgKCBlbGVtIHx8IGVsZW0gPT09IDAgKSB7XG5cblx0XHRcdC8vIEFkZCBub2RlcyBkaXJlY3RseVxuXHRcdFx0aWYgKCB0b1R5cGUoIGVsZW0gKSA9PT0gXCJvYmplY3RcIiApIHtcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4wIG9ubHksIFBoYW50b21KUyAxIG9ubHlcblx0XHRcdFx0Ly8gcHVzaC5hcHBseShfLCBhcnJheWxpa2UpIHRocm93cyBvbiBhbmNpZW50IFdlYktpdFxuXHRcdFx0XHRqUXVlcnkubWVyZ2UoIG5vZGVzLCBlbGVtLm5vZGVUeXBlID8gWyBlbGVtIF0gOiBlbGVtICk7XG5cblx0XHRcdC8vIENvbnZlcnQgbm9uLWh0bWwgaW50byBhIHRleHQgbm9kZVxuXHRcdFx0fSBlbHNlIGlmICggIXJodG1sLnRlc3QoIGVsZW0gKSApIHtcblx0XHRcdFx0bm9kZXMucHVzaCggY29udGV4dC5jcmVhdGVUZXh0Tm9kZSggZWxlbSApICk7XG5cblx0XHRcdC8vIENvbnZlcnQgaHRtbCBpbnRvIERPTSBub2Rlc1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dG1wID0gdG1wIHx8IGZyYWdtZW50LmFwcGVuZENoaWxkKCBjb250ZXh0LmNyZWF0ZUVsZW1lbnQoIFwiZGl2XCIgKSApO1xuXG5cdFx0XHRcdC8vIERlc2VyaWFsaXplIGEgc3RhbmRhcmQgcmVwcmVzZW50YXRpb25cblx0XHRcdFx0dGFnID0gKCBydGFnTmFtZS5leGVjKCBlbGVtICkgfHwgWyBcIlwiLCBcIlwiIF0gKVsgMSBdLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRcdHdyYXAgPSB3cmFwTWFwWyB0YWcgXSB8fCB3cmFwTWFwLl9kZWZhdWx0O1xuXHRcdFx0XHR0bXAuaW5uZXJIVE1MID0gd3JhcFsgMSBdICsgalF1ZXJ5Lmh0bWxQcmVmaWx0ZXIoIGVsZW0gKSArIHdyYXBbIDIgXTtcblxuXHRcdFx0XHQvLyBEZXNjZW5kIHRocm91Z2ggd3JhcHBlcnMgdG8gdGhlIHJpZ2h0IGNvbnRlbnRcblx0XHRcdFx0aiA9IHdyYXBbIDAgXTtcblx0XHRcdFx0d2hpbGUgKCBqLS0gKSB7XG5cdFx0XHRcdFx0dG1wID0gdG1wLmxhc3RDaGlsZDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjAgb25seSwgUGhhbnRvbUpTIDEgb25seVxuXHRcdFx0XHQvLyBwdXNoLmFwcGx5KF8sIGFycmF5bGlrZSkgdGhyb3dzIG9uIGFuY2llbnQgV2ViS2l0XG5cdFx0XHRcdGpRdWVyeS5tZXJnZSggbm9kZXMsIHRtcC5jaGlsZE5vZGVzICk7XG5cblx0XHRcdFx0Ly8gUmVtZW1iZXIgdGhlIHRvcC1sZXZlbCBjb250YWluZXJcblx0XHRcdFx0dG1wID0gZnJhZ21lbnQuZmlyc3RDaGlsZDtcblxuXHRcdFx0XHQvLyBFbnN1cmUgdGhlIGNyZWF0ZWQgbm9kZXMgYXJlIG9ycGhhbmVkICh0cmFjLTEyMzkyKVxuXHRcdFx0XHR0bXAudGV4dENvbnRlbnQgPSBcIlwiO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIFJlbW92ZSB3cmFwcGVyIGZyb20gZnJhZ21lbnRcblx0ZnJhZ21lbnQudGV4dENvbnRlbnQgPSBcIlwiO1xuXG5cdGkgPSAwO1xuXHR3aGlsZSAoICggZWxlbSA9IG5vZGVzWyBpKysgXSApICkge1xuXG5cdFx0Ly8gU2tpcCBlbGVtZW50cyBhbHJlYWR5IGluIHRoZSBjb250ZXh0IGNvbGxlY3Rpb24gKHRyYWMtNDA4Nylcblx0XHRpZiAoIHNlbGVjdGlvbiAmJiBqUXVlcnkuaW5BcnJheSggZWxlbSwgc2VsZWN0aW9uICkgPiAtMSApIHtcblx0XHRcdGlmICggaWdub3JlZCApIHtcblx0XHRcdFx0aWdub3JlZC5wdXNoKCBlbGVtICk7XG5cdFx0XHR9XG5cdFx0XHRjb250aW51ZTtcblx0XHR9XG5cblx0XHRhdHRhY2hlZCA9IGlzQXR0YWNoZWQoIGVsZW0gKTtcblxuXHRcdC8vIEFwcGVuZCB0byBmcmFnbWVudFxuXHRcdHRtcCA9IGdldEFsbCggZnJhZ21lbnQuYXBwZW5kQ2hpbGQoIGVsZW0gKSwgXCJzY3JpcHRcIiApO1xuXG5cdFx0Ly8gUHJlc2VydmUgc2NyaXB0IGV2YWx1YXRpb24gaGlzdG9yeVxuXHRcdGlmICggYXR0YWNoZWQgKSB7XG5cdFx0XHRzZXRHbG9iYWxFdmFsKCB0bXAgKTtcblx0XHR9XG5cblx0XHQvLyBDYXB0dXJlIGV4ZWN1dGFibGVzXG5cdFx0aWYgKCBzY3JpcHRzICkge1xuXHRcdFx0aiA9IDA7XG5cdFx0XHR3aGlsZSAoICggZWxlbSA9IHRtcFsgaisrIF0gKSApIHtcblx0XHRcdFx0aWYgKCByc2NyaXB0VHlwZS50ZXN0KCBlbGVtLnR5cGUgfHwgXCJcIiApICkge1xuXHRcdFx0XHRcdHNjcmlwdHMucHVzaCggZWxlbSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGZyYWdtZW50O1xufVxuXG5cbnZhciBydHlwZW5hbWVzcGFjZSA9IC9eKFteLl0qKSg/OlxcLiguKyl8KS87XG5cbmZ1bmN0aW9uIHJldHVyblRydWUoKSB7XG5cdHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiByZXR1cm5GYWxzZSgpIHtcblx0cmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBvbiggZWxlbSwgdHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbiwgb25lICkge1xuXHR2YXIgb3JpZ0ZuLCB0eXBlO1xuXG5cdC8vIFR5cGVzIGNhbiBiZSBhIG1hcCBvZiB0eXBlcy9oYW5kbGVyc1xuXHRpZiAoIHR5cGVvZiB0eXBlcyA9PT0gXCJvYmplY3RcIiApIHtcblxuXHRcdC8vICggdHlwZXMtT2JqZWN0LCBzZWxlY3RvciwgZGF0YSApXG5cdFx0aWYgKCB0eXBlb2Ygc2VsZWN0b3IgIT09IFwic3RyaW5nXCIgKSB7XG5cblx0XHRcdC8vICggdHlwZXMtT2JqZWN0LCBkYXRhIClcblx0XHRcdGRhdGEgPSBkYXRhIHx8IHNlbGVjdG9yO1xuXHRcdFx0c2VsZWN0b3IgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHRcdGZvciAoIHR5cGUgaW4gdHlwZXMgKSB7XG5cdFx0XHRvbiggZWxlbSwgdHlwZSwgc2VsZWN0b3IsIGRhdGEsIHR5cGVzWyB0eXBlIF0sIG9uZSApO1xuXHRcdH1cblx0XHRyZXR1cm4gZWxlbTtcblx0fVxuXG5cdGlmICggZGF0YSA9PSBudWxsICYmIGZuID09IG51bGwgKSB7XG5cblx0XHQvLyAoIHR5cGVzLCBmbiApXG5cdFx0Zm4gPSBzZWxlY3Rvcjtcblx0XHRkYXRhID0gc2VsZWN0b3IgPSB1bmRlZmluZWQ7XG5cdH0gZWxzZSBpZiAoIGZuID09IG51bGwgKSB7XG5cdFx0aWYgKCB0eXBlb2Ygc2VsZWN0b3IgPT09IFwic3RyaW5nXCIgKSB7XG5cblx0XHRcdC8vICggdHlwZXMsIHNlbGVjdG9yLCBmbiApXG5cdFx0XHRmbiA9IGRhdGE7XG5cdFx0XHRkYXRhID0gdW5kZWZpbmVkO1xuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vICggdHlwZXMsIGRhdGEsIGZuIClcblx0XHRcdGZuID0gZGF0YTtcblx0XHRcdGRhdGEgPSBzZWxlY3Rvcjtcblx0XHRcdHNlbGVjdG9yID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0fVxuXHRpZiAoIGZuID09PSBmYWxzZSApIHtcblx0XHRmbiA9IHJldHVybkZhbHNlO1xuXHR9IGVsc2UgaWYgKCAhZm4gKSB7XG5cdFx0cmV0dXJuIGVsZW07XG5cdH1cblxuXHRpZiAoIG9uZSA9PT0gMSApIHtcblx0XHRvcmlnRm4gPSBmbjtcblx0XHRmbiA9IGZ1bmN0aW9uKCBldmVudCApIHtcblxuXHRcdFx0Ly8gQ2FuIHVzZSBhbiBlbXB0eSBzZXQsIHNpbmNlIGV2ZW50IGNvbnRhaW5zIHRoZSBpbmZvXG5cdFx0XHRqUXVlcnkoKS5vZmYoIGV2ZW50ICk7XG5cdFx0XHRyZXR1cm4gb3JpZ0ZuLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHR9O1xuXG5cdFx0Ly8gVXNlIHNhbWUgZ3VpZCBzbyBjYWxsZXIgY2FuIHJlbW92ZSB1c2luZyBvcmlnRm5cblx0XHRmbi5ndWlkID0gb3JpZ0ZuLmd1aWQgfHwgKCBvcmlnRm4uZ3VpZCA9IGpRdWVyeS5ndWlkKysgKTtcblx0fVxuXHRyZXR1cm4gZWxlbS5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRqUXVlcnkuZXZlbnQuYWRkKCB0aGlzLCB0eXBlcywgZm4sIGRhdGEsIHNlbGVjdG9yICk7XG5cdH0gKTtcbn1cblxuLypcbiAqIEhlbHBlciBmdW5jdGlvbnMgZm9yIG1hbmFnaW5nIGV2ZW50cyAtLSBub3QgcGFydCBvZiB0aGUgcHVibGljIGludGVyZmFjZS5cbiAqIFByb3BzIHRvIERlYW4gRWR3YXJkcycgYWRkRXZlbnQgbGlicmFyeSBmb3IgbWFueSBvZiB0aGUgaWRlYXMuXG4gKi9cbmpRdWVyeS5ldmVudCA9IHtcblxuXHRnbG9iYWw6IHt9LFxuXG5cdGFkZDogZnVuY3Rpb24oIGVsZW0sIHR5cGVzLCBoYW5kbGVyLCBkYXRhLCBzZWxlY3RvciApIHtcblxuXHRcdHZhciBoYW5kbGVPYmpJbiwgZXZlbnRIYW5kbGUsIHRtcCxcblx0XHRcdGV2ZW50cywgdCwgaGFuZGxlT2JqLFxuXHRcdFx0c3BlY2lhbCwgaGFuZGxlcnMsIHR5cGUsIG5hbWVzcGFjZXMsIG9yaWdUeXBlLFxuXHRcdFx0ZWxlbURhdGEgPSBkYXRhUHJpdi5nZXQoIGVsZW0gKTtcblxuXHRcdC8vIE9ubHkgYXR0YWNoIGV2ZW50cyB0byBvYmplY3RzIHRoYXQgYWNjZXB0IGRhdGFcblx0XHRpZiAoICFhY2NlcHREYXRhKCBlbGVtICkgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gQ2FsbGVyIGNhbiBwYXNzIGluIGFuIG9iamVjdCBvZiBjdXN0b20gZGF0YSBpbiBsaWV1IG9mIHRoZSBoYW5kbGVyXG5cdFx0aWYgKCBoYW5kbGVyLmhhbmRsZXIgKSB7XG5cdFx0XHRoYW5kbGVPYmpJbiA9IGhhbmRsZXI7XG5cdFx0XHRoYW5kbGVyID0gaGFuZGxlT2JqSW4uaGFuZGxlcjtcblx0XHRcdHNlbGVjdG9yID0gaGFuZGxlT2JqSW4uc2VsZWN0b3I7XG5cdFx0fVxuXG5cdFx0Ly8gRW5zdXJlIHRoYXQgaW52YWxpZCBzZWxlY3RvcnMgdGhyb3cgZXhjZXB0aW9ucyBhdCBhdHRhY2ggdGltZVxuXHRcdC8vIEV2YWx1YXRlIGFnYWluc3QgZG9jdW1lbnRFbGVtZW50IGluIGNhc2UgZWxlbSBpcyBhIG5vbi1lbGVtZW50IG5vZGUgKGUuZy4sIGRvY3VtZW50KVxuXHRcdGlmICggc2VsZWN0b3IgKSB7XG5cdFx0XHRqUXVlcnkuZmluZC5tYXRjaGVzU2VsZWN0b3IoIGRvY3VtZW50RWxlbWVudCwgc2VsZWN0b3IgKTtcblx0XHR9XG5cblx0XHQvLyBNYWtlIHN1cmUgdGhhdCB0aGUgaGFuZGxlciBoYXMgYSB1bmlxdWUgSUQsIHVzZWQgdG8gZmluZC9yZW1vdmUgaXQgbGF0ZXJcblx0XHRpZiAoICFoYW5kbGVyLmd1aWQgKSB7XG5cdFx0XHRoYW5kbGVyLmd1aWQgPSBqUXVlcnkuZ3VpZCsrO1xuXHRcdH1cblxuXHRcdC8vIEluaXQgdGhlIGVsZW1lbnQncyBldmVudCBzdHJ1Y3R1cmUgYW5kIG1haW4gaGFuZGxlciwgaWYgdGhpcyBpcyB0aGUgZmlyc3Rcblx0XHRpZiAoICEoIGV2ZW50cyA9IGVsZW1EYXRhLmV2ZW50cyApICkge1xuXHRcdFx0ZXZlbnRzID0gZWxlbURhdGEuZXZlbnRzID0gT2JqZWN0LmNyZWF0ZSggbnVsbCApO1xuXHRcdH1cblx0XHRpZiAoICEoIGV2ZW50SGFuZGxlID0gZWxlbURhdGEuaGFuZGxlICkgKSB7XG5cdFx0XHRldmVudEhhbmRsZSA9IGVsZW1EYXRhLmhhbmRsZSA9IGZ1bmN0aW9uKCBlICkge1xuXG5cdFx0XHRcdC8vIERpc2NhcmQgdGhlIHNlY29uZCBldmVudCBvZiBhIGpRdWVyeS5ldmVudC50cmlnZ2VyKCkgYW5kXG5cdFx0XHRcdC8vIHdoZW4gYW4gZXZlbnQgaXMgY2FsbGVkIGFmdGVyIGEgcGFnZSBoYXMgdW5sb2FkZWRcblx0XHRcdFx0cmV0dXJuIHR5cGVvZiBqUXVlcnkgIT09IFwidW5kZWZpbmVkXCIgJiYgalF1ZXJ5LmV2ZW50LnRyaWdnZXJlZCAhPT0gZS50eXBlID9cblx0XHRcdFx0XHRqUXVlcnkuZXZlbnQuZGlzcGF0Y2guYXBwbHkoIGVsZW0sIGFyZ3VtZW50cyApIDogdW5kZWZpbmVkO1xuXHRcdFx0fTtcblx0XHR9XG5cblx0XHQvLyBIYW5kbGUgbXVsdGlwbGUgZXZlbnRzIHNlcGFyYXRlZCBieSBhIHNwYWNlXG5cdFx0dHlwZXMgPSAoIHR5cGVzIHx8IFwiXCIgKS5tYXRjaCggcm5vdGh0bWx3aGl0ZSApIHx8IFsgXCJcIiBdO1xuXHRcdHQgPSB0eXBlcy5sZW5ndGg7XG5cdFx0d2hpbGUgKCB0LS0gKSB7XG5cdFx0XHR0bXAgPSBydHlwZW5hbWVzcGFjZS5leGVjKCB0eXBlc1sgdCBdICkgfHwgW107XG5cdFx0XHR0eXBlID0gb3JpZ1R5cGUgPSB0bXBbIDEgXTtcblx0XHRcdG5hbWVzcGFjZXMgPSAoIHRtcFsgMiBdIHx8IFwiXCIgKS5zcGxpdCggXCIuXCIgKS5zb3J0KCk7XG5cblx0XHRcdC8vIFRoZXJlICptdXN0KiBiZSBhIHR5cGUsIG5vIGF0dGFjaGluZyBuYW1lc3BhY2Utb25seSBoYW5kbGVyc1xuXHRcdFx0aWYgKCAhdHlwZSApIHtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cblx0XHRcdC8vIElmIGV2ZW50IGNoYW5nZXMgaXRzIHR5cGUsIHVzZSB0aGUgc3BlY2lhbCBldmVudCBoYW5kbGVycyBmb3IgdGhlIGNoYW5nZWQgdHlwZVxuXHRcdFx0c3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsWyB0eXBlIF0gfHwge307XG5cblx0XHRcdC8vIElmIHNlbGVjdG9yIGRlZmluZWQsIGRldGVybWluZSBzcGVjaWFsIGV2ZW50IGFwaSB0eXBlLCBvdGhlcndpc2UgZ2l2ZW4gdHlwZVxuXHRcdFx0dHlwZSA9ICggc2VsZWN0b3IgPyBzcGVjaWFsLmRlbGVnYXRlVHlwZSA6IHNwZWNpYWwuYmluZFR5cGUgKSB8fCB0eXBlO1xuXG5cdFx0XHQvLyBVcGRhdGUgc3BlY2lhbCBiYXNlZCBvbiBuZXdseSByZXNldCB0eXBlXG5cdFx0XHRzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWxbIHR5cGUgXSB8fCB7fTtcblxuXHRcdFx0Ly8gaGFuZGxlT2JqIGlzIHBhc3NlZCB0byBhbGwgZXZlbnQgaGFuZGxlcnNcblx0XHRcdGhhbmRsZU9iaiA9IGpRdWVyeS5leHRlbmQoIHtcblx0XHRcdFx0dHlwZTogdHlwZSxcblx0XHRcdFx0b3JpZ1R5cGU6IG9yaWdUeXBlLFxuXHRcdFx0XHRkYXRhOiBkYXRhLFxuXHRcdFx0XHRoYW5kbGVyOiBoYW5kbGVyLFxuXHRcdFx0XHRndWlkOiBoYW5kbGVyLmd1aWQsXG5cdFx0XHRcdHNlbGVjdG9yOiBzZWxlY3Rvcixcblx0XHRcdFx0bmVlZHNDb250ZXh0OiBzZWxlY3RvciAmJiBqUXVlcnkuZXhwci5tYXRjaC5uZWVkc0NvbnRleHQudGVzdCggc2VsZWN0b3IgKSxcblx0XHRcdFx0bmFtZXNwYWNlOiBuYW1lc3BhY2VzLmpvaW4oIFwiLlwiIClcblx0XHRcdH0sIGhhbmRsZU9iakluICk7XG5cblx0XHRcdC8vIEluaXQgdGhlIGV2ZW50IGhhbmRsZXIgcXVldWUgaWYgd2UncmUgdGhlIGZpcnN0XG5cdFx0XHRpZiAoICEoIGhhbmRsZXJzID0gZXZlbnRzWyB0eXBlIF0gKSApIHtcblx0XHRcdFx0aGFuZGxlcnMgPSBldmVudHNbIHR5cGUgXSA9IFtdO1xuXHRcdFx0XHRoYW5kbGVycy5kZWxlZ2F0ZUNvdW50ID0gMDtcblxuXHRcdFx0XHQvLyBPbmx5IHVzZSBhZGRFdmVudExpc3RlbmVyIGlmIHRoZSBzcGVjaWFsIGV2ZW50cyBoYW5kbGVyIHJldHVybnMgZmFsc2Vcblx0XHRcdFx0aWYgKCAhc3BlY2lhbC5zZXR1cCB8fFxuXHRcdFx0XHRcdHNwZWNpYWwuc2V0dXAuY2FsbCggZWxlbSwgZGF0YSwgbmFtZXNwYWNlcywgZXZlbnRIYW5kbGUgKSA9PT0gZmFsc2UgKSB7XG5cblx0XHRcdFx0XHRpZiAoIGVsZW0uYWRkRXZlbnRMaXN0ZW5lciApIHtcblx0XHRcdFx0XHRcdGVsZW0uYWRkRXZlbnRMaXN0ZW5lciggdHlwZSwgZXZlbnRIYW5kbGUgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBzcGVjaWFsLmFkZCApIHtcblx0XHRcdFx0c3BlY2lhbC5hZGQuY2FsbCggZWxlbSwgaGFuZGxlT2JqICk7XG5cblx0XHRcdFx0aWYgKCAhaGFuZGxlT2JqLmhhbmRsZXIuZ3VpZCApIHtcblx0XHRcdFx0XHRoYW5kbGVPYmouaGFuZGxlci5ndWlkID0gaGFuZGxlci5ndWlkO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIEFkZCB0byB0aGUgZWxlbWVudCdzIGhhbmRsZXIgbGlzdCwgZGVsZWdhdGVzIGluIGZyb250XG5cdFx0XHRpZiAoIHNlbGVjdG9yICkge1xuXHRcdFx0XHRoYW5kbGVycy5zcGxpY2UoIGhhbmRsZXJzLmRlbGVnYXRlQ291bnQrKywgMCwgaGFuZGxlT2JqICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRoYW5kbGVycy5wdXNoKCBoYW5kbGVPYmogKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gS2VlcCB0cmFjayBvZiB3aGljaCBldmVudHMgaGF2ZSBldmVyIGJlZW4gdXNlZCwgZm9yIGV2ZW50IG9wdGltaXphdGlvblxuXHRcdFx0alF1ZXJ5LmV2ZW50Lmdsb2JhbFsgdHlwZSBdID0gdHJ1ZTtcblx0XHR9XG5cblx0fSxcblxuXHQvLyBEZXRhY2ggYW4gZXZlbnQgb3Igc2V0IG9mIGV2ZW50cyBmcm9tIGFuIGVsZW1lbnRcblx0cmVtb3ZlOiBmdW5jdGlvbiggZWxlbSwgdHlwZXMsIGhhbmRsZXIsIHNlbGVjdG9yLCBtYXBwZWRUeXBlcyApIHtcblxuXHRcdHZhciBqLCBvcmlnQ291bnQsIHRtcCxcblx0XHRcdGV2ZW50cywgdCwgaGFuZGxlT2JqLFxuXHRcdFx0c3BlY2lhbCwgaGFuZGxlcnMsIHR5cGUsIG5hbWVzcGFjZXMsIG9yaWdUeXBlLFxuXHRcdFx0ZWxlbURhdGEgPSBkYXRhUHJpdi5oYXNEYXRhKCBlbGVtICkgJiYgZGF0YVByaXYuZ2V0KCBlbGVtICk7XG5cblx0XHRpZiAoICFlbGVtRGF0YSB8fCAhKCBldmVudHMgPSBlbGVtRGF0YS5ldmVudHMgKSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBPbmNlIGZvciBlYWNoIHR5cGUubmFtZXNwYWNlIGluIHR5cGVzOyB0eXBlIG1heSBiZSBvbWl0dGVkXG5cdFx0dHlwZXMgPSAoIHR5cGVzIHx8IFwiXCIgKS5tYXRjaCggcm5vdGh0bWx3aGl0ZSApIHx8IFsgXCJcIiBdO1xuXHRcdHQgPSB0eXBlcy5sZW5ndGg7XG5cdFx0d2hpbGUgKCB0LS0gKSB7XG5cdFx0XHR0bXAgPSBydHlwZW5hbWVzcGFjZS5leGVjKCB0eXBlc1sgdCBdICkgfHwgW107XG5cdFx0XHR0eXBlID0gb3JpZ1R5cGUgPSB0bXBbIDEgXTtcblx0XHRcdG5hbWVzcGFjZXMgPSAoIHRtcFsgMiBdIHx8IFwiXCIgKS5zcGxpdCggXCIuXCIgKS5zb3J0KCk7XG5cblx0XHRcdC8vIFVuYmluZCBhbGwgZXZlbnRzIChvbiB0aGlzIG5hbWVzcGFjZSwgaWYgcHJvdmlkZWQpIGZvciB0aGUgZWxlbWVudFxuXHRcdFx0aWYgKCAhdHlwZSApIHtcblx0XHRcdFx0Zm9yICggdHlwZSBpbiBldmVudHMgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LnJlbW92ZSggZWxlbSwgdHlwZSArIHR5cGVzWyB0IF0sIGhhbmRsZXIsIHNlbGVjdG9yLCB0cnVlICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cblx0XHRcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgdHlwZSBdIHx8IHt9O1xuXHRcdFx0dHlwZSA9ICggc2VsZWN0b3IgPyBzcGVjaWFsLmRlbGVnYXRlVHlwZSA6IHNwZWNpYWwuYmluZFR5cGUgKSB8fCB0eXBlO1xuXHRcdFx0aGFuZGxlcnMgPSBldmVudHNbIHR5cGUgXSB8fCBbXTtcblx0XHRcdHRtcCA9IHRtcFsgMiBdICYmXG5cdFx0XHRcdG5ldyBSZWdFeHAoIFwiKF58XFxcXC4pXCIgKyBuYW1lc3BhY2VzLmpvaW4oIFwiXFxcXC4oPzouKlxcXFwufClcIiApICsgXCIoXFxcXC58JClcIiApO1xuXG5cdFx0XHQvLyBSZW1vdmUgbWF0Y2hpbmcgZXZlbnRzXG5cdFx0XHRvcmlnQ291bnQgPSBqID0gaGFuZGxlcnMubGVuZ3RoO1xuXHRcdFx0d2hpbGUgKCBqLS0gKSB7XG5cdFx0XHRcdGhhbmRsZU9iaiA9IGhhbmRsZXJzWyBqIF07XG5cblx0XHRcdFx0aWYgKCAoIG1hcHBlZFR5cGVzIHx8IG9yaWdUeXBlID09PSBoYW5kbGVPYmoub3JpZ1R5cGUgKSAmJlxuXHRcdFx0XHRcdCggIWhhbmRsZXIgfHwgaGFuZGxlci5ndWlkID09PSBoYW5kbGVPYmouZ3VpZCApICYmXG5cdFx0XHRcdFx0KCAhdG1wIHx8IHRtcC50ZXN0KCBoYW5kbGVPYmoubmFtZXNwYWNlICkgKSAmJlxuXHRcdFx0XHRcdCggIXNlbGVjdG9yIHx8IHNlbGVjdG9yID09PSBoYW5kbGVPYmouc2VsZWN0b3IgfHxcblx0XHRcdFx0XHRcdHNlbGVjdG9yID09PSBcIioqXCIgJiYgaGFuZGxlT2JqLnNlbGVjdG9yICkgKSB7XG5cdFx0XHRcdFx0aGFuZGxlcnMuc3BsaWNlKCBqLCAxICk7XG5cblx0XHRcdFx0XHRpZiAoIGhhbmRsZU9iai5zZWxlY3RvciApIHtcblx0XHRcdFx0XHRcdGhhbmRsZXJzLmRlbGVnYXRlQ291bnQtLTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKCBzcGVjaWFsLnJlbW92ZSApIHtcblx0XHRcdFx0XHRcdHNwZWNpYWwucmVtb3ZlLmNhbGwoIGVsZW0sIGhhbmRsZU9iaiApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBSZW1vdmUgZ2VuZXJpYyBldmVudCBoYW5kbGVyIGlmIHdlIHJlbW92ZWQgc29tZXRoaW5nIGFuZCBubyBtb3JlIGhhbmRsZXJzIGV4aXN0XG5cdFx0XHQvLyAoYXZvaWRzIHBvdGVudGlhbCBmb3IgZW5kbGVzcyByZWN1cnNpb24gZHVyaW5nIHJlbW92YWwgb2Ygc3BlY2lhbCBldmVudCBoYW5kbGVycylcblx0XHRcdGlmICggb3JpZ0NvdW50ICYmICFoYW5kbGVycy5sZW5ndGggKSB7XG5cdFx0XHRcdGlmICggIXNwZWNpYWwudGVhcmRvd24gfHxcblx0XHRcdFx0XHRzcGVjaWFsLnRlYXJkb3duLmNhbGwoIGVsZW0sIG5hbWVzcGFjZXMsIGVsZW1EYXRhLmhhbmRsZSApID09PSBmYWxzZSApIHtcblxuXHRcdFx0XHRcdGpRdWVyeS5yZW1vdmVFdmVudCggZWxlbSwgdHlwZSwgZWxlbURhdGEuaGFuZGxlICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRkZWxldGUgZXZlbnRzWyB0eXBlIF07XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gUmVtb3ZlIGRhdGEgYW5kIHRoZSBleHBhbmRvIGlmIGl0J3Mgbm8gbG9uZ2VyIHVzZWRcblx0XHRpZiAoIGpRdWVyeS5pc0VtcHR5T2JqZWN0KCBldmVudHMgKSApIHtcblx0XHRcdGRhdGFQcml2LnJlbW92ZSggZWxlbSwgXCJoYW5kbGUgZXZlbnRzXCIgKTtcblx0XHR9XG5cdH0sXG5cblx0ZGlzcGF0Y2g6IGZ1bmN0aW9uKCBuYXRpdmVFdmVudCApIHtcblxuXHRcdHZhciBpLCBqLCByZXQsIG1hdGNoZWQsIGhhbmRsZU9iaiwgaGFuZGxlclF1ZXVlLFxuXHRcdFx0YXJncyA9IG5ldyBBcnJheSggYXJndW1lbnRzLmxlbmd0aCApLFxuXG5cdFx0XHQvLyBNYWtlIGEgd3JpdGFibGUgalF1ZXJ5LkV2ZW50IGZyb20gdGhlIG5hdGl2ZSBldmVudCBvYmplY3Rcblx0XHRcdGV2ZW50ID0galF1ZXJ5LmV2ZW50LmZpeCggbmF0aXZlRXZlbnQgKSxcblxuXHRcdFx0aGFuZGxlcnMgPSAoXG5cdFx0XHRcdGRhdGFQcml2LmdldCggdGhpcywgXCJldmVudHNcIiApIHx8IE9iamVjdC5jcmVhdGUoIG51bGwgKVxuXHRcdFx0KVsgZXZlbnQudHlwZSBdIHx8IFtdLFxuXHRcdFx0c3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsWyBldmVudC50eXBlIF0gfHwge307XG5cblx0XHQvLyBVc2UgdGhlIGZpeC1lZCBqUXVlcnkuRXZlbnQgcmF0aGVyIHRoYW4gdGhlIChyZWFkLW9ubHkpIG5hdGl2ZSBldmVudFxuXHRcdGFyZ3NbIDAgXSA9IGV2ZW50O1xuXG5cdFx0Zm9yICggaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKysgKSB7XG5cdFx0XHRhcmdzWyBpIF0gPSBhcmd1bWVudHNbIGkgXTtcblx0XHR9XG5cblx0XHRldmVudC5kZWxlZ2F0ZVRhcmdldCA9IHRoaXM7XG5cblx0XHQvLyBDYWxsIHRoZSBwcmVEaXNwYXRjaCBob29rIGZvciB0aGUgbWFwcGVkIHR5cGUsIGFuZCBsZXQgaXQgYmFpbCBpZiBkZXNpcmVkXG5cdFx0aWYgKCBzcGVjaWFsLnByZURpc3BhdGNoICYmIHNwZWNpYWwucHJlRGlzcGF0Y2guY2FsbCggdGhpcywgZXZlbnQgKSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gRGV0ZXJtaW5lIGhhbmRsZXJzXG5cdFx0aGFuZGxlclF1ZXVlID0galF1ZXJ5LmV2ZW50LmhhbmRsZXJzLmNhbGwoIHRoaXMsIGV2ZW50LCBoYW5kbGVycyApO1xuXG5cdFx0Ly8gUnVuIGRlbGVnYXRlcyBmaXJzdDsgdGhleSBtYXkgd2FudCB0byBzdG9wIHByb3BhZ2F0aW9uIGJlbmVhdGggdXNcblx0XHRpID0gMDtcblx0XHR3aGlsZSAoICggbWF0Y2hlZCA9IGhhbmRsZXJRdWV1ZVsgaSsrIF0gKSAmJiAhZXZlbnQuaXNQcm9wYWdhdGlvblN0b3BwZWQoKSApIHtcblx0XHRcdGV2ZW50LmN1cnJlbnRUYXJnZXQgPSBtYXRjaGVkLmVsZW07XG5cblx0XHRcdGogPSAwO1xuXHRcdFx0d2hpbGUgKCAoIGhhbmRsZU9iaiA9IG1hdGNoZWQuaGFuZGxlcnNbIGorKyBdICkgJiZcblx0XHRcdFx0IWV2ZW50LmlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkKCkgKSB7XG5cblx0XHRcdFx0Ly8gSWYgdGhlIGV2ZW50IGlzIG5hbWVzcGFjZWQsIHRoZW4gZWFjaCBoYW5kbGVyIGlzIG9ubHkgaW52b2tlZCBpZiBpdCBpc1xuXHRcdFx0XHQvLyBzcGVjaWFsbHkgdW5pdmVyc2FsIG9yIGl0cyBuYW1lc3BhY2VzIGFyZSBhIHN1cGVyc2V0IG9mIHRoZSBldmVudCdzLlxuXHRcdFx0XHRpZiAoICFldmVudC5ybmFtZXNwYWNlIHx8IGhhbmRsZU9iai5uYW1lc3BhY2UgPT09IGZhbHNlIHx8XG5cdFx0XHRcdFx0ZXZlbnQucm5hbWVzcGFjZS50ZXN0KCBoYW5kbGVPYmoubmFtZXNwYWNlICkgKSB7XG5cblx0XHRcdFx0XHRldmVudC5oYW5kbGVPYmogPSBoYW5kbGVPYmo7XG5cdFx0XHRcdFx0ZXZlbnQuZGF0YSA9IGhhbmRsZU9iai5kYXRhO1xuXG5cdFx0XHRcdFx0cmV0ID0gKCAoIGpRdWVyeS5ldmVudC5zcGVjaWFsWyBoYW5kbGVPYmoub3JpZ1R5cGUgXSB8fCB7fSApLmhhbmRsZSB8fFxuXHRcdFx0XHRcdFx0aGFuZGxlT2JqLmhhbmRsZXIgKS5hcHBseSggbWF0Y2hlZC5lbGVtLCBhcmdzICk7XG5cblx0XHRcdFx0XHRpZiAoIHJldCAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdFx0aWYgKCAoIGV2ZW50LnJlc3VsdCA9IHJldCApID09PSBmYWxzZSApIHtcblx0XHRcdFx0XHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHRcdFx0XHRcdFx0ZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQ2FsbCB0aGUgcG9zdERpc3BhdGNoIGhvb2sgZm9yIHRoZSBtYXBwZWQgdHlwZVxuXHRcdGlmICggc3BlY2lhbC5wb3N0RGlzcGF0Y2ggKSB7XG5cdFx0XHRzcGVjaWFsLnBvc3REaXNwYXRjaC5jYWxsKCB0aGlzLCBldmVudCApO1xuXHRcdH1cblxuXHRcdHJldHVybiBldmVudC5yZXN1bHQ7XG5cdH0sXG5cblx0aGFuZGxlcnM6IGZ1bmN0aW9uKCBldmVudCwgaGFuZGxlcnMgKSB7XG5cdFx0dmFyIGksIGhhbmRsZU9iaiwgc2VsLCBtYXRjaGVkSGFuZGxlcnMsIG1hdGNoZWRTZWxlY3RvcnMsXG5cdFx0XHRoYW5kbGVyUXVldWUgPSBbXSxcblx0XHRcdGRlbGVnYXRlQ291bnQgPSBoYW5kbGVycy5kZWxlZ2F0ZUNvdW50LFxuXHRcdFx0Y3VyID0gZXZlbnQudGFyZ2V0O1xuXG5cdFx0Ly8gRmluZCBkZWxlZ2F0ZSBoYW5kbGVyc1xuXHRcdGlmICggZGVsZWdhdGVDb3VudCAmJlxuXG5cdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTlcblx0XHRcdC8vIEJsYWNrLWhvbGUgU1ZHIDx1c2U+IGluc3RhbmNlIHRyZWVzICh0cmFjLTEzMTgwKVxuXHRcdFx0Y3VyLm5vZGVUeXBlICYmXG5cblx0XHRcdC8vIFN1cHBvcnQ6IEZpcmVmb3ggPD00MlxuXHRcdFx0Ly8gU3VwcHJlc3Mgc3BlYy12aW9sYXRpbmcgY2xpY2tzIGluZGljYXRpbmcgYSBub24tcHJpbWFyeSBwb2ludGVyIGJ1dHRvbiAodHJhYy0zODYxKVxuXHRcdFx0Ly8gaHR0cHM6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy8jZXZlbnQtdHlwZS1jbGlja1xuXHRcdFx0Ly8gU3VwcG9ydDogSUUgMTEgb25seVxuXHRcdFx0Ly8gLi4uYnV0IG5vdCBhcnJvdyBrZXkgXCJjbGlja3NcIiBvZiByYWRpbyBpbnB1dHMsIHdoaWNoIGNhbiBoYXZlIGBidXR0b25gIC0xIChnaC0yMzQzKVxuXHRcdFx0ISggZXZlbnQudHlwZSA9PT0gXCJjbGlja1wiICYmIGV2ZW50LmJ1dHRvbiA+PSAxICkgKSB7XG5cblx0XHRcdGZvciAoIDsgY3VyICE9PSB0aGlzOyBjdXIgPSBjdXIucGFyZW50Tm9kZSB8fCB0aGlzICkge1xuXG5cdFx0XHRcdC8vIERvbid0IGNoZWNrIG5vbi1lbGVtZW50cyAodHJhYy0xMzIwOClcblx0XHRcdFx0Ly8gRG9uJ3QgcHJvY2VzcyBjbGlja3Mgb24gZGlzYWJsZWQgZWxlbWVudHMgKHRyYWMtNjkxMSwgdHJhYy04MTY1LCB0cmFjLTExMzgyLCB0cmFjLTExNzY0KVxuXHRcdFx0XHRpZiAoIGN1ci5ub2RlVHlwZSA9PT0gMSAmJiAhKCBldmVudC50eXBlID09PSBcImNsaWNrXCIgJiYgY3VyLmRpc2FibGVkID09PSB0cnVlICkgKSB7XG5cdFx0XHRcdFx0bWF0Y2hlZEhhbmRsZXJzID0gW107XG5cdFx0XHRcdFx0bWF0Y2hlZFNlbGVjdG9ycyA9IHt9O1xuXHRcdFx0XHRcdGZvciAoIGkgPSAwOyBpIDwgZGVsZWdhdGVDb3VudDsgaSsrICkge1xuXHRcdFx0XHRcdFx0aGFuZGxlT2JqID0gaGFuZGxlcnNbIGkgXTtcblxuXHRcdFx0XHRcdFx0Ly8gRG9uJ3QgY29uZmxpY3Qgd2l0aCBPYmplY3QucHJvdG90eXBlIHByb3BlcnRpZXMgKHRyYWMtMTMyMDMpXG5cdFx0XHRcdFx0XHRzZWwgPSBoYW5kbGVPYmouc2VsZWN0b3IgKyBcIiBcIjtcblxuXHRcdFx0XHRcdFx0aWYgKCBtYXRjaGVkU2VsZWN0b3JzWyBzZWwgXSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdFx0XHRtYXRjaGVkU2VsZWN0b3JzWyBzZWwgXSA9IGhhbmRsZU9iai5uZWVkc0NvbnRleHQgP1xuXHRcdFx0XHRcdFx0XHRcdGpRdWVyeSggc2VsLCB0aGlzICkuaW5kZXgoIGN1ciApID4gLTEgOlxuXHRcdFx0XHRcdFx0XHRcdGpRdWVyeS5maW5kKCBzZWwsIHRoaXMsIG51bGwsIFsgY3VyIF0gKS5sZW5ndGg7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZiAoIG1hdGNoZWRTZWxlY3RvcnNbIHNlbCBdICkge1xuXHRcdFx0XHRcdFx0XHRtYXRjaGVkSGFuZGxlcnMucHVzaCggaGFuZGxlT2JqICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICggbWF0Y2hlZEhhbmRsZXJzLmxlbmd0aCApIHtcblx0XHRcdFx0XHRcdGhhbmRsZXJRdWV1ZS5wdXNoKCB7IGVsZW06IGN1ciwgaGFuZGxlcnM6IG1hdGNoZWRIYW5kbGVycyB9ICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQWRkIHRoZSByZW1haW5pbmcgKGRpcmVjdGx5LWJvdW5kKSBoYW5kbGVyc1xuXHRcdGN1ciA9IHRoaXM7XG5cdFx0aWYgKCBkZWxlZ2F0ZUNvdW50IDwgaGFuZGxlcnMubGVuZ3RoICkge1xuXHRcdFx0aGFuZGxlclF1ZXVlLnB1c2goIHsgZWxlbTogY3VyLCBoYW5kbGVyczogaGFuZGxlcnMuc2xpY2UoIGRlbGVnYXRlQ291bnQgKSB9ICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGhhbmRsZXJRdWV1ZTtcblx0fSxcblxuXHRhZGRQcm9wOiBmdW5jdGlvbiggbmFtZSwgaG9vayApIHtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoIGpRdWVyeS5FdmVudC5wcm90b3R5cGUsIG5hbWUsIHtcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHRjb25maWd1cmFibGU6IHRydWUsXG5cblx0XHRcdGdldDogaXNGdW5jdGlvbiggaG9vayApID9cblx0XHRcdFx0ZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0aWYgKCB0aGlzLm9yaWdpbmFsRXZlbnQgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gaG9vayggdGhpcy5vcmlnaW5hbEV2ZW50ICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IDpcblx0XHRcdFx0ZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0aWYgKCB0aGlzLm9yaWdpbmFsRXZlbnQgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gdGhpcy5vcmlnaW5hbEV2ZW50WyBuYW1lIF07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9LFxuXG5cdFx0XHRzZXQ6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KCB0aGlzLCBuYW1lLCB7XG5cdFx0XHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdFx0XHRjb25maWd1cmFibGU6IHRydWUsXG5cdFx0XHRcdFx0d3JpdGFibGU6IHRydWUsXG5cdFx0XHRcdFx0dmFsdWU6IHZhbHVlXG5cdFx0XHRcdH0gKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cblx0Zml4OiBmdW5jdGlvbiggb3JpZ2luYWxFdmVudCApIHtcblx0XHRyZXR1cm4gb3JpZ2luYWxFdmVudFsgalF1ZXJ5LmV4cGFuZG8gXSA/XG5cdFx0XHRvcmlnaW5hbEV2ZW50IDpcblx0XHRcdG5ldyBqUXVlcnkuRXZlbnQoIG9yaWdpbmFsRXZlbnQgKTtcblx0fSxcblxuXHRzcGVjaWFsOiB7XG5cdFx0bG9hZDoge1xuXG5cdFx0XHQvLyBQcmV2ZW50IHRyaWdnZXJlZCBpbWFnZS5sb2FkIGV2ZW50cyBmcm9tIGJ1YmJsaW5nIHRvIHdpbmRvdy5sb2FkXG5cdFx0XHRub0J1YmJsZTogdHJ1ZVxuXHRcdH0sXG5cdFx0Y2xpY2s6IHtcblxuXHRcdFx0Ly8gVXRpbGl6ZSBuYXRpdmUgZXZlbnQgdG8gZW5zdXJlIGNvcnJlY3Qgc3RhdGUgZm9yIGNoZWNrYWJsZSBpbnB1dHNcblx0XHRcdHNldHVwOiBmdW5jdGlvbiggZGF0YSApIHtcblxuXHRcdFx0XHQvLyBGb3IgbXV0dWFsIGNvbXByZXNzaWJpbGl0eSB3aXRoIF9kZWZhdWx0LCByZXBsYWNlIGB0aGlzYCBhY2Nlc3Mgd2l0aCBhIGxvY2FsIHZhci5cblx0XHRcdFx0Ly8gYHx8IGRhdGFgIGlzIGRlYWQgY29kZSBtZWFudCBvbmx5IHRvIHByZXNlcnZlIHRoZSB2YXJpYWJsZSB0aHJvdWdoIG1pbmlmaWNhdGlvbi5cblx0XHRcdFx0dmFyIGVsID0gdGhpcyB8fCBkYXRhO1xuXG5cdFx0XHRcdC8vIENsYWltIHRoZSBmaXJzdCBoYW5kbGVyXG5cdFx0XHRcdGlmICggcmNoZWNrYWJsZVR5cGUudGVzdCggZWwudHlwZSApICYmXG5cdFx0XHRcdFx0ZWwuY2xpY2sgJiYgbm9kZU5hbWUoIGVsLCBcImlucHV0XCIgKSApIHtcblxuXHRcdFx0XHRcdC8vIGRhdGFQcml2LnNldCggZWwsIFwiY2xpY2tcIiwgLi4uIClcblx0XHRcdFx0XHRsZXZlcmFnZU5hdGl2ZSggZWwsIFwiY2xpY2tcIiwgdHJ1ZSApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gUmV0dXJuIGZhbHNlIHRvIGFsbG93IG5vcm1hbCBwcm9jZXNzaW5nIGluIHRoZSBjYWxsZXJcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fSxcblx0XHRcdHRyaWdnZXI6IGZ1bmN0aW9uKCBkYXRhICkge1xuXG5cdFx0XHRcdC8vIEZvciBtdXR1YWwgY29tcHJlc3NpYmlsaXR5IHdpdGggX2RlZmF1bHQsIHJlcGxhY2UgYHRoaXNgIGFjY2VzcyB3aXRoIGEgbG9jYWwgdmFyLlxuXHRcdFx0XHQvLyBgfHwgZGF0YWAgaXMgZGVhZCBjb2RlIG1lYW50IG9ubHkgdG8gcHJlc2VydmUgdGhlIHZhcmlhYmxlIHRocm91Z2ggbWluaWZpY2F0aW9uLlxuXHRcdFx0XHR2YXIgZWwgPSB0aGlzIHx8IGRhdGE7XG5cblx0XHRcdFx0Ly8gRm9yY2Ugc2V0dXAgYmVmb3JlIHRyaWdnZXJpbmcgYSBjbGlja1xuXHRcdFx0XHRpZiAoIHJjaGVja2FibGVUeXBlLnRlc3QoIGVsLnR5cGUgKSAmJlxuXHRcdFx0XHRcdGVsLmNsaWNrICYmIG5vZGVOYW1lKCBlbCwgXCJpbnB1dFwiICkgKSB7XG5cblx0XHRcdFx0XHRsZXZlcmFnZU5hdGl2ZSggZWwsIFwiY2xpY2tcIiApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gUmV0dXJuIG5vbi1mYWxzZSB0byBhbGxvdyBub3JtYWwgZXZlbnQtcGF0aCBwcm9wYWdhdGlvblxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH0sXG5cblx0XHRcdC8vIEZvciBjcm9zcy1icm93c2VyIGNvbnNpc3RlbmN5LCBzdXBwcmVzcyBuYXRpdmUgLmNsaWNrKCkgb24gbGlua3Ncblx0XHRcdC8vIEFsc28gcHJldmVudCBpdCBpZiB3ZSdyZSBjdXJyZW50bHkgaW5zaWRlIGEgbGV2ZXJhZ2VkIG5hdGl2ZS1ldmVudCBzdGFja1xuXHRcdFx0X2RlZmF1bHQ6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdFx0dmFyIHRhcmdldCA9IGV2ZW50LnRhcmdldDtcblx0XHRcdFx0cmV0dXJuIHJjaGVja2FibGVUeXBlLnRlc3QoIHRhcmdldC50eXBlICkgJiZcblx0XHRcdFx0XHR0YXJnZXQuY2xpY2sgJiYgbm9kZU5hbWUoIHRhcmdldCwgXCJpbnB1dFwiICkgJiZcblx0XHRcdFx0XHRkYXRhUHJpdi5nZXQoIHRhcmdldCwgXCJjbGlja1wiICkgfHxcblx0XHRcdFx0XHRub2RlTmFtZSggdGFyZ2V0LCBcImFcIiApO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRiZWZvcmV1bmxvYWQ6IHtcblx0XHRcdHBvc3REaXNwYXRjaDogZnVuY3Rpb24oIGV2ZW50ICkge1xuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IEZpcmVmb3ggMjArXG5cdFx0XHRcdC8vIEZpcmVmb3ggZG9lc24ndCBhbGVydCBpZiB0aGUgcmV0dXJuVmFsdWUgZmllbGQgaXMgbm90IHNldC5cblx0XHRcdFx0aWYgKCBldmVudC5yZXN1bHQgIT09IHVuZGVmaW5lZCAmJiBldmVudC5vcmlnaW5hbEV2ZW50ICkge1xuXHRcdFx0XHRcdGV2ZW50Lm9yaWdpbmFsRXZlbnQucmV0dXJuVmFsdWUgPSBldmVudC5yZXN1bHQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cbn07XG5cbi8vIEVuc3VyZSB0aGUgcHJlc2VuY2Ugb2YgYW4gZXZlbnQgbGlzdGVuZXIgdGhhdCBoYW5kbGVzIG1hbnVhbGx5LXRyaWdnZXJlZFxuLy8gc3ludGhldGljIGV2ZW50cyBieSBpbnRlcnJ1cHRpbmcgcHJvZ3Jlc3MgdW50aWwgcmVpbnZva2VkIGluIHJlc3BvbnNlIHRvXG4vLyAqbmF0aXZlKiBldmVudHMgdGhhdCBpdCBmaXJlcyBkaXJlY3RseSwgZW5zdXJpbmcgdGhhdCBzdGF0ZSBjaGFuZ2VzIGhhdmVcbi8vIGFscmVhZHkgb2NjdXJyZWQgYmVmb3JlIG90aGVyIGxpc3RlbmVycyBhcmUgaW52b2tlZC5cbmZ1bmN0aW9uIGxldmVyYWdlTmF0aXZlKCBlbCwgdHlwZSwgaXNTZXR1cCApIHtcblxuXHQvLyBNaXNzaW5nIGBpc1NldHVwYCBpbmRpY2F0ZXMgYSB0cmlnZ2VyIGNhbGwsIHdoaWNoIG11c3QgZm9yY2Ugc2V0dXAgdGhyb3VnaCBqUXVlcnkuZXZlbnQuYWRkXG5cdGlmICggIWlzU2V0dXAgKSB7XG5cdFx0aWYgKCBkYXRhUHJpdi5nZXQoIGVsLCB0eXBlICkgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdGpRdWVyeS5ldmVudC5hZGQoIGVsLCB0eXBlLCByZXR1cm5UcnVlICk7XG5cdFx0fVxuXHRcdHJldHVybjtcblx0fVxuXG5cdC8vIFJlZ2lzdGVyIHRoZSBjb250cm9sbGVyIGFzIGEgc3BlY2lhbCB1bml2ZXJzYWwgaGFuZGxlciBmb3IgYWxsIGV2ZW50IG5hbWVzcGFjZXNcblx0ZGF0YVByaXYuc2V0KCBlbCwgdHlwZSwgZmFsc2UgKTtcblx0alF1ZXJ5LmV2ZW50LmFkZCggZWwsIHR5cGUsIHtcblx0XHRuYW1lc3BhY2U6IGZhbHNlLFxuXHRcdGhhbmRsZXI6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdHZhciByZXN1bHQsXG5cdFx0XHRcdHNhdmVkID0gZGF0YVByaXYuZ2V0KCB0aGlzLCB0eXBlICk7XG5cblx0XHRcdGlmICggKCBldmVudC5pc1RyaWdnZXIgJiAxICkgJiYgdGhpc1sgdHlwZSBdICkge1xuXG5cdFx0XHRcdC8vIEludGVycnVwdCBwcm9jZXNzaW5nIG9mIHRoZSBvdXRlciBzeW50aGV0aWMgLnRyaWdnZXIoKWVkIGV2ZW50XG5cdFx0XHRcdGlmICggIXNhdmVkICkge1xuXG5cdFx0XHRcdFx0Ly8gU3RvcmUgYXJndW1lbnRzIGZvciB1c2Ugd2hlbiBoYW5kbGluZyB0aGUgaW5uZXIgbmF0aXZlIGV2ZW50XG5cdFx0XHRcdFx0Ly8gVGhlcmUgd2lsbCBhbHdheXMgYmUgYXQgbGVhc3Qgb25lIGFyZ3VtZW50IChhbiBldmVudCBvYmplY3QpLCBzbyB0aGlzIGFycmF5XG5cdFx0XHRcdFx0Ly8gd2lsbCBub3QgYmUgY29uZnVzZWQgd2l0aCBhIGxlZnRvdmVyIGNhcHR1cmUgb2JqZWN0LlxuXHRcdFx0XHRcdHNhdmVkID0gc2xpY2UuY2FsbCggYXJndW1lbnRzICk7XG5cdFx0XHRcdFx0ZGF0YVByaXYuc2V0KCB0aGlzLCB0eXBlLCBzYXZlZCApO1xuXG5cdFx0XHRcdFx0Ly8gVHJpZ2dlciB0aGUgbmF0aXZlIGV2ZW50IGFuZCBjYXB0dXJlIGl0cyByZXN1bHRcblx0XHRcdFx0XHR0aGlzWyB0eXBlIF0oKTtcblx0XHRcdFx0XHRyZXN1bHQgPSBkYXRhUHJpdi5nZXQoIHRoaXMsIHR5cGUgKTtcblx0XHRcdFx0XHRkYXRhUHJpdi5zZXQoIHRoaXMsIHR5cGUsIGZhbHNlICk7XG5cblx0XHRcdFx0XHRpZiAoIHNhdmVkICE9PSByZXN1bHQgKSB7XG5cblx0XHRcdFx0XHRcdC8vIENhbmNlbCB0aGUgb3V0ZXIgc3ludGhldGljIGV2ZW50XG5cdFx0XHRcdFx0XHRldmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcblx0XHRcdFx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cblx0XHRcdFx0XHRcdHJldHVybiByZXN1bHQ7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIElmIHRoaXMgaXMgYW4gaW5uZXIgc3ludGhldGljIGV2ZW50IGZvciBhbiBldmVudCB3aXRoIGEgYnViYmxpbmcgc3Vycm9nYXRlXG5cdFx0XHRcdC8vIChmb2N1cyBvciBibHVyKSwgYXNzdW1lIHRoYXQgdGhlIHN1cnJvZ2F0ZSBhbHJlYWR5IHByb3BhZ2F0ZWQgZnJvbSB0cmlnZ2VyaW5nXG5cdFx0XHRcdC8vIHRoZSBuYXRpdmUgZXZlbnQgYW5kIHByZXZlbnQgdGhhdCBmcm9tIGhhcHBlbmluZyBhZ2FpbiBoZXJlLlxuXHRcdFx0XHQvLyBUaGlzIHRlY2huaWNhbGx5IGdldHMgdGhlIG9yZGVyaW5nIHdyb25nIHcuci50LiB0byBgLnRyaWdnZXIoKWAgKGluIHdoaWNoIHRoZVxuXHRcdFx0XHQvLyBidWJibGluZyBzdXJyb2dhdGUgcHJvcGFnYXRlcyAqYWZ0ZXIqIHRoZSBub24tYnViYmxpbmcgYmFzZSksIGJ1dCB0aGF0IHNlZW1zXG5cdFx0XHRcdC8vIGxlc3MgYmFkIHRoYW4gZHVwbGljYXRpb24uXG5cdFx0XHRcdH0gZWxzZSBpZiAoICggalF1ZXJ5LmV2ZW50LnNwZWNpYWxbIHR5cGUgXSB8fCB7fSApLmRlbGVnYXRlVHlwZSApIHtcblx0XHRcdFx0XHRldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcblx0XHRcdFx0fVxuXG5cdFx0XHQvLyBJZiB0aGlzIGlzIGEgbmF0aXZlIGV2ZW50IHRyaWdnZXJlZCBhYm92ZSwgZXZlcnl0aGluZyBpcyBub3cgaW4gb3JkZXJcblx0XHRcdC8vIEZpcmUgYW4gaW5uZXIgc3ludGhldGljIGV2ZW50IHdpdGggdGhlIG9yaWdpbmFsIGFyZ3VtZW50c1xuXHRcdFx0fSBlbHNlIGlmICggc2F2ZWQgKSB7XG5cblx0XHRcdFx0Ly8gLi4uYW5kIGNhcHR1cmUgdGhlIHJlc3VsdFxuXHRcdFx0XHRkYXRhUHJpdi5zZXQoIHRoaXMsIHR5cGUsIGpRdWVyeS5ldmVudC50cmlnZ2VyKFxuXHRcdFx0XHRcdHNhdmVkWyAwIF0sXG5cdFx0XHRcdFx0c2F2ZWQuc2xpY2UoIDEgKSxcblx0XHRcdFx0XHR0aGlzXG5cdFx0XHRcdCkgKTtcblxuXHRcdFx0XHQvLyBBYm9ydCBoYW5kbGluZyBvZiB0aGUgbmF0aXZlIGV2ZW50IGJ5IGFsbCBqUXVlcnkgaGFuZGxlcnMgd2hpbGUgYWxsb3dpbmdcblx0XHRcdFx0Ly8gbmF0aXZlIGhhbmRsZXJzIG9uIHRoZSBzYW1lIGVsZW1lbnQgdG8gcnVuLiBPbiB0YXJnZXQsIHRoaXMgaXMgYWNoaWV2ZWRcblx0XHRcdFx0Ly8gYnkgc3RvcHBpbmcgaW1tZWRpYXRlIHByb3BhZ2F0aW9uIGp1c3Qgb24gdGhlIGpRdWVyeSBldmVudC4gSG93ZXZlcixcblx0XHRcdFx0Ly8gdGhlIG5hdGl2ZSBldmVudCBpcyByZS13cmFwcGVkIGJ5IGEgalF1ZXJ5IG9uZSBvbiBlYWNoIGxldmVsIG9mIHRoZVxuXHRcdFx0XHQvLyBwcm9wYWdhdGlvbiBzbyB0aGUgb25seSB3YXkgdG8gc3RvcCBpdCBmb3IgalF1ZXJ5IGlzIHRvIHN0b3AgaXQgZm9yXG5cdFx0XHRcdC8vIGV2ZXJ5b25lIHZpYSBuYXRpdmUgYHN0b3BQcm9wYWdhdGlvbigpYC4gVGhpcyBpcyBub3QgYSBwcm9ibGVtIGZvclxuXHRcdFx0XHQvLyBmb2N1cy9ibHVyIHdoaWNoIGRvbid0IGJ1YmJsZSwgYnV0IGl0IGRvZXMgYWxzbyBzdG9wIGNsaWNrIG9uIGNoZWNrYm94ZXNcblx0XHRcdFx0Ly8gYW5kIHJhZGlvcy4gV2UgYWNjZXB0IHRoaXMgbGltaXRhdGlvbi5cblx0XHRcdFx0ZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdFx0XHRcdGV2ZW50LmlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkID0gcmV0dXJuVHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cdH0gKTtcbn1cblxualF1ZXJ5LnJlbW92ZUV2ZW50ID0gZnVuY3Rpb24oIGVsZW0sIHR5cGUsIGhhbmRsZSApIHtcblxuXHQvLyBUaGlzIFwiaWZcIiBpcyBuZWVkZWQgZm9yIHBsYWluIG9iamVjdHNcblx0aWYgKCBlbGVtLnJlbW92ZUV2ZW50TGlzdGVuZXIgKSB7XG5cdFx0ZWxlbS5yZW1vdmVFdmVudExpc3RlbmVyKCB0eXBlLCBoYW5kbGUgKTtcblx0fVxufTtcblxualF1ZXJ5LkV2ZW50ID0gZnVuY3Rpb24oIHNyYywgcHJvcHMgKSB7XG5cblx0Ly8gQWxsb3cgaW5zdGFudGlhdGlvbiB3aXRob3V0IHRoZSAnbmV3JyBrZXl3b3JkXG5cdGlmICggISggdGhpcyBpbnN0YW5jZW9mIGpRdWVyeS5FdmVudCApICkge1xuXHRcdHJldHVybiBuZXcgalF1ZXJ5LkV2ZW50KCBzcmMsIHByb3BzICk7XG5cdH1cblxuXHQvLyBFdmVudCBvYmplY3Rcblx0aWYgKCBzcmMgJiYgc3JjLnR5cGUgKSB7XG5cdFx0dGhpcy5vcmlnaW5hbEV2ZW50ID0gc3JjO1xuXHRcdHRoaXMudHlwZSA9IHNyYy50eXBlO1xuXG5cdFx0Ly8gRXZlbnRzIGJ1YmJsaW5nIHVwIHRoZSBkb2N1bWVudCBtYXkgaGF2ZSBiZWVuIG1hcmtlZCBhcyBwcmV2ZW50ZWRcblx0XHQvLyBieSBhIGhhbmRsZXIgbG93ZXIgZG93biB0aGUgdHJlZTsgcmVmbGVjdCB0aGUgY29ycmVjdCB2YWx1ZS5cblx0XHR0aGlzLmlzRGVmYXVsdFByZXZlbnRlZCA9IHNyYy5kZWZhdWx0UHJldmVudGVkIHx8XG5cdFx0XHRcdHNyYy5kZWZhdWx0UHJldmVudGVkID09PSB1bmRlZmluZWQgJiZcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9Mi4zIG9ubHlcblx0XHRcdFx0c3JjLnJldHVyblZhbHVlID09PSBmYWxzZSA/XG5cdFx0XHRyZXR1cm5UcnVlIDpcblx0XHRcdHJldHVybkZhbHNlO1xuXG5cdFx0Ly8gQ3JlYXRlIHRhcmdldCBwcm9wZXJ0aWVzXG5cdFx0Ly8gU3VwcG9ydDogU2FmYXJpIDw9NiAtIDcgb25seVxuXHRcdC8vIFRhcmdldCBzaG91bGQgbm90IGJlIGEgdGV4dCBub2RlICh0cmFjLTUwNCwgdHJhYy0xMzE0Mylcblx0XHR0aGlzLnRhcmdldCA9ICggc3JjLnRhcmdldCAmJiBzcmMudGFyZ2V0Lm5vZGVUeXBlID09PSAzICkgP1xuXHRcdFx0c3JjLnRhcmdldC5wYXJlbnROb2RlIDpcblx0XHRcdHNyYy50YXJnZXQ7XG5cblx0XHR0aGlzLmN1cnJlbnRUYXJnZXQgPSBzcmMuY3VycmVudFRhcmdldDtcblx0XHR0aGlzLnJlbGF0ZWRUYXJnZXQgPSBzcmMucmVsYXRlZFRhcmdldDtcblxuXHQvLyBFdmVudCB0eXBlXG5cdH0gZWxzZSB7XG5cdFx0dGhpcy50eXBlID0gc3JjO1xuXHR9XG5cblx0Ly8gUHV0IGV4cGxpY2l0bHkgcHJvdmlkZWQgcHJvcGVydGllcyBvbnRvIHRoZSBldmVudCBvYmplY3Rcblx0aWYgKCBwcm9wcyApIHtcblx0XHRqUXVlcnkuZXh0ZW5kKCB0aGlzLCBwcm9wcyApO1xuXHR9XG5cblx0Ly8gQ3JlYXRlIGEgdGltZXN0YW1wIGlmIGluY29taW5nIGV2ZW50IGRvZXNuJ3QgaGF2ZSBvbmVcblx0dGhpcy50aW1lU3RhbXAgPSBzcmMgJiYgc3JjLnRpbWVTdGFtcCB8fCBEYXRlLm5vdygpO1xuXG5cdC8vIE1hcmsgaXQgYXMgZml4ZWRcblx0dGhpc1sgalF1ZXJ5LmV4cGFuZG8gXSA9IHRydWU7XG59O1xuXG4vLyBqUXVlcnkuRXZlbnQgaXMgYmFzZWQgb24gRE9NMyBFdmVudHMgYXMgc3BlY2lmaWVkIGJ5IHRoZSBFQ01BU2NyaXB0IExhbmd1YWdlIEJpbmRpbmdcbi8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi8yMDAzL1dELURPTS1MZXZlbC0zLUV2ZW50cy0yMDAzMDMzMS9lY21hLXNjcmlwdC1iaW5kaW5nLmh0bWxcbmpRdWVyeS5FdmVudC5wcm90b3R5cGUgPSB7XG5cdGNvbnN0cnVjdG9yOiBqUXVlcnkuRXZlbnQsXG5cdGlzRGVmYXVsdFByZXZlbnRlZDogcmV0dXJuRmFsc2UsXG5cdGlzUHJvcGFnYXRpb25TdG9wcGVkOiByZXR1cm5GYWxzZSxcblx0aXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQ6IHJldHVybkZhbHNlLFxuXHRpc1NpbXVsYXRlZDogZmFsc2UsXG5cblx0cHJldmVudERlZmF1bHQ6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBlID0gdGhpcy5vcmlnaW5hbEV2ZW50O1xuXG5cdFx0dGhpcy5pc0RlZmF1bHRQcmV2ZW50ZWQgPSByZXR1cm5UcnVlO1xuXG5cdFx0aWYgKCBlICYmICF0aGlzLmlzU2ltdWxhdGVkICkge1xuXHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdH1cblx0fSxcblx0c3RvcFByb3BhZ2F0aW9uOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgZSA9IHRoaXMub3JpZ2luYWxFdmVudDtcblxuXHRcdHRoaXMuaXNQcm9wYWdhdGlvblN0b3BwZWQgPSByZXR1cm5UcnVlO1xuXG5cdFx0aWYgKCBlICYmICF0aGlzLmlzU2ltdWxhdGVkICkge1xuXHRcdFx0ZS5zdG9wUHJvcGFnYXRpb24oKTtcblx0XHR9XG5cdH0sXG5cdHN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGUgPSB0aGlzLm9yaWdpbmFsRXZlbnQ7XG5cblx0XHR0aGlzLmlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkID0gcmV0dXJuVHJ1ZTtcblxuXHRcdGlmICggZSAmJiAhdGhpcy5pc1NpbXVsYXRlZCApIHtcblx0XHRcdGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG5cdFx0fVxuXG5cdFx0dGhpcy5zdG9wUHJvcGFnYXRpb24oKTtcblx0fVxufTtcblxuLy8gSW5jbHVkZXMgYWxsIGNvbW1vbiBldmVudCBwcm9wcyBpbmNsdWRpbmcgS2V5RXZlbnQgYW5kIE1vdXNlRXZlbnQgc3BlY2lmaWMgcHJvcHNcbmpRdWVyeS5lYWNoKCB7XG5cdGFsdEtleTogdHJ1ZSxcblx0YnViYmxlczogdHJ1ZSxcblx0Y2FuY2VsYWJsZTogdHJ1ZSxcblx0Y2hhbmdlZFRvdWNoZXM6IHRydWUsXG5cdGN0cmxLZXk6IHRydWUsXG5cdGRldGFpbDogdHJ1ZSxcblx0ZXZlbnRQaGFzZTogdHJ1ZSxcblx0bWV0YUtleTogdHJ1ZSxcblx0cGFnZVg6IHRydWUsXG5cdHBhZ2VZOiB0cnVlLFxuXHRzaGlmdEtleTogdHJ1ZSxcblx0dmlldzogdHJ1ZSxcblx0XCJjaGFyXCI6IHRydWUsXG5cdGNvZGU6IHRydWUsXG5cdGNoYXJDb2RlOiB0cnVlLFxuXHRrZXk6IHRydWUsXG5cdGtleUNvZGU6IHRydWUsXG5cdGJ1dHRvbjogdHJ1ZSxcblx0YnV0dG9uczogdHJ1ZSxcblx0Y2xpZW50WDogdHJ1ZSxcblx0Y2xpZW50WTogdHJ1ZSxcblx0b2Zmc2V0WDogdHJ1ZSxcblx0b2Zmc2V0WTogdHJ1ZSxcblx0cG9pbnRlcklkOiB0cnVlLFxuXHRwb2ludGVyVHlwZTogdHJ1ZSxcblx0c2NyZWVuWDogdHJ1ZSxcblx0c2NyZWVuWTogdHJ1ZSxcblx0dGFyZ2V0VG91Y2hlczogdHJ1ZSxcblx0dG9FbGVtZW50OiB0cnVlLFxuXHR0b3VjaGVzOiB0cnVlLFxuXHR3aGljaDogdHJ1ZVxufSwgalF1ZXJ5LmV2ZW50LmFkZFByb3AgKTtcblxualF1ZXJ5LmVhY2goIHsgZm9jdXM6IFwiZm9jdXNpblwiLCBibHVyOiBcImZvY3Vzb3V0XCIgfSwgZnVuY3Rpb24oIHR5cGUsIGRlbGVnYXRlVHlwZSApIHtcblxuXHRmdW5jdGlvbiBmb2N1c01hcHBlZEhhbmRsZXIoIG5hdGl2ZUV2ZW50ICkge1xuXHRcdGlmICggZG9jdW1lbnQuZG9jdW1lbnRNb2RlICkge1xuXG5cdFx0XHQvLyBTdXBwb3J0OiBJRSAxMStcblx0XHRcdC8vIEF0dGFjaCBhIHNpbmdsZSBmb2N1c2luL2ZvY3Vzb3V0IGhhbmRsZXIgb24gdGhlIGRvY3VtZW50IHdoaWxlIHNvbWVvbmUgd2FudHNcblx0XHRcdC8vIGZvY3VzL2JsdXIuIFRoaXMgaXMgYmVjYXVzZSB0aGUgZm9ybWVyIGFyZSBzeW5jaHJvbm91cyBpbiBJRSB3aGlsZSB0aGUgbGF0dGVyXG5cdFx0XHQvLyBhcmUgYXN5bmMuIEluIG90aGVyIGJyb3dzZXJzLCBhbGwgdGhvc2UgaGFuZGxlcnMgYXJlIGludm9rZWQgc3luY2hyb25vdXNseS5cblxuXHRcdFx0Ly8gYGhhbmRsZWAgZnJvbSBwcml2YXRlIGRhdGEgd291bGQgYWxyZWFkeSB3cmFwIHRoZSBldmVudCwgYnV0IHdlIG5lZWRcblx0XHRcdC8vIHRvIGNoYW5nZSB0aGUgYHR5cGVgIGhlcmUuXG5cdFx0XHR2YXIgaGFuZGxlID0gZGF0YVByaXYuZ2V0KCB0aGlzLCBcImhhbmRsZVwiICksXG5cdFx0XHRcdGV2ZW50ID0galF1ZXJ5LmV2ZW50LmZpeCggbmF0aXZlRXZlbnQgKTtcblx0XHRcdGV2ZW50LnR5cGUgPSBuYXRpdmVFdmVudC50eXBlID09PSBcImZvY3VzaW5cIiA/IFwiZm9jdXNcIiA6IFwiYmx1clwiO1xuXHRcdFx0ZXZlbnQuaXNTaW11bGF0ZWQgPSB0cnVlO1xuXG5cdFx0XHQvLyBGaXJzdCwgaGFuZGxlIGZvY3VzaW4vZm9jdXNvdXRcblx0XHRcdGhhbmRsZSggbmF0aXZlRXZlbnQgKTtcblxuXHRcdFx0Ly8gLi4udGhlbiwgaGFuZGxlIGZvY3VzL2JsdXJcblx0XHRcdC8vXG5cdFx0XHQvLyBmb2N1cy9ibHVyIGRvbid0IGJ1YmJsZSB3aGlsZSBmb2N1c2luL2ZvY3Vzb3V0IGRvOyBzaW11bGF0ZSB0aGUgZm9ybWVyIGJ5IG9ubHlcblx0XHRcdC8vIGludm9raW5nIHRoZSBoYW5kbGVyIGF0IHRoZSBsb3dlciBsZXZlbC5cblx0XHRcdGlmICggZXZlbnQudGFyZ2V0ID09PSBldmVudC5jdXJyZW50VGFyZ2V0ICkge1xuXG5cdFx0XHRcdC8vIFRoZSBzZXR1cCBwYXJ0IGNhbGxzIGBsZXZlcmFnZU5hdGl2ZWAsIHdoaWNoLCBpbiB0dXJuLCBjYWxsc1xuXHRcdFx0XHQvLyBgalF1ZXJ5LmV2ZW50LmFkZGAsIHNvIGV2ZW50IGhhbmRsZSB3aWxsIGFscmVhZHkgaGF2ZSBiZWVuIHNldFxuXHRcdFx0XHQvLyBieSB0aGlzIHBvaW50LlxuXHRcdFx0XHRoYW5kbGUoIGV2ZW50ICk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Ly8gRm9yIG5vbi1JRSBicm93c2VycywgYXR0YWNoIGEgc2luZ2xlIGNhcHR1cmluZyBoYW5kbGVyIG9uIHRoZSBkb2N1bWVudFxuXHRcdFx0Ly8gd2hpbGUgc29tZW9uZSB3YW50cyBmb2N1c2luL2ZvY3Vzb3V0LlxuXHRcdFx0alF1ZXJ5LmV2ZW50LnNpbXVsYXRlKCBkZWxlZ2F0ZVR5cGUsIG5hdGl2ZUV2ZW50LnRhcmdldCxcblx0XHRcdFx0alF1ZXJ5LmV2ZW50LmZpeCggbmF0aXZlRXZlbnQgKSApO1xuXHRcdH1cblx0fVxuXG5cdGpRdWVyeS5ldmVudC5zcGVjaWFsWyB0eXBlIF0gPSB7XG5cblx0XHQvLyBVdGlsaXplIG5hdGl2ZSBldmVudCBpZiBwb3NzaWJsZSBzbyBibHVyL2ZvY3VzIHNlcXVlbmNlIGlzIGNvcnJlY3Rcblx0XHRzZXR1cDogZnVuY3Rpb24oKSB7XG5cblx0XHRcdHZhciBhdHRhY2hlcztcblxuXHRcdFx0Ly8gQ2xhaW0gdGhlIGZpcnN0IGhhbmRsZXJcblx0XHRcdC8vIGRhdGFQcml2LnNldCggdGhpcywgXCJmb2N1c1wiLCAuLi4gKVxuXHRcdFx0Ly8gZGF0YVByaXYuc2V0KCB0aGlzLCBcImJsdXJcIiwgLi4uIClcblx0XHRcdGxldmVyYWdlTmF0aXZlKCB0aGlzLCB0eXBlLCB0cnVlICk7XG5cblx0XHRcdGlmICggZG9jdW1lbnQuZG9jdW1lbnRNb2RlICkge1xuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDkgLSAxMStcblx0XHRcdFx0Ly8gV2UgdXNlIHRoZSBzYW1lIG5hdGl2ZSBoYW5kbGVyIGZvciBmb2N1c2luICYgZm9jdXMgKGFuZCBmb2N1c291dCAmIGJsdXIpXG5cdFx0XHRcdC8vIHNvIHdlIG5lZWQgdG8gY29vcmRpbmF0ZSBzZXR1cCAmIHRlYXJkb3duIHBhcnRzIGJldHdlZW4gdGhvc2UgZXZlbnRzLlxuXHRcdFx0XHQvLyBVc2UgYGRlbGVnYXRlVHlwZWAgYXMgdGhlIGtleSBhcyBgdHlwZWAgaXMgYWxyZWFkeSB1c2VkIGJ5IGBsZXZlcmFnZU5hdGl2ZWAuXG5cdFx0XHRcdGF0dGFjaGVzID0gZGF0YVByaXYuZ2V0KCB0aGlzLCBkZWxlZ2F0ZVR5cGUgKTtcblx0XHRcdFx0aWYgKCAhYXR0YWNoZXMgKSB7XG5cdFx0XHRcdFx0dGhpcy5hZGRFdmVudExpc3RlbmVyKCBkZWxlZ2F0ZVR5cGUsIGZvY3VzTWFwcGVkSGFuZGxlciApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGRhdGFQcml2LnNldCggdGhpcywgZGVsZWdhdGVUeXBlLCAoIGF0dGFjaGVzIHx8IDAgKSArIDEgKTtcblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Ly8gUmV0dXJuIGZhbHNlIHRvIGFsbG93IG5vcm1hbCBwcm9jZXNzaW5nIGluIHRoZSBjYWxsZXJcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0dHJpZ2dlcjogZnVuY3Rpb24oKSB7XG5cblx0XHRcdC8vIEZvcmNlIHNldHVwIGJlZm9yZSB0cmlnZ2VyXG5cdFx0XHRsZXZlcmFnZU5hdGl2ZSggdGhpcywgdHlwZSApO1xuXG5cdFx0XHQvLyBSZXR1cm4gbm9uLWZhbHNlIHRvIGFsbG93IG5vcm1hbCBldmVudC1wYXRoIHByb3BhZ2F0aW9uXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9LFxuXG5cdFx0dGVhcmRvd246IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGF0dGFjaGVzO1xuXG5cdFx0XHRpZiAoIGRvY3VtZW50LmRvY3VtZW50TW9kZSApIHtcblx0XHRcdFx0YXR0YWNoZXMgPSBkYXRhUHJpdi5nZXQoIHRoaXMsIGRlbGVnYXRlVHlwZSApIC0gMTtcblx0XHRcdFx0aWYgKCAhYXR0YWNoZXMgKSB7XG5cdFx0XHRcdFx0dGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKCBkZWxlZ2F0ZVR5cGUsIGZvY3VzTWFwcGVkSGFuZGxlciApO1xuXHRcdFx0XHRcdGRhdGFQcml2LnJlbW92ZSggdGhpcywgZGVsZWdhdGVUeXBlICk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0ZGF0YVByaXYuc2V0KCB0aGlzLCBkZWxlZ2F0ZVR5cGUsIGF0dGFjaGVzICk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Ly8gUmV0dXJuIGZhbHNlIHRvIGluZGljYXRlIHN0YW5kYXJkIHRlYXJkb3duIHNob3VsZCBiZSBhcHBsaWVkXG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0Ly8gU3VwcHJlc3MgbmF0aXZlIGZvY3VzIG9yIGJsdXIgaWYgd2UncmUgY3VycmVudGx5IGluc2lkZVxuXHRcdC8vIGEgbGV2ZXJhZ2VkIG5hdGl2ZS1ldmVudCBzdGFja1xuXHRcdF9kZWZhdWx0OiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHRyZXR1cm4gZGF0YVByaXYuZ2V0KCBldmVudC50YXJnZXQsIHR5cGUgKTtcblx0XHR9LFxuXG5cdFx0ZGVsZWdhdGVUeXBlOiBkZWxlZ2F0ZVR5cGVcblx0fTtcblxuXHQvLyBTdXBwb3J0OiBGaXJlZm94IDw9NDRcblx0Ly8gRmlyZWZveCBkb2Vzbid0IGhhdmUgZm9jdXMoaW4gfCBvdXQpIGV2ZW50c1xuXHQvLyBSZWxhdGVkIHRpY2tldCAtIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTY4Nzc4N1xuXHQvL1xuXHQvLyBTdXBwb3J0OiBDaHJvbWUgPD00OCAtIDQ5LCBTYWZhcmkgPD05LjAgLSA5LjFcblx0Ly8gZm9jdXMoaW4gfCBvdXQpIGV2ZW50cyBmaXJlIGFmdGVyIGZvY3VzICYgYmx1ciBldmVudHMsXG5cdC8vIHdoaWNoIGlzIHNwZWMgdmlvbGF0aW9uIC0gaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzLyNldmVudHMtZm9jdXNldmVudC1ldmVudC1vcmRlclxuXHQvLyBSZWxhdGVkIHRpY2tldCAtIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTQ0OTg1N1xuXHQvL1xuXHQvLyBTdXBwb3J0OiBJRSA5IC0gMTErXG5cdC8vIFRvIHByZXNlcnZlIHJlbGF0aXZlIGZvY3VzaW4vZm9jdXMgJiBmb2N1c291dC9ibHVyIGV2ZW50IG9yZGVyIGd1YXJhbnRlZWQgb24gdGhlIDMueCBicmFuY2gsXG5cdC8vIGF0dGFjaCBhIHNpbmdsZSBoYW5kbGVyIGZvciBib3RoIGV2ZW50cyBpbiBJRS5cblx0alF1ZXJ5LmV2ZW50LnNwZWNpYWxbIGRlbGVnYXRlVHlwZSBdID0ge1xuXHRcdHNldHVwOiBmdW5jdGlvbigpIHtcblxuXHRcdFx0Ly8gSGFuZGxlOiByZWd1bGFyIG5vZGVzICh2aWEgYHRoaXMub3duZXJEb2N1bWVudGApLCB3aW5kb3dcblx0XHRcdC8vICh2aWEgYHRoaXMuZG9jdW1lbnRgKSAmIGRvY3VtZW50ICh2aWEgYHRoaXNgKS5cblx0XHRcdHZhciBkb2MgPSB0aGlzLm93bmVyRG9jdW1lbnQgfHwgdGhpcy5kb2N1bWVudCB8fCB0aGlzLFxuXHRcdFx0XHRkYXRhSG9sZGVyID0gZG9jdW1lbnQuZG9jdW1lbnRNb2RlID8gdGhpcyA6IGRvYyxcblx0XHRcdFx0YXR0YWNoZXMgPSBkYXRhUHJpdi5nZXQoIGRhdGFIb2xkZXIsIGRlbGVnYXRlVHlwZSApO1xuXG5cdFx0XHQvLyBTdXBwb3J0OiBJRSA5IC0gMTErXG5cdFx0XHQvLyBXZSB1c2UgdGhlIHNhbWUgbmF0aXZlIGhhbmRsZXIgZm9yIGZvY3VzaW4gJiBmb2N1cyAoYW5kIGZvY3Vzb3V0ICYgYmx1cilcblx0XHRcdC8vIHNvIHdlIG5lZWQgdG8gY29vcmRpbmF0ZSBzZXR1cCAmIHRlYXJkb3duIHBhcnRzIGJldHdlZW4gdGhvc2UgZXZlbnRzLlxuXHRcdFx0Ly8gVXNlIGBkZWxlZ2F0ZVR5cGVgIGFzIHRoZSBrZXkgYXMgYHR5cGVgIGlzIGFscmVhZHkgdXNlZCBieSBgbGV2ZXJhZ2VOYXRpdmVgLlxuXHRcdFx0aWYgKCAhYXR0YWNoZXMgKSB7XG5cdFx0XHRcdGlmICggZG9jdW1lbnQuZG9jdW1lbnRNb2RlICkge1xuXHRcdFx0XHRcdHRoaXMuYWRkRXZlbnRMaXN0ZW5lciggZGVsZWdhdGVUeXBlLCBmb2N1c01hcHBlZEhhbmRsZXIgKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRkb2MuYWRkRXZlbnRMaXN0ZW5lciggdHlwZSwgZm9jdXNNYXBwZWRIYW5kbGVyLCB0cnVlICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGRhdGFQcml2LnNldCggZGF0YUhvbGRlciwgZGVsZWdhdGVUeXBlLCAoIGF0dGFjaGVzIHx8IDAgKSArIDEgKTtcblx0XHR9LFxuXHRcdHRlYXJkb3duOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBkb2MgPSB0aGlzLm93bmVyRG9jdW1lbnQgfHwgdGhpcy5kb2N1bWVudCB8fCB0aGlzLFxuXHRcdFx0XHRkYXRhSG9sZGVyID0gZG9jdW1lbnQuZG9jdW1lbnRNb2RlID8gdGhpcyA6IGRvYyxcblx0XHRcdFx0YXR0YWNoZXMgPSBkYXRhUHJpdi5nZXQoIGRhdGFIb2xkZXIsIGRlbGVnYXRlVHlwZSApIC0gMTtcblxuXHRcdFx0aWYgKCAhYXR0YWNoZXMgKSB7XG5cdFx0XHRcdGlmICggZG9jdW1lbnQuZG9jdW1lbnRNb2RlICkge1xuXHRcdFx0XHRcdHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lciggZGVsZWdhdGVUeXBlLCBmb2N1c01hcHBlZEhhbmRsZXIgKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRkb2MucmVtb3ZlRXZlbnRMaXN0ZW5lciggdHlwZSwgZm9jdXNNYXBwZWRIYW5kbGVyLCB0cnVlICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZGF0YVByaXYucmVtb3ZlKCBkYXRhSG9sZGVyLCBkZWxlZ2F0ZVR5cGUgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGRhdGFQcml2LnNldCggZGF0YUhvbGRlciwgZGVsZWdhdGVUeXBlLCBhdHRhY2hlcyApO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcbn0gKTtcblxuLy8gQ3JlYXRlIG1vdXNlZW50ZXIvbGVhdmUgZXZlbnRzIHVzaW5nIG1vdXNlb3Zlci9vdXQgYW5kIGV2ZW50LXRpbWUgY2hlY2tzXG4vLyBzbyB0aGF0IGV2ZW50IGRlbGVnYXRpb24gd29ya3MgaW4galF1ZXJ5LlxuLy8gRG8gdGhlIHNhbWUgZm9yIHBvaW50ZXJlbnRlci9wb2ludGVybGVhdmUgYW5kIHBvaW50ZXJvdmVyL3BvaW50ZXJvdXRcbi8vXG4vLyBTdXBwb3J0OiBTYWZhcmkgNyBvbmx5XG4vLyBTYWZhcmkgc2VuZHMgbW91c2VlbnRlciB0b28gb2Z0ZW47IHNlZTpcbi8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTQ3MDI1OFxuLy8gZm9yIHRoZSBkZXNjcmlwdGlvbiBvZiB0aGUgYnVnIChpdCBleGlzdGVkIGluIG9sZGVyIENocm9tZSB2ZXJzaW9ucyBhcyB3ZWxsKS5cbmpRdWVyeS5lYWNoKCB7XG5cdG1vdXNlZW50ZXI6IFwibW91c2VvdmVyXCIsXG5cdG1vdXNlbGVhdmU6IFwibW91c2VvdXRcIixcblx0cG9pbnRlcmVudGVyOiBcInBvaW50ZXJvdmVyXCIsXG5cdHBvaW50ZXJsZWF2ZTogXCJwb2ludGVyb3V0XCJcbn0sIGZ1bmN0aW9uKCBvcmlnLCBmaXggKSB7XG5cdGpRdWVyeS5ldmVudC5zcGVjaWFsWyBvcmlnIF0gPSB7XG5cdFx0ZGVsZWdhdGVUeXBlOiBmaXgsXG5cdFx0YmluZFR5cGU6IGZpeCxcblxuXHRcdGhhbmRsZTogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0dmFyIHJldCxcblx0XHRcdFx0dGFyZ2V0ID0gdGhpcyxcblx0XHRcdFx0cmVsYXRlZCA9IGV2ZW50LnJlbGF0ZWRUYXJnZXQsXG5cdFx0XHRcdGhhbmRsZU9iaiA9IGV2ZW50LmhhbmRsZU9iajtcblxuXHRcdFx0Ly8gRm9yIG1vdXNlZW50ZXIvbGVhdmUgY2FsbCB0aGUgaGFuZGxlciBpZiByZWxhdGVkIGlzIG91dHNpZGUgdGhlIHRhcmdldC5cblx0XHRcdC8vIE5COiBObyByZWxhdGVkVGFyZ2V0IGlmIHRoZSBtb3VzZSBsZWZ0L2VudGVyZWQgdGhlIGJyb3dzZXIgd2luZG93XG5cdFx0XHRpZiAoICFyZWxhdGVkIHx8ICggcmVsYXRlZCAhPT0gdGFyZ2V0ICYmICFqUXVlcnkuY29udGFpbnMoIHRhcmdldCwgcmVsYXRlZCApICkgKSB7XG5cdFx0XHRcdGV2ZW50LnR5cGUgPSBoYW5kbGVPYmoub3JpZ1R5cGU7XG5cdFx0XHRcdHJldCA9IGhhbmRsZU9iai5oYW5kbGVyLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHRcdFx0ZXZlbnQudHlwZSA9IGZpeDtcblx0XHRcdH1cblx0XHRcdHJldHVybiByZXQ7XG5cdFx0fVxuXHR9O1xufSApO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cblx0b246IGZ1bmN0aW9uKCB0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuICkge1xuXHRcdHJldHVybiBvbiggdGhpcywgdHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbiApO1xuXHR9LFxuXHRvbmU6IGZ1bmN0aW9uKCB0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuICkge1xuXHRcdHJldHVybiBvbiggdGhpcywgdHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbiwgMSApO1xuXHR9LFxuXHRvZmY6IGZ1bmN0aW9uKCB0eXBlcywgc2VsZWN0b3IsIGZuICkge1xuXHRcdHZhciBoYW5kbGVPYmosIHR5cGU7XG5cdFx0aWYgKCB0eXBlcyAmJiB0eXBlcy5wcmV2ZW50RGVmYXVsdCAmJiB0eXBlcy5oYW5kbGVPYmogKSB7XG5cblx0XHRcdC8vICggZXZlbnQgKSAgZGlzcGF0Y2hlZCBqUXVlcnkuRXZlbnRcblx0XHRcdGhhbmRsZU9iaiA9IHR5cGVzLmhhbmRsZU9iajtcblx0XHRcdGpRdWVyeSggdHlwZXMuZGVsZWdhdGVUYXJnZXQgKS5vZmYoXG5cdFx0XHRcdGhhbmRsZU9iai5uYW1lc3BhY2UgP1xuXHRcdFx0XHRcdGhhbmRsZU9iai5vcmlnVHlwZSArIFwiLlwiICsgaGFuZGxlT2JqLm5hbWVzcGFjZSA6XG5cdFx0XHRcdFx0aGFuZGxlT2JqLm9yaWdUeXBlLFxuXHRcdFx0XHRoYW5kbGVPYmouc2VsZWN0b3IsXG5cdFx0XHRcdGhhbmRsZU9iai5oYW5kbGVyXG5cdFx0XHQpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXHRcdGlmICggdHlwZW9mIHR5cGVzID09PSBcIm9iamVjdFwiICkge1xuXG5cdFx0XHQvLyAoIHR5cGVzLW9iamVjdCBbLCBzZWxlY3Rvcl0gKVxuXHRcdFx0Zm9yICggdHlwZSBpbiB0eXBlcyApIHtcblx0XHRcdFx0dGhpcy5vZmYoIHR5cGUsIHNlbGVjdG9yLCB0eXBlc1sgdHlwZSBdICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cdFx0aWYgKCBzZWxlY3RvciA9PT0gZmFsc2UgfHwgdHlwZW9mIHNlbGVjdG9yID09PSBcImZ1bmN0aW9uXCIgKSB7XG5cblx0XHRcdC8vICggdHlwZXMgWywgZm5dIClcblx0XHRcdGZuID0gc2VsZWN0b3I7XG5cdFx0XHRzZWxlY3RvciA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdFx0aWYgKCBmbiA9PT0gZmFsc2UgKSB7XG5cdFx0XHRmbiA9IHJldHVybkZhbHNlO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGpRdWVyeS5ldmVudC5yZW1vdmUoIHRoaXMsIHR5cGVzLCBmbiwgc2VsZWN0b3IgKTtcblx0XHR9ICk7XG5cdH1cbn0gKTtcblxuXG52YXJcblxuXHQvLyBTdXBwb3J0OiBJRSA8PTEwIC0gMTEsIEVkZ2UgMTIgLSAxMyBvbmx5XG5cdC8vIEluIElFL0VkZ2UgdXNpbmcgcmVnZXggZ3JvdXBzIGhlcmUgY2F1c2VzIHNldmVyZSBzbG93ZG93bnMuXG5cdC8vIFNlZSBodHRwczovL2Nvbm5lY3QubWljcm9zb2Z0LmNvbS9JRS9mZWVkYmFjay9kZXRhaWxzLzE3MzY1MTIvXG5cdHJub0lubmVyaHRtbCA9IC88c2NyaXB0fDxzdHlsZXw8bGluay9pLFxuXG5cdC8vIGNoZWNrZWQ9XCJjaGVja2VkXCIgb3IgY2hlY2tlZFxuXHRyY2hlY2tlZCA9IC9jaGVja2VkXFxzKig/OltePV18PVxccyouY2hlY2tlZC4pL2ksXG5cblx0cmNsZWFuU2NyaXB0ID0gL15cXHMqPCFcXFtDREFUQVxcW3xcXF1cXF0+XFxzKiQvZztcblxuLy8gUHJlZmVyIGEgdGJvZHkgb3ZlciBpdHMgcGFyZW50IHRhYmxlIGZvciBjb250YWluaW5nIG5ldyByb3dzXG5mdW5jdGlvbiBtYW5pcHVsYXRpb25UYXJnZXQoIGVsZW0sIGNvbnRlbnQgKSB7XG5cdGlmICggbm9kZU5hbWUoIGVsZW0sIFwidGFibGVcIiApICYmXG5cdFx0bm9kZU5hbWUoIGNvbnRlbnQubm9kZVR5cGUgIT09IDExID8gY29udGVudCA6IGNvbnRlbnQuZmlyc3RDaGlsZCwgXCJ0clwiICkgKSB7XG5cblx0XHRyZXR1cm4galF1ZXJ5KCBlbGVtICkuY2hpbGRyZW4oIFwidGJvZHlcIiApWyAwIF0gfHwgZWxlbTtcblx0fVxuXG5cdHJldHVybiBlbGVtO1xufVxuXG4vLyBSZXBsYWNlL3Jlc3RvcmUgdGhlIHR5cGUgYXR0cmlidXRlIG9mIHNjcmlwdCBlbGVtZW50cyBmb3Igc2FmZSBET00gbWFuaXB1bGF0aW9uXG5mdW5jdGlvbiBkaXNhYmxlU2NyaXB0KCBlbGVtICkge1xuXHRlbGVtLnR5cGUgPSAoIGVsZW0uZ2V0QXR0cmlidXRlKCBcInR5cGVcIiApICE9PSBudWxsICkgKyBcIi9cIiArIGVsZW0udHlwZTtcblx0cmV0dXJuIGVsZW07XG59XG5mdW5jdGlvbiByZXN0b3JlU2NyaXB0KCBlbGVtICkge1xuXHRpZiAoICggZWxlbS50eXBlIHx8IFwiXCIgKS5zbGljZSggMCwgNSApID09PSBcInRydWUvXCIgKSB7XG5cdFx0ZWxlbS50eXBlID0gZWxlbS50eXBlLnNsaWNlKCA1ICk7XG5cdH0gZWxzZSB7XG5cdFx0ZWxlbS5yZW1vdmVBdHRyaWJ1dGUoIFwidHlwZVwiICk7XG5cdH1cblxuXHRyZXR1cm4gZWxlbTtcbn1cblxuZnVuY3Rpb24gY2xvbmVDb3B5RXZlbnQoIHNyYywgZGVzdCApIHtcblx0dmFyIGksIGwsIHR5cGUsIHBkYXRhT2xkLCB1ZGF0YU9sZCwgdWRhdGFDdXIsIGV2ZW50cztcblxuXHRpZiAoIGRlc3Qubm9kZVR5cGUgIT09IDEgKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0Ly8gMS4gQ29weSBwcml2YXRlIGRhdGE6IGV2ZW50cywgaGFuZGxlcnMsIGV0Yy5cblx0aWYgKCBkYXRhUHJpdi5oYXNEYXRhKCBzcmMgKSApIHtcblx0XHRwZGF0YU9sZCA9IGRhdGFQcml2LmdldCggc3JjICk7XG5cdFx0ZXZlbnRzID0gcGRhdGFPbGQuZXZlbnRzO1xuXG5cdFx0aWYgKCBldmVudHMgKSB7XG5cdFx0XHRkYXRhUHJpdi5yZW1vdmUoIGRlc3QsIFwiaGFuZGxlIGV2ZW50c1wiICk7XG5cblx0XHRcdGZvciAoIHR5cGUgaW4gZXZlbnRzICkge1xuXHRcdFx0XHRmb3IgKCBpID0gMCwgbCA9IGV2ZW50c1sgdHlwZSBdLmxlbmd0aDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0XHRqUXVlcnkuZXZlbnQuYWRkKCBkZXN0LCB0eXBlLCBldmVudHNbIHR5cGUgXVsgaSBdICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyAyLiBDb3B5IHVzZXIgZGF0YVxuXHRpZiAoIGRhdGFVc2VyLmhhc0RhdGEoIHNyYyApICkge1xuXHRcdHVkYXRhT2xkID0gZGF0YVVzZXIuYWNjZXNzKCBzcmMgKTtcblx0XHR1ZGF0YUN1ciA9IGpRdWVyeS5leHRlbmQoIHt9LCB1ZGF0YU9sZCApO1xuXG5cdFx0ZGF0YVVzZXIuc2V0KCBkZXN0LCB1ZGF0YUN1ciApO1xuXHR9XG59XG5cbi8vIEZpeCBJRSBidWdzLCBzZWUgc3VwcG9ydCB0ZXN0c1xuZnVuY3Rpb24gZml4SW5wdXQoIHNyYywgZGVzdCApIHtcblx0dmFyIG5vZGVOYW1lID0gZGVzdC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuXG5cdC8vIEZhaWxzIHRvIHBlcnNpc3QgdGhlIGNoZWNrZWQgc3RhdGUgb2YgYSBjbG9uZWQgY2hlY2tib3ggb3IgcmFkaW8gYnV0dG9uLlxuXHRpZiAoIG5vZGVOYW1lID09PSBcImlucHV0XCIgJiYgcmNoZWNrYWJsZVR5cGUudGVzdCggc3JjLnR5cGUgKSApIHtcblx0XHRkZXN0LmNoZWNrZWQgPSBzcmMuY2hlY2tlZDtcblxuXHQvLyBGYWlscyB0byByZXR1cm4gdGhlIHNlbGVjdGVkIG9wdGlvbiB0byB0aGUgZGVmYXVsdCBzZWxlY3RlZCBzdGF0ZSB3aGVuIGNsb25pbmcgb3B0aW9uc1xuXHR9IGVsc2UgaWYgKCBub2RlTmFtZSA9PT0gXCJpbnB1dFwiIHx8IG5vZGVOYW1lID09PSBcInRleHRhcmVhXCIgKSB7XG5cdFx0ZGVzdC5kZWZhdWx0VmFsdWUgPSBzcmMuZGVmYXVsdFZhbHVlO1xuXHR9XG59XG5cbmZ1bmN0aW9uIGRvbU1hbmlwKCBjb2xsZWN0aW9uLCBhcmdzLCBjYWxsYmFjaywgaWdub3JlZCApIHtcblxuXHQvLyBGbGF0dGVuIGFueSBuZXN0ZWQgYXJyYXlzXG5cdGFyZ3MgPSBmbGF0KCBhcmdzICk7XG5cblx0dmFyIGZyYWdtZW50LCBmaXJzdCwgc2NyaXB0cywgaGFzU2NyaXB0cywgbm9kZSwgZG9jLFxuXHRcdGkgPSAwLFxuXHRcdGwgPSBjb2xsZWN0aW9uLmxlbmd0aCxcblx0XHRpTm9DbG9uZSA9IGwgLSAxLFxuXHRcdHZhbHVlID0gYXJnc1sgMCBdLFxuXHRcdHZhbHVlSXNGdW5jdGlvbiA9IGlzRnVuY3Rpb24oIHZhbHVlICk7XG5cblx0Ly8gV2UgY2FuJ3QgY2xvbmVOb2RlIGZyYWdtZW50cyB0aGF0IGNvbnRhaW4gY2hlY2tlZCwgaW4gV2ViS2l0XG5cdGlmICggdmFsdWVJc0Z1bmN0aW9uIHx8XG5cdFx0XHQoIGwgPiAxICYmIHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiAmJlxuXHRcdFx0XHQhc3VwcG9ydC5jaGVja0Nsb25lICYmIHJjaGVja2VkLnRlc3QoIHZhbHVlICkgKSApIHtcblx0XHRyZXR1cm4gY29sbGVjdGlvbi5lYWNoKCBmdW5jdGlvbiggaW5kZXggKSB7XG5cdFx0XHR2YXIgc2VsZiA9IGNvbGxlY3Rpb24uZXEoIGluZGV4ICk7XG5cdFx0XHRpZiAoIHZhbHVlSXNGdW5jdGlvbiApIHtcblx0XHRcdFx0YXJnc1sgMCBdID0gdmFsdWUuY2FsbCggdGhpcywgaW5kZXgsIHNlbGYuaHRtbCgpICk7XG5cdFx0XHR9XG5cdFx0XHRkb21NYW5pcCggc2VsZiwgYXJncywgY2FsbGJhY2ssIGlnbm9yZWQgKTtcblx0XHR9ICk7XG5cdH1cblxuXHRpZiAoIGwgKSB7XG5cdFx0ZnJhZ21lbnQgPSBidWlsZEZyYWdtZW50KCBhcmdzLCBjb2xsZWN0aW9uWyAwIF0ub3duZXJEb2N1bWVudCwgZmFsc2UsIGNvbGxlY3Rpb24sIGlnbm9yZWQgKTtcblx0XHRmaXJzdCA9IGZyYWdtZW50LmZpcnN0Q2hpbGQ7XG5cblx0XHRpZiAoIGZyYWdtZW50LmNoaWxkTm9kZXMubGVuZ3RoID09PSAxICkge1xuXHRcdFx0ZnJhZ21lbnQgPSBmaXJzdDtcblx0XHR9XG5cblx0XHQvLyBSZXF1aXJlIGVpdGhlciBuZXcgY29udGVudCBvciBhbiBpbnRlcmVzdCBpbiBpZ25vcmVkIGVsZW1lbnRzIHRvIGludm9rZSB0aGUgY2FsbGJhY2tcblx0XHRpZiAoIGZpcnN0IHx8IGlnbm9yZWQgKSB7XG5cdFx0XHRzY3JpcHRzID0galF1ZXJ5Lm1hcCggZ2V0QWxsKCBmcmFnbWVudCwgXCJzY3JpcHRcIiApLCBkaXNhYmxlU2NyaXB0ICk7XG5cdFx0XHRoYXNTY3JpcHRzID0gc2NyaXB0cy5sZW5ndGg7XG5cblx0XHRcdC8vIFVzZSB0aGUgb3JpZ2luYWwgZnJhZ21lbnQgZm9yIHRoZSBsYXN0IGl0ZW1cblx0XHRcdC8vIGluc3RlYWQgb2YgdGhlIGZpcnN0IGJlY2F1c2UgaXQgY2FuIGVuZCB1cFxuXHRcdFx0Ly8gYmVpbmcgZW1wdGllZCBpbmNvcnJlY3RseSBpbiBjZXJ0YWluIHNpdHVhdGlvbnMgKHRyYWMtODA3MCkuXG5cdFx0XHRmb3IgKCA7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdG5vZGUgPSBmcmFnbWVudDtcblxuXHRcdFx0XHRpZiAoIGkgIT09IGlOb0Nsb25lICkge1xuXHRcdFx0XHRcdG5vZGUgPSBqUXVlcnkuY2xvbmUoIG5vZGUsIHRydWUsIHRydWUgKTtcblxuXHRcdFx0XHRcdC8vIEtlZXAgcmVmZXJlbmNlcyB0byBjbG9uZWQgc2NyaXB0cyBmb3IgbGF0ZXIgcmVzdG9yYXRpb25cblx0XHRcdFx0XHRpZiAoIGhhc1NjcmlwdHMgKSB7XG5cblx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjAgb25seSwgUGhhbnRvbUpTIDEgb25seVxuXHRcdFx0XHRcdFx0Ly8gcHVzaC5hcHBseShfLCBhcnJheWxpa2UpIHRocm93cyBvbiBhbmNpZW50IFdlYktpdFxuXHRcdFx0XHRcdFx0alF1ZXJ5Lm1lcmdlKCBzY3JpcHRzLCBnZXRBbGwoIG5vZGUsIFwic2NyaXB0XCIgKSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGNhbGxiYWNrLmNhbGwoIGNvbGxlY3Rpb25bIGkgXSwgbm9kZSwgaSApO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGhhc1NjcmlwdHMgKSB7XG5cdFx0XHRcdGRvYyA9IHNjcmlwdHNbIHNjcmlwdHMubGVuZ3RoIC0gMSBdLm93bmVyRG9jdW1lbnQ7XG5cblx0XHRcdFx0Ly8gUmUtZW5hYmxlIHNjcmlwdHNcblx0XHRcdFx0alF1ZXJ5Lm1hcCggc2NyaXB0cywgcmVzdG9yZVNjcmlwdCApO1xuXG5cdFx0XHRcdC8vIEV2YWx1YXRlIGV4ZWN1dGFibGUgc2NyaXB0cyBvbiBmaXJzdCBkb2N1bWVudCBpbnNlcnRpb25cblx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPCBoYXNTY3JpcHRzOyBpKysgKSB7XG5cdFx0XHRcdFx0bm9kZSA9IHNjcmlwdHNbIGkgXTtcblx0XHRcdFx0XHRpZiAoIHJzY3JpcHRUeXBlLnRlc3QoIG5vZGUudHlwZSB8fCBcIlwiICkgJiZcblx0XHRcdFx0XHRcdCFkYXRhUHJpdi5hY2Nlc3MoIG5vZGUsIFwiZ2xvYmFsRXZhbFwiICkgJiZcblx0XHRcdFx0XHRcdGpRdWVyeS5jb250YWlucyggZG9jLCBub2RlICkgKSB7XG5cblx0XHRcdFx0XHRcdGlmICggbm9kZS5zcmMgJiYgKCBub2RlLnR5cGUgfHwgXCJcIiApLnRvTG93ZXJDYXNlKCkgICE9PSBcIm1vZHVsZVwiICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIE9wdGlvbmFsIEFKQVggZGVwZW5kZW5jeSwgYnV0IHdvbid0IHJ1biBzY3JpcHRzIGlmIG5vdCBwcmVzZW50XG5cdFx0XHRcdFx0XHRcdGlmICggalF1ZXJ5Ll9ldmFsVXJsICYmICFub2RlLm5vTW9kdWxlICkge1xuXHRcdFx0XHRcdFx0XHRcdGpRdWVyeS5fZXZhbFVybCggbm9kZS5zcmMsIHtcblx0XHRcdFx0XHRcdFx0XHRcdG5vbmNlOiBub2RlLm5vbmNlIHx8IG5vZGUuZ2V0QXR0cmlidXRlKCBcIm5vbmNlXCIgKVxuXHRcdFx0XHRcdFx0XHRcdH0sIGRvYyApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdC8vIFVud3JhcCBhIENEQVRBIHNlY3Rpb24gY29udGFpbmluZyBzY3JpcHQgY29udGVudHMuIFRoaXMgc2hvdWxkbid0IGJlXG5cdFx0XHRcdFx0XHRcdC8vIG5lZWRlZCBhcyBpbiBYTUwgZG9jdW1lbnRzIHRoZXkncmUgYWxyZWFkeSBub3QgdmlzaWJsZSB3aGVuXG5cdFx0XHRcdFx0XHRcdC8vIGluc3BlY3RpbmcgZWxlbWVudCBjb250ZW50cyBhbmQgaW4gSFRNTCBkb2N1bWVudHMgdGhleSBoYXZlIG5vXG5cdFx0XHRcdFx0XHRcdC8vIG1lYW5pbmcgYnV0IHdlJ3JlIHByZXNlcnZpbmcgdGhhdCBsb2dpYyBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuXG5cdFx0XHRcdFx0XHRcdC8vIFRoaXMgd2lsbCBiZSByZW1vdmVkIGNvbXBsZXRlbHkgaW4gNC4wLiBTZWUgZ2gtNDkwNC5cblx0XHRcdFx0XHRcdFx0RE9NRXZhbCggbm9kZS50ZXh0Q29udGVudC5yZXBsYWNlKCByY2xlYW5TY3JpcHQsIFwiXCIgKSwgbm9kZSwgZG9jICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGNvbGxlY3Rpb247XG59XG5cbmZ1bmN0aW9uIHJlbW92ZSggZWxlbSwgc2VsZWN0b3IsIGtlZXBEYXRhICkge1xuXHR2YXIgbm9kZSxcblx0XHRub2RlcyA9IHNlbGVjdG9yID8galF1ZXJ5LmZpbHRlciggc2VsZWN0b3IsIGVsZW0gKSA6IGVsZW0sXG5cdFx0aSA9IDA7XG5cblx0Zm9yICggOyAoIG5vZGUgPSBub2Rlc1sgaSBdICkgIT0gbnVsbDsgaSsrICkge1xuXHRcdGlmICggIWtlZXBEYXRhICYmIG5vZGUubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0XHRqUXVlcnkuY2xlYW5EYXRhKCBnZXRBbGwoIG5vZGUgKSApO1xuXHRcdH1cblxuXHRcdGlmICggbm9kZS5wYXJlbnROb2RlICkge1xuXHRcdFx0aWYgKCBrZWVwRGF0YSAmJiBpc0F0dGFjaGVkKCBub2RlICkgKSB7XG5cdFx0XHRcdHNldEdsb2JhbEV2YWwoIGdldEFsbCggbm9kZSwgXCJzY3JpcHRcIiApICk7XG5cdFx0XHR9XG5cdFx0XHRub2RlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoIG5vZGUgKTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gZWxlbTtcbn1cblxualF1ZXJ5LmV4dGVuZCgge1xuXHRodG1sUHJlZmlsdGVyOiBmdW5jdGlvbiggaHRtbCApIHtcblx0XHRyZXR1cm4gaHRtbDtcblx0fSxcblxuXHRjbG9uZTogZnVuY3Rpb24oIGVsZW0sIGRhdGFBbmRFdmVudHMsIGRlZXBEYXRhQW5kRXZlbnRzICkge1xuXHRcdHZhciBpLCBsLCBzcmNFbGVtZW50cywgZGVzdEVsZW1lbnRzLFxuXHRcdFx0Y2xvbmUgPSBlbGVtLmNsb25lTm9kZSggdHJ1ZSApLFxuXHRcdFx0aW5QYWdlID0gaXNBdHRhY2hlZCggZWxlbSApO1xuXG5cdFx0Ly8gRml4IElFIGNsb25pbmcgaXNzdWVzXG5cdFx0aWYgKCAhc3VwcG9ydC5ub0Nsb25lQ2hlY2tlZCAmJiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgfHwgZWxlbS5ub2RlVHlwZSA9PT0gMTEgKSAmJlxuXHRcdFx0XHQhalF1ZXJ5LmlzWE1MRG9jKCBlbGVtICkgKSB7XG5cblx0XHRcdC8vIFdlIGVzY2hldyBqUXVlcnkjZmluZCBoZXJlIGZvciBwZXJmb3JtYW5jZSByZWFzb25zOlxuXHRcdFx0Ly8gaHR0cHM6Ly9qc3BlcmYuY29tL2dldGFsbC12cy1zaXp6bGUvMlxuXHRcdFx0ZGVzdEVsZW1lbnRzID0gZ2V0QWxsKCBjbG9uZSApO1xuXHRcdFx0c3JjRWxlbWVudHMgPSBnZXRBbGwoIGVsZW0gKTtcblxuXHRcdFx0Zm9yICggaSA9IDAsIGwgPSBzcmNFbGVtZW50cy5sZW5ndGg7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdGZpeElucHV0KCBzcmNFbGVtZW50c1sgaSBdLCBkZXN0RWxlbWVudHNbIGkgXSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIENvcHkgdGhlIGV2ZW50cyBmcm9tIHRoZSBvcmlnaW5hbCB0byB0aGUgY2xvbmVcblx0XHRpZiAoIGRhdGFBbmRFdmVudHMgKSB7XG5cdFx0XHRpZiAoIGRlZXBEYXRhQW5kRXZlbnRzICkge1xuXHRcdFx0XHRzcmNFbGVtZW50cyA9IHNyY0VsZW1lbnRzIHx8IGdldEFsbCggZWxlbSApO1xuXHRcdFx0XHRkZXN0RWxlbWVudHMgPSBkZXN0RWxlbWVudHMgfHwgZ2V0QWxsKCBjbG9uZSApO1xuXG5cdFx0XHRcdGZvciAoIGkgPSAwLCBsID0gc3JjRWxlbWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0XHRcdGNsb25lQ29weUV2ZW50KCBzcmNFbGVtZW50c1sgaSBdLCBkZXN0RWxlbWVudHNbIGkgXSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjbG9uZUNvcHlFdmVudCggZWxlbSwgY2xvbmUgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBQcmVzZXJ2ZSBzY3JpcHQgZXZhbHVhdGlvbiBoaXN0b3J5XG5cdFx0ZGVzdEVsZW1lbnRzID0gZ2V0QWxsKCBjbG9uZSwgXCJzY3JpcHRcIiApO1xuXHRcdGlmICggZGVzdEVsZW1lbnRzLmxlbmd0aCA+IDAgKSB7XG5cdFx0XHRzZXRHbG9iYWxFdmFsKCBkZXN0RWxlbWVudHMsICFpblBhZ2UgJiYgZ2V0QWxsKCBlbGVtLCBcInNjcmlwdFwiICkgKTtcblx0XHR9XG5cblx0XHQvLyBSZXR1cm4gdGhlIGNsb25lZCBzZXRcblx0XHRyZXR1cm4gY2xvbmU7XG5cdH0sXG5cblx0Y2xlYW5EYXRhOiBmdW5jdGlvbiggZWxlbXMgKSB7XG5cdFx0dmFyIGRhdGEsIGVsZW0sIHR5cGUsXG5cdFx0XHRzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWwsXG5cdFx0XHRpID0gMDtcblxuXHRcdGZvciAoIDsgKCBlbGVtID0gZWxlbXNbIGkgXSApICE9PSB1bmRlZmluZWQ7IGkrKyApIHtcblx0XHRcdGlmICggYWNjZXB0RGF0YSggZWxlbSApICkge1xuXHRcdFx0XHRpZiAoICggZGF0YSA9IGVsZW1bIGRhdGFQcml2LmV4cGFuZG8gXSApICkge1xuXHRcdFx0XHRcdGlmICggZGF0YS5ldmVudHMgKSB7XG5cdFx0XHRcdFx0XHRmb3IgKCB0eXBlIGluIGRhdGEuZXZlbnRzICkge1xuXHRcdFx0XHRcdFx0XHRpZiAoIHNwZWNpYWxbIHR5cGUgXSApIHtcblx0XHRcdFx0XHRcdFx0XHRqUXVlcnkuZXZlbnQucmVtb3ZlKCBlbGVtLCB0eXBlICk7XG5cblx0XHRcdFx0XHRcdFx0Ly8gVGhpcyBpcyBhIHNob3J0Y3V0IHRvIGF2b2lkIGpRdWVyeS5ldmVudC5yZW1vdmUncyBvdmVyaGVhZFxuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdGpRdWVyeS5yZW1vdmVFdmVudCggZWxlbSwgdHlwZSwgZGF0YS5oYW5kbGUgKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIFN1cHBvcnQ6IENocm9tZSA8PTM1IC0gNDUrXG5cdFx0XHRcdFx0Ly8gQXNzaWduIHVuZGVmaW5lZCBpbnN0ZWFkIG9mIHVzaW5nIGRlbGV0ZSwgc2VlIERhdGEjcmVtb3ZlXG5cdFx0XHRcdFx0ZWxlbVsgZGF0YVByaXYuZXhwYW5kbyBdID0gdW5kZWZpbmVkO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggZWxlbVsgZGF0YVVzZXIuZXhwYW5kbyBdICkge1xuXG5cdFx0XHRcdFx0Ly8gU3VwcG9ydDogQ2hyb21lIDw9MzUgLSA0NStcblx0XHRcdFx0XHQvLyBBc3NpZ24gdW5kZWZpbmVkIGluc3RlYWQgb2YgdXNpbmcgZGVsZXRlLCBzZWUgRGF0YSNyZW1vdmVcblx0XHRcdFx0XHRlbGVtWyBkYXRhVXNlci5leHBhbmRvIF0gPSB1bmRlZmluZWQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cbn0gKTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRkZXRhY2g6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRyZXR1cm4gcmVtb3ZlKCB0aGlzLCBzZWxlY3RvciwgdHJ1ZSApO1xuXHR9LFxuXG5cdHJlbW92ZTogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHJldHVybiByZW1vdmUoIHRoaXMsIHNlbGVjdG9yICk7XG5cdH0sXG5cblx0dGV4dDogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkID9cblx0XHRcdFx0alF1ZXJ5LnRleHQoIHRoaXMgKSA6XG5cdFx0XHRcdHRoaXMuZW1wdHkoKS5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRpZiAoIHRoaXMubm9kZVR5cGUgPT09IDEgfHwgdGhpcy5ub2RlVHlwZSA9PT0gMTEgfHwgdGhpcy5ub2RlVHlwZSA9PT0gOSApIHtcblx0XHRcdFx0XHRcdHRoaXMudGV4dENvbnRlbnQgPSB2YWx1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gKTtcblx0XHR9LCBudWxsLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCApO1xuXHR9LFxuXG5cdGFwcGVuZDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGRvbU1hbmlwKCB0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0aWYgKCB0aGlzLm5vZGVUeXBlID09PSAxIHx8IHRoaXMubm9kZVR5cGUgPT09IDExIHx8IHRoaXMubm9kZVR5cGUgPT09IDkgKSB7XG5cdFx0XHRcdHZhciB0YXJnZXQgPSBtYW5pcHVsYXRpb25UYXJnZXQoIHRoaXMsIGVsZW0gKTtcblx0XHRcdFx0dGFyZ2V0LmFwcGVuZENoaWxkKCBlbGVtICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXG5cdHByZXBlbmQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBkb21NYW5pcCggdGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdGlmICggdGhpcy5ub2RlVHlwZSA9PT0gMSB8fCB0aGlzLm5vZGVUeXBlID09PSAxMSB8fCB0aGlzLm5vZGVUeXBlID09PSA5ICkge1xuXHRcdFx0XHR2YXIgdGFyZ2V0ID0gbWFuaXB1bGF0aW9uVGFyZ2V0KCB0aGlzLCBlbGVtICk7XG5cdFx0XHRcdHRhcmdldC5pbnNlcnRCZWZvcmUoIGVsZW0sIHRhcmdldC5maXJzdENoaWxkICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXG5cdGJlZm9yZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGRvbU1hbmlwKCB0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0aWYgKCB0aGlzLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdHRoaXMucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoIGVsZW0sIHRoaXMgKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cblx0YWZ0ZXI6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBkb21NYW5pcCggdGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdGlmICggdGhpcy5wYXJlbnROb2RlICkge1xuXHRcdFx0XHR0aGlzLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKCBlbGVtLCB0aGlzLm5leHRTaWJsaW5nICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXG5cdGVtcHR5OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgZWxlbSxcblx0XHRcdGkgPSAwO1xuXG5cdFx0Zm9yICggOyAoIGVsZW0gPSB0aGlzWyBpIF0gKSAhPSBudWxsOyBpKysgKSB7XG5cdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cblx0XHRcdFx0Ly8gUHJldmVudCBtZW1vcnkgbGVha3Ncblx0XHRcdFx0alF1ZXJ5LmNsZWFuRGF0YSggZ2V0QWxsKCBlbGVtLCBmYWxzZSApICk7XG5cblx0XHRcdFx0Ly8gUmVtb3ZlIGFueSByZW1haW5pbmcgbm9kZXNcblx0XHRcdFx0ZWxlbS50ZXh0Q29udGVudCA9IFwiXCI7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Y2xvbmU6IGZ1bmN0aW9uKCBkYXRhQW5kRXZlbnRzLCBkZWVwRGF0YUFuZEV2ZW50cyApIHtcblx0XHRkYXRhQW5kRXZlbnRzID0gZGF0YUFuZEV2ZW50cyA9PSBudWxsID8gZmFsc2UgOiBkYXRhQW5kRXZlbnRzO1xuXHRcdGRlZXBEYXRhQW5kRXZlbnRzID0gZGVlcERhdGFBbmRFdmVudHMgPT0gbnVsbCA/IGRhdGFBbmRFdmVudHMgOiBkZWVwRGF0YUFuZEV2ZW50cztcblxuXHRcdHJldHVybiB0aGlzLm1hcCggZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4galF1ZXJ5LmNsb25lKCB0aGlzLCBkYXRhQW5kRXZlbnRzLCBkZWVwRGF0YUFuZEV2ZW50cyApO1xuXHRcdH0gKTtcblx0fSxcblxuXHRodG1sOiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0dmFyIGVsZW0gPSB0aGlzWyAwIF0gfHwge30sXG5cdFx0XHRcdGkgPSAwLFxuXHRcdFx0XHRsID0gdGhpcy5sZW5ndGg7XG5cblx0XHRcdGlmICggdmFsdWUgPT09IHVuZGVmaW5lZCAmJiBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXHRcdFx0XHRyZXR1cm4gZWxlbS5pbm5lckhUTUw7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFNlZSBpZiB3ZSBjYW4gdGFrZSBhIHNob3J0Y3V0IGFuZCBqdXN0IHVzZSBpbm5lckhUTUxcblx0XHRcdGlmICggdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiICYmICFybm9Jbm5lcmh0bWwudGVzdCggdmFsdWUgKSAmJlxuXHRcdFx0XHQhd3JhcE1hcFsgKCBydGFnTmFtZS5leGVjKCB2YWx1ZSApIHx8IFsgXCJcIiwgXCJcIiBdIClbIDEgXS50b0xvd2VyQ2FzZSgpIF0gKSB7XG5cblx0XHRcdFx0dmFsdWUgPSBqUXVlcnkuaHRtbFByZWZpbHRlciggdmFsdWUgKTtcblxuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdGZvciAoIDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0XHRcdGVsZW0gPSB0aGlzWyBpIF0gfHwge307XG5cblx0XHRcdFx0XHRcdC8vIFJlbW92ZSBlbGVtZW50IG5vZGVzIGFuZCBwcmV2ZW50IG1lbW9yeSBsZWFrc1xuXHRcdFx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXHRcdFx0XHRcdFx0XHRqUXVlcnkuY2xlYW5EYXRhKCBnZXRBbGwoIGVsZW0sIGZhbHNlICkgKTtcblx0XHRcdFx0XHRcdFx0ZWxlbS5pbm5lckhUTUwgPSB2YWx1ZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRlbGVtID0gMDtcblxuXHRcdFx0XHQvLyBJZiB1c2luZyBpbm5lckhUTUwgdGhyb3dzIGFuIGV4Y2VwdGlvbiwgdXNlIHRoZSBmYWxsYmFjayBtZXRob2Rcblx0XHRcdFx0fSBjYXRjaCAoIGUgKSB7fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGVsZW0gKSB7XG5cdFx0XHRcdHRoaXMuZW1wdHkoKS5hcHBlbmQoIHZhbHVlICk7XG5cdFx0XHR9XG5cdFx0fSwgbnVsbCwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggKTtcblx0fSxcblxuXHRyZXBsYWNlV2l0aDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGlnbm9yZWQgPSBbXTtcblxuXHRcdC8vIE1ha2UgdGhlIGNoYW5nZXMsIHJlcGxhY2luZyBlYWNoIG5vbi1pZ25vcmVkIGNvbnRleHQgZWxlbWVudCB3aXRoIHRoZSBuZXcgY29udGVudFxuXHRcdHJldHVybiBkb21NYW5pcCggdGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHZhciBwYXJlbnQgPSB0aGlzLnBhcmVudE5vZGU7XG5cblx0XHRcdGlmICggalF1ZXJ5LmluQXJyYXkoIHRoaXMsIGlnbm9yZWQgKSA8IDAgKSB7XG5cdFx0XHRcdGpRdWVyeS5jbGVhbkRhdGEoIGdldEFsbCggdGhpcyApICk7XG5cdFx0XHRcdGlmICggcGFyZW50ICkge1xuXHRcdFx0XHRcdHBhcmVudC5yZXBsYWNlQ2hpbGQoIGVsZW0sIHRoaXMgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0Ly8gRm9yY2UgY2FsbGJhY2sgaW52b2NhdGlvblxuXHRcdH0sIGlnbm9yZWQgKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZWFjaCgge1xuXHRhcHBlbmRUbzogXCJhcHBlbmRcIixcblx0cHJlcGVuZFRvOiBcInByZXBlbmRcIixcblx0aW5zZXJ0QmVmb3JlOiBcImJlZm9yZVwiLFxuXHRpbnNlcnRBZnRlcjogXCJhZnRlclwiLFxuXHRyZXBsYWNlQWxsOiBcInJlcGxhY2VXaXRoXCJcbn0sIGZ1bmN0aW9uKCBuYW1lLCBvcmlnaW5hbCApIHtcblx0alF1ZXJ5LmZuWyBuYW1lIF0gPSBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0dmFyIGVsZW1zLFxuXHRcdFx0cmV0ID0gW10sXG5cdFx0XHRpbnNlcnQgPSBqUXVlcnkoIHNlbGVjdG9yICksXG5cdFx0XHRsYXN0ID0gaW5zZXJ0Lmxlbmd0aCAtIDEsXG5cdFx0XHRpID0gMDtcblxuXHRcdGZvciAoIDsgaSA8PSBsYXN0OyBpKysgKSB7XG5cdFx0XHRlbGVtcyA9IGkgPT09IGxhc3QgPyB0aGlzIDogdGhpcy5jbG9uZSggdHJ1ZSApO1xuXHRcdFx0alF1ZXJ5KCBpbnNlcnRbIGkgXSApWyBvcmlnaW5hbCBdKCBlbGVtcyApO1xuXG5cdFx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4wIG9ubHksIFBoYW50b21KUyAxIG9ubHlcblx0XHRcdC8vIC5nZXQoKSBiZWNhdXNlIHB1c2guYXBwbHkoXywgYXJyYXlsaWtlKSB0aHJvd3Mgb24gYW5jaWVudCBXZWJLaXRcblx0XHRcdHB1c2guYXBwbHkoIHJldCwgZWxlbXMuZ2V0KCkgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIHJldCApO1xuXHR9O1xufSApO1xudmFyIHJudW1ub25weCA9IG5ldyBSZWdFeHAoIFwiXihcIiArIHBudW0gKyBcIikoPyFweClbYS16JV0rJFwiLCBcImlcIiApO1xuXG52YXIgcmN1c3RvbVByb3AgPSAvXi0tLztcblxuXG52YXIgZ2V0U3R5bGVzID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cblx0XHQvLyBTdXBwb3J0OiBJRSA8PTExIG9ubHksIEZpcmVmb3ggPD0zMCAodHJhYy0xNTA5OCwgdHJhYy0xNDE1MClcblx0XHQvLyBJRSB0aHJvd3Mgb24gZWxlbWVudHMgY3JlYXRlZCBpbiBwb3B1cHNcblx0XHQvLyBGRiBtZWFud2hpbGUgdGhyb3dzIG9uIGZyYW1lIGVsZW1lbnRzIHRocm91Z2ggXCJkZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlXCJcblx0XHR2YXIgdmlldyA9IGVsZW0ub3duZXJEb2N1bWVudC5kZWZhdWx0VmlldztcblxuXHRcdGlmICggIXZpZXcgfHwgIXZpZXcub3BlbmVyICkge1xuXHRcdFx0dmlldyA9IHdpbmRvdztcblx0XHR9XG5cblx0XHRyZXR1cm4gdmlldy5nZXRDb21wdXRlZFN0eWxlKCBlbGVtICk7XG5cdH07XG5cbnZhciBzd2FwID0gZnVuY3Rpb24oIGVsZW0sIG9wdGlvbnMsIGNhbGxiYWNrICkge1xuXHR2YXIgcmV0LCBuYW1lLFxuXHRcdG9sZCA9IHt9O1xuXG5cdC8vIFJlbWVtYmVyIHRoZSBvbGQgdmFsdWVzLCBhbmQgaW5zZXJ0IHRoZSBuZXcgb25lc1xuXHRmb3IgKCBuYW1lIGluIG9wdGlvbnMgKSB7XG5cdFx0b2xkWyBuYW1lIF0gPSBlbGVtLnN0eWxlWyBuYW1lIF07XG5cdFx0ZWxlbS5zdHlsZVsgbmFtZSBdID0gb3B0aW9uc1sgbmFtZSBdO1xuXHR9XG5cblx0cmV0ID0gY2FsbGJhY2suY2FsbCggZWxlbSApO1xuXG5cdC8vIFJldmVydCB0aGUgb2xkIHZhbHVlc1xuXHRmb3IgKCBuYW1lIGluIG9wdGlvbnMgKSB7XG5cdFx0ZWxlbS5zdHlsZVsgbmFtZSBdID0gb2xkWyBuYW1lIF07XG5cdH1cblxuXHRyZXR1cm4gcmV0O1xufTtcblxuXG52YXIgcmJveFN0eWxlID0gbmV3IFJlZ0V4cCggY3NzRXhwYW5kLmpvaW4oIFwifFwiICksIFwiaVwiICk7XG5cblxuXG4oIGZ1bmN0aW9uKCkge1xuXG5cdC8vIEV4ZWN1dGluZyBib3RoIHBpeGVsUG9zaXRpb24gJiBib3hTaXppbmdSZWxpYWJsZSB0ZXN0cyByZXF1aXJlIG9ubHkgb25lIGxheW91dFxuXHQvLyBzbyB0aGV5J3JlIGV4ZWN1dGVkIGF0IHRoZSBzYW1lIHRpbWUgdG8gc2F2ZSB0aGUgc2Vjb25kIGNvbXB1dGF0aW9uLlxuXHRmdW5jdGlvbiBjb21wdXRlU3R5bGVUZXN0cygpIHtcblxuXHRcdC8vIFRoaXMgaXMgYSBzaW5nbGV0b24sIHdlIG5lZWQgdG8gZXhlY3V0ZSBpdCBvbmx5IG9uY2Vcblx0XHRpZiAoICFkaXYgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Y29udGFpbmVyLnN0eWxlLmNzc1RleHQgPSBcInBvc2l0aW9uOmFic29sdXRlO2xlZnQ6LTExMTExcHg7d2lkdGg6NjBweDtcIiArXG5cdFx0XHRcIm1hcmdpbi10b3A6MXB4O3BhZGRpbmc6MDtib3JkZXI6MFwiO1xuXHRcdGRpdi5zdHlsZS5jc3NUZXh0ID1cblx0XHRcdFwicG9zaXRpb246cmVsYXRpdmU7ZGlzcGxheTpibG9jaztib3gtc2l6aW5nOmJvcmRlci1ib3g7b3ZlcmZsb3c6c2Nyb2xsO1wiICtcblx0XHRcdFwibWFyZ2luOmF1dG87Ym9yZGVyOjFweDtwYWRkaW5nOjFweDtcIiArXG5cdFx0XHRcIndpZHRoOjYwJTt0b3A6MSVcIjtcblx0XHRkb2N1bWVudEVsZW1lbnQuYXBwZW5kQ2hpbGQoIGNvbnRhaW5lciApLmFwcGVuZENoaWxkKCBkaXYgKTtcblxuXHRcdHZhciBkaXZTdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKCBkaXYgKTtcblx0XHRwaXhlbFBvc2l0aW9uVmFsID0gZGl2U3R5bGUudG9wICE9PSBcIjElXCI7XG5cblx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDQuMCAtIDQuMyBvbmx5LCBGaXJlZm94IDw9MyAtIDQ0XG5cdFx0cmVsaWFibGVNYXJnaW5MZWZ0VmFsID0gcm91bmRQaXhlbE1lYXN1cmVzKCBkaXZTdHlsZS5tYXJnaW5MZWZ0ICkgPT09IDEyO1xuXG5cdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA0LjAgLSA0LjMgb25seSwgU2FmYXJpIDw9OS4xIC0gMTAuMSwgaU9TIDw9Ny4wIC0gOS4zXG5cdFx0Ly8gU29tZSBzdHlsZXMgY29tZSBiYWNrIHdpdGggcGVyY2VudGFnZSB2YWx1ZXMsIGV2ZW4gdGhvdWdoIHRoZXkgc2hvdWxkbid0XG5cdFx0ZGl2LnN0eWxlLnJpZ2h0ID0gXCI2MCVcIjtcblx0XHRwaXhlbEJveFN0eWxlc1ZhbCA9IHJvdW5kUGl4ZWxNZWFzdXJlcyggZGl2U3R5bGUucmlnaHQgKSA9PT0gMzY7XG5cblx0XHQvLyBTdXBwb3J0OiBJRSA5IC0gMTEgb25seVxuXHRcdC8vIERldGVjdCBtaXNyZXBvcnRpbmcgb2YgY29udGVudCBkaW1lbnNpb25zIGZvciBib3gtc2l6aW5nOmJvcmRlci1ib3ggZWxlbWVudHNcblx0XHRib3hTaXppbmdSZWxpYWJsZVZhbCA9IHJvdW5kUGl4ZWxNZWFzdXJlcyggZGl2U3R5bGUud2lkdGggKSA9PT0gMzY7XG5cblx0XHQvLyBTdXBwb3J0OiBJRSA5IG9ubHlcblx0XHQvLyBEZXRlY3Qgb3ZlcmZsb3c6c2Nyb2xsIHNjcmV3aW5lc3MgKGdoLTM2OTkpXG5cdFx0Ly8gU3VwcG9ydDogQ2hyb21lIDw9NjRcblx0XHQvLyBEb24ndCBnZXQgdHJpY2tlZCB3aGVuIHpvb20gYWZmZWN0cyBvZmZzZXRXaWR0aCAoZ2gtNDAyOSlcblx0XHRkaXYuc3R5bGUucG9zaXRpb24gPSBcImFic29sdXRlXCI7XG5cdFx0c2Nyb2xsYm94U2l6ZVZhbCA9IHJvdW5kUGl4ZWxNZWFzdXJlcyggZGl2Lm9mZnNldFdpZHRoIC8gMyApID09PSAxMjtcblxuXHRcdGRvY3VtZW50RWxlbWVudC5yZW1vdmVDaGlsZCggY29udGFpbmVyICk7XG5cblx0XHQvLyBOdWxsaWZ5IHRoZSBkaXYgc28gaXQgd291bGRuJ3QgYmUgc3RvcmVkIGluIHRoZSBtZW1vcnkgYW5kXG5cdFx0Ly8gaXQgd2lsbCBhbHNvIGJlIGEgc2lnbiB0aGF0IGNoZWNrcyBhbHJlYWR5IHBlcmZvcm1lZFxuXHRcdGRpdiA9IG51bGw7XG5cdH1cblxuXHRmdW5jdGlvbiByb3VuZFBpeGVsTWVhc3VyZXMoIG1lYXN1cmUgKSB7XG5cdFx0cmV0dXJuIE1hdGgucm91bmQoIHBhcnNlRmxvYXQoIG1lYXN1cmUgKSApO1xuXHR9XG5cblx0dmFyIHBpeGVsUG9zaXRpb25WYWwsIGJveFNpemluZ1JlbGlhYmxlVmFsLCBzY3JvbGxib3hTaXplVmFsLCBwaXhlbEJveFN0eWxlc1ZhbCxcblx0XHRyZWxpYWJsZVRyRGltZW5zaW9uc1ZhbCwgcmVsaWFibGVNYXJnaW5MZWZ0VmFsLFxuXHRcdGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiZGl2XCIgKSxcblx0XHRkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImRpdlwiICk7XG5cblx0Ly8gRmluaXNoIGVhcmx5IGluIGxpbWl0ZWQgKG5vbi1icm93c2VyKSBlbnZpcm9ubWVudHNcblx0aWYgKCAhZGl2LnN0eWxlICkge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdC8vIFN1cHBvcnQ6IElFIDw9OSAtIDExIG9ubHlcblx0Ly8gU3R5bGUgb2YgY2xvbmVkIGVsZW1lbnQgYWZmZWN0cyBzb3VyY2UgZWxlbWVudCBjbG9uZWQgKHRyYWMtODkwOClcblx0ZGl2LnN0eWxlLmJhY2tncm91bmRDbGlwID0gXCJjb250ZW50LWJveFwiO1xuXHRkaXYuY2xvbmVOb2RlKCB0cnVlICkuc3R5bGUuYmFja2dyb3VuZENsaXAgPSBcIlwiO1xuXHRzdXBwb3J0LmNsZWFyQ2xvbmVTdHlsZSA9IGRpdi5zdHlsZS5iYWNrZ3JvdW5kQ2xpcCA9PT0gXCJjb250ZW50LWJveFwiO1xuXG5cdGpRdWVyeS5leHRlbmQoIHN1cHBvcnQsIHtcblx0XHRib3hTaXppbmdSZWxpYWJsZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRjb21wdXRlU3R5bGVUZXN0cygpO1xuXHRcdFx0cmV0dXJuIGJveFNpemluZ1JlbGlhYmxlVmFsO1xuXHRcdH0sXG5cdFx0cGl4ZWxCb3hTdHlsZXM6IGZ1bmN0aW9uKCkge1xuXHRcdFx0Y29tcHV0ZVN0eWxlVGVzdHMoKTtcblx0XHRcdHJldHVybiBwaXhlbEJveFN0eWxlc1ZhbDtcblx0XHR9LFxuXHRcdHBpeGVsUG9zaXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdFx0Y29tcHV0ZVN0eWxlVGVzdHMoKTtcblx0XHRcdHJldHVybiBwaXhlbFBvc2l0aW9uVmFsO1xuXHRcdH0sXG5cdFx0cmVsaWFibGVNYXJnaW5MZWZ0OiBmdW5jdGlvbigpIHtcblx0XHRcdGNvbXB1dGVTdHlsZVRlc3RzKCk7XG5cdFx0XHRyZXR1cm4gcmVsaWFibGVNYXJnaW5MZWZ0VmFsO1xuXHRcdH0sXG5cdFx0c2Nyb2xsYm94U2l6ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRjb21wdXRlU3R5bGVUZXN0cygpO1xuXHRcdFx0cmV0dXJuIHNjcm9sbGJveFNpemVWYWw7XG5cdFx0fSxcblxuXHRcdC8vIFN1cHBvcnQ6IElFIDkgLSAxMSssIEVkZ2UgMTUgLSAxOCtcblx0XHQvLyBJRS9FZGdlIG1pc3JlcG9ydCBgZ2V0Q29tcHV0ZWRTdHlsZWAgb2YgdGFibGUgcm93cyB3aXRoIHdpZHRoL2hlaWdodFxuXHRcdC8vIHNldCBpbiBDU1Mgd2hpbGUgYG9mZnNldCpgIHByb3BlcnRpZXMgcmVwb3J0IGNvcnJlY3QgdmFsdWVzLlxuXHRcdC8vIEJlaGF2aW9yIGluIElFIDkgaXMgbW9yZSBzdWJ0bGUgdGhhbiBpbiBuZXdlciB2ZXJzaW9ucyAmIGl0IHBhc3Nlc1xuXHRcdC8vIHNvbWUgdmVyc2lvbnMgb2YgdGhpcyB0ZXN0OyBtYWtlIHN1cmUgbm90IHRvIG1ha2UgaXQgcGFzcyB0aGVyZSFcblx0XHQvL1xuXHRcdC8vIFN1cHBvcnQ6IEZpcmVmb3ggNzArXG5cdFx0Ly8gT25seSBGaXJlZm94IGluY2x1ZGVzIGJvcmRlciB3aWR0aHNcblx0XHQvLyBpbiBjb21wdXRlZCBkaW1lbnNpb25zLiAoZ2gtNDUyOSlcblx0XHRyZWxpYWJsZVRyRGltZW5zaW9uczogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgdGFibGUsIHRyLCB0ckNoaWxkLCB0clN0eWxlO1xuXHRcdFx0aWYgKCByZWxpYWJsZVRyRGltZW5zaW9uc1ZhbCA9PSBudWxsICkge1xuXHRcdFx0XHR0YWJsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwidGFibGVcIiApO1xuXHRcdFx0XHR0ciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwidHJcIiApO1xuXHRcdFx0XHR0ckNoaWxkID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJkaXZcIiApO1xuXG5cdFx0XHRcdHRhYmxlLnN0eWxlLmNzc1RleHQgPSBcInBvc2l0aW9uOmFic29sdXRlO2xlZnQ6LTExMTExcHg7Ym9yZGVyLWNvbGxhcHNlOnNlcGFyYXRlXCI7XG5cdFx0XHRcdHRyLnN0eWxlLmNzc1RleHQgPSBcImJveC1zaXppbmc6Y29udGVudC1ib3g7Ym9yZGVyOjFweCBzb2xpZFwiO1xuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IENocm9tZSA4Nitcblx0XHRcdFx0Ly8gSGVpZ2h0IHNldCB0aHJvdWdoIGNzc1RleHQgZG9lcyBub3QgZ2V0IGFwcGxpZWQuXG5cdFx0XHRcdC8vIENvbXB1dGVkIGhlaWdodCB0aGVuIGNvbWVzIGJhY2sgYXMgMC5cblx0XHRcdFx0dHIuc3R5bGUuaGVpZ2h0ID0gXCIxcHhcIjtcblx0XHRcdFx0dHJDaGlsZC5zdHlsZS5oZWlnaHQgPSBcIjlweFwiO1xuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgOCBDaHJvbWUgODYrXG5cdFx0XHRcdC8vIEluIG91ciBib2R5QmFja2dyb3VuZC5odG1sIGlmcmFtZSxcblx0XHRcdFx0Ly8gZGlzcGxheSBmb3IgYWxsIGRpdiBlbGVtZW50cyBpcyBzZXQgdG8gXCJpbmxpbmVcIixcblx0XHRcdFx0Ly8gd2hpY2ggY2F1c2VzIGEgcHJvYmxlbSBvbmx5IGluIEFuZHJvaWQgOCBDaHJvbWUgODYuXG5cdFx0XHRcdC8vIEVuc3VyaW5nIHRoZSBkaXYgaXMgYGRpc3BsYXk6IGJsb2NrYFxuXHRcdFx0XHQvLyBnZXRzIGFyb3VuZCB0aGlzIGlzc3VlLlxuXHRcdFx0XHR0ckNoaWxkLnN0eWxlLmRpc3BsYXkgPSBcImJsb2NrXCI7XG5cblx0XHRcdFx0ZG9jdW1lbnRFbGVtZW50XG5cdFx0XHRcdFx0LmFwcGVuZENoaWxkKCB0YWJsZSApXG5cdFx0XHRcdFx0LmFwcGVuZENoaWxkKCB0ciApXG5cdFx0XHRcdFx0LmFwcGVuZENoaWxkKCB0ckNoaWxkICk7XG5cblx0XHRcdFx0dHJTdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKCB0ciApO1xuXHRcdFx0XHRyZWxpYWJsZVRyRGltZW5zaW9uc1ZhbCA9ICggcGFyc2VJbnQoIHRyU3R5bGUuaGVpZ2h0LCAxMCApICtcblx0XHRcdFx0XHRwYXJzZUludCggdHJTdHlsZS5ib3JkZXJUb3BXaWR0aCwgMTAgKSArXG5cdFx0XHRcdFx0cGFyc2VJbnQoIHRyU3R5bGUuYm9yZGVyQm90dG9tV2lkdGgsIDEwICkgKSA9PT0gdHIub2Zmc2V0SGVpZ2h0O1xuXG5cdFx0XHRcdGRvY3VtZW50RWxlbWVudC5yZW1vdmVDaGlsZCggdGFibGUgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiByZWxpYWJsZVRyRGltZW5zaW9uc1ZhbDtcblx0XHR9XG5cdH0gKTtcbn0gKSgpO1xuXG5cbmZ1bmN0aW9uIGN1ckNTUyggZWxlbSwgbmFtZSwgY29tcHV0ZWQgKSB7XG5cdHZhciB3aWR0aCwgbWluV2lkdGgsIG1heFdpZHRoLCByZXQsXG5cdFx0aXNDdXN0b21Qcm9wID0gcmN1c3RvbVByb3AudGVzdCggbmFtZSApLFxuXG5cdFx0Ly8gU3VwcG9ydDogRmlyZWZveCA1MStcblx0XHQvLyBSZXRyaWV2aW5nIHN0eWxlIGJlZm9yZSBjb21wdXRlZCBzb21laG93XG5cdFx0Ly8gZml4ZXMgYW4gaXNzdWUgd2l0aCBnZXR0aW5nIHdyb25nIHZhbHVlc1xuXHRcdC8vIG9uIGRldGFjaGVkIGVsZW1lbnRzXG5cdFx0c3R5bGUgPSBlbGVtLnN0eWxlO1xuXG5cdGNvbXB1dGVkID0gY29tcHV0ZWQgfHwgZ2V0U3R5bGVzKCBlbGVtICk7XG5cblx0Ly8gZ2V0UHJvcGVydHlWYWx1ZSBpcyBuZWVkZWQgZm9yOlxuXHQvLyAgIC5jc3MoJ2ZpbHRlcicpIChJRSA5IG9ubHksIHRyYWMtMTI1MzcpXG5cdC8vICAgLmNzcygnLS1jdXN0b21Qcm9wZXJ0eSkgKGdoLTMxNDQpXG5cdGlmICggY29tcHV0ZWQgKSB7XG5cblx0XHQvLyBTdXBwb3J0OiBJRSA8PTkgLSAxMStcblx0XHQvLyBJRSBvbmx5IHN1cHBvcnRzIGBcImZsb2F0XCJgIGluIGBnZXRQcm9wZXJ0eVZhbHVlYDsgaW4gY29tcHV0ZWQgc3R5bGVzXG5cdFx0Ly8gaXQncyBvbmx5IGF2YWlsYWJsZSBhcyBgXCJjc3NGbG9hdFwiYC4gV2Ugbm8gbG9uZ2VyIG1vZGlmeSBwcm9wZXJ0aWVzXG5cdFx0Ly8gc2VudCB0byBgLmNzcygpYCBhcGFydCBmcm9tIGNhbWVsQ2FzaW5nLCBzbyB3ZSBuZWVkIHRvIGNoZWNrIGJvdGguXG5cdFx0Ly8gTm9ybWFsbHksIHRoaXMgd291bGQgY3JlYXRlIGRpZmZlcmVuY2UgaW4gYmVoYXZpb3I6IGlmXG5cdFx0Ly8gYGdldFByb3BlcnR5VmFsdWVgIHJldHVybnMgYW4gZW1wdHkgc3RyaW5nLCB0aGUgdmFsdWUgcmV0dXJuZWRcblx0XHQvLyBieSBgLmNzcygpYCB3b3VsZCBiZSBgdW5kZWZpbmVkYC4gVGhpcyBpcyB1c3VhbGx5IHRoZSBjYXNlIGZvclxuXHRcdC8vIGRpc2Nvbm5lY3RlZCBlbGVtZW50cy4gSG93ZXZlciwgaW4gSUUgZXZlbiBkaXNjb25uZWN0ZWQgZWxlbWVudHNcblx0XHQvLyB3aXRoIG5vIHN0eWxlcyByZXR1cm4gYFwibm9uZVwiYCBmb3IgYGdldFByb3BlcnR5VmFsdWUoIFwiZmxvYXRcIiApYFxuXHRcdHJldCA9IGNvbXB1dGVkLmdldFByb3BlcnR5VmFsdWUoIG5hbWUgKSB8fCBjb21wdXRlZFsgbmFtZSBdO1xuXG5cdFx0aWYgKCBpc0N1c3RvbVByb3AgJiYgcmV0ICkge1xuXG5cdFx0XHQvLyBTdXBwb3J0OiBGaXJlZm94IDEwNSssIENocm9tZSA8PTEwNStcblx0XHRcdC8vIFNwZWMgcmVxdWlyZXMgdHJpbW1pbmcgd2hpdGVzcGFjZSBmb3IgY3VzdG9tIHByb3BlcnRpZXMgKGdoLTQ5MjYpLlxuXHRcdFx0Ly8gRmlyZWZveCBvbmx5IHRyaW1zIGxlYWRpbmcgd2hpdGVzcGFjZS4gQ2hyb21lIGp1c3QgY29sbGFwc2VzXG5cdFx0XHQvLyBib3RoIGxlYWRpbmcgJiB0cmFpbGluZyB3aGl0ZXNwYWNlIHRvIGEgc2luZ2xlIHNwYWNlLlxuXHRcdFx0Ly9cblx0XHRcdC8vIEZhbGwgYmFjayB0byBgdW5kZWZpbmVkYCBpZiBlbXB0eSBzdHJpbmcgcmV0dXJuZWQuXG5cdFx0XHQvLyBUaGlzIGNvbGxhcHNlcyBhIG1pc3NpbmcgZGVmaW5pdGlvbiB3aXRoIHByb3BlcnR5IGRlZmluZWRcblx0XHRcdC8vIGFuZCBzZXQgdG8gYW4gZW1wdHkgc3RyaW5nIGJ1dCB0aGVyZSdzIG5vIHN0YW5kYXJkIEFQSVxuXHRcdFx0Ly8gYWxsb3dpbmcgdXMgdG8gZGlmZmVyZW50aWF0ZSB0aGVtIHdpdGhvdXQgYSBwZXJmb3JtYW5jZSBwZW5hbHR5XG5cdFx0XHQvLyBhbmQgcmV0dXJuaW5nIGB1bmRlZmluZWRgIGFsaWducyB3aXRoIG9sZGVyIGpRdWVyeS5cblx0XHRcdC8vXG5cdFx0XHQvLyBydHJpbUNTUyB0cmVhdHMgVSswMDBEIENBUlJJQUdFIFJFVFVSTiBhbmQgVSswMDBDIEZPUk0gRkVFRFxuXHRcdFx0Ly8gYXMgd2hpdGVzcGFjZSB3aGlsZSBDU1MgZG9lcyBub3QsIGJ1dCB0aGlzIGlzIG5vdCBhIHByb2JsZW1cblx0XHRcdC8vIGJlY2F1c2UgQ1NTIHByZXByb2Nlc3NpbmcgcmVwbGFjZXMgdGhlbSB3aXRoIFUrMDAwQSBMSU5FIEZFRURcblx0XHRcdC8vICh3aGljaCAqaXMqIENTUyB3aGl0ZXNwYWNlKVxuXHRcdFx0Ly8gaHR0cHM6Ly93d3cudzMub3JnL1RSL2Nzcy1zeW50YXgtMy8jaW5wdXQtcHJlcHJvY2Vzc2luZ1xuXHRcdFx0cmV0ID0gcmV0LnJlcGxhY2UoIHJ0cmltQ1NTLCBcIiQxXCIgKSB8fCB1bmRlZmluZWQ7XG5cdFx0fVxuXG5cdFx0aWYgKCByZXQgPT09IFwiXCIgJiYgIWlzQXR0YWNoZWQoIGVsZW0gKSApIHtcblx0XHRcdHJldCA9IGpRdWVyeS5zdHlsZSggZWxlbSwgbmFtZSApO1xuXHRcdH1cblxuXHRcdC8vIEEgdHJpYnV0ZSB0byB0aGUgXCJhd2Vzb21lIGhhY2sgYnkgRGVhbiBFZHdhcmRzXCJcblx0XHQvLyBBbmRyb2lkIEJyb3dzZXIgcmV0dXJucyBwZXJjZW50YWdlIGZvciBzb21lIHZhbHVlcyxcblx0XHQvLyBidXQgd2lkdGggc2VlbXMgdG8gYmUgcmVsaWFibHkgcGl4ZWxzLlxuXHRcdC8vIFRoaXMgaXMgYWdhaW5zdCB0aGUgQ1NTT00gZHJhZnQgc3BlYzpcblx0XHQvLyBodHRwczovL2RyYWZ0cy5jc3N3Zy5vcmcvY3Nzb20vI3Jlc29sdmVkLXZhbHVlc1xuXHRcdGlmICggIXN1cHBvcnQucGl4ZWxCb3hTdHlsZXMoKSAmJiBybnVtbm9ucHgudGVzdCggcmV0ICkgJiYgcmJveFN0eWxlLnRlc3QoIG5hbWUgKSApIHtcblxuXHRcdFx0Ly8gUmVtZW1iZXIgdGhlIG9yaWdpbmFsIHZhbHVlc1xuXHRcdFx0d2lkdGggPSBzdHlsZS53aWR0aDtcblx0XHRcdG1pbldpZHRoID0gc3R5bGUubWluV2lkdGg7XG5cdFx0XHRtYXhXaWR0aCA9IHN0eWxlLm1heFdpZHRoO1xuXG5cdFx0XHQvLyBQdXQgaW4gdGhlIG5ldyB2YWx1ZXMgdG8gZ2V0IGEgY29tcHV0ZWQgdmFsdWUgb3V0XG5cdFx0XHRzdHlsZS5taW5XaWR0aCA9IHN0eWxlLm1heFdpZHRoID0gc3R5bGUud2lkdGggPSByZXQ7XG5cdFx0XHRyZXQgPSBjb21wdXRlZC53aWR0aDtcblxuXHRcdFx0Ly8gUmV2ZXJ0IHRoZSBjaGFuZ2VkIHZhbHVlc1xuXHRcdFx0c3R5bGUud2lkdGggPSB3aWR0aDtcblx0XHRcdHN0eWxlLm1pbldpZHRoID0gbWluV2lkdGg7XG5cdFx0XHRzdHlsZS5tYXhXaWR0aCA9IG1heFdpZHRoO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiByZXQgIT09IHVuZGVmaW5lZCA/XG5cblx0XHQvLyBTdXBwb3J0OiBJRSA8PTkgLSAxMSBvbmx5XG5cdFx0Ly8gSUUgcmV0dXJucyB6SW5kZXggdmFsdWUgYXMgYW4gaW50ZWdlci5cblx0XHRyZXQgKyBcIlwiIDpcblx0XHRyZXQ7XG59XG5cblxuZnVuY3Rpb24gYWRkR2V0SG9va0lmKCBjb25kaXRpb25GbiwgaG9va0ZuICkge1xuXG5cdC8vIERlZmluZSB0aGUgaG9vaywgd2UnbGwgY2hlY2sgb24gdGhlIGZpcnN0IHJ1biBpZiBpdCdzIHJlYWxseSBuZWVkZWQuXG5cdHJldHVybiB7XG5cdFx0Z2V0OiBmdW5jdGlvbigpIHtcblx0XHRcdGlmICggY29uZGl0aW9uRm4oKSApIHtcblxuXHRcdFx0XHQvLyBIb29rIG5vdCBuZWVkZWQgKG9yIGl0J3Mgbm90IHBvc3NpYmxlIHRvIHVzZSBpdCBkdWVcblx0XHRcdFx0Ly8gdG8gbWlzc2luZyBkZXBlbmRlbmN5KSwgcmVtb3ZlIGl0LlxuXHRcdFx0XHRkZWxldGUgdGhpcy5nZXQ7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSG9vayBuZWVkZWQ7IHJlZGVmaW5lIGl0IHNvIHRoYXQgdGhlIHN1cHBvcnQgdGVzdCBpcyBub3QgZXhlY3V0ZWQgYWdhaW4uXG5cdFx0XHRyZXR1cm4gKCB0aGlzLmdldCA9IGhvb2tGbiApLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHR9XG5cdH07XG59XG5cblxudmFyIGNzc1ByZWZpeGVzID0gWyBcIldlYmtpdFwiLCBcIk1velwiLCBcIm1zXCIgXSxcblx0ZW1wdHlTdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiZGl2XCIgKS5zdHlsZSxcblx0dmVuZG9yUHJvcHMgPSB7fTtcblxuLy8gUmV0dXJuIGEgdmVuZG9yLXByZWZpeGVkIHByb3BlcnR5IG9yIHVuZGVmaW5lZFxuZnVuY3Rpb24gdmVuZG9yUHJvcE5hbWUoIG5hbWUgKSB7XG5cblx0Ly8gQ2hlY2sgZm9yIHZlbmRvciBwcmVmaXhlZCBuYW1lc1xuXHR2YXIgY2FwTmFtZSA9IG5hbWVbIDAgXS50b1VwcGVyQ2FzZSgpICsgbmFtZS5zbGljZSggMSApLFxuXHRcdGkgPSBjc3NQcmVmaXhlcy5sZW5ndGg7XG5cblx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0bmFtZSA9IGNzc1ByZWZpeGVzWyBpIF0gKyBjYXBOYW1lO1xuXHRcdGlmICggbmFtZSBpbiBlbXB0eVN0eWxlICkge1xuXHRcdFx0cmV0dXJuIG5hbWU7XG5cdFx0fVxuXHR9XG59XG5cbi8vIFJldHVybiBhIHBvdGVudGlhbGx5LW1hcHBlZCBqUXVlcnkuY3NzUHJvcHMgb3IgdmVuZG9yIHByZWZpeGVkIHByb3BlcnR5XG5mdW5jdGlvbiBmaW5hbFByb3BOYW1lKCBuYW1lICkge1xuXHR2YXIgZmluYWwgPSBqUXVlcnkuY3NzUHJvcHNbIG5hbWUgXSB8fCB2ZW5kb3JQcm9wc1sgbmFtZSBdO1xuXG5cdGlmICggZmluYWwgKSB7XG5cdFx0cmV0dXJuIGZpbmFsO1xuXHR9XG5cdGlmICggbmFtZSBpbiBlbXB0eVN0eWxlICkge1xuXHRcdHJldHVybiBuYW1lO1xuXHR9XG5cdHJldHVybiB2ZW5kb3JQcm9wc1sgbmFtZSBdID0gdmVuZG9yUHJvcE5hbWUoIG5hbWUgKSB8fCBuYW1lO1xufVxuXG5cbnZhclxuXG5cdC8vIFN3YXBwYWJsZSBpZiBkaXNwbGF5IGlzIG5vbmUgb3Igc3RhcnRzIHdpdGggdGFibGVcblx0Ly8gZXhjZXB0IFwidGFibGVcIiwgXCJ0YWJsZS1jZWxsXCIsIG9yIFwidGFibGUtY2FwdGlvblwiXG5cdC8vIFNlZSBoZXJlIGZvciBkaXNwbGF5IHZhbHVlczogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9DU1MvZGlzcGxheVxuXHRyZGlzcGxheXN3YXAgPSAvXihub25lfHRhYmxlKD8hLWNbZWFdKS4rKS8sXG5cdGNzc1Nob3cgPSB7IHBvc2l0aW9uOiBcImFic29sdXRlXCIsIHZpc2liaWxpdHk6IFwiaGlkZGVuXCIsIGRpc3BsYXk6IFwiYmxvY2tcIiB9LFxuXHRjc3NOb3JtYWxUcmFuc2Zvcm0gPSB7XG5cdFx0bGV0dGVyU3BhY2luZzogXCIwXCIsXG5cdFx0Zm9udFdlaWdodDogXCI0MDBcIlxuXHR9O1xuXG5mdW5jdGlvbiBzZXRQb3NpdGl2ZU51bWJlciggX2VsZW0sIHZhbHVlLCBzdWJ0cmFjdCApIHtcblxuXHQvLyBBbnkgcmVsYXRpdmUgKCsvLSkgdmFsdWVzIGhhdmUgYWxyZWFkeSBiZWVuXG5cdC8vIG5vcm1hbGl6ZWQgYXQgdGhpcyBwb2ludFxuXHR2YXIgbWF0Y2hlcyA9IHJjc3NOdW0uZXhlYyggdmFsdWUgKTtcblx0cmV0dXJuIG1hdGNoZXMgP1xuXG5cdFx0Ly8gR3VhcmQgYWdhaW5zdCB1bmRlZmluZWQgXCJzdWJ0cmFjdFwiLCBlLmcuLCB3aGVuIHVzZWQgYXMgaW4gY3NzSG9va3Ncblx0XHRNYXRoLm1heCggMCwgbWF0Y2hlc1sgMiBdIC0gKCBzdWJ0cmFjdCB8fCAwICkgKSArICggbWF0Y2hlc1sgMyBdIHx8IFwicHhcIiApIDpcblx0XHR2YWx1ZTtcbn1cblxuZnVuY3Rpb24gYm94TW9kZWxBZGp1c3RtZW50KCBlbGVtLCBkaW1lbnNpb24sIGJveCwgaXNCb3JkZXJCb3gsIHN0eWxlcywgY29tcHV0ZWRWYWwgKSB7XG5cdHZhciBpID0gZGltZW5zaW9uID09PSBcIndpZHRoXCIgPyAxIDogMCxcblx0XHRleHRyYSA9IDAsXG5cdFx0ZGVsdGEgPSAwLFxuXHRcdG1hcmdpbkRlbHRhID0gMDtcblxuXHQvLyBBZGp1c3RtZW50IG1heSBub3QgYmUgbmVjZXNzYXJ5XG5cdGlmICggYm94ID09PSAoIGlzQm9yZGVyQm94ID8gXCJib3JkZXJcIiA6IFwiY29udGVudFwiICkgKSB7XG5cdFx0cmV0dXJuIDA7XG5cdH1cblxuXHRmb3IgKCA7IGkgPCA0OyBpICs9IDIgKSB7XG5cblx0XHQvLyBCb3RoIGJveCBtb2RlbHMgZXhjbHVkZSBtYXJnaW5cblx0XHQvLyBDb3VudCBtYXJnaW4gZGVsdGEgc2VwYXJhdGVseSB0byBvbmx5IGFkZCBpdCBhZnRlciBzY3JvbGwgZ3V0dGVyIGFkanVzdG1lbnQuXG5cdFx0Ly8gVGhpcyBpcyBuZWVkZWQgdG8gbWFrZSBuZWdhdGl2ZSBtYXJnaW5zIHdvcmsgd2l0aCBgb3V0ZXJIZWlnaHQoIHRydWUgKWAgKGdoLTM5ODIpLlxuXHRcdGlmICggYm94ID09PSBcIm1hcmdpblwiICkge1xuXHRcdFx0bWFyZ2luRGVsdGEgKz0galF1ZXJ5LmNzcyggZWxlbSwgYm94ICsgY3NzRXhwYW5kWyBpIF0sIHRydWUsIHN0eWxlcyApO1xuXHRcdH1cblxuXHRcdC8vIElmIHdlIGdldCBoZXJlIHdpdGggYSBjb250ZW50LWJveCwgd2UncmUgc2Vla2luZyBcInBhZGRpbmdcIiBvciBcImJvcmRlclwiIG9yIFwibWFyZ2luXCJcblx0XHRpZiAoICFpc0JvcmRlckJveCApIHtcblxuXHRcdFx0Ly8gQWRkIHBhZGRpbmdcblx0XHRcdGRlbHRhICs9IGpRdWVyeS5jc3MoIGVsZW0sIFwicGFkZGluZ1wiICsgY3NzRXhwYW5kWyBpIF0sIHRydWUsIHN0eWxlcyApO1xuXG5cdFx0XHQvLyBGb3IgXCJib3JkZXJcIiBvciBcIm1hcmdpblwiLCBhZGQgYm9yZGVyXG5cdFx0XHRpZiAoIGJveCAhPT0gXCJwYWRkaW5nXCIgKSB7XG5cdFx0XHRcdGRlbHRhICs9IGpRdWVyeS5jc3MoIGVsZW0sIFwiYm9yZGVyXCIgKyBjc3NFeHBhbmRbIGkgXSArIFwiV2lkdGhcIiwgdHJ1ZSwgc3R5bGVzICk7XG5cblx0XHRcdC8vIEJ1dCBzdGlsbCBrZWVwIHRyYWNrIG9mIGl0IG90aGVyd2lzZVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZXh0cmEgKz0galF1ZXJ5LmNzcyggZWxlbSwgXCJib3JkZXJcIiArIGNzc0V4cGFuZFsgaSBdICsgXCJXaWR0aFwiLCB0cnVlLCBzdHlsZXMgKTtcblx0XHRcdH1cblxuXHRcdC8vIElmIHdlIGdldCBoZXJlIHdpdGggYSBib3JkZXItYm94IChjb250ZW50ICsgcGFkZGluZyArIGJvcmRlciksIHdlJ3JlIHNlZWtpbmcgXCJjb250ZW50XCIgb3Jcblx0XHQvLyBcInBhZGRpbmdcIiBvciBcIm1hcmdpblwiXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Ly8gRm9yIFwiY29udGVudFwiLCBzdWJ0cmFjdCBwYWRkaW5nXG5cdFx0XHRpZiAoIGJveCA9PT0gXCJjb250ZW50XCIgKSB7XG5cdFx0XHRcdGRlbHRhIC09IGpRdWVyeS5jc3MoIGVsZW0sIFwicGFkZGluZ1wiICsgY3NzRXhwYW5kWyBpIF0sIHRydWUsIHN0eWxlcyApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBGb3IgXCJjb250ZW50XCIgb3IgXCJwYWRkaW5nXCIsIHN1YnRyYWN0IGJvcmRlclxuXHRcdFx0aWYgKCBib3ggIT09IFwibWFyZ2luXCIgKSB7XG5cdFx0XHRcdGRlbHRhIC09IGpRdWVyeS5jc3MoIGVsZW0sIFwiYm9yZGVyXCIgKyBjc3NFeHBhbmRbIGkgXSArIFwiV2lkdGhcIiwgdHJ1ZSwgc3R5bGVzICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gQWNjb3VudCBmb3IgcG9zaXRpdmUgY29udGVudC1ib3ggc2Nyb2xsIGd1dHRlciB3aGVuIHJlcXVlc3RlZCBieSBwcm92aWRpbmcgY29tcHV0ZWRWYWxcblx0aWYgKCAhaXNCb3JkZXJCb3ggJiYgY29tcHV0ZWRWYWwgPj0gMCApIHtcblxuXHRcdC8vIG9mZnNldFdpZHRoL29mZnNldEhlaWdodCBpcyBhIHJvdW5kZWQgc3VtIG9mIGNvbnRlbnQsIHBhZGRpbmcsIHNjcm9sbCBndXR0ZXIsIGFuZCBib3JkZXJcblx0XHQvLyBBc3N1bWluZyBpbnRlZ2VyIHNjcm9sbCBndXR0ZXIsIHN1YnRyYWN0IHRoZSByZXN0IGFuZCByb3VuZCBkb3duXG5cdFx0ZGVsdGEgKz0gTWF0aC5tYXgoIDAsIE1hdGguY2VpbChcblx0XHRcdGVsZW1bIFwib2Zmc2V0XCIgKyBkaW1lbnNpb25bIDAgXS50b1VwcGVyQ2FzZSgpICsgZGltZW5zaW9uLnNsaWNlKCAxICkgXSAtXG5cdFx0XHRjb21wdXRlZFZhbCAtXG5cdFx0XHRkZWx0YSAtXG5cdFx0XHRleHRyYSAtXG5cdFx0XHQwLjVcblxuXHRcdC8vIElmIG9mZnNldFdpZHRoL29mZnNldEhlaWdodCBpcyB1bmtub3duLCB0aGVuIHdlIGNhbid0IGRldGVybWluZSBjb250ZW50LWJveCBzY3JvbGwgZ3V0dGVyXG5cdFx0Ly8gVXNlIGFuIGV4cGxpY2l0IHplcm8gdG8gYXZvaWQgTmFOIChnaC0zOTY0KVxuXHRcdCkgKSB8fCAwO1xuXHR9XG5cblx0cmV0dXJuIGRlbHRhICsgbWFyZ2luRGVsdGE7XG59XG5cbmZ1bmN0aW9uIGdldFdpZHRoT3JIZWlnaHQoIGVsZW0sIGRpbWVuc2lvbiwgZXh0cmEgKSB7XG5cblx0Ly8gU3RhcnQgd2l0aCBjb21wdXRlZCBzdHlsZVxuXHR2YXIgc3R5bGVzID0gZ2V0U3R5bGVzKCBlbGVtICksXG5cblx0XHQvLyBUbyBhdm9pZCBmb3JjaW5nIGEgcmVmbG93LCBvbmx5IGZldGNoIGJveFNpemluZyBpZiB3ZSBuZWVkIGl0IChnaC00MzIyKS5cblx0XHQvLyBGYWtlIGNvbnRlbnQtYm94IHVudGlsIHdlIGtub3cgaXQncyBuZWVkZWQgdG8ga25vdyB0aGUgdHJ1ZSB2YWx1ZS5cblx0XHRib3hTaXppbmdOZWVkZWQgPSAhc3VwcG9ydC5ib3hTaXppbmdSZWxpYWJsZSgpIHx8IGV4dHJhLFxuXHRcdGlzQm9yZGVyQm94ID0gYm94U2l6aW5nTmVlZGVkICYmXG5cdFx0XHRqUXVlcnkuY3NzKCBlbGVtLCBcImJveFNpemluZ1wiLCBmYWxzZSwgc3R5bGVzICkgPT09IFwiYm9yZGVyLWJveFwiLFxuXHRcdHZhbHVlSXNCb3JkZXJCb3ggPSBpc0JvcmRlckJveCxcblxuXHRcdHZhbCA9IGN1ckNTUyggZWxlbSwgZGltZW5zaW9uLCBzdHlsZXMgKSxcblx0XHRvZmZzZXRQcm9wID0gXCJvZmZzZXRcIiArIGRpbWVuc2lvblsgMCBdLnRvVXBwZXJDYXNlKCkgKyBkaW1lbnNpb24uc2xpY2UoIDEgKTtcblxuXHQvLyBTdXBwb3J0OiBGaXJlZm94IDw9NTRcblx0Ly8gUmV0dXJuIGEgY29uZm91bmRpbmcgbm9uLXBpeGVsIHZhbHVlIG9yIGZlaWduIGlnbm9yYW5jZSwgYXMgYXBwcm9wcmlhdGUuXG5cdGlmICggcm51bW5vbnB4LnRlc3QoIHZhbCApICkge1xuXHRcdGlmICggIWV4dHJhICkge1xuXHRcdFx0cmV0dXJuIHZhbDtcblx0XHR9XG5cdFx0dmFsID0gXCJhdXRvXCI7XG5cdH1cblxuXG5cdC8vIFN1cHBvcnQ6IElFIDkgLSAxMSBvbmx5XG5cdC8vIFVzZSBvZmZzZXRXaWR0aC9vZmZzZXRIZWlnaHQgZm9yIHdoZW4gYm94IHNpemluZyBpcyB1bnJlbGlhYmxlLlxuXHQvLyBJbiB0aG9zZSBjYXNlcywgdGhlIGNvbXB1dGVkIHZhbHVlIGNhbiBiZSB0cnVzdGVkIHRvIGJlIGJvcmRlci1ib3guXG5cdGlmICggKCAhc3VwcG9ydC5ib3hTaXppbmdSZWxpYWJsZSgpICYmIGlzQm9yZGVyQm94IHx8XG5cblx0XHQvLyBTdXBwb3J0OiBJRSAxMCAtIDExKywgRWRnZSAxNSAtIDE4K1xuXHRcdC8vIElFL0VkZ2UgbWlzcmVwb3J0IGBnZXRDb21wdXRlZFN0eWxlYCBvZiB0YWJsZSByb3dzIHdpdGggd2lkdGgvaGVpZ2h0XG5cdFx0Ly8gc2V0IGluIENTUyB3aGlsZSBgb2Zmc2V0KmAgcHJvcGVydGllcyByZXBvcnQgY29ycmVjdCB2YWx1ZXMuXG5cdFx0Ly8gSW50ZXJlc3RpbmdseSwgaW4gc29tZSBjYXNlcyBJRSA5IGRvZXNuJ3Qgc3VmZmVyIGZyb20gdGhpcyBpc3N1ZS5cblx0XHQhc3VwcG9ydC5yZWxpYWJsZVRyRGltZW5zaW9ucygpICYmIG5vZGVOYW1lKCBlbGVtLCBcInRyXCIgKSB8fFxuXG5cdFx0Ly8gRmFsbCBiYWNrIHRvIG9mZnNldFdpZHRoL29mZnNldEhlaWdodCB3aGVuIHZhbHVlIGlzIFwiYXV0b1wiXG5cdFx0Ly8gVGhpcyBoYXBwZW5zIGZvciBpbmxpbmUgZWxlbWVudHMgd2l0aCBubyBleHBsaWNpdCBzZXR0aW5nIChnaC0zNTcxKVxuXHRcdHZhbCA9PT0gXCJhdXRvXCIgfHxcblxuXHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjEgLSA0LjMgb25seVxuXHRcdC8vIEFsc28gdXNlIG9mZnNldFdpZHRoL29mZnNldEhlaWdodCBmb3IgbWlzcmVwb3J0ZWQgaW5saW5lIGRpbWVuc2lvbnMgKGdoLTM2MDIpXG5cdFx0IXBhcnNlRmxvYXQoIHZhbCApICYmIGpRdWVyeS5jc3MoIGVsZW0sIFwiZGlzcGxheVwiLCBmYWxzZSwgc3R5bGVzICkgPT09IFwiaW5saW5lXCIgKSAmJlxuXG5cdFx0Ly8gTWFrZSBzdXJlIHRoZSBlbGVtZW50IGlzIHZpc2libGUgJiBjb25uZWN0ZWRcblx0XHRlbGVtLmdldENsaWVudFJlY3RzKCkubGVuZ3RoICkge1xuXG5cdFx0aXNCb3JkZXJCb3ggPSBqUXVlcnkuY3NzKCBlbGVtLCBcImJveFNpemluZ1wiLCBmYWxzZSwgc3R5bGVzICkgPT09IFwiYm9yZGVyLWJveFwiO1xuXG5cdFx0Ly8gV2hlcmUgYXZhaWxhYmxlLCBvZmZzZXRXaWR0aC9vZmZzZXRIZWlnaHQgYXBwcm94aW1hdGUgYm9yZGVyIGJveCBkaW1lbnNpb25zLlxuXHRcdC8vIFdoZXJlIG5vdCBhdmFpbGFibGUgKGUuZy4sIFNWRyksIGFzc3VtZSB1bnJlbGlhYmxlIGJveC1zaXppbmcgYW5kIGludGVycHJldCB0aGVcblx0XHQvLyByZXRyaWV2ZWQgdmFsdWUgYXMgYSBjb250ZW50IGJveCBkaW1lbnNpb24uXG5cdFx0dmFsdWVJc0JvcmRlckJveCA9IG9mZnNldFByb3AgaW4gZWxlbTtcblx0XHRpZiAoIHZhbHVlSXNCb3JkZXJCb3ggKSB7XG5cdFx0XHR2YWwgPSBlbGVtWyBvZmZzZXRQcm9wIF07XG5cdFx0fVxuXHR9XG5cblx0Ly8gTm9ybWFsaXplIFwiXCIgYW5kIGF1dG9cblx0dmFsID0gcGFyc2VGbG9hdCggdmFsICkgfHwgMDtcblxuXHQvLyBBZGp1c3QgZm9yIHRoZSBlbGVtZW50J3MgYm94IG1vZGVsXG5cdHJldHVybiAoIHZhbCArXG5cdFx0Ym94TW9kZWxBZGp1c3RtZW50KFxuXHRcdFx0ZWxlbSxcblx0XHRcdGRpbWVuc2lvbixcblx0XHRcdGV4dHJhIHx8ICggaXNCb3JkZXJCb3ggPyBcImJvcmRlclwiIDogXCJjb250ZW50XCIgKSxcblx0XHRcdHZhbHVlSXNCb3JkZXJCb3gsXG5cdFx0XHRzdHlsZXMsXG5cblx0XHRcdC8vIFByb3ZpZGUgdGhlIGN1cnJlbnQgY29tcHV0ZWQgc2l6ZSB0byByZXF1ZXN0IHNjcm9sbCBndXR0ZXIgY2FsY3VsYXRpb24gKGdoLTM1ODkpXG5cdFx0XHR2YWxcblx0XHQpXG5cdCkgKyBcInB4XCI7XG59XG5cbmpRdWVyeS5leHRlbmQoIHtcblxuXHQvLyBBZGQgaW4gc3R5bGUgcHJvcGVydHkgaG9va3MgZm9yIG92ZXJyaWRpbmcgdGhlIGRlZmF1bHRcblx0Ly8gYmVoYXZpb3Igb2YgZ2V0dGluZyBhbmQgc2V0dGluZyBhIHN0eWxlIHByb3BlcnR5XG5cdGNzc0hvb2tzOiB7XG5cdFx0b3BhY2l0eToge1xuXHRcdFx0Z2V0OiBmdW5jdGlvbiggZWxlbSwgY29tcHV0ZWQgKSB7XG5cdFx0XHRcdGlmICggY29tcHV0ZWQgKSB7XG5cblx0XHRcdFx0XHQvLyBXZSBzaG91bGQgYWx3YXlzIGdldCBhIG51bWJlciBiYWNrIGZyb20gb3BhY2l0eVxuXHRcdFx0XHRcdHZhciByZXQgPSBjdXJDU1MoIGVsZW0sIFwib3BhY2l0eVwiICk7XG5cdFx0XHRcdFx0cmV0dXJuIHJldCA9PT0gXCJcIiA/IFwiMVwiIDogcmV0O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdC8vIERvbid0IGF1dG9tYXRpY2FsbHkgYWRkIFwicHhcIiB0byB0aGVzZSBwb3NzaWJseS11bml0bGVzcyBwcm9wZXJ0aWVzXG5cdGNzc051bWJlcjoge1xuXHRcdGFuaW1hdGlvbkl0ZXJhdGlvbkNvdW50OiB0cnVlLFxuXHRcdGFzcGVjdFJhdGlvOiB0cnVlLFxuXHRcdGJvcmRlckltYWdlU2xpY2U6IHRydWUsXG5cdFx0Y29sdW1uQ291bnQ6IHRydWUsXG5cdFx0ZmxleEdyb3c6IHRydWUsXG5cdFx0ZmxleFNocmluazogdHJ1ZSxcblx0XHRmb250V2VpZ2h0OiB0cnVlLFxuXHRcdGdyaWRBcmVhOiB0cnVlLFxuXHRcdGdyaWRDb2x1bW46IHRydWUsXG5cdFx0Z3JpZENvbHVtbkVuZDogdHJ1ZSxcblx0XHRncmlkQ29sdW1uU3RhcnQ6IHRydWUsXG5cdFx0Z3JpZFJvdzogdHJ1ZSxcblx0XHRncmlkUm93RW5kOiB0cnVlLFxuXHRcdGdyaWRSb3dTdGFydDogdHJ1ZSxcblx0XHRsaW5lSGVpZ2h0OiB0cnVlLFxuXHRcdG9wYWNpdHk6IHRydWUsXG5cdFx0b3JkZXI6IHRydWUsXG5cdFx0b3JwaGFuczogdHJ1ZSxcblx0XHRzY2FsZTogdHJ1ZSxcblx0XHR3aWRvd3M6IHRydWUsXG5cdFx0ekluZGV4OiB0cnVlLFxuXHRcdHpvb206IHRydWUsXG5cblx0XHQvLyBTVkctcmVsYXRlZFxuXHRcdGZpbGxPcGFjaXR5OiB0cnVlLFxuXHRcdGZsb29kT3BhY2l0eTogdHJ1ZSxcblx0XHRzdG9wT3BhY2l0eTogdHJ1ZSxcblx0XHRzdHJva2VNaXRlcmxpbWl0OiB0cnVlLFxuXHRcdHN0cm9rZU9wYWNpdHk6IHRydWVcblx0fSxcblxuXHQvLyBBZGQgaW4gcHJvcGVydGllcyB3aG9zZSBuYW1lcyB5b3Ugd2lzaCB0byBmaXggYmVmb3JlXG5cdC8vIHNldHRpbmcgb3IgZ2V0dGluZyB0aGUgdmFsdWVcblx0Y3NzUHJvcHM6IHt9LFxuXG5cdC8vIEdldCBhbmQgc2V0IHRoZSBzdHlsZSBwcm9wZXJ0eSBvbiBhIERPTSBOb2RlXG5cdHN0eWxlOiBmdW5jdGlvbiggZWxlbSwgbmFtZSwgdmFsdWUsIGV4dHJhICkge1xuXG5cdFx0Ly8gRG9uJ3Qgc2V0IHN0eWxlcyBvbiB0ZXh0IGFuZCBjb21tZW50IG5vZGVzXG5cdFx0aWYgKCAhZWxlbSB8fCBlbGVtLm5vZGVUeXBlID09PSAzIHx8IGVsZW0ubm9kZVR5cGUgPT09IDggfHwgIWVsZW0uc3R5bGUgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gTWFrZSBzdXJlIHRoYXQgd2UncmUgd29ya2luZyB3aXRoIHRoZSByaWdodCBuYW1lXG5cdFx0dmFyIHJldCwgdHlwZSwgaG9va3MsXG5cdFx0XHRvcmlnTmFtZSA9IGNhbWVsQ2FzZSggbmFtZSApLFxuXHRcdFx0aXNDdXN0b21Qcm9wID0gcmN1c3RvbVByb3AudGVzdCggbmFtZSApLFxuXHRcdFx0c3R5bGUgPSBlbGVtLnN0eWxlO1xuXG5cdFx0Ly8gTWFrZSBzdXJlIHRoYXQgd2UncmUgd29ya2luZyB3aXRoIHRoZSByaWdodCBuYW1lLiBXZSBkb24ndFxuXHRcdC8vIHdhbnQgdG8gcXVlcnkgdGhlIHZhbHVlIGlmIGl0IGlzIGEgQ1NTIGN1c3RvbSBwcm9wZXJ0eVxuXHRcdC8vIHNpbmNlIHRoZXkgYXJlIHVzZXItZGVmaW5lZC5cblx0XHRpZiAoICFpc0N1c3RvbVByb3AgKSB7XG5cdFx0XHRuYW1lID0gZmluYWxQcm9wTmFtZSggb3JpZ05hbWUgKTtcblx0XHR9XG5cblx0XHQvLyBHZXRzIGhvb2sgZm9yIHRoZSBwcmVmaXhlZCB2ZXJzaW9uLCB0aGVuIHVucHJlZml4ZWQgdmVyc2lvblxuXHRcdGhvb2tzID0galF1ZXJ5LmNzc0hvb2tzWyBuYW1lIF0gfHwgalF1ZXJ5LmNzc0hvb2tzWyBvcmlnTmFtZSBdO1xuXG5cdFx0Ly8gQ2hlY2sgaWYgd2UncmUgc2V0dGluZyBhIHZhbHVlXG5cdFx0aWYgKCB2YWx1ZSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0dHlwZSA9IHR5cGVvZiB2YWx1ZTtcblxuXHRcdFx0Ly8gQ29udmVydCBcIis9XCIgb3IgXCItPVwiIHRvIHJlbGF0aXZlIG51bWJlcnMgKHRyYWMtNzM0NSlcblx0XHRcdGlmICggdHlwZSA9PT0gXCJzdHJpbmdcIiAmJiAoIHJldCA9IHJjc3NOdW0uZXhlYyggdmFsdWUgKSApICYmIHJldFsgMSBdICkge1xuXHRcdFx0XHR2YWx1ZSA9IGFkanVzdENTUyggZWxlbSwgbmFtZSwgcmV0ICk7XG5cblx0XHRcdFx0Ly8gRml4ZXMgYnVnIHRyYWMtOTIzN1xuXHRcdFx0XHR0eXBlID0gXCJudW1iZXJcIjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gTWFrZSBzdXJlIHRoYXQgbnVsbCBhbmQgTmFOIHZhbHVlcyBhcmVuJ3Qgc2V0ICh0cmFjLTcxMTYpXG5cdFx0XHRpZiAoIHZhbHVlID09IG51bGwgfHwgdmFsdWUgIT09IHZhbHVlICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdC8vIElmIGEgbnVtYmVyIHdhcyBwYXNzZWQgaW4sIGFkZCB0aGUgdW5pdCAoZXhjZXB0IGZvciBjZXJ0YWluIENTUyBwcm9wZXJ0aWVzKVxuXHRcdFx0Ly8gVGhlIGlzQ3VzdG9tUHJvcCBjaGVjayBjYW4gYmUgcmVtb3ZlZCBpbiBqUXVlcnkgNC4wIHdoZW4gd2Ugb25seSBhdXRvLWFwcGVuZFxuXHRcdFx0Ly8gXCJweFwiIHRvIGEgZmV3IGhhcmRjb2RlZCB2YWx1ZXMuXG5cdFx0XHRpZiAoIHR5cGUgPT09IFwibnVtYmVyXCIgJiYgIWlzQ3VzdG9tUHJvcCApIHtcblx0XHRcdFx0dmFsdWUgKz0gcmV0ICYmIHJldFsgMyBdIHx8ICggalF1ZXJ5LmNzc051bWJlclsgb3JpZ05hbWUgXSA/IFwiXCIgOiBcInB4XCIgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gYmFja2dyb3VuZC0qIHByb3BzIGFmZmVjdCBvcmlnaW5hbCBjbG9uZSdzIHZhbHVlc1xuXHRcdFx0aWYgKCAhc3VwcG9ydC5jbGVhckNsb25lU3R5bGUgJiYgdmFsdWUgPT09IFwiXCIgJiYgbmFtZS5pbmRleE9mKCBcImJhY2tncm91bmRcIiApID09PSAwICkge1xuXHRcdFx0XHRzdHlsZVsgbmFtZSBdID0gXCJpbmhlcml0XCI7XG5cdFx0XHR9XG5cblx0XHRcdC8vIElmIGEgaG9vayB3YXMgcHJvdmlkZWQsIHVzZSB0aGF0IHZhbHVlLCBvdGhlcndpc2UganVzdCBzZXQgdGhlIHNwZWNpZmllZCB2YWx1ZVxuXHRcdFx0aWYgKCAhaG9va3MgfHwgISggXCJzZXRcIiBpbiBob29rcyApIHx8XG5cdFx0XHRcdCggdmFsdWUgPSBob29rcy5zZXQoIGVsZW0sIHZhbHVlLCBleHRyYSApICkgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRpZiAoIGlzQ3VzdG9tUHJvcCApIHtcblx0XHRcdFx0XHRzdHlsZS5zZXRQcm9wZXJ0eSggbmFtZSwgdmFsdWUgKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRzdHlsZVsgbmFtZSBdID0gdmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vIElmIGEgaG9vayB3YXMgcHJvdmlkZWQgZ2V0IHRoZSBub24tY29tcHV0ZWQgdmFsdWUgZnJvbSB0aGVyZVxuXHRcdFx0aWYgKCBob29rcyAmJiBcImdldFwiIGluIGhvb2tzICYmXG5cdFx0XHRcdCggcmV0ID0gaG9va3MuZ2V0KCBlbGVtLCBmYWxzZSwgZXh0cmEgKSApICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0cmV0dXJuIHJldDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gT3RoZXJ3aXNlIGp1c3QgZ2V0IHRoZSB2YWx1ZSBmcm9tIHRoZSBzdHlsZSBvYmplY3Rcblx0XHRcdHJldHVybiBzdHlsZVsgbmFtZSBdO1xuXHRcdH1cblx0fSxcblxuXHRjc3M6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBleHRyYSwgc3R5bGVzICkge1xuXHRcdHZhciB2YWwsIG51bSwgaG9va3MsXG5cdFx0XHRvcmlnTmFtZSA9IGNhbWVsQ2FzZSggbmFtZSApLFxuXHRcdFx0aXNDdXN0b21Qcm9wID0gcmN1c3RvbVByb3AudGVzdCggbmFtZSApO1xuXG5cdFx0Ly8gTWFrZSBzdXJlIHRoYXQgd2UncmUgd29ya2luZyB3aXRoIHRoZSByaWdodCBuYW1lLiBXZSBkb24ndFxuXHRcdC8vIHdhbnQgdG8gbW9kaWZ5IHRoZSB2YWx1ZSBpZiBpdCBpcyBhIENTUyBjdXN0b20gcHJvcGVydHlcblx0XHQvLyBzaW5jZSB0aGV5IGFyZSB1c2VyLWRlZmluZWQuXG5cdFx0aWYgKCAhaXNDdXN0b21Qcm9wICkge1xuXHRcdFx0bmFtZSA9IGZpbmFsUHJvcE5hbWUoIG9yaWdOYW1lICk7XG5cdFx0fVxuXG5cdFx0Ly8gVHJ5IHByZWZpeGVkIG5hbWUgZm9sbG93ZWQgYnkgdGhlIHVucHJlZml4ZWQgbmFtZVxuXHRcdGhvb2tzID0galF1ZXJ5LmNzc0hvb2tzWyBuYW1lIF0gfHwgalF1ZXJ5LmNzc0hvb2tzWyBvcmlnTmFtZSBdO1xuXG5cdFx0Ly8gSWYgYSBob29rIHdhcyBwcm92aWRlZCBnZXQgdGhlIGNvbXB1dGVkIHZhbHVlIGZyb20gdGhlcmVcblx0XHRpZiAoIGhvb2tzICYmIFwiZ2V0XCIgaW4gaG9va3MgKSB7XG5cdFx0XHR2YWwgPSBob29rcy5nZXQoIGVsZW0sIHRydWUsIGV4dHJhICk7XG5cdFx0fVxuXG5cdFx0Ly8gT3RoZXJ3aXNlLCBpZiBhIHdheSB0byBnZXQgdGhlIGNvbXB1dGVkIHZhbHVlIGV4aXN0cywgdXNlIHRoYXRcblx0XHRpZiAoIHZhbCA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0dmFsID0gY3VyQ1NTKCBlbGVtLCBuYW1lLCBzdHlsZXMgKTtcblx0XHR9XG5cblx0XHQvLyBDb252ZXJ0IFwibm9ybWFsXCIgdG8gY29tcHV0ZWQgdmFsdWVcblx0XHRpZiAoIHZhbCA9PT0gXCJub3JtYWxcIiAmJiBuYW1lIGluIGNzc05vcm1hbFRyYW5zZm9ybSApIHtcblx0XHRcdHZhbCA9IGNzc05vcm1hbFRyYW5zZm9ybVsgbmFtZSBdO1xuXHRcdH1cblxuXHRcdC8vIE1ha2UgbnVtZXJpYyBpZiBmb3JjZWQgb3IgYSBxdWFsaWZpZXIgd2FzIHByb3ZpZGVkIGFuZCB2YWwgbG9va3MgbnVtZXJpY1xuXHRcdGlmICggZXh0cmEgPT09IFwiXCIgfHwgZXh0cmEgKSB7XG5cdFx0XHRudW0gPSBwYXJzZUZsb2F0KCB2YWwgKTtcblx0XHRcdHJldHVybiBleHRyYSA9PT0gdHJ1ZSB8fCBpc0Zpbml0ZSggbnVtICkgPyBudW0gfHwgMCA6IHZhbDtcblx0XHR9XG5cblx0XHRyZXR1cm4gdmFsO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5lYWNoKCBbIFwiaGVpZ2h0XCIsIFwid2lkdGhcIiBdLCBmdW5jdGlvbiggX2ksIGRpbWVuc2lvbiApIHtcblx0alF1ZXJ5LmNzc0hvb2tzWyBkaW1lbnNpb24gXSA9IHtcblx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtLCBjb21wdXRlZCwgZXh0cmEgKSB7XG5cdFx0XHRpZiAoIGNvbXB1dGVkICkge1xuXG5cdFx0XHRcdC8vIENlcnRhaW4gZWxlbWVudHMgY2FuIGhhdmUgZGltZW5zaW9uIGluZm8gaWYgd2UgaW52aXNpYmx5IHNob3cgdGhlbVxuXHRcdFx0XHQvLyBidXQgaXQgbXVzdCBoYXZlIGEgY3VycmVudCBkaXNwbGF5IHN0eWxlIHRoYXQgd291bGQgYmVuZWZpdFxuXHRcdFx0XHRyZXR1cm4gcmRpc3BsYXlzd2FwLnRlc3QoIGpRdWVyeS5jc3MoIGVsZW0sIFwiZGlzcGxheVwiICkgKSAmJlxuXG5cdFx0XHRcdFx0Ly8gU3VwcG9ydDogU2FmYXJpIDgrXG5cdFx0XHRcdFx0Ly8gVGFibGUgY29sdW1ucyBpbiBTYWZhcmkgaGF2ZSBub24temVybyBvZmZzZXRXaWR0aCAmIHplcm9cblx0XHRcdFx0XHQvLyBnZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aCB1bmxlc3MgZGlzcGxheSBpcyBjaGFuZ2VkLlxuXHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9MTEgb25seVxuXHRcdFx0XHRcdC8vIFJ1bm5pbmcgZ2V0Qm91bmRpbmdDbGllbnRSZWN0IG9uIGEgZGlzY29ubmVjdGVkIG5vZGVcblx0XHRcdFx0XHQvLyBpbiBJRSB0aHJvd3MgYW4gZXJyb3IuXG5cdFx0XHRcdFx0KCAhZWxlbS5nZXRDbGllbnRSZWN0cygpLmxlbmd0aCB8fCAhZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aCApID9cblx0XHRcdFx0XHRzd2FwKCBlbGVtLCBjc3NTaG93LCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdHJldHVybiBnZXRXaWR0aE9ySGVpZ2h0KCBlbGVtLCBkaW1lbnNpb24sIGV4dHJhICk7XG5cdFx0XHRcdFx0fSApIDpcblx0XHRcdFx0XHRnZXRXaWR0aE9ySGVpZ2h0KCBlbGVtLCBkaW1lbnNpb24sIGV4dHJhICk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlLCBleHRyYSApIHtcblx0XHRcdHZhciBtYXRjaGVzLFxuXHRcdFx0XHRzdHlsZXMgPSBnZXRTdHlsZXMoIGVsZW0gKSxcblxuXHRcdFx0XHQvLyBPbmx5IHJlYWQgc3R5bGVzLnBvc2l0aW9uIGlmIHRoZSB0ZXN0IGhhcyBhIGNoYW5jZSB0byBmYWlsXG5cdFx0XHRcdC8vIHRvIGF2b2lkIGZvcmNpbmcgYSByZWZsb3cuXG5cdFx0XHRcdHNjcm9sbGJveFNpemVCdWdneSA9ICFzdXBwb3J0LnNjcm9sbGJveFNpemUoKSAmJlxuXHRcdFx0XHRcdHN0eWxlcy5wb3NpdGlvbiA9PT0gXCJhYnNvbHV0ZVwiLFxuXG5cdFx0XHRcdC8vIFRvIGF2b2lkIGZvcmNpbmcgYSByZWZsb3csIG9ubHkgZmV0Y2ggYm94U2l6aW5nIGlmIHdlIG5lZWQgaXQgKGdoLTM5OTEpXG5cdFx0XHRcdGJveFNpemluZ05lZWRlZCA9IHNjcm9sbGJveFNpemVCdWdneSB8fCBleHRyYSxcblx0XHRcdFx0aXNCb3JkZXJCb3ggPSBib3hTaXppbmdOZWVkZWQgJiZcblx0XHRcdFx0XHRqUXVlcnkuY3NzKCBlbGVtLCBcImJveFNpemluZ1wiLCBmYWxzZSwgc3R5bGVzICkgPT09IFwiYm9yZGVyLWJveFwiLFxuXHRcdFx0XHRzdWJ0cmFjdCA9IGV4dHJhID9cblx0XHRcdFx0XHRib3hNb2RlbEFkanVzdG1lbnQoXG5cdFx0XHRcdFx0XHRlbGVtLFxuXHRcdFx0XHRcdFx0ZGltZW5zaW9uLFxuXHRcdFx0XHRcdFx0ZXh0cmEsXG5cdFx0XHRcdFx0XHRpc0JvcmRlckJveCxcblx0XHRcdFx0XHRcdHN0eWxlc1xuXHRcdFx0XHRcdCkgOlxuXHRcdFx0XHRcdDA7XG5cblx0XHRcdC8vIEFjY291bnQgZm9yIHVucmVsaWFibGUgYm9yZGVyLWJveCBkaW1lbnNpb25zIGJ5IGNvbXBhcmluZyBvZmZzZXQqIHRvIGNvbXB1dGVkIGFuZFxuXHRcdFx0Ly8gZmFraW5nIGEgY29udGVudC1ib3ggdG8gZ2V0IGJvcmRlciBhbmQgcGFkZGluZyAoZ2gtMzY5OSlcblx0XHRcdGlmICggaXNCb3JkZXJCb3ggJiYgc2Nyb2xsYm94U2l6ZUJ1Z2d5ICkge1xuXHRcdFx0XHRzdWJ0cmFjdCAtPSBNYXRoLmNlaWwoXG5cdFx0XHRcdFx0ZWxlbVsgXCJvZmZzZXRcIiArIGRpbWVuc2lvblsgMCBdLnRvVXBwZXJDYXNlKCkgKyBkaW1lbnNpb24uc2xpY2UoIDEgKSBdIC1cblx0XHRcdFx0XHRwYXJzZUZsb2F0KCBzdHlsZXNbIGRpbWVuc2lvbiBdICkgLVxuXHRcdFx0XHRcdGJveE1vZGVsQWRqdXN0bWVudCggZWxlbSwgZGltZW5zaW9uLCBcImJvcmRlclwiLCBmYWxzZSwgc3R5bGVzICkgLVxuXHRcdFx0XHRcdDAuNVxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDb252ZXJ0IHRvIHBpeGVscyBpZiB2YWx1ZSBhZGp1c3RtZW50IGlzIG5lZWRlZFxuXHRcdFx0aWYgKCBzdWJ0cmFjdCAmJiAoIG1hdGNoZXMgPSByY3NzTnVtLmV4ZWMoIHZhbHVlICkgKSAmJlxuXHRcdFx0XHQoIG1hdGNoZXNbIDMgXSB8fCBcInB4XCIgKSAhPT0gXCJweFwiICkge1xuXG5cdFx0XHRcdGVsZW0uc3R5bGVbIGRpbWVuc2lvbiBdID0gdmFsdWU7XG5cdFx0XHRcdHZhbHVlID0galF1ZXJ5LmNzcyggZWxlbSwgZGltZW5zaW9uICk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBzZXRQb3NpdGl2ZU51bWJlciggZWxlbSwgdmFsdWUsIHN1YnRyYWN0ICk7XG5cdFx0fVxuXHR9O1xufSApO1xuXG5qUXVlcnkuY3NzSG9va3MubWFyZ2luTGVmdCA9IGFkZEdldEhvb2tJZiggc3VwcG9ydC5yZWxpYWJsZU1hcmdpbkxlZnQsXG5cdGZ1bmN0aW9uKCBlbGVtLCBjb21wdXRlZCApIHtcblx0XHRpZiAoIGNvbXB1dGVkICkge1xuXHRcdFx0cmV0dXJuICggcGFyc2VGbG9hdCggY3VyQ1NTKCBlbGVtLCBcIm1hcmdpbkxlZnRcIiApICkgfHxcblx0XHRcdFx0ZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0IC1cblx0XHRcdFx0XHRzd2FwKCBlbGVtLCB7IG1hcmdpbkxlZnQ6IDAgfSwgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0O1xuXHRcdFx0XHRcdH0gKVxuXHRcdFx0KSArIFwicHhcIjtcblx0XHR9XG5cdH1cbik7XG5cbi8vIFRoZXNlIGhvb2tzIGFyZSB1c2VkIGJ5IGFuaW1hdGUgdG8gZXhwYW5kIHByb3BlcnRpZXNcbmpRdWVyeS5lYWNoKCB7XG5cdG1hcmdpbjogXCJcIixcblx0cGFkZGluZzogXCJcIixcblx0Ym9yZGVyOiBcIldpZHRoXCJcbn0sIGZ1bmN0aW9uKCBwcmVmaXgsIHN1ZmZpeCApIHtcblx0alF1ZXJ5LmNzc0hvb2tzWyBwcmVmaXggKyBzdWZmaXggXSA9IHtcblx0XHRleHBhbmQ6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdHZhciBpID0gMCxcblx0XHRcdFx0ZXhwYW5kZWQgPSB7fSxcblxuXHRcdFx0XHQvLyBBc3N1bWVzIGEgc2luZ2xlIG51bWJlciBpZiBub3QgYSBzdHJpbmdcblx0XHRcdFx0cGFydHMgPSB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgPyB2YWx1ZS5zcGxpdCggXCIgXCIgKSA6IFsgdmFsdWUgXTtcblxuXHRcdFx0Zm9yICggOyBpIDwgNDsgaSsrICkge1xuXHRcdFx0XHRleHBhbmRlZFsgcHJlZml4ICsgY3NzRXhwYW5kWyBpIF0gKyBzdWZmaXggXSA9XG5cdFx0XHRcdFx0cGFydHNbIGkgXSB8fCBwYXJ0c1sgaSAtIDIgXSB8fCBwYXJ0c1sgMCBdO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZXhwYW5kZWQ7XG5cdFx0fVxuXHR9O1xuXG5cdGlmICggcHJlZml4ICE9PSBcIm1hcmdpblwiICkge1xuXHRcdGpRdWVyeS5jc3NIb29rc1sgcHJlZml4ICsgc3VmZml4IF0uc2V0ID0gc2V0UG9zaXRpdmVOdW1iZXI7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRjc3M6IGZ1bmN0aW9uKCBuYW1lLCB2YWx1ZSApIHtcblx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBmdW5jdGlvbiggZWxlbSwgbmFtZSwgdmFsdWUgKSB7XG5cdFx0XHR2YXIgc3R5bGVzLCBsZW4sXG5cdFx0XHRcdG1hcCA9IHt9LFxuXHRcdFx0XHRpID0gMDtcblxuXHRcdFx0aWYgKCBBcnJheS5pc0FycmF5KCBuYW1lICkgKSB7XG5cdFx0XHRcdHN0eWxlcyA9IGdldFN0eWxlcyggZWxlbSApO1xuXHRcdFx0XHRsZW4gPSBuYW1lLmxlbmd0aDtcblxuXHRcdFx0XHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRcdFx0XHRtYXBbIG5hbWVbIGkgXSBdID0galF1ZXJ5LmNzcyggZWxlbSwgbmFtZVsgaSBdLCBmYWxzZSwgc3R5bGVzICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gbWFwO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdmFsdWUgIT09IHVuZGVmaW5lZCA/XG5cdFx0XHRcdGpRdWVyeS5zdHlsZSggZWxlbSwgbmFtZSwgdmFsdWUgKSA6XG5cdFx0XHRcdGpRdWVyeS5jc3MoIGVsZW0sIG5hbWUgKTtcblx0XHR9LCBuYW1lLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCA+IDEgKTtcblx0fVxufSApO1xuXG5cbmZ1bmN0aW9uIFR3ZWVuKCBlbGVtLCBvcHRpb25zLCBwcm9wLCBlbmQsIGVhc2luZyApIHtcblx0cmV0dXJuIG5ldyBUd2Vlbi5wcm90b3R5cGUuaW5pdCggZWxlbSwgb3B0aW9ucywgcHJvcCwgZW5kLCBlYXNpbmcgKTtcbn1cbmpRdWVyeS5Ud2VlbiA9IFR3ZWVuO1xuXG5Ud2Vlbi5wcm90b3R5cGUgPSB7XG5cdGNvbnN0cnVjdG9yOiBUd2Vlbixcblx0aW5pdDogZnVuY3Rpb24oIGVsZW0sIG9wdGlvbnMsIHByb3AsIGVuZCwgZWFzaW5nLCB1bml0ICkge1xuXHRcdHRoaXMuZWxlbSA9IGVsZW07XG5cdFx0dGhpcy5wcm9wID0gcHJvcDtcblx0XHR0aGlzLmVhc2luZyA9IGVhc2luZyB8fCBqUXVlcnkuZWFzaW5nLl9kZWZhdWx0O1xuXHRcdHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG5cdFx0dGhpcy5zdGFydCA9IHRoaXMubm93ID0gdGhpcy5jdXIoKTtcblx0XHR0aGlzLmVuZCA9IGVuZDtcblx0XHR0aGlzLnVuaXQgPSB1bml0IHx8ICggalF1ZXJ5LmNzc051bWJlclsgcHJvcCBdID8gXCJcIiA6IFwicHhcIiApO1xuXHR9LFxuXHRjdXI6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBob29rcyA9IFR3ZWVuLnByb3BIb29rc1sgdGhpcy5wcm9wIF07XG5cblx0XHRyZXR1cm4gaG9va3MgJiYgaG9va3MuZ2V0ID9cblx0XHRcdGhvb2tzLmdldCggdGhpcyApIDpcblx0XHRcdFR3ZWVuLnByb3BIb29rcy5fZGVmYXVsdC5nZXQoIHRoaXMgKTtcblx0fSxcblx0cnVuOiBmdW5jdGlvbiggcGVyY2VudCApIHtcblx0XHR2YXIgZWFzZWQsXG5cdFx0XHRob29rcyA9IFR3ZWVuLnByb3BIb29rc1sgdGhpcy5wcm9wIF07XG5cblx0XHRpZiAoIHRoaXMub3B0aW9ucy5kdXJhdGlvbiApIHtcblx0XHRcdHRoaXMucG9zID0gZWFzZWQgPSBqUXVlcnkuZWFzaW5nWyB0aGlzLmVhc2luZyBdKFxuXHRcdFx0XHRwZXJjZW50LCB0aGlzLm9wdGlvbnMuZHVyYXRpb24gKiBwZXJjZW50LCAwLCAxLCB0aGlzLm9wdGlvbnMuZHVyYXRpb25cblx0XHRcdCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMucG9zID0gZWFzZWQgPSBwZXJjZW50O1xuXHRcdH1cblx0XHR0aGlzLm5vdyA9ICggdGhpcy5lbmQgLSB0aGlzLnN0YXJ0ICkgKiBlYXNlZCArIHRoaXMuc3RhcnQ7XG5cblx0XHRpZiAoIHRoaXMub3B0aW9ucy5zdGVwICkge1xuXHRcdFx0dGhpcy5vcHRpb25zLnN0ZXAuY2FsbCggdGhpcy5lbGVtLCB0aGlzLm5vdywgdGhpcyApO1xuXHRcdH1cblxuXHRcdGlmICggaG9va3MgJiYgaG9va3Muc2V0ICkge1xuXHRcdFx0aG9va3Muc2V0KCB0aGlzICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdFR3ZWVuLnByb3BIb29rcy5fZGVmYXVsdC5zZXQoIHRoaXMgKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cbn07XG5cblR3ZWVuLnByb3RvdHlwZS5pbml0LnByb3RvdHlwZSA9IFR3ZWVuLnByb3RvdHlwZTtcblxuVHdlZW4ucHJvcEhvb2tzID0ge1xuXHRfZGVmYXVsdDoge1xuXHRcdGdldDogZnVuY3Rpb24oIHR3ZWVuICkge1xuXHRcdFx0dmFyIHJlc3VsdDtcblxuXHRcdFx0Ly8gVXNlIGEgcHJvcGVydHkgb24gdGhlIGVsZW1lbnQgZGlyZWN0bHkgd2hlbiBpdCBpcyBub3QgYSBET00gZWxlbWVudCxcblx0XHRcdC8vIG9yIHdoZW4gdGhlcmUgaXMgbm8gbWF0Y2hpbmcgc3R5bGUgcHJvcGVydHkgdGhhdCBleGlzdHMuXG5cdFx0XHRpZiAoIHR3ZWVuLmVsZW0ubm9kZVR5cGUgIT09IDEgfHxcblx0XHRcdFx0dHdlZW4uZWxlbVsgdHdlZW4ucHJvcCBdICE9IG51bGwgJiYgdHdlZW4uZWxlbS5zdHlsZVsgdHdlZW4ucHJvcCBdID09IG51bGwgKSB7XG5cdFx0XHRcdHJldHVybiB0d2Vlbi5lbGVtWyB0d2Vlbi5wcm9wIF07XG5cdFx0XHR9XG5cblx0XHRcdC8vIFBhc3NpbmcgYW4gZW1wdHkgc3RyaW5nIGFzIGEgM3JkIHBhcmFtZXRlciB0byAuY3NzIHdpbGwgYXV0b21hdGljYWxseVxuXHRcdFx0Ly8gYXR0ZW1wdCBhIHBhcnNlRmxvYXQgYW5kIGZhbGxiYWNrIHRvIGEgc3RyaW5nIGlmIHRoZSBwYXJzZSBmYWlscy5cblx0XHRcdC8vIFNpbXBsZSB2YWx1ZXMgc3VjaCBhcyBcIjEwcHhcIiBhcmUgcGFyc2VkIHRvIEZsb2F0O1xuXHRcdFx0Ly8gY29tcGxleCB2YWx1ZXMgc3VjaCBhcyBcInJvdGF0ZSgxcmFkKVwiIGFyZSByZXR1cm5lZCBhcy1pcy5cblx0XHRcdHJlc3VsdCA9IGpRdWVyeS5jc3MoIHR3ZWVuLmVsZW0sIHR3ZWVuLnByb3AsIFwiXCIgKTtcblxuXHRcdFx0Ly8gRW1wdHkgc3RyaW5ncywgbnVsbCwgdW5kZWZpbmVkIGFuZCBcImF1dG9cIiBhcmUgY29udmVydGVkIHRvIDAuXG5cdFx0XHRyZXR1cm4gIXJlc3VsdCB8fCByZXN1bHQgPT09IFwiYXV0b1wiID8gMCA6IHJlc3VsdDtcblx0XHR9LFxuXHRcdHNldDogZnVuY3Rpb24oIHR3ZWVuICkge1xuXG5cdFx0XHQvLyBVc2Ugc3RlcCBob29rIGZvciBiYWNrIGNvbXBhdC5cblx0XHRcdC8vIFVzZSBjc3NIb29rIGlmIGl0cyB0aGVyZS5cblx0XHRcdC8vIFVzZSAuc3R5bGUgaWYgYXZhaWxhYmxlIGFuZCB1c2UgcGxhaW4gcHJvcGVydGllcyB3aGVyZSBhdmFpbGFibGUuXG5cdFx0XHRpZiAoIGpRdWVyeS5meC5zdGVwWyB0d2Vlbi5wcm9wIF0gKSB7XG5cdFx0XHRcdGpRdWVyeS5meC5zdGVwWyB0d2Vlbi5wcm9wIF0oIHR3ZWVuICk7XG5cdFx0XHR9IGVsc2UgaWYgKCB0d2Vlbi5lbGVtLm5vZGVUeXBlID09PSAxICYmIChcblx0XHRcdFx0alF1ZXJ5LmNzc0hvb2tzWyB0d2Vlbi5wcm9wIF0gfHxcblx0XHRcdFx0XHR0d2Vlbi5lbGVtLnN0eWxlWyBmaW5hbFByb3BOYW1lKCB0d2Vlbi5wcm9wICkgXSAhPSBudWxsICkgKSB7XG5cdFx0XHRcdGpRdWVyeS5zdHlsZSggdHdlZW4uZWxlbSwgdHdlZW4ucHJvcCwgdHdlZW4ubm93ICsgdHdlZW4udW5pdCApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dHdlZW4uZWxlbVsgdHdlZW4ucHJvcCBdID0gdHdlZW4ubm93O1xuXHRcdFx0fVxuXHRcdH1cblx0fVxufTtcblxuLy8gU3VwcG9ydDogSUUgPD05IG9ubHlcbi8vIFBhbmljIGJhc2VkIGFwcHJvYWNoIHRvIHNldHRpbmcgdGhpbmdzIG9uIGRpc2Nvbm5lY3RlZCBub2Rlc1xuVHdlZW4ucHJvcEhvb2tzLnNjcm9sbFRvcCA9IFR3ZWVuLnByb3BIb29rcy5zY3JvbGxMZWZ0ID0ge1xuXHRzZXQ6IGZ1bmN0aW9uKCB0d2VlbiApIHtcblx0XHRpZiAoIHR3ZWVuLmVsZW0ubm9kZVR5cGUgJiYgdHdlZW4uZWxlbS5wYXJlbnROb2RlICkge1xuXHRcdFx0dHdlZW4uZWxlbVsgdHdlZW4ucHJvcCBdID0gdHdlZW4ubm93O1xuXHRcdH1cblx0fVxufTtcblxualF1ZXJ5LmVhc2luZyA9IHtcblx0bGluZWFyOiBmdW5jdGlvbiggcCApIHtcblx0XHRyZXR1cm4gcDtcblx0fSxcblx0c3dpbmc6IGZ1bmN0aW9uKCBwICkge1xuXHRcdHJldHVybiAwLjUgLSBNYXRoLmNvcyggcCAqIE1hdGguUEkgKSAvIDI7XG5cdH0sXG5cdF9kZWZhdWx0OiBcInN3aW5nXCJcbn07XG5cbmpRdWVyeS5meCA9IFR3ZWVuLnByb3RvdHlwZS5pbml0O1xuXG4vLyBCYWNrIGNvbXBhdCA8MS44IGV4dGVuc2lvbiBwb2ludFxualF1ZXJ5LmZ4LnN0ZXAgPSB7fTtcblxuXG5cblxudmFyXG5cdGZ4Tm93LCBpblByb2dyZXNzLFxuXHRyZnh0eXBlcyA9IC9eKD86dG9nZ2xlfHNob3d8aGlkZSkkLyxcblx0cnJ1biA9IC9xdWV1ZUhvb2tzJC87XG5cbmZ1bmN0aW9uIHNjaGVkdWxlKCkge1xuXHRpZiAoIGluUHJvZ3Jlc3MgKSB7XG5cdFx0aWYgKCBkb2N1bWVudC5oaWRkZW4gPT09IGZhbHNlICYmIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgKSB7XG5cdFx0XHR3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCBzY2hlZHVsZSApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR3aW5kb3cuc2V0VGltZW91dCggc2NoZWR1bGUsIGpRdWVyeS5meC5pbnRlcnZhbCApO1xuXHRcdH1cblxuXHRcdGpRdWVyeS5meC50aWNrKCk7XG5cdH1cbn1cblxuLy8gQW5pbWF0aW9ucyBjcmVhdGVkIHN5bmNocm9ub3VzbHkgd2lsbCBydW4gc3luY2hyb25vdXNseVxuZnVuY3Rpb24gY3JlYXRlRnhOb3coKSB7XG5cdHdpbmRvdy5zZXRUaW1lb3V0KCBmdW5jdGlvbigpIHtcblx0XHRmeE5vdyA9IHVuZGVmaW5lZDtcblx0fSApO1xuXHRyZXR1cm4gKCBmeE5vdyA9IERhdGUubm93KCkgKTtcbn1cblxuLy8gR2VuZXJhdGUgcGFyYW1ldGVycyB0byBjcmVhdGUgYSBzdGFuZGFyZCBhbmltYXRpb25cbmZ1bmN0aW9uIGdlbkZ4KCB0eXBlLCBpbmNsdWRlV2lkdGggKSB7XG5cdHZhciB3aGljaCxcblx0XHRpID0gMCxcblx0XHRhdHRycyA9IHsgaGVpZ2h0OiB0eXBlIH07XG5cblx0Ly8gSWYgd2UgaW5jbHVkZSB3aWR0aCwgc3RlcCB2YWx1ZSBpcyAxIHRvIGRvIGFsbCBjc3NFeHBhbmQgdmFsdWVzLFxuXHQvLyBvdGhlcndpc2Ugc3RlcCB2YWx1ZSBpcyAyIHRvIHNraXAgb3ZlciBMZWZ0IGFuZCBSaWdodFxuXHRpbmNsdWRlV2lkdGggPSBpbmNsdWRlV2lkdGggPyAxIDogMDtcblx0Zm9yICggOyBpIDwgNDsgaSArPSAyIC0gaW5jbHVkZVdpZHRoICkge1xuXHRcdHdoaWNoID0gY3NzRXhwYW5kWyBpIF07XG5cdFx0YXR0cnNbIFwibWFyZ2luXCIgKyB3aGljaCBdID0gYXR0cnNbIFwicGFkZGluZ1wiICsgd2hpY2ggXSA9IHR5cGU7XG5cdH1cblxuXHRpZiAoIGluY2x1ZGVXaWR0aCApIHtcblx0XHRhdHRycy5vcGFjaXR5ID0gYXR0cnMud2lkdGggPSB0eXBlO1xuXHR9XG5cblx0cmV0dXJuIGF0dHJzO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVUd2VlbiggdmFsdWUsIHByb3AsIGFuaW1hdGlvbiApIHtcblx0dmFyIHR3ZWVuLFxuXHRcdGNvbGxlY3Rpb24gPSAoIEFuaW1hdGlvbi50d2VlbmVyc1sgcHJvcCBdIHx8IFtdICkuY29uY2F0KCBBbmltYXRpb24udHdlZW5lcnNbIFwiKlwiIF0gKSxcblx0XHRpbmRleCA9IDAsXG5cdFx0bGVuZ3RoID0gY29sbGVjdGlvbi5sZW5ndGg7XG5cdGZvciAoIDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XG5cdFx0aWYgKCAoIHR3ZWVuID0gY29sbGVjdGlvblsgaW5kZXggXS5jYWxsKCBhbmltYXRpb24sIHByb3AsIHZhbHVlICkgKSApIHtcblxuXHRcdFx0Ly8gV2UncmUgZG9uZSB3aXRoIHRoaXMgcHJvcGVydHlcblx0XHRcdHJldHVybiB0d2Vlbjtcblx0XHR9XG5cdH1cbn1cblxuZnVuY3Rpb24gZGVmYXVsdFByZWZpbHRlciggZWxlbSwgcHJvcHMsIG9wdHMgKSB7XG5cdHZhciBwcm9wLCB2YWx1ZSwgdG9nZ2xlLCBob29rcywgb2xkZmlyZSwgcHJvcFR3ZWVuLCByZXN0b3JlRGlzcGxheSwgZGlzcGxheSxcblx0XHRpc0JveCA9IFwid2lkdGhcIiBpbiBwcm9wcyB8fCBcImhlaWdodFwiIGluIHByb3BzLFxuXHRcdGFuaW0gPSB0aGlzLFxuXHRcdG9yaWcgPSB7fSxcblx0XHRzdHlsZSA9IGVsZW0uc3R5bGUsXG5cdFx0aGlkZGVuID0gZWxlbS5ub2RlVHlwZSAmJiBpc0hpZGRlbldpdGhpblRyZWUoIGVsZW0gKSxcblx0XHRkYXRhU2hvdyA9IGRhdGFQcml2LmdldCggZWxlbSwgXCJmeHNob3dcIiApO1xuXG5cdC8vIFF1ZXVlLXNraXBwaW5nIGFuaW1hdGlvbnMgaGlqYWNrIHRoZSBmeCBob29rc1xuXHRpZiAoICFvcHRzLnF1ZXVlICkge1xuXHRcdGhvb2tzID0galF1ZXJ5Ll9xdWV1ZUhvb2tzKCBlbGVtLCBcImZ4XCIgKTtcblx0XHRpZiAoIGhvb2tzLnVucXVldWVkID09IG51bGwgKSB7XG5cdFx0XHRob29rcy51bnF1ZXVlZCA9IDA7XG5cdFx0XHRvbGRmaXJlID0gaG9va3MuZW1wdHkuZmlyZTtcblx0XHRcdGhvb2tzLmVtcHR5LmZpcmUgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCAhaG9va3MudW5xdWV1ZWQgKSB7XG5cdFx0XHRcdFx0b2xkZmlyZSgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdH1cblx0XHRob29rcy51bnF1ZXVlZCsrO1xuXG5cdFx0YW5pbS5hbHdheXMoIGZ1bmN0aW9uKCkge1xuXG5cdFx0XHQvLyBFbnN1cmUgdGhlIGNvbXBsZXRlIGhhbmRsZXIgaXMgY2FsbGVkIGJlZm9yZSB0aGlzIGNvbXBsZXRlc1xuXHRcdFx0YW5pbS5hbHdheXMoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRob29rcy51bnF1ZXVlZC0tO1xuXHRcdFx0XHRpZiAoICFqUXVlcnkucXVldWUoIGVsZW0sIFwiZnhcIiApLmxlbmd0aCApIHtcblx0XHRcdFx0XHRob29rcy5lbXB0eS5maXJlKCk7XG5cdFx0XHRcdH1cblx0XHRcdH0gKTtcblx0XHR9ICk7XG5cdH1cblxuXHQvLyBEZXRlY3Qgc2hvdy9oaWRlIGFuaW1hdGlvbnNcblx0Zm9yICggcHJvcCBpbiBwcm9wcyApIHtcblx0XHR2YWx1ZSA9IHByb3BzWyBwcm9wIF07XG5cdFx0aWYgKCByZnh0eXBlcy50ZXN0KCB2YWx1ZSApICkge1xuXHRcdFx0ZGVsZXRlIHByb3BzWyBwcm9wIF07XG5cdFx0XHR0b2dnbGUgPSB0b2dnbGUgfHwgdmFsdWUgPT09IFwidG9nZ2xlXCI7XG5cdFx0XHRpZiAoIHZhbHVlID09PSAoIGhpZGRlbiA/IFwiaGlkZVwiIDogXCJzaG93XCIgKSApIHtcblxuXHRcdFx0XHQvLyBQcmV0ZW5kIHRvIGJlIGhpZGRlbiBpZiB0aGlzIGlzIGEgXCJzaG93XCIgYW5kXG5cdFx0XHRcdC8vIHRoZXJlIGlzIHN0aWxsIGRhdGEgZnJvbSBhIHN0b3BwZWQgc2hvdy9oaWRlXG5cdFx0XHRcdGlmICggdmFsdWUgPT09IFwic2hvd1wiICYmIGRhdGFTaG93ICYmIGRhdGFTaG93WyBwcm9wIF0gIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRoaWRkZW4gPSB0cnVlO1xuXG5cdFx0XHRcdC8vIElnbm9yZSBhbGwgb3RoZXIgbm8tb3Agc2hvdy9oaWRlIGRhdGFcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0b3JpZ1sgcHJvcCBdID0gZGF0YVNob3cgJiYgZGF0YVNob3dbIHByb3AgXSB8fCBqUXVlcnkuc3R5bGUoIGVsZW0sIHByb3AgKTtcblx0XHR9XG5cdH1cblxuXHQvLyBCYWlsIG91dCBpZiB0aGlzIGlzIGEgbm8tb3AgbGlrZSAuaGlkZSgpLmhpZGUoKVxuXHRwcm9wVHdlZW4gPSAhalF1ZXJ5LmlzRW1wdHlPYmplY3QoIHByb3BzICk7XG5cdGlmICggIXByb3BUd2VlbiAmJiBqUXVlcnkuaXNFbXB0eU9iamVjdCggb3JpZyApICkge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdC8vIFJlc3RyaWN0IFwib3ZlcmZsb3dcIiBhbmQgXCJkaXNwbGF5XCIgc3R5bGVzIGR1cmluZyBib3ggYW5pbWF0aW9uc1xuXHRpZiAoIGlzQm94ICYmIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cblx0XHQvLyBTdXBwb3J0OiBJRSA8PTkgLSAxMSwgRWRnZSAxMiAtIDE1XG5cdFx0Ly8gUmVjb3JkIGFsbCAzIG92ZXJmbG93IGF0dHJpYnV0ZXMgYmVjYXVzZSBJRSBkb2VzIG5vdCBpbmZlciB0aGUgc2hvcnRoYW5kXG5cdFx0Ly8gZnJvbSBpZGVudGljYWxseS12YWx1ZWQgb3ZlcmZsb3dYIGFuZCBvdmVyZmxvd1kgYW5kIEVkZ2UganVzdCBtaXJyb3JzXG5cdFx0Ly8gdGhlIG92ZXJmbG93WCB2YWx1ZSB0aGVyZS5cblx0XHRvcHRzLm92ZXJmbG93ID0gWyBzdHlsZS5vdmVyZmxvdywgc3R5bGUub3ZlcmZsb3dYLCBzdHlsZS5vdmVyZmxvd1kgXTtcblxuXHRcdC8vIElkZW50aWZ5IGEgZGlzcGxheSB0eXBlLCBwcmVmZXJyaW5nIG9sZCBzaG93L2hpZGUgZGF0YSBvdmVyIHRoZSBDU1MgY2FzY2FkZVxuXHRcdHJlc3RvcmVEaXNwbGF5ID0gZGF0YVNob3cgJiYgZGF0YVNob3cuZGlzcGxheTtcblx0XHRpZiAoIHJlc3RvcmVEaXNwbGF5ID09IG51bGwgKSB7XG5cdFx0XHRyZXN0b3JlRGlzcGxheSA9IGRhdGFQcml2LmdldCggZWxlbSwgXCJkaXNwbGF5XCIgKTtcblx0XHR9XG5cdFx0ZGlzcGxheSA9IGpRdWVyeS5jc3MoIGVsZW0sIFwiZGlzcGxheVwiICk7XG5cdFx0aWYgKCBkaXNwbGF5ID09PSBcIm5vbmVcIiApIHtcblx0XHRcdGlmICggcmVzdG9yZURpc3BsYXkgKSB7XG5cdFx0XHRcdGRpc3BsYXkgPSByZXN0b3JlRGlzcGxheTtcblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Ly8gR2V0IG5vbmVtcHR5IHZhbHVlKHMpIGJ5IHRlbXBvcmFyaWx5IGZvcmNpbmcgdmlzaWJpbGl0eVxuXHRcdFx0XHRzaG93SGlkZSggWyBlbGVtIF0sIHRydWUgKTtcblx0XHRcdFx0cmVzdG9yZURpc3BsYXkgPSBlbGVtLnN0eWxlLmRpc3BsYXkgfHwgcmVzdG9yZURpc3BsYXk7XG5cdFx0XHRcdGRpc3BsYXkgPSBqUXVlcnkuY3NzKCBlbGVtLCBcImRpc3BsYXlcIiApO1xuXHRcdFx0XHRzaG93SGlkZSggWyBlbGVtIF0gKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBBbmltYXRlIGlubGluZSBlbGVtZW50cyBhcyBpbmxpbmUtYmxvY2tcblx0XHRpZiAoIGRpc3BsYXkgPT09IFwiaW5saW5lXCIgfHwgZGlzcGxheSA9PT0gXCJpbmxpbmUtYmxvY2tcIiAmJiByZXN0b3JlRGlzcGxheSAhPSBudWxsICkge1xuXHRcdFx0aWYgKCBqUXVlcnkuY3NzKCBlbGVtLCBcImZsb2F0XCIgKSA9PT0gXCJub25lXCIgKSB7XG5cblx0XHRcdFx0Ly8gUmVzdG9yZSB0aGUgb3JpZ2luYWwgZGlzcGxheSB2YWx1ZSBhdCB0aGUgZW5kIG9mIHB1cmUgc2hvdy9oaWRlIGFuaW1hdGlvbnNcblx0XHRcdFx0aWYgKCAhcHJvcFR3ZWVuICkge1xuXHRcdFx0XHRcdGFuaW0uZG9uZSggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRzdHlsZS5kaXNwbGF5ID0gcmVzdG9yZURpc3BsYXk7XG5cdFx0XHRcdFx0fSApO1xuXHRcdFx0XHRcdGlmICggcmVzdG9yZURpc3BsYXkgPT0gbnVsbCApIHtcblx0XHRcdFx0XHRcdGRpc3BsYXkgPSBzdHlsZS5kaXNwbGF5O1xuXHRcdFx0XHRcdFx0cmVzdG9yZURpc3BsYXkgPSBkaXNwbGF5ID09PSBcIm5vbmVcIiA/IFwiXCIgOiBkaXNwbGF5O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRzdHlsZS5kaXNwbGF5ID0gXCJpbmxpbmUtYmxvY2tcIjtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRpZiAoIG9wdHMub3ZlcmZsb3cgKSB7XG5cdFx0c3R5bGUub3ZlcmZsb3cgPSBcImhpZGRlblwiO1xuXHRcdGFuaW0uYWx3YXlzKCBmdW5jdGlvbigpIHtcblx0XHRcdHN0eWxlLm92ZXJmbG93ID0gb3B0cy5vdmVyZmxvd1sgMCBdO1xuXHRcdFx0c3R5bGUub3ZlcmZsb3dYID0gb3B0cy5vdmVyZmxvd1sgMSBdO1xuXHRcdFx0c3R5bGUub3ZlcmZsb3dZID0gb3B0cy5vdmVyZmxvd1sgMiBdO1xuXHRcdH0gKTtcblx0fVxuXG5cdC8vIEltcGxlbWVudCBzaG93L2hpZGUgYW5pbWF0aW9uc1xuXHRwcm9wVHdlZW4gPSBmYWxzZTtcblx0Zm9yICggcHJvcCBpbiBvcmlnICkge1xuXG5cdFx0Ly8gR2VuZXJhbCBzaG93L2hpZGUgc2V0dXAgZm9yIHRoaXMgZWxlbWVudCBhbmltYXRpb25cblx0XHRpZiAoICFwcm9wVHdlZW4gKSB7XG5cdFx0XHRpZiAoIGRhdGFTaG93ICkge1xuXHRcdFx0XHRpZiAoIFwiaGlkZGVuXCIgaW4gZGF0YVNob3cgKSB7XG5cdFx0XHRcdFx0aGlkZGVuID0gZGF0YVNob3cuaGlkZGVuO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRkYXRhU2hvdyA9IGRhdGFQcml2LmFjY2VzcyggZWxlbSwgXCJmeHNob3dcIiwgeyBkaXNwbGF5OiByZXN0b3JlRGlzcGxheSB9ICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN0b3JlIGhpZGRlbi92aXNpYmxlIGZvciB0b2dnbGUgc28gYC5zdG9wKCkudG9nZ2xlKClgIFwicmV2ZXJzZXNcIlxuXHRcdFx0aWYgKCB0b2dnbGUgKSB7XG5cdFx0XHRcdGRhdGFTaG93LmhpZGRlbiA9ICFoaWRkZW47XG5cdFx0XHR9XG5cblx0XHRcdC8vIFNob3cgZWxlbWVudHMgYmVmb3JlIGFuaW1hdGluZyB0aGVtXG5cdFx0XHRpZiAoIGhpZGRlbiApIHtcblx0XHRcdFx0c2hvd0hpZGUoIFsgZWxlbSBdLCB0cnVlICk7XG5cdFx0XHR9XG5cblx0XHRcdC8qIGVzbGludC1kaXNhYmxlIG5vLWxvb3AtZnVuYyAqL1xuXG5cdFx0XHRhbmltLmRvbmUoIGZ1bmN0aW9uKCkge1xuXG5cdFx0XHRcdC8qIGVzbGludC1lbmFibGUgbm8tbG9vcC1mdW5jICovXG5cblx0XHRcdFx0Ly8gVGhlIGZpbmFsIHN0ZXAgb2YgYSBcImhpZGVcIiBhbmltYXRpb24gaXMgYWN0dWFsbHkgaGlkaW5nIHRoZSBlbGVtZW50XG5cdFx0XHRcdGlmICggIWhpZGRlbiApIHtcblx0XHRcdFx0XHRzaG93SGlkZSggWyBlbGVtIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRkYXRhUHJpdi5yZW1vdmUoIGVsZW0sIFwiZnhzaG93XCIgKTtcblx0XHRcdFx0Zm9yICggcHJvcCBpbiBvcmlnICkge1xuXHRcdFx0XHRcdGpRdWVyeS5zdHlsZSggZWxlbSwgcHJvcCwgb3JpZ1sgcHJvcCBdICk7XG5cdFx0XHRcdH1cblx0XHRcdH0gKTtcblx0XHR9XG5cblx0XHQvLyBQZXItcHJvcGVydHkgc2V0dXBcblx0XHRwcm9wVHdlZW4gPSBjcmVhdGVUd2VlbiggaGlkZGVuID8gZGF0YVNob3dbIHByb3AgXSA6IDAsIHByb3AsIGFuaW0gKTtcblx0XHRpZiAoICEoIHByb3AgaW4gZGF0YVNob3cgKSApIHtcblx0XHRcdGRhdGFTaG93WyBwcm9wIF0gPSBwcm9wVHdlZW4uc3RhcnQ7XG5cdFx0XHRpZiAoIGhpZGRlbiApIHtcblx0XHRcdFx0cHJvcFR3ZWVuLmVuZCA9IHByb3BUd2Vlbi5zdGFydDtcblx0XHRcdFx0cHJvcFR3ZWVuLnN0YXJ0ID0gMDtcblx0XHRcdH1cblx0XHR9XG5cdH1cbn1cblxuZnVuY3Rpb24gcHJvcEZpbHRlciggcHJvcHMsIHNwZWNpYWxFYXNpbmcgKSB7XG5cdHZhciBpbmRleCwgbmFtZSwgZWFzaW5nLCB2YWx1ZSwgaG9va3M7XG5cblx0Ly8gY2FtZWxDYXNlLCBzcGVjaWFsRWFzaW5nIGFuZCBleHBhbmQgY3NzSG9vayBwYXNzXG5cdGZvciAoIGluZGV4IGluIHByb3BzICkge1xuXHRcdG5hbWUgPSBjYW1lbENhc2UoIGluZGV4ICk7XG5cdFx0ZWFzaW5nID0gc3BlY2lhbEVhc2luZ1sgbmFtZSBdO1xuXHRcdHZhbHVlID0gcHJvcHNbIGluZGV4IF07XG5cdFx0aWYgKCBBcnJheS5pc0FycmF5KCB2YWx1ZSApICkge1xuXHRcdFx0ZWFzaW5nID0gdmFsdWVbIDEgXTtcblx0XHRcdHZhbHVlID0gcHJvcHNbIGluZGV4IF0gPSB2YWx1ZVsgMCBdO1xuXHRcdH1cblxuXHRcdGlmICggaW5kZXggIT09IG5hbWUgKSB7XG5cdFx0XHRwcm9wc1sgbmFtZSBdID0gdmFsdWU7XG5cdFx0XHRkZWxldGUgcHJvcHNbIGluZGV4IF07XG5cdFx0fVxuXG5cdFx0aG9va3MgPSBqUXVlcnkuY3NzSG9va3NbIG5hbWUgXTtcblx0XHRpZiAoIGhvb2tzICYmIFwiZXhwYW5kXCIgaW4gaG9va3MgKSB7XG5cdFx0XHR2YWx1ZSA9IGhvb2tzLmV4cGFuZCggdmFsdWUgKTtcblx0XHRcdGRlbGV0ZSBwcm9wc1sgbmFtZSBdO1xuXG5cdFx0XHQvLyBOb3QgcXVpdGUgJC5leHRlbmQsIHRoaXMgd29uJ3Qgb3ZlcndyaXRlIGV4aXN0aW5nIGtleXMuXG5cdFx0XHQvLyBSZXVzaW5nICdpbmRleCcgYmVjYXVzZSB3ZSBoYXZlIHRoZSBjb3JyZWN0IFwibmFtZVwiXG5cdFx0XHRmb3IgKCBpbmRleCBpbiB2YWx1ZSApIHtcblx0XHRcdFx0aWYgKCAhKCBpbmRleCBpbiBwcm9wcyApICkge1xuXHRcdFx0XHRcdHByb3BzWyBpbmRleCBdID0gdmFsdWVbIGluZGV4IF07XG5cdFx0XHRcdFx0c3BlY2lhbEVhc2luZ1sgaW5kZXggXSA9IGVhc2luZztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRzcGVjaWFsRWFzaW5nWyBuYW1lIF0gPSBlYXNpbmc7XG5cdFx0fVxuXHR9XG59XG5cbmZ1bmN0aW9uIEFuaW1hdGlvbiggZWxlbSwgcHJvcGVydGllcywgb3B0aW9ucyApIHtcblx0dmFyIHJlc3VsdCxcblx0XHRzdG9wcGVkLFxuXHRcdGluZGV4ID0gMCxcblx0XHRsZW5ndGggPSBBbmltYXRpb24ucHJlZmlsdGVycy5sZW5ndGgsXG5cdFx0ZGVmZXJyZWQgPSBqUXVlcnkuRGVmZXJyZWQoKS5hbHdheXMoIGZ1bmN0aW9uKCkge1xuXG5cdFx0XHQvLyBEb24ndCBtYXRjaCBlbGVtIGluIHRoZSA6YW5pbWF0ZWQgc2VsZWN0b3Jcblx0XHRcdGRlbGV0ZSB0aWNrLmVsZW07XG5cdFx0fSApLFxuXHRcdHRpY2sgPSBmdW5jdGlvbigpIHtcblx0XHRcdGlmICggc3RvcHBlZCApIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdFx0dmFyIGN1cnJlbnRUaW1lID0gZnhOb3cgfHwgY3JlYXRlRnhOb3coKSxcblx0XHRcdFx0cmVtYWluaW5nID0gTWF0aC5tYXgoIDAsIGFuaW1hdGlvbi5zdGFydFRpbWUgKyBhbmltYXRpb24uZHVyYXRpb24gLSBjdXJyZW50VGltZSApLFxuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgMi4zIG9ubHlcblx0XHRcdFx0Ly8gQXJjaGFpYyBjcmFzaCBidWcgd29uJ3QgYWxsb3cgdXMgdG8gdXNlIGAxIC0gKCAwLjUgfHwgMCApYCAodHJhYy0xMjQ5Nylcblx0XHRcdFx0dGVtcCA9IHJlbWFpbmluZyAvIGFuaW1hdGlvbi5kdXJhdGlvbiB8fCAwLFxuXHRcdFx0XHRwZXJjZW50ID0gMSAtIHRlbXAsXG5cdFx0XHRcdGluZGV4ID0gMCxcblx0XHRcdFx0bGVuZ3RoID0gYW5pbWF0aW9uLnR3ZWVucy5sZW5ndGg7XG5cblx0XHRcdGZvciAoIDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XG5cdFx0XHRcdGFuaW1hdGlvbi50d2VlbnNbIGluZGV4IF0ucnVuKCBwZXJjZW50ICk7XG5cdFx0XHR9XG5cblx0XHRcdGRlZmVycmVkLm5vdGlmeVdpdGgoIGVsZW0sIFsgYW5pbWF0aW9uLCBwZXJjZW50LCByZW1haW5pbmcgXSApO1xuXG5cdFx0XHQvLyBJZiB0aGVyZSdzIG1vcmUgdG8gZG8sIHlpZWxkXG5cdFx0XHRpZiAoIHBlcmNlbnQgPCAxICYmIGxlbmd0aCApIHtcblx0XHRcdFx0cmV0dXJuIHJlbWFpbmluZztcblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgdGhpcyB3YXMgYW4gZW1wdHkgYW5pbWF0aW9uLCBzeW50aGVzaXplIGEgZmluYWwgcHJvZ3Jlc3Mgbm90aWZpY2F0aW9uXG5cdFx0XHRpZiAoICFsZW5ndGggKSB7XG5cdFx0XHRcdGRlZmVycmVkLm5vdGlmeVdpdGgoIGVsZW0sIFsgYW5pbWF0aW9uLCAxLCAwIF0gKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gUmVzb2x2ZSB0aGUgYW5pbWF0aW9uIGFuZCByZXBvcnQgaXRzIGNvbmNsdXNpb25cblx0XHRcdGRlZmVycmVkLnJlc29sdmVXaXRoKCBlbGVtLCBbIGFuaW1hdGlvbiBdICk7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fSxcblx0XHRhbmltYXRpb24gPSBkZWZlcnJlZC5wcm9taXNlKCB7XG5cdFx0XHRlbGVtOiBlbGVtLFxuXHRcdFx0cHJvcHM6IGpRdWVyeS5leHRlbmQoIHt9LCBwcm9wZXJ0aWVzICksXG5cdFx0XHRvcHRzOiBqUXVlcnkuZXh0ZW5kKCB0cnVlLCB7XG5cdFx0XHRcdHNwZWNpYWxFYXNpbmc6IHt9LFxuXHRcdFx0XHRlYXNpbmc6IGpRdWVyeS5lYXNpbmcuX2RlZmF1bHRcblx0XHRcdH0sIG9wdGlvbnMgKSxcblx0XHRcdG9yaWdpbmFsUHJvcGVydGllczogcHJvcGVydGllcyxcblx0XHRcdG9yaWdpbmFsT3B0aW9uczogb3B0aW9ucyxcblx0XHRcdHN0YXJ0VGltZTogZnhOb3cgfHwgY3JlYXRlRnhOb3coKSxcblx0XHRcdGR1cmF0aW9uOiBvcHRpb25zLmR1cmF0aW9uLFxuXHRcdFx0dHdlZW5zOiBbXSxcblx0XHRcdGNyZWF0ZVR3ZWVuOiBmdW5jdGlvbiggcHJvcCwgZW5kICkge1xuXHRcdFx0XHR2YXIgdHdlZW4gPSBqUXVlcnkuVHdlZW4oIGVsZW0sIGFuaW1hdGlvbi5vcHRzLCBwcm9wLCBlbmQsXG5cdFx0XHRcdFx0YW5pbWF0aW9uLm9wdHMuc3BlY2lhbEVhc2luZ1sgcHJvcCBdIHx8IGFuaW1hdGlvbi5vcHRzLmVhc2luZyApO1xuXHRcdFx0XHRhbmltYXRpb24udHdlZW5zLnB1c2goIHR3ZWVuICk7XG5cdFx0XHRcdHJldHVybiB0d2Vlbjtcblx0XHRcdH0sXG5cdFx0XHRzdG9wOiBmdW5jdGlvbiggZ290b0VuZCApIHtcblx0XHRcdFx0dmFyIGluZGV4ID0gMCxcblxuXHRcdFx0XHRcdC8vIElmIHdlIGFyZSBnb2luZyB0byB0aGUgZW5kLCB3ZSB3YW50IHRvIHJ1biBhbGwgdGhlIHR3ZWVuc1xuXHRcdFx0XHRcdC8vIG90aGVyd2lzZSB3ZSBza2lwIHRoaXMgcGFydFxuXHRcdFx0XHRcdGxlbmd0aCA9IGdvdG9FbmQgPyBhbmltYXRpb24udHdlZW5zLmxlbmd0aCA6IDA7XG5cdFx0XHRcdGlmICggc3RvcHBlZCApIHtcblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fVxuXHRcdFx0XHRzdG9wcGVkID0gdHJ1ZTtcblx0XHRcdFx0Zm9yICggOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRcdFx0XHRhbmltYXRpb24udHdlZW5zWyBpbmRleCBdLnJ1biggMSApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gUmVzb2x2ZSB3aGVuIHdlIHBsYXllZCB0aGUgbGFzdCBmcmFtZTsgb3RoZXJ3aXNlLCByZWplY3Rcblx0XHRcdFx0aWYgKCBnb3RvRW5kICkge1xuXHRcdFx0XHRcdGRlZmVycmVkLm5vdGlmeVdpdGgoIGVsZW0sIFsgYW5pbWF0aW9uLCAxLCAwIF0gKTtcblx0XHRcdFx0XHRkZWZlcnJlZC5yZXNvbHZlV2l0aCggZWxlbSwgWyBhbmltYXRpb24sIGdvdG9FbmQgXSApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGRlZmVycmVkLnJlamVjdFdpdGgoIGVsZW0sIFsgYW5pbWF0aW9uLCBnb3RvRW5kIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH1cblx0XHR9ICksXG5cdFx0cHJvcHMgPSBhbmltYXRpb24ucHJvcHM7XG5cblx0cHJvcEZpbHRlciggcHJvcHMsIGFuaW1hdGlvbi5vcHRzLnNwZWNpYWxFYXNpbmcgKTtcblxuXHRmb3IgKCA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuXHRcdHJlc3VsdCA9IEFuaW1hdGlvbi5wcmVmaWx0ZXJzWyBpbmRleCBdLmNhbGwoIGFuaW1hdGlvbiwgZWxlbSwgcHJvcHMsIGFuaW1hdGlvbi5vcHRzICk7XG5cdFx0aWYgKCByZXN1bHQgKSB7XG5cdFx0XHRpZiAoIGlzRnVuY3Rpb24oIHJlc3VsdC5zdG9wICkgKSB7XG5cdFx0XHRcdGpRdWVyeS5fcXVldWVIb29rcyggYW5pbWF0aW9uLmVsZW0sIGFuaW1hdGlvbi5vcHRzLnF1ZXVlICkuc3RvcCA9XG5cdFx0XHRcdFx0cmVzdWx0LnN0b3AuYmluZCggcmVzdWx0ICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcmVzdWx0O1xuXHRcdH1cblx0fVxuXG5cdGpRdWVyeS5tYXAoIHByb3BzLCBjcmVhdGVUd2VlbiwgYW5pbWF0aW9uICk7XG5cblx0aWYgKCBpc0Z1bmN0aW9uKCBhbmltYXRpb24ub3B0cy5zdGFydCApICkge1xuXHRcdGFuaW1hdGlvbi5vcHRzLnN0YXJ0LmNhbGwoIGVsZW0sIGFuaW1hdGlvbiApO1xuXHR9XG5cblx0Ly8gQXR0YWNoIGNhbGxiYWNrcyBmcm9tIG9wdGlvbnNcblx0YW5pbWF0aW9uXG5cdFx0LnByb2dyZXNzKCBhbmltYXRpb24ub3B0cy5wcm9ncmVzcyApXG5cdFx0LmRvbmUoIGFuaW1hdGlvbi5vcHRzLmRvbmUsIGFuaW1hdGlvbi5vcHRzLmNvbXBsZXRlIClcblx0XHQuZmFpbCggYW5pbWF0aW9uLm9wdHMuZmFpbCApXG5cdFx0LmFsd2F5cyggYW5pbWF0aW9uLm9wdHMuYWx3YXlzICk7XG5cblx0alF1ZXJ5LmZ4LnRpbWVyKFxuXHRcdGpRdWVyeS5leHRlbmQoIHRpY2ssIHtcblx0XHRcdGVsZW06IGVsZW0sXG5cdFx0XHRhbmltOiBhbmltYXRpb24sXG5cdFx0XHRxdWV1ZTogYW5pbWF0aW9uLm9wdHMucXVldWVcblx0XHR9IClcblx0KTtcblxuXHRyZXR1cm4gYW5pbWF0aW9uO1xufVxuXG5qUXVlcnkuQW5pbWF0aW9uID0galF1ZXJ5LmV4dGVuZCggQW5pbWF0aW9uLCB7XG5cblx0dHdlZW5lcnM6IHtcblx0XHRcIipcIjogWyBmdW5jdGlvbiggcHJvcCwgdmFsdWUgKSB7XG5cdFx0XHR2YXIgdHdlZW4gPSB0aGlzLmNyZWF0ZVR3ZWVuKCBwcm9wLCB2YWx1ZSApO1xuXHRcdFx0YWRqdXN0Q1NTKCB0d2Vlbi5lbGVtLCBwcm9wLCByY3NzTnVtLmV4ZWMoIHZhbHVlICksIHR3ZWVuICk7XG5cdFx0XHRyZXR1cm4gdHdlZW47XG5cdFx0fSBdXG5cdH0sXG5cblx0dHdlZW5lcjogZnVuY3Rpb24oIHByb3BzLCBjYWxsYmFjayApIHtcblx0XHRpZiAoIGlzRnVuY3Rpb24oIHByb3BzICkgKSB7XG5cdFx0XHRjYWxsYmFjayA9IHByb3BzO1xuXHRcdFx0cHJvcHMgPSBbIFwiKlwiIF07XG5cdFx0fSBlbHNlIHtcblx0XHRcdHByb3BzID0gcHJvcHMubWF0Y2goIHJub3RodG1sd2hpdGUgKTtcblx0XHR9XG5cblx0XHR2YXIgcHJvcCxcblx0XHRcdGluZGV4ID0gMCxcblx0XHRcdGxlbmd0aCA9IHByb3BzLmxlbmd0aDtcblxuXHRcdGZvciAoIDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XG5cdFx0XHRwcm9wID0gcHJvcHNbIGluZGV4IF07XG5cdFx0XHRBbmltYXRpb24udHdlZW5lcnNbIHByb3AgXSA9IEFuaW1hdGlvbi50d2VlbmVyc1sgcHJvcCBdIHx8IFtdO1xuXHRcdFx0QW5pbWF0aW9uLnR3ZWVuZXJzWyBwcm9wIF0udW5zaGlmdCggY2FsbGJhY2sgKTtcblx0XHR9XG5cdH0sXG5cblx0cHJlZmlsdGVyczogWyBkZWZhdWx0UHJlZmlsdGVyIF0sXG5cblx0cHJlZmlsdGVyOiBmdW5jdGlvbiggY2FsbGJhY2ssIHByZXBlbmQgKSB7XG5cdFx0aWYgKCBwcmVwZW5kICkge1xuXHRcdFx0QW5pbWF0aW9uLnByZWZpbHRlcnMudW5zaGlmdCggY2FsbGJhY2sgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0QW5pbWF0aW9uLnByZWZpbHRlcnMucHVzaCggY2FsbGJhY2sgKTtcblx0XHR9XG5cdH1cbn0gKTtcblxualF1ZXJ5LnNwZWVkID0gZnVuY3Rpb24oIHNwZWVkLCBlYXNpbmcsIGZuICkge1xuXHR2YXIgb3B0ID0gc3BlZWQgJiYgdHlwZW9mIHNwZWVkID09PSBcIm9iamVjdFwiID8galF1ZXJ5LmV4dGVuZCgge30sIHNwZWVkICkgOiB7XG5cdFx0Y29tcGxldGU6IGZuIHx8ICFmbiAmJiBlYXNpbmcgfHxcblx0XHRcdGlzRnVuY3Rpb24oIHNwZWVkICkgJiYgc3BlZWQsXG5cdFx0ZHVyYXRpb246IHNwZWVkLFxuXHRcdGVhc2luZzogZm4gJiYgZWFzaW5nIHx8IGVhc2luZyAmJiAhaXNGdW5jdGlvbiggZWFzaW5nICkgJiYgZWFzaW5nXG5cdH07XG5cblx0Ly8gR28gdG8gdGhlIGVuZCBzdGF0ZSBpZiBmeCBhcmUgb2ZmXG5cdGlmICggalF1ZXJ5LmZ4Lm9mZiApIHtcblx0XHRvcHQuZHVyYXRpb24gPSAwO1xuXG5cdH0gZWxzZSB7XG5cdFx0aWYgKCB0eXBlb2Ygb3B0LmR1cmF0aW9uICE9PSBcIm51bWJlclwiICkge1xuXHRcdFx0aWYgKCBvcHQuZHVyYXRpb24gaW4galF1ZXJ5LmZ4LnNwZWVkcyApIHtcblx0XHRcdFx0b3B0LmR1cmF0aW9uID0galF1ZXJ5LmZ4LnNwZWVkc1sgb3B0LmR1cmF0aW9uIF07XG5cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG9wdC5kdXJhdGlvbiA9IGpRdWVyeS5meC5zcGVlZHMuX2RlZmF1bHQ7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gTm9ybWFsaXplIG9wdC5xdWV1ZSAtIHRydWUvdW5kZWZpbmVkL251bGwgLT4gXCJmeFwiXG5cdGlmICggb3B0LnF1ZXVlID09IG51bGwgfHwgb3B0LnF1ZXVlID09PSB0cnVlICkge1xuXHRcdG9wdC5xdWV1ZSA9IFwiZnhcIjtcblx0fVxuXG5cdC8vIFF1ZXVlaW5nXG5cdG9wdC5vbGQgPSBvcHQuY29tcGxldGU7XG5cblx0b3B0LmNvbXBsZXRlID0gZnVuY3Rpb24oKSB7XG5cdFx0aWYgKCBpc0Z1bmN0aW9uKCBvcHQub2xkICkgKSB7XG5cdFx0XHRvcHQub2xkLmNhbGwoIHRoaXMgKTtcblx0XHR9XG5cblx0XHRpZiAoIG9wdC5xdWV1ZSApIHtcblx0XHRcdGpRdWVyeS5kZXF1ZXVlKCB0aGlzLCBvcHQucXVldWUgKTtcblx0XHR9XG5cdH07XG5cblx0cmV0dXJuIG9wdDtcbn07XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0ZmFkZVRvOiBmdW5jdGlvbiggc3BlZWQsIHRvLCBlYXNpbmcsIGNhbGxiYWNrICkge1xuXG5cdFx0Ly8gU2hvdyBhbnkgaGlkZGVuIGVsZW1lbnRzIGFmdGVyIHNldHRpbmcgb3BhY2l0eSB0byAwXG5cdFx0cmV0dXJuIHRoaXMuZmlsdGVyKCBpc0hpZGRlbldpdGhpblRyZWUgKS5jc3MoIFwib3BhY2l0eVwiLCAwICkuc2hvdygpXG5cblx0XHRcdC8vIEFuaW1hdGUgdG8gdGhlIHZhbHVlIHNwZWNpZmllZFxuXHRcdFx0LmVuZCgpLmFuaW1hdGUoIHsgb3BhY2l0eTogdG8gfSwgc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKTtcblx0fSxcblx0YW5pbWF0ZTogZnVuY3Rpb24oIHByb3AsIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICkge1xuXHRcdHZhciBlbXB0eSA9IGpRdWVyeS5pc0VtcHR5T2JqZWN0KCBwcm9wICksXG5cdFx0XHRvcHRhbGwgPSBqUXVlcnkuc3BlZWQoIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICksXG5cdFx0XHRkb0FuaW1hdGlvbiA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0XHRcdC8vIE9wZXJhdGUgb24gYSBjb3B5IG9mIHByb3Agc28gcGVyLXByb3BlcnR5IGVhc2luZyB3b24ndCBiZSBsb3N0XG5cdFx0XHRcdHZhciBhbmltID0gQW5pbWF0aW9uKCB0aGlzLCBqUXVlcnkuZXh0ZW5kKCB7fSwgcHJvcCApLCBvcHRhbGwgKTtcblxuXHRcdFx0XHQvLyBFbXB0eSBhbmltYXRpb25zLCBvciBmaW5pc2hpbmcgcmVzb2x2ZXMgaW1tZWRpYXRlbHlcblx0XHRcdFx0aWYgKCBlbXB0eSB8fCBkYXRhUHJpdi5nZXQoIHRoaXMsIFwiZmluaXNoXCIgKSApIHtcblx0XHRcdFx0XHRhbmltLnN0b3AoIHRydWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblxuXHRcdGRvQW5pbWF0aW9uLmZpbmlzaCA9IGRvQW5pbWF0aW9uO1xuXG5cdFx0cmV0dXJuIGVtcHR5IHx8IG9wdGFsbC5xdWV1ZSA9PT0gZmFsc2UgP1xuXHRcdFx0dGhpcy5lYWNoKCBkb0FuaW1hdGlvbiApIDpcblx0XHRcdHRoaXMucXVldWUoIG9wdGFsbC5xdWV1ZSwgZG9BbmltYXRpb24gKTtcblx0fSxcblx0c3RvcDogZnVuY3Rpb24oIHR5cGUsIGNsZWFyUXVldWUsIGdvdG9FbmQgKSB7XG5cdFx0dmFyIHN0b3BRdWV1ZSA9IGZ1bmN0aW9uKCBob29rcyApIHtcblx0XHRcdHZhciBzdG9wID0gaG9va3Muc3RvcDtcblx0XHRcdGRlbGV0ZSBob29rcy5zdG9wO1xuXHRcdFx0c3RvcCggZ290b0VuZCApO1xuXHRcdH07XG5cblx0XHRpZiAoIHR5cGVvZiB0eXBlICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0Z290b0VuZCA9IGNsZWFyUXVldWU7XG5cdFx0XHRjbGVhclF1ZXVlID0gdHlwZTtcblx0XHRcdHR5cGUgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHRcdGlmICggY2xlYXJRdWV1ZSApIHtcblx0XHRcdHRoaXMucXVldWUoIHR5cGUgfHwgXCJmeFwiLCBbXSApO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGRlcXVldWUgPSB0cnVlLFxuXHRcdFx0XHRpbmRleCA9IHR5cGUgIT0gbnVsbCAmJiB0eXBlICsgXCJxdWV1ZUhvb2tzXCIsXG5cdFx0XHRcdHRpbWVycyA9IGpRdWVyeS50aW1lcnMsXG5cdFx0XHRcdGRhdGEgPSBkYXRhUHJpdi5nZXQoIHRoaXMgKTtcblxuXHRcdFx0aWYgKCBpbmRleCApIHtcblx0XHRcdFx0aWYgKCBkYXRhWyBpbmRleCBdICYmIGRhdGFbIGluZGV4IF0uc3RvcCApIHtcblx0XHRcdFx0XHRzdG9wUXVldWUoIGRhdGFbIGluZGV4IF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Zm9yICggaW5kZXggaW4gZGF0YSApIHtcblx0XHRcdFx0XHRpZiAoIGRhdGFbIGluZGV4IF0gJiYgZGF0YVsgaW5kZXggXS5zdG9wICYmIHJydW4udGVzdCggaW5kZXggKSApIHtcblx0XHRcdFx0XHRcdHN0b3BRdWV1ZSggZGF0YVsgaW5kZXggXSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRmb3IgKCBpbmRleCA9IHRpbWVycy5sZW5ndGg7IGluZGV4LS07ICkge1xuXHRcdFx0XHRpZiAoIHRpbWVyc1sgaW5kZXggXS5lbGVtID09PSB0aGlzICYmXG5cdFx0XHRcdFx0KCB0eXBlID09IG51bGwgfHwgdGltZXJzWyBpbmRleCBdLnF1ZXVlID09PSB0eXBlICkgKSB7XG5cblx0XHRcdFx0XHR0aW1lcnNbIGluZGV4IF0uYW5pbS5zdG9wKCBnb3RvRW5kICk7XG5cdFx0XHRcdFx0ZGVxdWV1ZSA9IGZhbHNlO1xuXHRcdFx0XHRcdHRpbWVycy5zcGxpY2UoIGluZGV4LCAxICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gU3RhcnQgdGhlIG5leHQgaW4gdGhlIHF1ZXVlIGlmIHRoZSBsYXN0IHN0ZXAgd2Fzbid0IGZvcmNlZC5cblx0XHRcdC8vIFRpbWVycyBjdXJyZW50bHkgd2lsbCBjYWxsIHRoZWlyIGNvbXBsZXRlIGNhbGxiYWNrcywgd2hpY2hcblx0XHRcdC8vIHdpbGwgZGVxdWV1ZSBidXQgb25seSBpZiB0aGV5IHdlcmUgZ290b0VuZC5cblx0XHRcdGlmICggZGVxdWV1ZSB8fCAhZ290b0VuZCApIHtcblx0XHRcdFx0alF1ZXJ5LmRlcXVldWUoIHRoaXMsIHR5cGUgKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cdGZpbmlzaDogZnVuY3Rpb24oIHR5cGUgKSB7XG5cdFx0aWYgKCB0eXBlICE9PSBmYWxzZSApIHtcblx0XHRcdHR5cGUgPSB0eXBlIHx8IFwiZnhcIjtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgaW5kZXgsXG5cdFx0XHRcdGRhdGEgPSBkYXRhUHJpdi5nZXQoIHRoaXMgKSxcblx0XHRcdFx0cXVldWUgPSBkYXRhWyB0eXBlICsgXCJxdWV1ZVwiIF0sXG5cdFx0XHRcdGhvb2tzID0gZGF0YVsgdHlwZSArIFwicXVldWVIb29rc1wiIF0sXG5cdFx0XHRcdHRpbWVycyA9IGpRdWVyeS50aW1lcnMsXG5cdFx0XHRcdGxlbmd0aCA9IHF1ZXVlID8gcXVldWUubGVuZ3RoIDogMDtcblxuXHRcdFx0Ly8gRW5hYmxlIGZpbmlzaGluZyBmbGFnIG9uIHByaXZhdGUgZGF0YVxuXHRcdFx0ZGF0YS5maW5pc2ggPSB0cnVlO1xuXG5cdFx0XHQvLyBFbXB0eSB0aGUgcXVldWUgZmlyc3Rcblx0XHRcdGpRdWVyeS5xdWV1ZSggdGhpcywgdHlwZSwgW10gKTtcblxuXHRcdFx0aWYgKCBob29rcyAmJiBob29rcy5zdG9wICkge1xuXHRcdFx0XHRob29rcy5zdG9wLmNhbGwoIHRoaXMsIHRydWUgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gTG9vayBmb3IgYW55IGFjdGl2ZSBhbmltYXRpb25zLCBhbmQgZmluaXNoIHRoZW1cblx0XHRcdGZvciAoIGluZGV4ID0gdGltZXJzLmxlbmd0aDsgaW5kZXgtLTsgKSB7XG5cdFx0XHRcdGlmICggdGltZXJzWyBpbmRleCBdLmVsZW0gPT09IHRoaXMgJiYgdGltZXJzWyBpbmRleCBdLnF1ZXVlID09PSB0eXBlICkge1xuXHRcdFx0XHRcdHRpbWVyc1sgaW5kZXggXS5hbmltLnN0b3AoIHRydWUgKTtcblx0XHRcdFx0XHR0aW1lcnMuc3BsaWNlKCBpbmRleCwgMSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIExvb2sgZm9yIGFueSBhbmltYXRpb25zIGluIHRoZSBvbGQgcXVldWUgYW5kIGZpbmlzaCB0aGVtXG5cdFx0XHRmb3IgKCBpbmRleCA9IDA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuXHRcdFx0XHRpZiAoIHF1ZXVlWyBpbmRleCBdICYmIHF1ZXVlWyBpbmRleCBdLmZpbmlzaCApIHtcblx0XHRcdFx0XHRxdWV1ZVsgaW5kZXggXS5maW5pc2guY2FsbCggdGhpcyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIFR1cm4gb2ZmIGZpbmlzaGluZyBmbGFnXG5cdFx0XHRkZWxldGUgZGF0YS5maW5pc2g7XG5cdFx0fSApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5lYWNoKCBbIFwidG9nZ2xlXCIsIFwic2hvd1wiLCBcImhpZGVcIiBdLCBmdW5jdGlvbiggX2ksIG5hbWUgKSB7XG5cdHZhciBjc3NGbiA9IGpRdWVyeS5mblsgbmFtZSBdO1xuXHRqUXVlcnkuZm5bIG5hbWUgXSA9IGZ1bmN0aW9uKCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApIHtcblx0XHRyZXR1cm4gc3BlZWQgPT0gbnVsbCB8fCB0eXBlb2Ygc3BlZWQgPT09IFwiYm9vbGVhblwiID9cblx0XHRcdGNzc0ZuLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKSA6XG5cdFx0XHR0aGlzLmFuaW1hdGUoIGdlbkZ4KCBuYW1lLCB0cnVlICksIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICk7XG5cdH07XG59ICk7XG5cbi8vIEdlbmVyYXRlIHNob3J0Y3V0cyBmb3IgY3VzdG9tIGFuaW1hdGlvbnNcbmpRdWVyeS5lYWNoKCB7XG5cdHNsaWRlRG93bjogZ2VuRngoIFwic2hvd1wiICksXG5cdHNsaWRlVXA6IGdlbkZ4KCBcImhpZGVcIiApLFxuXHRzbGlkZVRvZ2dsZTogZ2VuRngoIFwidG9nZ2xlXCIgKSxcblx0ZmFkZUluOiB7IG9wYWNpdHk6IFwic2hvd1wiIH0sXG5cdGZhZGVPdXQ6IHsgb3BhY2l0eTogXCJoaWRlXCIgfSxcblx0ZmFkZVRvZ2dsZTogeyBvcGFjaXR5OiBcInRvZ2dsZVwiIH1cbn0sIGZ1bmN0aW9uKCBuYW1lLCBwcm9wcyApIHtcblx0alF1ZXJ5LmZuWyBuYW1lIF0gPSBmdW5jdGlvbiggc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKSB7XG5cdFx0cmV0dXJuIHRoaXMuYW5pbWF0ZSggcHJvcHMsIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICk7XG5cdH07XG59ICk7XG5cbmpRdWVyeS50aW1lcnMgPSBbXTtcbmpRdWVyeS5meC50aWNrID0gZnVuY3Rpb24oKSB7XG5cdHZhciB0aW1lcixcblx0XHRpID0gMCxcblx0XHR0aW1lcnMgPSBqUXVlcnkudGltZXJzO1xuXG5cdGZ4Tm93ID0gRGF0ZS5ub3coKTtcblxuXHRmb3IgKCA7IGkgPCB0aW1lcnMubGVuZ3RoOyBpKysgKSB7XG5cdFx0dGltZXIgPSB0aW1lcnNbIGkgXTtcblxuXHRcdC8vIFJ1biB0aGUgdGltZXIgYW5kIHNhZmVseSByZW1vdmUgaXQgd2hlbiBkb25lIChhbGxvd2luZyBmb3IgZXh0ZXJuYWwgcmVtb3ZhbClcblx0XHRpZiAoICF0aW1lcigpICYmIHRpbWVyc1sgaSBdID09PSB0aW1lciApIHtcblx0XHRcdHRpbWVycy5zcGxpY2UoIGktLSwgMSApO1xuXHRcdH1cblx0fVxuXG5cdGlmICggIXRpbWVycy5sZW5ndGggKSB7XG5cdFx0alF1ZXJ5LmZ4LnN0b3AoKTtcblx0fVxuXHRmeE5vdyA9IHVuZGVmaW5lZDtcbn07XG5cbmpRdWVyeS5meC50aW1lciA9IGZ1bmN0aW9uKCB0aW1lciApIHtcblx0alF1ZXJ5LnRpbWVycy5wdXNoKCB0aW1lciApO1xuXHRqUXVlcnkuZnguc3RhcnQoKTtcbn07XG5cbmpRdWVyeS5meC5pbnRlcnZhbCA9IDEzO1xualF1ZXJ5LmZ4LnN0YXJ0ID0gZnVuY3Rpb24oKSB7XG5cdGlmICggaW5Qcm9ncmVzcyApIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHRpblByb2dyZXNzID0gdHJ1ZTtcblx0c2NoZWR1bGUoKTtcbn07XG5cbmpRdWVyeS5meC5zdG9wID0gZnVuY3Rpb24oKSB7XG5cdGluUHJvZ3Jlc3MgPSBudWxsO1xufTtcblxualF1ZXJ5LmZ4LnNwZWVkcyA9IHtcblx0c2xvdzogNjAwLFxuXHRmYXN0OiAyMDAsXG5cblx0Ly8gRGVmYXVsdCBzcGVlZFxuXHRfZGVmYXVsdDogNDAwXG59O1xuXG5cbi8vIEJhc2VkIG9mZiBvZiB0aGUgcGx1Z2luIGJ5IENsaW50IEhlbGZlcnMsIHdpdGggcGVybWlzc2lvbi5cbmpRdWVyeS5mbi5kZWxheSA9IGZ1bmN0aW9uKCB0aW1lLCB0eXBlICkge1xuXHR0aW1lID0galF1ZXJ5LmZ4ID8galF1ZXJ5LmZ4LnNwZWVkc1sgdGltZSBdIHx8IHRpbWUgOiB0aW1lO1xuXHR0eXBlID0gdHlwZSB8fCBcImZ4XCI7XG5cblx0cmV0dXJuIHRoaXMucXVldWUoIHR5cGUsIGZ1bmN0aW9uKCBuZXh0LCBob29rcyApIHtcblx0XHR2YXIgdGltZW91dCA9IHdpbmRvdy5zZXRUaW1lb3V0KCBuZXh0LCB0aW1lICk7XG5cdFx0aG9va3Muc3RvcCA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0d2luZG93LmNsZWFyVGltZW91dCggdGltZW91dCApO1xuXHRcdH07XG5cdH0gKTtcbn07XG5cblxuKCBmdW5jdGlvbigpIHtcblx0dmFyIGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJpbnB1dFwiICksXG5cdFx0c2VsZWN0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJzZWxlY3RcIiApLFxuXHRcdG9wdCA9IHNlbGVjdC5hcHBlbmRDaGlsZCggZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJvcHRpb25cIiApICk7XG5cblx0aW5wdXQudHlwZSA9IFwiY2hlY2tib3hcIjtcblxuXHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4zIG9ubHlcblx0Ly8gRGVmYXVsdCB2YWx1ZSBmb3IgYSBjaGVja2JveCBzaG91bGQgYmUgXCJvblwiXG5cdHN1cHBvcnQuY2hlY2tPbiA9IGlucHV0LnZhbHVlICE9PSBcIlwiO1xuXG5cdC8vIFN1cHBvcnQ6IElFIDw9MTEgb25seVxuXHQvLyBNdXN0IGFjY2VzcyBzZWxlY3RlZEluZGV4IHRvIG1ha2UgZGVmYXVsdCBvcHRpb25zIHNlbGVjdFxuXHRzdXBwb3J0Lm9wdFNlbGVjdGVkID0gb3B0LnNlbGVjdGVkO1xuXG5cdC8vIFN1cHBvcnQ6IElFIDw9MTEgb25seVxuXHQvLyBBbiBpbnB1dCBsb3NlcyBpdHMgdmFsdWUgYWZ0ZXIgYmVjb21pbmcgYSByYWRpb1xuXHRpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiaW5wdXRcIiApO1xuXHRpbnB1dC52YWx1ZSA9IFwidFwiO1xuXHRpbnB1dC50eXBlID0gXCJyYWRpb1wiO1xuXHRzdXBwb3J0LnJhZGlvVmFsdWUgPSBpbnB1dC52YWx1ZSA9PT0gXCJ0XCI7XG59ICkoKTtcblxuXG52YXIgYm9vbEhvb2ssXG5cdGF0dHJIYW5kbGUgPSBqUXVlcnkuZXhwci5hdHRySGFuZGxlO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdGF0dHI6IGZ1bmN0aW9uKCBuYW1lLCB2YWx1ZSApIHtcblx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBqUXVlcnkuYXR0ciwgbmFtZSwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggPiAxICk7XG5cdH0sXG5cblx0cmVtb3ZlQXR0cjogZnVuY3Rpb24oIG5hbWUgKSB7XG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRqUXVlcnkucmVtb3ZlQXR0ciggdGhpcywgbmFtZSApO1xuXHRcdH0gKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cdGF0dHI6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCB2YWx1ZSApIHtcblx0XHR2YXIgcmV0LCBob29rcyxcblx0XHRcdG5UeXBlID0gZWxlbS5ub2RlVHlwZTtcblxuXHRcdC8vIERvbid0IGdldC9zZXQgYXR0cmlidXRlcyBvbiB0ZXh0LCBjb21tZW50IGFuZCBhdHRyaWJ1dGUgbm9kZXNcblx0XHRpZiAoIG5UeXBlID09PSAzIHx8IG5UeXBlID09PSA4IHx8IG5UeXBlID09PSAyICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIEZhbGxiYWNrIHRvIHByb3Agd2hlbiBhdHRyaWJ1dGVzIGFyZSBub3Qgc3VwcG9ydGVkXG5cdFx0aWYgKCB0eXBlb2YgZWxlbS5nZXRBdHRyaWJ1dGUgPT09IFwidW5kZWZpbmVkXCIgKSB7XG5cdFx0XHRyZXR1cm4galF1ZXJ5LnByb3AoIGVsZW0sIG5hbWUsIHZhbHVlICk7XG5cdFx0fVxuXG5cdFx0Ly8gQXR0cmlidXRlIGhvb2tzIGFyZSBkZXRlcm1pbmVkIGJ5IHRoZSBsb3dlcmNhc2UgdmVyc2lvblxuXHRcdC8vIEdyYWIgbmVjZXNzYXJ5IGhvb2sgaWYgb25lIGlzIGRlZmluZWRcblx0XHRpZiAoIG5UeXBlICE9PSAxIHx8ICFqUXVlcnkuaXNYTUxEb2MoIGVsZW0gKSApIHtcblx0XHRcdGhvb2tzID0galF1ZXJ5LmF0dHJIb29rc1sgbmFtZS50b0xvd2VyQ2FzZSgpIF0gfHxcblx0XHRcdFx0KCBqUXVlcnkuZXhwci5tYXRjaC5ib29sLnRlc3QoIG5hbWUgKSA/IGJvb2xIb29rIDogdW5kZWZpbmVkICk7XG5cdFx0fVxuXG5cdFx0aWYgKCB2YWx1ZSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0aWYgKCB2YWx1ZSA9PT0gbnVsbCApIHtcblx0XHRcdFx0alF1ZXJ5LnJlbW92ZUF0dHIoIGVsZW0sIG5hbWUgKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGhvb2tzICYmIFwic2V0XCIgaW4gaG9va3MgJiZcblx0XHRcdFx0KCByZXQgPSBob29rcy5zZXQoIGVsZW0sIHZhbHVlLCBuYW1lICkgKSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRyZXR1cm4gcmV0O1xuXHRcdFx0fVxuXG5cdFx0XHRlbGVtLnNldEF0dHJpYnV0ZSggbmFtZSwgdmFsdWUgKyBcIlwiICk7XG5cdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0fVxuXG5cdFx0aWYgKCBob29rcyAmJiBcImdldFwiIGluIGhvb2tzICYmICggcmV0ID0gaG9va3MuZ2V0KCBlbGVtLCBuYW1lICkgKSAhPT0gbnVsbCApIHtcblx0XHRcdHJldHVybiByZXQ7XG5cdFx0fVxuXG5cdFx0cmV0ID0galF1ZXJ5LmZpbmQuYXR0ciggZWxlbSwgbmFtZSApO1xuXG5cdFx0Ly8gTm9uLWV4aXN0ZW50IGF0dHJpYnV0ZXMgcmV0dXJuIG51bGwsIHdlIG5vcm1hbGl6ZSB0byB1bmRlZmluZWRcblx0XHRyZXR1cm4gcmV0ID09IG51bGwgPyB1bmRlZmluZWQgOiByZXQ7XG5cdH0sXG5cblx0YXR0ckhvb2tzOiB7XG5cdFx0dHlwZToge1xuXHRcdFx0c2V0OiBmdW5jdGlvbiggZWxlbSwgdmFsdWUgKSB7XG5cdFx0XHRcdGlmICggIXN1cHBvcnQucmFkaW9WYWx1ZSAmJiB2YWx1ZSA9PT0gXCJyYWRpb1wiICYmXG5cdFx0XHRcdFx0bm9kZU5hbWUoIGVsZW0sIFwiaW5wdXRcIiApICkge1xuXHRcdFx0XHRcdHZhciB2YWwgPSBlbGVtLnZhbHVlO1xuXHRcdFx0XHRcdGVsZW0uc2V0QXR0cmlidXRlKCBcInR5cGVcIiwgdmFsdWUgKTtcblx0XHRcdFx0XHRpZiAoIHZhbCApIHtcblx0XHRcdFx0XHRcdGVsZW0udmFsdWUgPSB2YWw7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHRyZW1vdmVBdHRyOiBmdW5jdGlvbiggZWxlbSwgdmFsdWUgKSB7XG5cdFx0dmFyIG5hbWUsXG5cdFx0XHRpID0gMCxcblxuXHRcdFx0Ly8gQXR0cmlidXRlIG5hbWVzIGNhbiBjb250YWluIG5vbi1IVE1MIHdoaXRlc3BhY2UgY2hhcmFjdGVyc1xuXHRcdFx0Ly8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjYXR0cmlidXRlcy0yXG5cdFx0XHRhdHRyTmFtZXMgPSB2YWx1ZSAmJiB2YWx1ZS5tYXRjaCggcm5vdGh0bWx3aGl0ZSApO1xuXG5cdFx0aWYgKCBhdHRyTmFtZXMgJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRcdHdoaWxlICggKCBuYW1lID0gYXR0ck5hbWVzWyBpKysgXSApICkge1xuXHRcdFx0XHRlbGVtLnJlbW92ZUF0dHJpYnV0ZSggbmFtZSApO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxufSApO1xuXG4vLyBIb29rcyBmb3IgYm9vbGVhbiBhdHRyaWJ1dGVzXG5ib29sSG9vayA9IHtcblx0c2V0OiBmdW5jdGlvbiggZWxlbSwgdmFsdWUsIG5hbWUgKSB7XG5cdFx0aWYgKCB2YWx1ZSA9PT0gZmFsc2UgKSB7XG5cblx0XHRcdC8vIFJlbW92ZSBib29sZWFuIGF0dHJpYnV0ZXMgd2hlbiBzZXQgdG8gZmFsc2Vcblx0XHRcdGpRdWVyeS5yZW1vdmVBdHRyKCBlbGVtLCBuYW1lICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGVsZW0uc2V0QXR0cmlidXRlKCBuYW1lLCBuYW1lICk7XG5cdFx0fVxuXHRcdHJldHVybiBuYW1lO1xuXHR9XG59O1xuXG5qUXVlcnkuZWFjaCggalF1ZXJ5LmV4cHIubWF0Y2guYm9vbC5zb3VyY2UubWF0Y2goIC9cXHcrL2cgKSwgZnVuY3Rpb24oIF9pLCBuYW1lICkge1xuXHR2YXIgZ2V0dGVyID0gYXR0ckhhbmRsZVsgbmFtZSBdIHx8IGpRdWVyeS5maW5kLmF0dHI7XG5cblx0YXR0ckhhbmRsZVsgbmFtZSBdID0gZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGlzWE1MICkge1xuXHRcdHZhciByZXQsIGhhbmRsZSxcblx0XHRcdGxvd2VyY2FzZU5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG5cblx0XHRpZiAoICFpc1hNTCApIHtcblxuXHRcdFx0Ly8gQXZvaWQgYW4gaW5maW5pdGUgbG9vcCBieSB0ZW1wb3JhcmlseSByZW1vdmluZyB0aGlzIGZ1bmN0aW9uIGZyb20gdGhlIGdldHRlclxuXHRcdFx0aGFuZGxlID0gYXR0ckhhbmRsZVsgbG93ZXJjYXNlTmFtZSBdO1xuXHRcdFx0YXR0ckhhbmRsZVsgbG93ZXJjYXNlTmFtZSBdID0gcmV0O1xuXHRcdFx0cmV0ID0gZ2V0dGVyKCBlbGVtLCBuYW1lLCBpc1hNTCApICE9IG51bGwgP1xuXHRcdFx0XHRsb3dlcmNhc2VOYW1lIDpcblx0XHRcdFx0bnVsbDtcblx0XHRcdGF0dHJIYW5kbGVbIGxvd2VyY2FzZU5hbWUgXSA9IGhhbmRsZTtcblx0XHR9XG5cdFx0cmV0dXJuIHJldDtcblx0fTtcbn0gKTtcblxuXG5cblxudmFyIHJmb2N1c2FibGUgPSAvXig/OmlucHV0fHNlbGVjdHx0ZXh0YXJlYXxidXR0b24pJC9pLFxuXHRyY2xpY2thYmxlID0gL14oPzphfGFyZWEpJC9pO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdHByb3A6IGZ1bmN0aW9uKCBuYW1lLCB2YWx1ZSApIHtcblx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBqUXVlcnkucHJvcCwgbmFtZSwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggPiAxICk7XG5cdH0sXG5cblx0cmVtb3ZlUHJvcDogZnVuY3Rpb24oIG5hbWUgKSB7XG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRkZWxldGUgdGhpc1sgalF1ZXJ5LnByb3BGaXhbIG5hbWUgXSB8fCBuYW1lIF07XG5cdFx0fSApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5leHRlbmQoIHtcblx0cHJvcDogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIHZhbHVlICkge1xuXHRcdHZhciByZXQsIGhvb2tzLFxuXHRcdFx0blR5cGUgPSBlbGVtLm5vZGVUeXBlO1xuXG5cdFx0Ly8gRG9uJ3QgZ2V0L3NldCBwcm9wZXJ0aWVzIG9uIHRleHQsIGNvbW1lbnQgYW5kIGF0dHJpYnV0ZSBub2Rlc1xuXHRcdGlmICggblR5cGUgPT09IDMgfHwgblR5cGUgPT09IDggfHwgblR5cGUgPT09IDIgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKCBuVHlwZSAhPT0gMSB8fCAhalF1ZXJ5LmlzWE1MRG9jKCBlbGVtICkgKSB7XG5cblx0XHRcdC8vIEZpeCBuYW1lIGFuZCBhdHRhY2ggaG9va3Ncblx0XHRcdG5hbWUgPSBqUXVlcnkucHJvcEZpeFsgbmFtZSBdIHx8IG5hbWU7XG5cdFx0XHRob29rcyA9IGpRdWVyeS5wcm9wSG9va3NbIG5hbWUgXTtcblx0XHR9XG5cblx0XHRpZiAoIHZhbHVlICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRpZiAoIGhvb2tzICYmIFwic2V0XCIgaW4gaG9va3MgJiZcblx0XHRcdFx0KCByZXQgPSBob29rcy5zZXQoIGVsZW0sIHZhbHVlLCBuYW1lICkgKSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRyZXR1cm4gcmV0O1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gKCBlbGVtWyBuYW1lIF0gPSB2YWx1ZSApO1xuXHRcdH1cblxuXHRcdGlmICggaG9va3MgJiYgXCJnZXRcIiBpbiBob29rcyAmJiAoIHJldCA9IGhvb2tzLmdldCggZWxlbSwgbmFtZSApICkgIT09IG51bGwgKSB7XG5cdFx0XHRyZXR1cm4gcmV0O1xuXHRcdH1cblxuXHRcdHJldHVybiBlbGVtWyBuYW1lIF07XG5cdH0sXG5cblx0cHJvcEhvb2tzOiB7XG5cdFx0dGFiSW5kZXg6IHtcblx0XHRcdGdldDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPD05IC0gMTEgb25seVxuXHRcdFx0XHQvLyBlbGVtLnRhYkluZGV4IGRvZXNuJ3QgYWx3YXlzIHJldHVybiB0aGVcblx0XHRcdFx0Ly8gY29ycmVjdCB2YWx1ZSB3aGVuIGl0IGhhc24ndCBiZWVuIGV4cGxpY2l0bHkgc2V0XG5cdFx0XHRcdC8vIFVzZSBwcm9wZXIgYXR0cmlidXRlIHJldHJpZXZhbCAodHJhYy0xMjA3Milcblx0XHRcdFx0dmFyIHRhYmluZGV4ID0galF1ZXJ5LmZpbmQuYXR0ciggZWxlbSwgXCJ0YWJpbmRleFwiICk7XG5cblx0XHRcdFx0aWYgKCB0YWJpbmRleCApIHtcblx0XHRcdFx0XHRyZXR1cm4gcGFyc2VJbnQoIHRhYmluZGV4LCAxMCApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKFxuXHRcdFx0XHRcdHJmb2N1c2FibGUudGVzdCggZWxlbS5ub2RlTmFtZSApIHx8XG5cdFx0XHRcdFx0cmNsaWNrYWJsZS50ZXN0KCBlbGVtLm5vZGVOYW1lICkgJiZcblx0XHRcdFx0XHRlbGVtLmhyZWZcblx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0cmV0dXJuIDA7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gLTE7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdHByb3BGaXg6IHtcblx0XHRcImZvclwiOiBcImh0bWxGb3JcIixcblx0XHRcImNsYXNzXCI6IFwiY2xhc3NOYW1lXCJcblx0fVxufSApO1xuXG4vLyBTdXBwb3J0OiBJRSA8PTExIG9ubHlcbi8vIEFjY2Vzc2luZyB0aGUgc2VsZWN0ZWRJbmRleCBwcm9wZXJ0eVxuLy8gZm9yY2VzIHRoZSBicm93c2VyIHRvIHJlc3BlY3Qgc2V0dGluZyBzZWxlY3RlZFxuLy8gb24gdGhlIG9wdGlvblxuLy8gVGhlIGdldHRlciBlbnN1cmVzIGEgZGVmYXVsdCBvcHRpb24gaXMgc2VsZWN0ZWRcbi8vIHdoZW4gaW4gYW4gb3B0Z3JvdXBcbi8vIGVzbGludCBydWxlIFwibm8tdW51c2VkLWV4cHJlc3Npb25zXCIgaXMgZGlzYWJsZWQgZm9yIHRoaXMgY29kZVxuLy8gc2luY2UgaXQgY29uc2lkZXJzIHN1Y2ggYWNjZXNzaW9ucyBub29wXG5pZiAoICFzdXBwb3J0Lm9wdFNlbGVjdGVkICkge1xuXHRqUXVlcnkucHJvcEhvb2tzLnNlbGVjdGVkID0ge1xuXHRcdGdldDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cblx0XHRcdC8qIGVzbGludCBuby11bnVzZWQtZXhwcmVzc2lvbnM6IFwib2ZmXCIgKi9cblxuXHRcdFx0dmFyIHBhcmVudCA9IGVsZW0ucGFyZW50Tm9kZTtcblx0XHRcdGlmICggcGFyZW50ICYmIHBhcmVudC5wYXJlbnROb2RlICkge1xuXHRcdFx0XHRwYXJlbnQucGFyZW50Tm9kZS5zZWxlY3RlZEluZGV4O1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fSxcblx0XHRzZXQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXG5cdFx0XHQvKiBlc2xpbnQgbm8tdW51c2VkLWV4cHJlc3Npb25zOiBcIm9mZlwiICovXG5cblx0XHRcdHZhciBwYXJlbnQgPSBlbGVtLnBhcmVudE5vZGU7XG5cdFx0XHRpZiAoIHBhcmVudCApIHtcblx0XHRcdFx0cGFyZW50LnNlbGVjdGVkSW5kZXg7XG5cblx0XHRcdFx0aWYgKCBwYXJlbnQucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0XHRwYXJlbnQucGFyZW50Tm9kZS5zZWxlY3RlZEluZGV4O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xufVxuXG5qUXVlcnkuZWFjaCggW1xuXHRcInRhYkluZGV4XCIsXG5cdFwicmVhZE9ubHlcIixcblx0XCJtYXhMZW5ndGhcIixcblx0XCJjZWxsU3BhY2luZ1wiLFxuXHRcImNlbGxQYWRkaW5nXCIsXG5cdFwicm93U3BhblwiLFxuXHRcImNvbFNwYW5cIixcblx0XCJ1c2VNYXBcIixcblx0XCJmcmFtZUJvcmRlclwiLFxuXHRcImNvbnRlbnRFZGl0YWJsZVwiXG5dLCBmdW5jdGlvbigpIHtcblx0alF1ZXJ5LnByb3BGaXhbIHRoaXMudG9Mb3dlckNhc2UoKSBdID0gdGhpcztcbn0gKTtcblxuXG5cblxuXHQvLyBTdHJpcCBhbmQgY29sbGFwc2Ugd2hpdGVzcGFjZSBhY2NvcmRpbmcgdG8gSFRNTCBzcGVjXG5cdC8vIGh0dHBzOi8vaW5mcmEuc3BlYy53aGF0d2cub3JnLyNzdHJpcC1hbmQtY29sbGFwc2UtYXNjaWktd2hpdGVzcGFjZVxuXHRmdW5jdGlvbiBzdHJpcEFuZENvbGxhcHNlKCB2YWx1ZSApIHtcblx0XHR2YXIgdG9rZW5zID0gdmFsdWUubWF0Y2goIHJub3RodG1sd2hpdGUgKSB8fCBbXTtcblx0XHRyZXR1cm4gdG9rZW5zLmpvaW4oIFwiIFwiICk7XG5cdH1cblxuXG5mdW5jdGlvbiBnZXRDbGFzcyggZWxlbSApIHtcblx0cmV0dXJuIGVsZW0uZ2V0QXR0cmlidXRlICYmIGVsZW0uZ2V0QXR0cmlidXRlKCBcImNsYXNzXCIgKSB8fCBcIlwiO1xufVxuXG5mdW5jdGlvbiBjbGFzc2VzVG9BcnJheSggdmFsdWUgKSB7XG5cdGlmICggQXJyYXkuaXNBcnJheSggdmFsdWUgKSApIHtcblx0XHRyZXR1cm4gdmFsdWU7XG5cdH1cblx0aWYgKCB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0cmV0dXJuIHZhbHVlLm1hdGNoKCBybm90aHRtbHdoaXRlICkgfHwgW107XG5cdH1cblx0cmV0dXJuIFtdO1xufVxuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdGFkZENsYXNzOiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0dmFyIGNsYXNzTmFtZXMsIGN1ciwgY3VyVmFsdWUsIGNsYXNzTmFtZSwgaSwgZmluYWxWYWx1ZTtcblxuXHRcdGlmICggaXNGdW5jdGlvbiggdmFsdWUgKSApIHtcblx0XHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCBqICkge1xuXHRcdFx0XHRqUXVlcnkoIHRoaXMgKS5hZGRDbGFzcyggdmFsdWUuY2FsbCggdGhpcywgaiwgZ2V0Q2xhc3MoIHRoaXMgKSApICk7XG5cdFx0XHR9ICk7XG5cdFx0fVxuXG5cdFx0Y2xhc3NOYW1lcyA9IGNsYXNzZXNUb0FycmF5KCB2YWx1ZSApO1xuXG5cdFx0aWYgKCBjbGFzc05hbWVzLmxlbmd0aCApIHtcblx0XHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRjdXJWYWx1ZSA9IGdldENsYXNzKCB0aGlzICk7XG5cdFx0XHRcdGN1ciA9IHRoaXMubm9kZVR5cGUgPT09IDEgJiYgKCBcIiBcIiArIHN0cmlwQW5kQ29sbGFwc2UoIGN1clZhbHVlICkgKyBcIiBcIiApO1xuXG5cdFx0XHRcdGlmICggY3VyICkge1xuXHRcdFx0XHRcdGZvciAoIGkgPSAwOyBpIDwgY2xhc3NOYW1lcy5sZW5ndGg7IGkrKyApIHtcblx0XHRcdFx0XHRcdGNsYXNzTmFtZSA9IGNsYXNzTmFtZXNbIGkgXTtcblx0XHRcdFx0XHRcdGlmICggY3VyLmluZGV4T2YoIFwiIFwiICsgY2xhc3NOYW1lICsgXCIgXCIgKSA8IDAgKSB7XG5cdFx0XHRcdFx0XHRcdGN1ciArPSBjbGFzc05hbWUgKyBcIiBcIjtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBPbmx5IGFzc2lnbiBpZiBkaWZmZXJlbnQgdG8gYXZvaWQgdW5uZWVkZWQgcmVuZGVyaW5nLlxuXHRcdFx0XHRcdGZpbmFsVmFsdWUgPSBzdHJpcEFuZENvbGxhcHNlKCBjdXIgKTtcblx0XHRcdFx0XHRpZiAoIGN1clZhbHVlICE9PSBmaW5hbFZhbHVlICkge1xuXHRcdFx0XHRcdFx0dGhpcy5zZXRBdHRyaWJ1dGUoIFwiY2xhc3NcIiwgZmluYWxWYWx1ZSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdHJlbW92ZUNsYXNzOiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0dmFyIGNsYXNzTmFtZXMsIGN1ciwgY3VyVmFsdWUsIGNsYXNzTmFtZSwgaSwgZmluYWxWYWx1ZTtcblxuXHRcdGlmICggaXNGdW5jdGlvbiggdmFsdWUgKSApIHtcblx0XHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCBqICkge1xuXHRcdFx0XHRqUXVlcnkoIHRoaXMgKS5yZW1vdmVDbGFzcyggdmFsdWUuY2FsbCggdGhpcywgaiwgZ2V0Q2xhc3MoIHRoaXMgKSApICk7XG5cdFx0XHR9ICk7XG5cdFx0fVxuXG5cdFx0aWYgKCAhYXJndW1lbnRzLmxlbmd0aCApIHtcblx0XHRcdHJldHVybiB0aGlzLmF0dHIoIFwiY2xhc3NcIiwgXCJcIiApO1xuXHRcdH1cblxuXHRcdGNsYXNzTmFtZXMgPSBjbGFzc2VzVG9BcnJheSggdmFsdWUgKTtcblxuXHRcdGlmICggY2xhc3NOYW1lcy5sZW5ndGggKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0Y3VyVmFsdWUgPSBnZXRDbGFzcyggdGhpcyApO1xuXG5cdFx0XHRcdC8vIFRoaXMgZXhwcmVzc2lvbiBpcyBoZXJlIGZvciBiZXR0ZXIgY29tcHJlc3NpYmlsaXR5IChzZWUgYWRkQ2xhc3MpXG5cdFx0XHRcdGN1ciA9IHRoaXMubm9kZVR5cGUgPT09IDEgJiYgKCBcIiBcIiArIHN0cmlwQW5kQ29sbGFwc2UoIGN1clZhbHVlICkgKyBcIiBcIiApO1xuXG5cdFx0XHRcdGlmICggY3VyICkge1xuXHRcdFx0XHRcdGZvciAoIGkgPSAwOyBpIDwgY2xhc3NOYW1lcy5sZW5ndGg7IGkrKyApIHtcblx0XHRcdFx0XHRcdGNsYXNzTmFtZSA9IGNsYXNzTmFtZXNbIGkgXTtcblxuXHRcdFx0XHRcdFx0Ly8gUmVtb3ZlICphbGwqIGluc3RhbmNlc1xuXHRcdFx0XHRcdFx0d2hpbGUgKCBjdXIuaW5kZXhPZiggXCIgXCIgKyBjbGFzc05hbWUgKyBcIiBcIiApID4gLTEgKSB7XG5cdFx0XHRcdFx0XHRcdGN1ciA9IGN1ci5yZXBsYWNlKCBcIiBcIiArIGNsYXNzTmFtZSArIFwiIFwiLCBcIiBcIiApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIE9ubHkgYXNzaWduIGlmIGRpZmZlcmVudCB0byBhdm9pZCB1bm5lZWRlZCByZW5kZXJpbmcuXG5cdFx0XHRcdFx0ZmluYWxWYWx1ZSA9IHN0cmlwQW5kQ29sbGFwc2UoIGN1ciApO1xuXHRcdFx0XHRcdGlmICggY3VyVmFsdWUgIT09IGZpbmFsVmFsdWUgKSB7XG5cdFx0XHRcdFx0XHR0aGlzLnNldEF0dHJpYnV0ZSggXCJjbGFzc1wiLCBmaW5hbFZhbHVlICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9ICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0dG9nZ2xlQ2xhc3M6IGZ1bmN0aW9uKCB2YWx1ZSwgc3RhdGVWYWwgKSB7XG5cdFx0dmFyIGNsYXNzTmFtZXMsIGNsYXNzTmFtZSwgaSwgc2VsZixcblx0XHRcdHR5cGUgPSB0eXBlb2YgdmFsdWUsXG5cdFx0XHRpc1ZhbGlkVmFsdWUgPSB0eXBlID09PSBcInN0cmluZ1wiIHx8IEFycmF5LmlzQXJyYXkoIHZhbHVlICk7XG5cblx0XHRpZiAoIGlzRnVuY3Rpb24oIHZhbHVlICkgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbiggaSApIHtcblx0XHRcdFx0alF1ZXJ5KCB0aGlzICkudG9nZ2xlQ2xhc3MoXG5cdFx0XHRcdFx0dmFsdWUuY2FsbCggdGhpcywgaSwgZ2V0Q2xhc3MoIHRoaXMgKSwgc3RhdGVWYWwgKSxcblx0XHRcdFx0XHRzdGF0ZVZhbFxuXHRcdFx0XHQpO1xuXHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdGlmICggdHlwZW9mIHN0YXRlVmFsID09PSBcImJvb2xlYW5cIiAmJiBpc1ZhbGlkVmFsdWUgKSB7XG5cdFx0XHRyZXR1cm4gc3RhdGVWYWwgPyB0aGlzLmFkZENsYXNzKCB2YWx1ZSApIDogdGhpcy5yZW1vdmVDbGFzcyggdmFsdWUgKTtcblx0XHR9XG5cblx0XHRjbGFzc05hbWVzID0gY2xhc3Nlc1RvQXJyYXkoIHZhbHVlICk7XG5cblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGlmICggaXNWYWxpZFZhbHVlICkge1xuXG5cdFx0XHRcdC8vIFRvZ2dsZSBpbmRpdmlkdWFsIGNsYXNzIG5hbWVzXG5cdFx0XHRcdHNlbGYgPSBqUXVlcnkoIHRoaXMgKTtcblxuXHRcdFx0XHRmb3IgKCBpID0gMDsgaSA8IGNsYXNzTmFtZXMubGVuZ3RoOyBpKysgKSB7XG5cdFx0XHRcdFx0Y2xhc3NOYW1lID0gY2xhc3NOYW1lc1sgaSBdO1xuXG5cdFx0XHRcdFx0Ly8gQ2hlY2sgZWFjaCBjbGFzc05hbWUgZ2l2ZW4sIHNwYWNlIHNlcGFyYXRlZCBsaXN0XG5cdFx0XHRcdFx0aWYgKCBzZWxmLmhhc0NsYXNzKCBjbGFzc05hbWUgKSApIHtcblx0XHRcdFx0XHRcdHNlbGYucmVtb3ZlQ2xhc3MoIGNsYXNzTmFtZSApO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRzZWxmLmFkZENsYXNzKCBjbGFzc05hbWUgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0Ly8gVG9nZ2xlIHdob2xlIGNsYXNzIG5hbWVcblx0XHRcdH0gZWxzZSBpZiAoIHZhbHVlID09PSB1bmRlZmluZWQgfHwgdHlwZSA9PT0gXCJib29sZWFuXCIgKSB7XG5cdFx0XHRcdGNsYXNzTmFtZSA9IGdldENsYXNzKCB0aGlzICk7XG5cdFx0XHRcdGlmICggY2xhc3NOYW1lICkge1xuXG5cdFx0XHRcdFx0Ly8gU3RvcmUgY2xhc3NOYW1lIGlmIHNldFxuXHRcdFx0XHRcdGRhdGFQcml2LnNldCggdGhpcywgXCJfX2NsYXNzTmFtZV9fXCIsIGNsYXNzTmFtZSApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gSWYgdGhlIGVsZW1lbnQgaGFzIGEgY2xhc3MgbmFtZSBvciBpZiB3ZSdyZSBwYXNzZWQgYGZhbHNlYCxcblx0XHRcdFx0Ly8gdGhlbiByZW1vdmUgdGhlIHdob2xlIGNsYXNzbmFtZSAoaWYgdGhlcmUgd2FzIG9uZSwgdGhlIGFib3ZlIHNhdmVkIGl0KS5cblx0XHRcdFx0Ly8gT3RoZXJ3aXNlIGJyaW5nIGJhY2sgd2hhdGV2ZXIgd2FzIHByZXZpb3VzbHkgc2F2ZWQgKGlmIGFueXRoaW5nKSxcblx0XHRcdFx0Ly8gZmFsbGluZyBiYWNrIHRvIHRoZSBlbXB0eSBzdHJpbmcgaWYgbm90aGluZyB3YXMgc3RvcmVkLlxuXHRcdFx0XHRpZiAoIHRoaXMuc2V0QXR0cmlidXRlICkge1xuXHRcdFx0XHRcdHRoaXMuc2V0QXR0cmlidXRlKCBcImNsYXNzXCIsXG5cdFx0XHRcdFx0XHRjbGFzc05hbWUgfHwgdmFsdWUgPT09IGZhbHNlID9cblx0XHRcdFx0XHRcdFx0XCJcIiA6XG5cdFx0XHRcdFx0XHRcdGRhdGFQcml2LmdldCggdGhpcywgXCJfX2NsYXNzTmFtZV9fXCIgKSB8fCBcIlwiXG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHRoYXNDbGFzczogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHZhciBjbGFzc05hbWUsIGVsZW0sXG5cdFx0XHRpID0gMDtcblxuXHRcdGNsYXNzTmFtZSA9IFwiIFwiICsgc2VsZWN0b3IgKyBcIiBcIjtcblx0XHR3aGlsZSAoICggZWxlbSA9IHRoaXNbIGkrKyBdICkgKSB7XG5cdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgJiZcblx0XHRcdFx0KCBcIiBcIiArIHN0cmlwQW5kQ29sbGFwc2UoIGdldENsYXNzKCBlbGVtICkgKSArIFwiIFwiICkuaW5kZXhPZiggY2xhc3NOYW1lICkgPiAtMSApIHtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG59ICk7XG5cblxuXG5cbnZhciBycmV0dXJuID0gL1xcci9nO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdHZhbDogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdHZhciBob29rcywgcmV0LCB2YWx1ZUlzRnVuY3Rpb24sXG5cdFx0XHRlbGVtID0gdGhpc1sgMCBdO1xuXG5cdFx0aWYgKCAhYXJndW1lbnRzLmxlbmd0aCApIHtcblx0XHRcdGlmICggZWxlbSApIHtcblx0XHRcdFx0aG9va3MgPSBqUXVlcnkudmFsSG9va3NbIGVsZW0udHlwZSBdIHx8XG5cdFx0XHRcdFx0alF1ZXJ5LnZhbEhvb2tzWyBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgXTtcblxuXHRcdFx0XHRpZiAoIGhvb2tzICYmXG5cdFx0XHRcdFx0XCJnZXRcIiBpbiBob29rcyAmJlxuXHRcdFx0XHRcdCggcmV0ID0gaG9va3MuZ2V0KCBlbGVtLCBcInZhbHVlXCIgKSApICE9PSB1bmRlZmluZWRcblx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0cmV0dXJuIHJldDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldCA9IGVsZW0udmFsdWU7XG5cblx0XHRcdFx0Ly8gSGFuZGxlIG1vc3QgY29tbW9uIHN0cmluZyBjYXNlc1xuXHRcdFx0XHRpZiAoIHR5cGVvZiByZXQgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHJldC5yZXBsYWNlKCBycmV0dXJuLCBcIlwiICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBIYW5kbGUgY2FzZXMgd2hlcmUgdmFsdWUgaXMgbnVsbC91bmRlZiBvciBudW1iZXJcblx0XHRcdFx0cmV0dXJuIHJldCA9PSBudWxsID8gXCJcIiA6IHJldDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHZhbHVlSXNGdW5jdGlvbiA9IGlzRnVuY3Rpb24oIHZhbHVlICk7XG5cblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbiggaSApIHtcblx0XHRcdHZhciB2YWw7XG5cblx0XHRcdGlmICggdGhpcy5ub2RlVHlwZSAhPT0gMSApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHZhbHVlSXNGdW5jdGlvbiApIHtcblx0XHRcdFx0dmFsID0gdmFsdWUuY2FsbCggdGhpcywgaSwgalF1ZXJ5KCB0aGlzICkudmFsKCkgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHZhbCA9IHZhbHVlO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBUcmVhdCBudWxsL3VuZGVmaW5lZCBhcyBcIlwiOyBjb252ZXJ0IG51bWJlcnMgdG8gc3RyaW5nXG5cdFx0XHRpZiAoIHZhbCA9PSBudWxsICkge1xuXHRcdFx0XHR2YWwgPSBcIlwiO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCB0eXBlb2YgdmFsID09PSBcIm51bWJlclwiICkge1xuXHRcdFx0XHR2YWwgKz0gXCJcIjtcblxuXHRcdFx0fSBlbHNlIGlmICggQXJyYXkuaXNBcnJheSggdmFsICkgKSB7XG5cdFx0XHRcdHZhbCA9IGpRdWVyeS5tYXAoIHZhbCwgZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0XHRcdHJldHVybiB2YWx1ZSA9PSBudWxsID8gXCJcIiA6IHZhbHVlICsgXCJcIjtcblx0XHRcdFx0fSApO1xuXHRcdFx0fVxuXG5cdFx0XHRob29rcyA9IGpRdWVyeS52YWxIb29rc1sgdGhpcy50eXBlIF0gfHwgalF1ZXJ5LnZhbEhvb2tzWyB0aGlzLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgXTtcblxuXHRcdFx0Ly8gSWYgc2V0IHJldHVybnMgdW5kZWZpbmVkLCBmYWxsIGJhY2sgdG8gbm9ybWFsIHNldHRpbmdcblx0XHRcdGlmICggIWhvb2tzIHx8ICEoIFwic2V0XCIgaW4gaG9va3MgKSB8fCBob29rcy5zZXQoIHRoaXMsIHZhbCwgXCJ2YWx1ZVwiICkgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0dGhpcy52YWx1ZSA9IHZhbDtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmV4dGVuZCgge1xuXHR2YWxIb29rczoge1xuXHRcdG9wdGlvbjoge1xuXHRcdFx0Z2V0OiBmdW5jdGlvbiggZWxlbSApIHtcblxuXHRcdFx0XHR2YXIgdmFsID0galF1ZXJ5LmZpbmQuYXR0ciggZWxlbSwgXCJ2YWx1ZVwiICk7XG5cdFx0XHRcdHJldHVybiB2YWwgIT0gbnVsbCA/XG5cdFx0XHRcdFx0dmFsIDpcblxuXHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9MTAgLSAxMSBvbmx5XG5cdFx0XHRcdFx0Ly8gb3B0aW9uLnRleHQgdGhyb3dzIGV4Y2VwdGlvbnMgKHRyYWMtMTQ2ODYsIHRyYWMtMTQ4NTgpXG5cdFx0XHRcdFx0Ly8gU3RyaXAgYW5kIGNvbGxhcHNlIHdoaXRlc3BhY2Vcblx0XHRcdFx0XHQvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnLyNzdHJpcC1hbmQtY29sbGFwc2Utd2hpdGVzcGFjZVxuXHRcdFx0XHRcdHN0cmlwQW5kQ29sbGFwc2UoIGpRdWVyeS50ZXh0KCBlbGVtICkgKTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdHNlbGVjdDoge1xuXHRcdFx0Z2V0OiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0dmFyIHZhbHVlLCBvcHRpb24sIGksXG5cdFx0XHRcdFx0b3B0aW9ucyA9IGVsZW0ub3B0aW9ucyxcblx0XHRcdFx0XHRpbmRleCA9IGVsZW0uc2VsZWN0ZWRJbmRleCxcblx0XHRcdFx0XHRvbmUgPSBlbGVtLnR5cGUgPT09IFwic2VsZWN0LW9uZVwiLFxuXHRcdFx0XHRcdHZhbHVlcyA9IG9uZSA/IG51bGwgOiBbXSxcblx0XHRcdFx0XHRtYXggPSBvbmUgPyBpbmRleCArIDEgOiBvcHRpb25zLmxlbmd0aDtcblxuXHRcdFx0XHRpZiAoIGluZGV4IDwgMCApIHtcblx0XHRcdFx0XHRpID0gbWF4O1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0aSA9IG9uZSA/IGluZGV4IDogMDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIExvb3AgdGhyb3VnaCBhbGwgdGhlIHNlbGVjdGVkIG9wdGlvbnNcblx0XHRcdFx0Zm9yICggOyBpIDwgbWF4OyBpKysgKSB7XG5cdFx0XHRcdFx0b3B0aW9uID0gb3B0aW9uc1sgaSBdO1xuXG5cdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPD05IG9ubHlcblx0XHRcdFx0XHQvLyBJRTgtOSBkb2Vzbid0IHVwZGF0ZSBzZWxlY3RlZCBhZnRlciBmb3JtIHJlc2V0ICh0cmFjLTI1NTEpXG5cdFx0XHRcdFx0aWYgKCAoIG9wdGlvbi5zZWxlY3RlZCB8fCBpID09PSBpbmRleCApICYmXG5cblx0XHRcdFx0XHRcdFx0Ly8gRG9uJ3QgcmV0dXJuIG9wdGlvbnMgdGhhdCBhcmUgZGlzYWJsZWQgb3IgaW4gYSBkaXNhYmxlZCBvcHRncm91cFxuXHRcdFx0XHRcdFx0XHQhb3B0aW9uLmRpc2FibGVkICYmXG5cdFx0XHRcdFx0XHRcdCggIW9wdGlvbi5wYXJlbnROb2RlLmRpc2FibGVkIHx8XG5cdFx0XHRcdFx0XHRcdFx0IW5vZGVOYW1lKCBvcHRpb24ucGFyZW50Tm9kZSwgXCJvcHRncm91cFwiICkgKSApIHtcblxuXHRcdFx0XHRcdFx0Ly8gR2V0IHRoZSBzcGVjaWZpYyB2YWx1ZSBmb3IgdGhlIG9wdGlvblxuXHRcdFx0XHRcdFx0dmFsdWUgPSBqUXVlcnkoIG9wdGlvbiApLnZhbCgpO1xuXG5cdFx0XHRcdFx0XHQvLyBXZSBkb24ndCBuZWVkIGFuIGFycmF5IGZvciBvbmUgc2VsZWN0c1xuXHRcdFx0XHRcdFx0aWYgKCBvbmUgKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Ly8gTXVsdGktU2VsZWN0cyByZXR1cm4gYW4gYXJyYXlcblx0XHRcdFx0XHRcdHZhbHVlcy5wdXNoKCB2YWx1ZSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiB2YWx1ZXM7XG5cdFx0XHR9LFxuXG5cdFx0XHRzZXQ6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSApIHtcblx0XHRcdFx0dmFyIG9wdGlvblNldCwgb3B0aW9uLFxuXHRcdFx0XHRcdG9wdGlvbnMgPSBlbGVtLm9wdGlvbnMsXG5cdFx0XHRcdFx0dmFsdWVzID0galF1ZXJ5Lm1ha2VBcnJheSggdmFsdWUgKSxcblx0XHRcdFx0XHRpID0gb3B0aW9ucy5sZW5ndGg7XG5cblx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0b3B0aW9uID0gb3B0aW9uc1sgaSBdO1xuXG5cdFx0XHRcdFx0LyogZXNsaW50LWRpc2FibGUgbm8tY29uZC1hc3NpZ24gKi9cblxuXHRcdFx0XHRcdGlmICggb3B0aW9uLnNlbGVjdGVkID1cblx0XHRcdFx0XHRcdGpRdWVyeS5pbkFycmF5KCBqUXVlcnkudmFsSG9va3Mub3B0aW9uLmdldCggb3B0aW9uICksIHZhbHVlcyApID4gLTFcblx0XHRcdFx0XHQpIHtcblx0XHRcdFx0XHRcdG9wdGlvblNldCA9IHRydWU7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0LyogZXNsaW50LWVuYWJsZSBuby1jb25kLWFzc2lnbiAqL1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gRm9yY2UgYnJvd3NlcnMgdG8gYmVoYXZlIGNvbnNpc3RlbnRseSB3aGVuIG5vbi1tYXRjaGluZyB2YWx1ZSBpcyBzZXRcblx0XHRcdFx0aWYgKCAhb3B0aW9uU2V0ICkge1xuXHRcdFx0XHRcdGVsZW0uc2VsZWN0ZWRJbmRleCA9IC0xO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB2YWx1ZXM7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59ICk7XG5cbi8vIFJhZGlvcyBhbmQgY2hlY2tib3hlcyBnZXR0ZXIvc2V0dGVyXG5qUXVlcnkuZWFjaCggWyBcInJhZGlvXCIsIFwiY2hlY2tib3hcIiBdLCBmdW5jdGlvbigpIHtcblx0alF1ZXJ5LnZhbEhvb2tzWyB0aGlzIF0gPSB7XG5cdFx0c2V0OiBmdW5jdGlvbiggZWxlbSwgdmFsdWUgKSB7XG5cdFx0XHRpZiAoIEFycmF5LmlzQXJyYXkoIHZhbHVlICkgKSB7XG5cdFx0XHRcdHJldHVybiAoIGVsZW0uY2hlY2tlZCA9IGpRdWVyeS5pbkFycmF5KCBqUXVlcnkoIGVsZW0gKS52YWwoKSwgdmFsdWUgKSA+IC0xICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXHRpZiAoICFzdXBwb3J0LmNoZWNrT24gKSB7XG5cdFx0alF1ZXJ5LnZhbEhvb2tzWyB0aGlzIF0uZ2V0ID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gZWxlbS5nZXRBdHRyaWJ1dGUoIFwidmFsdWVcIiApID09PSBudWxsID8gXCJvblwiIDogZWxlbS52YWx1ZTtcblx0XHR9O1xuXHR9XG59ICk7XG5cblxuXG5cbi8vIFJldHVybiBqUXVlcnkgZm9yIGF0dHJpYnV0ZXMtb25seSBpbmNsdXNpb25cbnZhciBsb2NhdGlvbiA9IHdpbmRvdy5sb2NhdGlvbjtcblxudmFyIG5vbmNlID0geyBndWlkOiBEYXRlLm5vdygpIH07XG5cbnZhciBycXVlcnkgPSAoIC9cXD8vICk7XG5cblxuXG4vLyBDcm9zcy1icm93c2VyIHhtbCBwYXJzaW5nXG5qUXVlcnkucGFyc2VYTUwgPSBmdW5jdGlvbiggZGF0YSApIHtcblx0dmFyIHhtbCwgcGFyc2VyRXJyb3JFbGVtO1xuXHRpZiAoICFkYXRhIHx8IHR5cGVvZiBkYXRhICE9PSBcInN0cmluZ1wiICkge1xuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cblx0Ly8gU3VwcG9ydDogSUUgOSAtIDExIG9ubHlcblx0Ly8gSUUgdGhyb3dzIG9uIHBhcnNlRnJvbVN0cmluZyB3aXRoIGludmFsaWQgaW5wdXQuXG5cdHRyeSB7XG5cdFx0eG1sID0gKCBuZXcgd2luZG93LkRPTVBhcnNlcigpICkucGFyc2VGcm9tU3RyaW5nKCBkYXRhLCBcInRleHQveG1sXCIgKTtcblx0fSBjYXRjaCAoIGUgKSB7fVxuXG5cdHBhcnNlckVycm9yRWxlbSA9IHhtbCAmJiB4bWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoIFwicGFyc2VyZXJyb3JcIiApWyAwIF07XG5cdGlmICggIXhtbCB8fCBwYXJzZXJFcnJvckVsZW0gKSB7XG5cdFx0alF1ZXJ5LmVycm9yKCBcIkludmFsaWQgWE1MOiBcIiArIChcblx0XHRcdHBhcnNlckVycm9yRWxlbSA/XG5cdFx0XHRcdGpRdWVyeS5tYXAoIHBhcnNlckVycm9yRWxlbS5jaGlsZE5vZGVzLCBmdW5jdGlvbiggZWwgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGVsLnRleHRDb250ZW50O1xuXHRcdFx0XHR9ICkuam9pbiggXCJcXG5cIiApIDpcblx0XHRcdFx0ZGF0YVxuXHRcdCkgKTtcblx0fVxuXHRyZXR1cm4geG1sO1xufTtcblxuXG52YXIgcmZvY3VzTW9ycGggPSAvXig/OmZvY3VzaW5mb2N1c3xmb2N1c291dGJsdXIpJC8sXG5cdHN0b3BQcm9wYWdhdGlvbkNhbGxiYWNrID0gZnVuY3Rpb24oIGUgKSB7XG5cdFx0ZS5zdG9wUHJvcGFnYXRpb24oKTtcblx0fTtcblxualF1ZXJ5LmV4dGVuZCggalF1ZXJ5LmV2ZW50LCB7XG5cblx0dHJpZ2dlcjogZnVuY3Rpb24oIGV2ZW50LCBkYXRhLCBlbGVtLCBvbmx5SGFuZGxlcnMgKSB7XG5cblx0XHR2YXIgaSwgY3VyLCB0bXAsIGJ1YmJsZVR5cGUsIG9udHlwZSwgaGFuZGxlLCBzcGVjaWFsLCBsYXN0RWxlbWVudCxcblx0XHRcdGV2ZW50UGF0aCA9IFsgZWxlbSB8fCBkb2N1bWVudCBdLFxuXHRcdFx0dHlwZSA9IGhhc093bi5jYWxsKCBldmVudCwgXCJ0eXBlXCIgKSA/IGV2ZW50LnR5cGUgOiBldmVudCxcblx0XHRcdG5hbWVzcGFjZXMgPSBoYXNPd24uY2FsbCggZXZlbnQsIFwibmFtZXNwYWNlXCIgKSA/IGV2ZW50Lm5hbWVzcGFjZS5zcGxpdCggXCIuXCIgKSA6IFtdO1xuXG5cdFx0Y3VyID0gbGFzdEVsZW1lbnQgPSB0bXAgPSBlbGVtID0gZWxlbSB8fCBkb2N1bWVudDtcblxuXHRcdC8vIERvbid0IGRvIGV2ZW50cyBvbiB0ZXh0IGFuZCBjb21tZW50IG5vZGVzXG5cdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAzIHx8IGVsZW0ubm9kZVR5cGUgPT09IDggKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gZm9jdXMvYmx1ciBtb3JwaHMgdG8gZm9jdXNpbi9vdXQ7IGVuc3VyZSB3ZSdyZSBub3QgZmlyaW5nIHRoZW0gcmlnaHQgbm93XG5cdFx0aWYgKCByZm9jdXNNb3JwaC50ZXN0KCB0eXBlICsgalF1ZXJ5LmV2ZW50LnRyaWdnZXJlZCApICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmICggdHlwZS5pbmRleE9mKCBcIi5cIiApID4gLTEgKSB7XG5cblx0XHRcdC8vIE5hbWVzcGFjZWQgdHJpZ2dlcjsgY3JlYXRlIGEgcmVnZXhwIHRvIG1hdGNoIGV2ZW50IHR5cGUgaW4gaGFuZGxlKClcblx0XHRcdG5hbWVzcGFjZXMgPSB0eXBlLnNwbGl0KCBcIi5cIiApO1xuXHRcdFx0dHlwZSA9IG5hbWVzcGFjZXMuc2hpZnQoKTtcblx0XHRcdG5hbWVzcGFjZXMuc29ydCgpO1xuXHRcdH1cblx0XHRvbnR5cGUgPSB0eXBlLmluZGV4T2YoIFwiOlwiICkgPCAwICYmIFwib25cIiArIHR5cGU7XG5cblx0XHQvLyBDYWxsZXIgY2FuIHBhc3MgaW4gYSBqUXVlcnkuRXZlbnQgb2JqZWN0LCBPYmplY3QsIG9yIGp1c3QgYW4gZXZlbnQgdHlwZSBzdHJpbmdcblx0XHRldmVudCA9IGV2ZW50WyBqUXVlcnkuZXhwYW5kbyBdID9cblx0XHRcdGV2ZW50IDpcblx0XHRcdG5ldyBqUXVlcnkuRXZlbnQoIHR5cGUsIHR5cGVvZiBldmVudCA9PT0gXCJvYmplY3RcIiAmJiBldmVudCApO1xuXG5cdFx0Ly8gVHJpZ2dlciBiaXRtYXNrOiAmIDEgZm9yIG5hdGl2ZSBoYW5kbGVyczsgJiAyIGZvciBqUXVlcnkgKGFsd2F5cyB0cnVlKVxuXHRcdGV2ZW50LmlzVHJpZ2dlciA9IG9ubHlIYW5kbGVycyA/IDIgOiAzO1xuXHRcdGV2ZW50Lm5hbWVzcGFjZSA9IG5hbWVzcGFjZXMuam9pbiggXCIuXCIgKTtcblx0XHRldmVudC5ybmFtZXNwYWNlID0gZXZlbnQubmFtZXNwYWNlID9cblx0XHRcdG5ldyBSZWdFeHAoIFwiKF58XFxcXC4pXCIgKyBuYW1lc3BhY2VzLmpvaW4oIFwiXFxcXC4oPzouKlxcXFwufClcIiApICsgXCIoXFxcXC58JClcIiApIDpcblx0XHRcdG51bGw7XG5cblx0XHQvLyBDbGVhbiB1cCB0aGUgZXZlbnQgaW4gY2FzZSBpdCBpcyBiZWluZyByZXVzZWRcblx0XHRldmVudC5yZXN1bHQgPSB1bmRlZmluZWQ7XG5cdFx0aWYgKCAhZXZlbnQudGFyZ2V0ICkge1xuXHRcdFx0ZXZlbnQudGFyZ2V0ID0gZWxlbTtcblx0XHR9XG5cblx0XHQvLyBDbG9uZSBhbnkgaW5jb21pbmcgZGF0YSBhbmQgcHJlcGVuZCB0aGUgZXZlbnQsIGNyZWF0aW5nIHRoZSBoYW5kbGVyIGFyZyBsaXN0XG5cdFx0ZGF0YSA9IGRhdGEgPT0gbnVsbCA/XG5cdFx0XHRbIGV2ZW50IF0gOlxuXHRcdFx0alF1ZXJ5Lm1ha2VBcnJheSggZGF0YSwgWyBldmVudCBdICk7XG5cblx0XHQvLyBBbGxvdyBzcGVjaWFsIGV2ZW50cyB0byBkcmF3IG91dHNpZGUgdGhlIGxpbmVzXG5cdFx0c3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsWyB0eXBlIF0gfHwge307XG5cdFx0aWYgKCAhb25seUhhbmRsZXJzICYmIHNwZWNpYWwudHJpZ2dlciAmJiBzcGVjaWFsLnRyaWdnZXIuYXBwbHkoIGVsZW0sIGRhdGEgKSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gRGV0ZXJtaW5lIGV2ZW50IHByb3BhZ2F0aW9uIHBhdGggaW4gYWR2YW5jZSwgcGVyIFczQyBldmVudHMgc3BlYyAodHJhYy05OTUxKVxuXHRcdC8vIEJ1YmJsZSB1cCB0byBkb2N1bWVudCwgdGhlbiB0byB3aW5kb3c7IHdhdGNoIGZvciBhIGdsb2JhbCBvd25lckRvY3VtZW50IHZhciAodHJhYy05NzI0KVxuXHRcdGlmICggIW9ubHlIYW5kbGVycyAmJiAhc3BlY2lhbC5ub0J1YmJsZSAmJiAhaXNXaW5kb3coIGVsZW0gKSApIHtcblxuXHRcdFx0YnViYmxlVHlwZSA9IHNwZWNpYWwuZGVsZWdhdGVUeXBlIHx8IHR5cGU7XG5cdFx0XHRpZiAoICFyZm9jdXNNb3JwaC50ZXN0KCBidWJibGVUeXBlICsgdHlwZSApICkge1xuXHRcdFx0XHRjdXIgPSBjdXIucGFyZW50Tm9kZTtcblx0XHRcdH1cblx0XHRcdGZvciAoIDsgY3VyOyBjdXIgPSBjdXIucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0ZXZlbnRQYXRoLnB1c2goIGN1ciApO1xuXHRcdFx0XHR0bXAgPSBjdXI7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE9ubHkgYWRkIHdpbmRvdyBpZiB3ZSBnb3QgdG8gZG9jdW1lbnQgKGUuZy4sIG5vdCBwbGFpbiBvYmogb3IgZGV0YWNoZWQgRE9NKVxuXHRcdFx0aWYgKCB0bXAgPT09ICggZWxlbS5vd25lckRvY3VtZW50IHx8IGRvY3VtZW50ICkgKSB7XG5cdFx0XHRcdGV2ZW50UGF0aC5wdXNoKCB0bXAuZGVmYXVsdFZpZXcgfHwgdG1wLnBhcmVudFdpbmRvdyB8fCB3aW5kb3cgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBGaXJlIGhhbmRsZXJzIG9uIHRoZSBldmVudCBwYXRoXG5cdFx0aSA9IDA7XG5cdFx0d2hpbGUgKCAoIGN1ciA9IGV2ZW50UGF0aFsgaSsrIF0gKSAmJiAhZXZlbnQuaXNQcm9wYWdhdGlvblN0b3BwZWQoKSApIHtcblx0XHRcdGxhc3RFbGVtZW50ID0gY3VyO1xuXHRcdFx0ZXZlbnQudHlwZSA9IGkgPiAxID9cblx0XHRcdFx0YnViYmxlVHlwZSA6XG5cdFx0XHRcdHNwZWNpYWwuYmluZFR5cGUgfHwgdHlwZTtcblxuXHRcdFx0Ly8galF1ZXJ5IGhhbmRsZXJcblx0XHRcdGhhbmRsZSA9ICggZGF0YVByaXYuZ2V0KCBjdXIsIFwiZXZlbnRzXCIgKSB8fCBPYmplY3QuY3JlYXRlKCBudWxsICkgKVsgZXZlbnQudHlwZSBdICYmXG5cdFx0XHRcdGRhdGFQcml2LmdldCggY3VyLCBcImhhbmRsZVwiICk7XG5cdFx0XHRpZiAoIGhhbmRsZSApIHtcblx0XHRcdFx0aGFuZGxlLmFwcGx5KCBjdXIsIGRhdGEgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gTmF0aXZlIGhhbmRsZXJcblx0XHRcdGhhbmRsZSA9IG9udHlwZSAmJiBjdXJbIG9udHlwZSBdO1xuXHRcdFx0aWYgKCBoYW5kbGUgJiYgaGFuZGxlLmFwcGx5ICYmIGFjY2VwdERhdGEoIGN1ciApICkge1xuXHRcdFx0XHRldmVudC5yZXN1bHQgPSBoYW5kbGUuYXBwbHkoIGN1ciwgZGF0YSApO1xuXHRcdFx0XHRpZiAoIGV2ZW50LnJlc3VsdCA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRldmVudC50eXBlID0gdHlwZTtcblxuXHRcdC8vIElmIG5vYm9keSBwcmV2ZW50ZWQgdGhlIGRlZmF1bHQgYWN0aW9uLCBkbyBpdCBub3dcblx0XHRpZiAoICFvbmx5SGFuZGxlcnMgJiYgIWV2ZW50LmlzRGVmYXVsdFByZXZlbnRlZCgpICkge1xuXG5cdFx0XHRpZiAoICggIXNwZWNpYWwuX2RlZmF1bHQgfHxcblx0XHRcdFx0c3BlY2lhbC5fZGVmYXVsdC5hcHBseSggZXZlbnRQYXRoLnBvcCgpLCBkYXRhICkgPT09IGZhbHNlICkgJiZcblx0XHRcdFx0YWNjZXB0RGF0YSggZWxlbSApICkge1xuXG5cdFx0XHRcdC8vIENhbGwgYSBuYXRpdmUgRE9NIG1ldGhvZCBvbiB0aGUgdGFyZ2V0IHdpdGggdGhlIHNhbWUgbmFtZSBhcyB0aGUgZXZlbnQuXG5cdFx0XHRcdC8vIERvbid0IGRvIGRlZmF1bHQgYWN0aW9ucyBvbiB3aW5kb3csIHRoYXQncyB3aGVyZSBnbG9iYWwgdmFyaWFibGVzIGJlICh0cmFjLTYxNzApXG5cdFx0XHRcdGlmICggb250eXBlICYmIGlzRnVuY3Rpb24oIGVsZW1bIHR5cGUgXSApICYmICFpc1dpbmRvdyggZWxlbSApICkge1xuXG5cdFx0XHRcdFx0Ly8gRG9uJ3QgcmUtdHJpZ2dlciBhbiBvbkZPTyBldmVudCB3aGVuIHdlIGNhbGwgaXRzIEZPTygpIG1ldGhvZFxuXHRcdFx0XHRcdHRtcCA9IGVsZW1bIG9udHlwZSBdO1xuXG5cdFx0XHRcdFx0aWYgKCB0bXAgKSB7XG5cdFx0XHRcdFx0XHRlbGVtWyBvbnR5cGUgXSA9IG51bGw7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gUHJldmVudCByZS10cmlnZ2VyaW5nIG9mIHRoZSBzYW1lIGV2ZW50LCBzaW5jZSB3ZSBhbHJlYWR5IGJ1YmJsZWQgaXQgYWJvdmVcblx0XHRcdFx0XHRqUXVlcnkuZXZlbnQudHJpZ2dlcmVkID0gdHlwZTtcblxuXHRcdFx0XHRcdGlmICggZXZlbnQuaXNQcm9wYWdhdGlvblN0b3BwZWQoKSApIHtcblx0XHRcdFx0XHRcdGxhc3RFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoIHR5cGUsIHN0b3BQcm9wYWdhdGlvbkNhbGxiYWNrICk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0ZWxlbVsgdHlwZSBdKCk7XG5cblx0XHRcdFx0XHRpZiAoIGV2ZW50LmlzUHJvcGFnYXRpb25TdG9wcGVkKCkgKSB7XG5cdFx0XHRcdFx0XHRsYXN0RWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCB0eXBlLCBzdG9wUHJvcGFnYXRpb25DYWxsYmFjayApO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGpRdWVyeS5ldmVudC50cmlnZ2VyZWQgPSB1bmRlZmluZWQ7XG5cblx0XHRcdFx0XHRpZiAoIHRtcCApIHtcblx0XHRcdFx0XHRcdGVsZW1bIG9udHlwZSBdID0gdG1wO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBldmVudC5yZXN1bHQ7XG5cdH0sXG5cblx0Ly8gUGlnZ3liYWNrIG9uIGEgZG9ub3IgZXZlbnQgdG8gc2ltdWxhdGUgYSBkaWZmZXJlbnQgb25lXG5cdC8vIFVzZWQgb25seSBmb3IgYGZvY3VzKGluIHwgb3V0KWAgZXZlbnRzXG5cdHNpbXVsYXRlOiBmdW5jdGlvbiggdHlwZSwgZWxlbSwgZXZlbnQgKSB7XG5cdFx0dmFyIGUgPSBqUXVlcnkuZXh0ZW5kKFxuXHRcdFx0bmV3IGpRdWVyeS5FdmVudCgpLFxuXHRcdFx0ZXZlbnQsXG5cdFx0XHR7XG5cdFx0XHRcdHR5cGU6IHR5cGUsXG5cdFx0XHRcdGlzU2ltdWxhdGVkOiB0cnVlXG5cdFx0XHR9XG5cdFx0KTtcblxuXHRcdGpRdWVyeS5ldmVudC50cmlnZ2VyKCBlLCBudWxsLCBlbGVtICk7XG5cdH1cblxufSApO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cblx0dHJpZ2dlcjogZnVuY3Rpb24oIHR5cGUsIGRhdGEgKSB7XG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRqUXVlcnkuZXZlbnQudHJpZ2dlciggdHlwZSwgZGF0YSwgdGhpcyApO1xuXHRcdH0gKTtcblx0fSxcblx0dHJpZ2dlckhhbmRsZXI6IGZ1bmN0aW9uKCB0eXBlLCBkYXRhICkge1xuXHRcdHZhciBlbGVtID0gdGhpc1sgMCBdO1xuXHRcdGlmICggZWxlbSApIHtcblx0XHRcdHJldHVybiBqUXVlcnkuZXZlbnQudHJpZ2dlciggdHlwZSwgZGF0YSwgZWxlbSwgdHJ1ZSApO1xuXHRcdH1cblx0fVxufSApO1xuXG5cbnZhclxuXHRyYnJhY2tldCA9IC9cXFtcXF0kLyxcblx0ckNSTEYgPSAvXFxyP1xcbi9nLFxuXHRyc3VibWl0dGVyVHlwZXMgPSAvXig/OnN1Ym1pdHxidXR0b258aW1hZ2V8cmVzZXR8ZmlsZSkkL2ksXG5cdHJzdWJtaXR0YWJsZSA9IC9eKD86aW5wdXR8c2VsZWN0fHRleHRhcmVhfGtleWdlbikvaTtcblxuZnVuY3Rpb24gYnVpbGRQYXJhbXMoIHByZWZpeCwgb2JqLCB0cmFkaXRpb25hbCwgYWRkICkge1xuXHR2YXIgbmFtZTtcblxuXHRpZiAoIEFycmF5LmlzQXJyYXkoIG9iaiApICkge1xuXG5cdFx0Ly8gU2VyaWFsaXplIGFycmF5IGl0ZW0uXG5cdFx0alF1ZXJ5LmVhY2goIG9iaiwgZnVuY3Rpb24oIGksIHYgKSB7XG5cdFx0XHRpZiAoIHRyYWRpdGlvbmFsIHx8IHJicmFja2V0LnRlc3QoIHByZWZpeCApICkge1xuXG5cdFx0XHRcdC8vIFRyZWF0IGVhY2ggYXJyYXkgaXRlbSBhcyBhIHNjYWxhci5cblx0XHRcdFx0YWRkKCBwcmVmaXgsIHYgKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHQvLyBJdGVtIGlzIG5vbi1zY2FsYXIgKGFycmF5IG9yIG9iamVjdCksIGVuY29kZSBpdHMgbnVtZXJpYyBpbmRleC5cblx0XHRcdFx0YnVpbGRQYXJhbXMoXG5cdFx0XHRcdFx0cHJlZml4ICsgXCJbXCIgKyAoIHR5cGVvZiB2ID09PSBcIm9iamVjdFwiICYmIHYgIT0gbnVsbCA/IGkgOiBcIlwiICkgKyBcIl1cIixcblx0XHRcdFx0XHR2LFxuXHRcdFx0XHRcdHRyYWRpdGlvbmFsLFxuXHRcdFx0XHRcdGFkZFxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXHRcdH0gKTtcblxuXHR9IGVsc2UgaWYgKCAhdHJhZGl0aW9uYWwgJiYgdG9UeXBlKCBvYmogKSA9PT0gXCJvYmplY3RcIiApIHtcblxuXHRcdC8vIFNlcmlhbGl6ZSBvYmplY3QgaXRlbS5cblx0XHRmb3IgKCBuYW1lIGluIG9iaiApIHtcblx0XHRcdGJ1aWxkUGFyYW1zKCBwcmVmaXggKyBcIltcIiArIG5hbWUgKyBcIl1cIiwgb2JqWyBuYW1lIF0sIHRyYWRpdGlvbmFsLCBhZGQgKTtcblx0XHR9XG5cblx0fSBlbHNlIHtcblxuXHRcdC8vIFNlcmlhbGl6ZSBzY2FsYXIgaXRlbS5cblx0XHRhZGQoIHByZWZpeCwgb2JqICk7XG5cdH1cbn1cblxuLy8gU2VyaWFsaXplIGFuIGFycmF5IG9mIGZvcm0gZWxlbWVudHMgb3IgYSBzZXQgb2Zcbi8vIGtleS92YWx1ZXMgaW50byBhIHF1ZXJ5IHN0cmluZ1xualF1ZXJ5LnBhcmFtID0gZnVuY3Rpb24oIGEsIHRyYWRpdGlvbmFsICkge1xuXHR2YXIgcHJlZml4LFxuXHRcdHMgPSBbXSxcblx0XHRhZGQgPSBmdW5jdGlvbigga2V5LCB2YWx1ZU9yRnVuY3Rpb24gKSB7XG5cblx0XHRcdC8vIElmIHZhbHVlIGlzIGEgZnVuY3Rpb24sIGludm9rZSBpdCBhbmQgdXNlIGl0cyByZXR1cm4gdmFsdWVcblx0XHRcdHZhciB2YWx1ZSA9IGlzRnVuY3Rpb24oIHZhbHVlT3JGdW5jdGlvbiApID9cblx0XHRcdFx0dmFsdWVPckZ1bmN0aW9uKCkgOlxuXHRcdFx0XHR2YWx1ZU9yRnVuY3Rpb247XG5cblx0XHRcdHNbIHMubGVuZ3RoIF0gPSBlbmNvZGVVUklDb21wb25lbnQoIGtleSApICsgXCI9XCIgK1xuXHRcdFx0XHRlbmNvZGVVUklDb21wb25lbnQoIHZhbHVlID09IG51bGwgPyBcIlwiIDogdmFsdWUgKTtcblx0XHR9O1xuXG5cdGlmICggYSA9PSBudWxsICkge1xuXHRcdHJldHVybiBcIlwiO1xuXHR9XG5cblx0Ly8gSWYgYW4gYXJyYXkgd2FzIHBhc3NlZCBpbiwgYXNzdW1lIHRoYXQgaXQgaXMgYW4gYXJyYXkgb2YgZm9ybSBlbGVtZW50cy5cblx0aWYgKCBBcnJheS5pc0FycmF5KCBhICkgfHwgKCBhLmpxdWVyeSAmJiAhalF1ZXJ5LmlzUGxhaW5PYmplY3QoIGEgKSApICkge1xuXG5cdFx0Ly8gU2VyaWFsaXplIHRoZSBmb3JtIGVsZW1lbnRzXG5cdFx0alF1ZXJ5LmVhY2goIGEsIGZ1bmN0aW9uKCkge1xuXHRcdFx0YWRkKCB0aGlzLm5hbWUsIHRoaXMudmFsdWUgKTtcblx0XHR9ICk7XG5cblx0fSBlbHNlIHtcblxuXHRcdC8vIElmIHRyYWRpdGlvbmFsLCBlbmNvZGUgdGhlIFwib2xkXCIgd2F5ICh0aGUgd2F5IDEuMy4yIG9yIG9sZGVyXG5cdFx0Ly8gZGlkIGl0KSwgb3RoZXJ3aXNlIGVuY29kZSBwYXJhbXMgcmVjdXJzaXZlbHkuXG5cdFx0Zm9yICggcHJlZml4IGluIGEgKSB7XG5cdFx0XHRidWlsZFBhcmFtcyggcHJlZml4LCBhWyBwcmVmaXggXSwgdHJhZGl0aW9uYWwsIGFkZCApO1xuXHRcdH1cblx0fVxuXG5cdC8vIFJldHVybiB0aGUgcmVzdWx0aW5nIHNlcmlhbGl6YXRpb25cblx0cmV0dXJuIHMuam9pbiggXCImXCIgKTtcbn07XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0c2VyaWFsaXplOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4galF1ZXJ5LnBhcmFtKCB0aGlzLnNlcmlhbGl6ZUFycmF5KCkgKTtcblx0fSxcblx0c2VyaWFsaXplQXJyYXk6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLm1hcCggZnVuY3Rpb24oKSB7XG5cblx0XHRcdC8vIENhbiBhZGQgcHJvcEhvb2sgZm9yIFwiZWxlbWVudHNcIiB0byBmaWx0ZXIgb3IgYWRkIGZvcm0gZWxlbWVudHNcblx0XHRcdHZhciBlbGVtZW50cyA9IGpRdWVyeS5wcm9wKCB0aGlzLCBcImVsZW1lbnRzXCIgKTtcblx0XHRcdHJldHVybiBlbGVtZW50cyA/IGpRdWVyeS5tYWtlQXJyYXkoIGVsZW1lbnRzICkgOiB0aGlzO1xuXHRcdH0gKS5maWx0ZXIoIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHR5cGUgPSB0aGlzLnR5cGU7XG5cblx0XHRcdC8vIFVzZSAuaXMoIFwiOmRpc2FibGVkXCIgKSBzbyB0aGF0IGZpZWxkc2V0W2Rpc2FibGVkXSB3b3Jrc1xuXHRcdFx0cmV0dXJuIHRoaXMubmFtZSAmJiAhalF1ZXJ5KCB0aGlzICkuaXMoIFwiOmRpc2FibGVkXCIgKSAmJlxuXHRcdFx0XHRyc3VibWl0dGFibGUudGVzdCggdGhpcy5ub2RlTmFtZSApICYmICFyc3VibWl0dGVyVHlwZXMudGVzdCggdHlwZSApICYmXG5cdFx0XHRcdCggdGhpcy5jaGVja2VkIHx8ICFyY2hlY2thYmxlVHlwZS50ZXN0KCB0eXBlICkgKTtcblx0XHR9ICkubWFwKCBmdW5jdGlvbiggX2ksIGVsZW0gKSB7XG5cdFx0XHR2YXIgdmFsID0galF1ZXJ5KCB0aGlzICkudmFsKCk7XG5cblx0XHRcdGlmICggdmFsID09IG51bGwgKSB7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIEFycmF5LmlzQXJyYXkoIHZhbCApICkge1xuXHRcdFx0XHRyZXR1cm4galF1ZXJ5Lm1hcCggdmFsLCBmdW5jdGlvbiggdmFsICkge1xuXHRcdFx0XHRcdHJldHVybiB7IG5hbWU6IGVsZW0ubmFtZSwgdmFsdWU6IHZhbC5yZXBsYWNlKCByQ1JMRiwgXCJcXHJcXG5cIiApIH07XG5cdFx0XHRcdH0gKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHsgbmFtZTogZWxlbS5uYW1lLCB2YWx1ZTogdmFsLnJlcGxhY2UoIHJDUkxGLCBcIlxcclxcblwiICkgfTtcblx0XHR9ICkuZ2V0KCk7XG5cdH1cbn0gKTtcblxuXG52YXJcblx0cjIwID0gLyUyMC9nLFxuXHRyaGFzaCA9IC8jLiokLyxcblx0cmFudGlDYWNoZSA9IC8oWz8mXSlfPVteJl0qLyxcblx0cmhlYWRlcnMgPSAvXiguKj8pOlsgXFx0XSooW15cXHJcXG5dKikkL21nLFxuXG5cdC8vIHRyYWMtNzY1MywgdHJhYy04MTI1LCB0cmFjLTgxNTI6IGxvY2FsIHByb3RvY29sIGRldGVjdGlvblxuXHRybG9jYWxQcm90b2NvbCA9IC9eKD86YWJvdXR8YXBwfGFwcC1zdG9yYWdlfC4rLWV4dGVuc2lvbnxmaWxlfHJlc3x3aWRnZXQpOiQvLFxuXHRybm9Db250ZW50ID0gL14oPzpHRVR8SEVBRCkkLyxcblx0cnByb3RvY29sID0gL15cXC9cXC8vLFxuXG5cdC8qIFByZWZpbHRlcnNcblx0ICogMSkgVGhleSBhcmUgdXNlZnVsIHRvIGludHJvZHVjZSBjdXN0b20gZGF0YVR5cGVzIChzZWUgYWpheC9qc29ucC5qcyBmb3IgYW4gZXhhbXBsZSlcblx0ICogMikgVGhlc2UgYXJlIGNhbGxlZDpcblx0ICogICAgLSBCRUZPUkUgYXNraW5nIGZvciBhIHRyYW5zcG9ydFxuXHQgKiAgICAtIEFGVEVSIHBhcmFtIHNlcmlhbGl6YXRpb24gKHMuZGF0YSBpcyBhIHN0cmluZyBpZiBzLnByb2Nlc3NEYXRhIGlzIHRydWUpXG5cdCAqIDMpIGtleSBpcyB0aGUgZGF0YVR5cGVcblx0ICogNCkgdGhlIGNhdGNoYWxsIHN5bWJvbCBcIipcIiBjYW4gYmUgdXNlZFxuXHQgKiA1KSBleGVjdXRpb24gd2lsbCBzdGFydCB3aXRoIHRyYW5zcG9ydCBkYXRhVHlwZSBhbmQgVEhFTiBjb250aW51ZSBkb3duIHRvIFwiKlwiIGlmIG5lZWRlZFxuXHQgKi9cblx0cHJlZmlsdGVycyA9IHt9LFxuXG5cdC8qIFRyYW5zcG9ydHMgYmluZGluZ3Ncblx0ICogMSkga2V5IGlzIHRoZSBkYXRhVHlwZVxuXHQgKiAyKSB0aGUgY2F0Y2hhbGwgc3ltYm9sIFwiKlwiIGNhbiBiZSB1c2VkXG5cdCAqIDMpIHNlbGVjdGlvbiB3aWxsIHN0YXJ0IHdpdGggdHJhbnNwb3J0IGRhdGFUeXBlIGFuZCBUSEVOIGdvIHRvIFwiKlwiIGlmIG5lZWRlZFxuXHQgKi9cblx0dHJhbnNwb3J0cyA9IHt9LFxuXG5cdC8vIEF2b2lkIGNvbW1lbnQtcHJvbG9nIGNoYXIgc2VxdWVuY2UgKHRyYWMtMTAwOTgpOyBtdXN0IGFwcGVhc2UgbGludCBhbmQgZXZhZGUgY29tcHJlc3Npb25cblx0YWxsVHlwZXMgPSBcIiovXCIuY29uY2F0KCBcIipcIiApLFxuXG5cdC8vIEFuY2hvciB0YWcgZm9yIHBhcnNpbmcgdGhlIGRvY3VtZW50IG9yaWdpblxuXHRvcmlnaW5BbmNob3IgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImFcIiApO1xuXG5vcmlnaW5BbmNob3IuaHJlZiA9IGxvY2F0aW9uLmhyZWY7XG5cbi8vIEJhc2UgXCJjb25zdHJ1Y3RvclwiIGZvciBqUXVlcnkuYWpheFByZWZpbHRlciBhbmQgalF1ZXJ5LmFqYXhUcmFuc3BvcnRcbmZ1bmN0aW9uIGFkZFRvUHJlZmlsdGVyc09yVHJhbnNwb3J0cyggc3RydWN0dXJlICkge1xuXG5cdC8vIGRhdGFUeXBlRXhwcmVzc2lvbiBpcyBvcHRpb25hbCBhbmQgZGVmYXVsdHMgdG8gXCIqXCJcblx0cmV0dXJuIGZ1bmN0aW9uKCBkYXRhVHlwZUV4cHJlc3Npb24sIGZ1bmMgKSB7XG5cblx0XHRpZiAoIHR5cGVvZiBkYXRhVHlwZUV4cHJlc3Npb24gIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRmdW5jID0gZGF0YVR5cGVFeHByZXNzaW9uO1xuXHRcdFx0ZGF0YVR5cGVFeHByZXNzaW9uID0gXCIqXCI7XG5cdFx0fVxuXG5cdFx0dmFyIGRhdGFUeXBlLFxuXHRcdFx0aSA9IDAsXG5cdFx0XHRkYXRhVHlwZXMgPSBkYXRhVHlwZUV4cHJlc3Npb24udG9Mb3dlckNhc2UoKS5tYXRjaCggcm5vdGh0bWx3aGl0ZSApIHx8IFtdO1xuXG5cdFx0aWYgKCBpc0Z1bmN0aW9uKCBmdW5jICkgKSB7XG5cblx0XHRcdC8vIEZvciBlYWNoIGRhdGFUeXBlIGluIHRoZSBkYXRhVHlwZUV4cHJlc3Npb25cblx0XHRcdHdoaWxlICggKCBkYXRhVHlwZSA9IGRhdGFUeXBlc1sgaSsrIF0gKSApIHtcblxuXHRcdFx0XHQvLyBQcmVwZW5kIGlmIHJlcXVlc3RlZFxuXHRcdFx0XHRpZiAoIGRhdGFUeXBlWyAwIF0gPT09IFwiK1wiICkge1xuXHRcdFx0XHRcdGRhdGFUeXBlID0gZGF0YVR5cGUuc2xpY2UoIDEgKSB8fCBcIipcIjtcblx0XHRcdFx0XHQoIHN0cnVjdHVyZVsgZGF0YVR5cGUgXSA9IHN0cnVjdHVyZVsgZGF0YVR5cGUgXSB8fCBbXSApLnVuc2hpZnQoIGZ1bmMgKTtcblxuXHRcdFx0XHQvLyBPdGhlcndpc2UgYXBwZW5kXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0KCBzdHJ1Y3R1cmVbIGRhdGFUeXBlIF0gPSBzdHJ1Y3R1cmVbIGRhdGFUeXBlIF0gfHwgW10gKS5wdXNoKCBmdW5jICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH07XG59XG5cbi8vIEJhc2UgaW5zcGVjdGlvbiBmdW5jdGlvbiBmb3IgcHJlZmlsdGVycyBhbmQgdHJhbnNwb3J0c1xuZnVuY3Rpb24gaW5zcGVjdFByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHN0cnVjdHVyZSwgb3B0aW9ucywgb3JpZ2luYWxPcHRpb25zLCBqcVhIUiApIHtcblxuXHR2YXIgaW5zcGVjdGVkID0ge30sXG5cdFx0c2Vla2luZ1RyYW5zcG9ydCA9ICggc3RydWN0dXJlID09PSB0cmFuc3BvcnRzICk7XG5cblx0ZnVuY3Rpb24gaW5zcGVjdCggZGF0YVR5cGUgKSB7XG5cdFx0dmFyIHNlbGVjdGVkO1xuXHRcdGluc3BlY3RlZFsgZGF0YVR5cGUgXSA9IHRydWU7XG5cdFx0alF1ZXJ5LmVhY2goIHN0cnVjdHVyZVsgZGF0YVR5cGUgXSB8fCBbXSwgZnVuY3Rpb24oIF8sIHByZWZpbHRlck9yRmFjdG9yeSApIHtcblx0XHRcdHZhciBkYXRhVHlwZU9yVHJhbnNwb3J0ID0gcHJlZmlsdGVyT3JGYWN0b3J5KCBvcHRpb25zLCBvcmlnaW5hbE9wdGlvbnMsIGpxWEhSICk7XG5cdFx0XHRpZiAoIHR5cGVvZiBkYXRhVHlwZU9yVHJhbnNwb3J0ID09PSBcInN0cmluZ1wiICYmXG5cdFx0XHRcdCFzZWVraW5nVHJhbnNwb3J0ICYmICFpbnNwZWN0ZWRbIGRhdGFUeXBlT3JUcmFuc3BvcnQgXSApIHtcblxuXHRcdFx0XHRvcHRpb25zLmRhdGFUeXBlcy51bnNoaWZ0KCBkYXRhVHlwZU9yVHJhbnNwb3J0ICk7XG5cdFx0XHRcdGluc3BlY3QoIGRhdGFUeXBlT3JUcmFuc3BvcnQgKTtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fSBlbHNlIGlmICggc2Vla2luZ1RyYW5zcG9ydCApIHtcblx0XHRcdFx0cmV0dXJuICEoIHNlbGVjdGVkID0gZGF0YVR5cGVPclRyYW5zcG9ydCApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0XHRyZXR1cm4gc2VsZWN0ZWQ7XG5cdH1cblxuXHRyZXR1cm4gaW5zcGVjdCggb3B0aW9ucy5kYXRhVHlwZXNbIDAgXSApIHx8ICFpbnNwZWN0ZWRbIFwiKlwiIF0gJiYgaW5zcGVjdCggXCIqXCIgKTtcbn1cblxuLy8gQSBzcGVjaWFsIGV4dGVuZCBmb3IgYWpheCBvcHRpb25zXG4vLyB0aGF0IHRha2VzIFwiZmxhdFwiIG9wdGlvbnMgKG5vdCB0byBiZSBkZWVwIGV4dGVuZGVkKVxuLy8gRml4ZXMgdHJhYy05ODg3XG5mdW5jdGlvbiBhamF4RXh0ZW5kKCB0YXJnZXQsIHNyYyApIHtcblx0dmFyIGtleSwgZGVlcCxcblx0XHRmbGF0T3B0aW9ucyA9IGpRdWVyeS5hamF4U2V0dGluZ3MuZmxhdE9wdGlvbnMgfHwge307XG5cblx0Zm9yICgga2V5IGluIHNyYyApIHtcblx0XHRpZiAoIHNyY1sga2V5IF0gIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdCggZmxhdE9wdGlvbnNbIGtleSBdID8gdGFyZ2V0IDogKCBkZWVwIHx8ICggZGVlcCA9IHt9ICkgKSApWyBrZXkgXSA9IHNyY1sga2V5IF07XG5cdFx0fVxuXHR9XG5cdGlmICggZGVlcCApIHtcblx0XHRqUXVlcnkuZXh0ZW5kKCB0cnVlLCB0YXJnZXQsIGRlZXAgKTtcblx0fVxuXG5cdHJldHVybiB0YXJnZXQ7XG59XG5cbi8qIEhhbmRsZXMgcmVzcG9uc2VzIHRvIGFuIGFqYXggcmVxdWVzdDpcbiAqIC0gZmluZHMgdGhlIHJpZ2h0IGRhdGFUeXBlIChtZWRpYXRlcyBiZXR3ZWVuIGNvbnRlbnQtdHlwZSBhbmQgZXhwZWN0ZWQgZGF0YVR5cGUpXG4gKiAtIHJldHVybnMgdGhlIGNvcnJlc3BvbmRpbmcgcmVzcG9uc2VcbiAqL1xuZnVuY3Rpb24gYWpheEhhbmRsZVJlc3BvbnNlcyggcywganFYSFIsIHJlc3BvbnNlcyApIHtcblxuXHR2YXIgY3QsIHR5cGUsIGZpbmFsRGF0YVR5cGUsIGZpcnN0RGF0YVR5cGUsXG5cdFx0Y29udGVudHMgPSBzLmNvbnRlbnRzLFxuXHRcdGRhdGFUeXBlcyA9IHMuZGF0YVR5cGVzO1xuXG5cdC8vIFJlbW92ZSBhdXRvIGRhdGFUeXBlIGFuZCBnZXQgY29udGVudC10eXBlIGluIHRoZSBwcm9jZXNzXG5cdHdoaWxlICggZGF0YVR5cGVzWyAwIF0gPT09IFwiKlwiICkge1xuXHRcdGRhdGFUeXBlcy5zaGlmdCgpO1xuXHRcdGlmICggY3QgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdGN0ID0gcy5taW1lVHlwZSB8fCBqcVhIUi5nZXRSZXNwb25zZUhlYWRlciggXCJDb250ZW50LVR5cGVcIiApO1xuXHRcdH1cblx0fVxuXG5cdC8vIENoZWNrIGlmIHdlJ3JlIGRlYWxpbmcgd2l0aCBhIGtub3duIGNvbnRlbnQtdHlwZVxuXHRpZiAoIGN0ICkge1xuXHRcdGZvciAoIHR5cGUgaW4gY29udGVudHMgKSB7XG5cdFx0XHRpZiAoIGNvbnRlbnRzWyB0eXBlIF0gJiYgY29udGVudHNbIHR5cGUgXS50ZXN0KCBjdCApICkge1xuXHRcdFx0XHRkYXRhVHlwZXMudW5zaGlmdCggdHlwZSApO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBDaGVjayB0byBzZWUgaWYgd2UgaGF2ZSBhIHJlc3BvbnNlIGZvciB0aGUgZXhwZWN0ZWQgZGF0YVR5cGVcblx0aWYgKCBkYXRhVHlwZXNbIDAgXSBpbiByZXNwb25zZXMgKSB7XG5cdFx0ZmluYWxEYXRhVHlwZSA9IGRhdGFUeXBlc1sgMCBdO1xuXHR9IGVsc2Uge1xuXG5cdFx0Ly8gVHJ5IGNvbnZlcnRpYmxlIGRhdGFUeXBlc1xuXHRcdGZvciAoIHR5cGUgaW4gcmVzcG9uc2VzICkge1xuXHRcdFx0aWYgKCAhZGF0YVR5cGVzWyAwIF0gfHwgcy5jb252ZXJ0ZXJzWyB0eXBlICsgXCIgXCIgKyBkYXRhVHlwZXNbIDAgXSBdICkge1xuXHRcdFx0XHRmaW5hbERhdGFUeXBlID0gdHlwZTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0XHRpZiAoICFmaXJzdERhdGFUeXBlICkge1xuXHRcdFx0XHRmaXJzdERhdGFUeXBlID0gdHlwZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBPciBqdXN0IHVzZSBmaXJzdCBvbmVcblx0XHRmaW5hbERhdGFUeXBlID0gZmluYWxEYXRhVHlwZSB8fCBmaXJzdERhdGFUeXBlO1xuXHR9XG5cblx0Ly8gSWYgd2UgZm91bmQgYSBkYXRhVHlwZVxuXHQvLyBXZSBhZGQgdGhlIGRhdGFUeXBlIHRvIHRoZSBsaXN0IGlmIG5lZWRlZFxuXHQvLyBhbmQgcmV0dXJuIHRoZSBjb3JyZXNwb25kaW5nIHJlc3BvbnNlXG5cdGlmICggZmluYWxEYXRhVHlwZSApIHtcblx0XHRpZiAoIGZpbmFsRGF0YVR5cGUgIT09IGRhdGFUeXBlc1sgMCBdICkge1xuXHRcdFx0ZGF0YVR5cGVzLnVuc2hpZnQoIGZpbmFsRGF0YVR5cGUgKTtcblx0XHR9XG5cdFx0cmV0dXJuIHJlc3BvbnNlc1sgZmluYWxEYXRhVHlwZSBdO1xuXHR9XG59XG5cbi8qIENoYWluIGNvbnZlcnNpb25zIGdpdmVuIHRoZSByZXF1ZXN0IGFuZCB0aGUgb3JpZ2luYWwgcmVzcG9uc2VcbiAqIEFsc28gc2V0cyB0aGUgcmVzcG9uc2VYWFggZmllbGRzIG9uIHRoZSBqcVhIUiBpbnN0YW5jZVxuICovXG5mdW5jdGlvbiBhamF4Q29udmVydCggcywgcmVzcG9uc2UsIGpxWEhSLCBpc1N1Y2Nlc3MgKSB7XG5cdHZhciBjb252MiwgY3VycmVudCwgY29udiwgdG1wLCBwcmV2LFxuXHRcdGNvbnZlcnRlcnMgPSB7fSxcblxuXHRcdC8vIFdvcmsgd2l0aCBhIGNvcHkgb2YgZGF0YVR5cGVzIGluIGNhc2Ugd2UgbmVlZCB0byBtb2RpZnkgaXQgZm9yIGNvbnZlcnNpb25cblx0XHRkYXRhVHlwZXMgPSBzLmRhdGFUeXBlcy5zbGljZSgpO1xuXG5cdC8vIENyZWF0ZSBjb252ZXJ0ZXJzIG1hcCB3aXRoIGxvd2VyY2FzZWQga2V5c1xuXHRpZiAoIGRhdGFUeXBlc1sgMSBdICkge1xuXHRcdGZvciAoIGNvbnYgaW4gcy5jb252ZXJ0ZXJzICkge1xuXHRcdFx0Y29udmVydGVyc1sgY29udi50b0xvd2VyQ2FzZSgpIF0gPSBzLmNvbnZlcnRlcnNbIGNvbnYgXTtcblx0XHR9XG5cdH1cblxuXHRjdXJyZW50ID0gZGF0YVR5cGVzLnNoaWZ0KCk7XG5cblx0Ly8gQ29udmVydCB0byBlYWNoIHNlcXVlbnRpYWwgZGF0YVR5cGVcblx0d2hpbGUgKCBjdXJyZW50ICkge1xuXG5cdFx0aWYgKCBzLnJlc3BvbnNlRmllbGRzWyBjdXJyZW50IF0gKSB7XG5cdFx0XHRqcVhIUlsgcy5yZXNwb25zZUZpZWxkc1sgY3VycmVudCBdIF0gPSByZXNwb25zZTtcblx0XHR9XG5cblx0XHQvLyBBcHBseSB0aGUgZGF0YUZpbHRlciBpZiBwcm92aWRlZFxuXHRcdGlmICggIXByZXYgJiYgaXNTdWNjZXNzICYmIHMuZGF0YUZpbHRlciApIHtcblx0XHRcdHJlc3BvbnNlID0gcy5kYXRhRmlsdGVyKCByZXNwb25zZSwgcy5kYXRhVHlwZSApO1xuXHRcdH1cblxuXHRcdHByZXYgPSBjdXJyZW50O1xuXHRcdGN1cnJlbnQgPSBkYXRhVHlwZXMuc2hpZnQoKTtcblxuXHRcdGlmICggY3VycmVudCApIHtcblxuXHRcdFx0Ly8gVGhlcmUncyBvbmx5IHdvcmsgdG8gZG8gaWYgY3VycmVudCBkYXRhVHlwZSBpcyBub24tYXV0b1xuXHRcdFx0aWYgKCBjdXJyZW50ID09PSBcIipcIiApIHtcblxuXHRcdFx0XHRjdXJyZW50ID0gcHJldjtcblxuXHRcdFx0Ly8gQ29udmVydCByZXNwb25zZSBpZiBwcmV2IGRhdGFUeXBlIGlzIG5vbi1hdXRvIGFuZCBkaWZmZXJzIGZyb20gY3VycmVudFxuXHRcdFx0fSBlbHNlIGlmICggcHJldiAhPT0gXCIqXCIgJiYgcHJldiAhPT0gY3VycmVudCApIHtcblxuXHRcdFx0XHQvLyBTZWVrIGEgZGlyZWN0IGNvbnZlcnRlclxuXHRcdFx0XHRjb252ID0gY29udmVydGVyc1sgcHJldiArIFwiIFwiICsgY3VycmVudCBdIHx8IGNvbnZlcnRlcnNbIFwiKiBcIiArIGN1cnJlbnQgXTtcblxuXHRcdFx0XHQvLyBJZiBub25lIGZvdW5kLCBzZWVrIGEgcGFpclxuXHRcdFx0XHRpZiAoICFjb252ICkge1xuXHRcdFx0XHRcdGZvciAoIGNvbnYyIGluIGNvbnZlcnRlcnMgKSB7XG5cblx0XHRcdFx0XHRcdC8vIElmIGNvbnYyIG91dHB1dHMgY3VycmVudFxuXHRcdFx0XHRcdFx0dG1wID0gY29udjIuc3BsaXQoIFwiIFwiICk7XG5cdFx0XHRcdFx0XHRpZiAoIHRtcFsgMSBdID09PSBjdXJyZW50ICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIElmIHByZXYgY2FuIGJlIGNvbnZlcnRlZCB0byBhY2NlcHRlZCBpbnB1dFxuXHRcdFx0XHRcdFx0XHRjb252ID0gY29udmVydGVyc1sgcHJldiArIFwiIFwiICsgdG1wWyAwIF0gXSB8fFxuXHRcdFx0XHRcdFx0XHRcdGNvbnZlcnRlcnNbIFwiKiBcIiArIHRtcFsgMCBdIF07XG5cdFx0XHRcdFx0XHRcdGlmICggY29udiApIHtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIENvbmRlbnNlIGVxdWl2YWxlbmNlIGNvbnZlcnRlcnNcblx0XHRcdFx0XHRcdFx0XHRpZiAoIGNvbnYgPT09IHRydWUgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRjb252ID0gY29udmVydGVyc1sgY29udjIgXTtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIE90aGVyd2lzZSwgaW5zZXJ0IHRoZSBpbnRlcm1lZGlhdGUgZGF0YVR5cGVcblx0XHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKCBjb252ZXJ0ZXJzWyBjb252MiBdICE9PSB0cnVlICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0Y3VycmVudCA9IHRtcFsgMCBdO1xuXHRcdFx0XHRcdFx0XHRcdFx0ZGF0YVR5cGVzLnVuc2hpZnQoIHRtcFsgMSBdICk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gQXBwbHkgY29udmVydGVyIChpZiBub3QgYW4gZXF1aXZhbGVuY2UpXG5cdFx0XHRcdGlmICggY29udiAhPT0gdHJ1ZSApIHtcblxuXHRcdFx0XHRcdC8vIFVubGVzcyBlcnJvcnMgYXJlIGFsbG93ZWQgdG8gYnViYmxlLCBjYXRjaCBhbmQgcmV0dXJuIHRoZW1cblx0XHRcdFx0XHRpZiAoIGNvbnYgJiYgcy50aHJvd3MgKSB7XG5cdFx0XHRcdFx0XHRyZXNwb25zZSA9IGNvbnYoIHJlc3BvbnNlICk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHRcdHJlc3BvbnNlID0gY29udiggcmVzcG9uc2UgKTtcblx0XHRcdFx0XHRcdH0gY2F0Y2ggKCBlICkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdFx0XHRcdHN0YXRlOiBcInBhcnNlcmVycm9yXCIsXG5cdFx0XHRcdFx0XHRcdFx0ZXJyb3I6IGNvbnYgPyBlIDogXCJObyBjb252ZXJzaW9uIGZyb20gXCIgKyBwcmV2ICsgXCIgdG8gXCIgKyBjdXJyZW50XG5cdFx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHsgc3RhdGU6IFwic3VjY2Vzc1wiLCBkYXRhOiByZXNwb25zZSB9O1xufVxuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cblx0Ly8gQ291bnRlciBmb3IgaG9sZGluZyB0aGUgbnVtYmVyIG9mIGFjdGl2ZSBxdWVyaWVzXG5cdGFjdGl2ZTogMCxcblxuXHQvLyBMYXN0LU1vZGlmaWVkIGhlYWRlciBjYWNoZSBmb3IgbmV4dCByZXF1ZXN0XG5cdGxhc3RNb2RpZmllZDoge30sXG5cdGV0YWc6IHt9LFxuXG5cdGFqYXhTZXR0aW5nczoge1xuXHRcdHVybDogbG9jYXRpb24uaHJlZixcblx0XHR0eXBlOiBcIkdFVFwiLFxuXHRcdGlzTG9jYWw6IHJsb2NhbFByb3RvY29sLnRlc3QoIGxvY2F0aW9uLnByb3RvY29sICksXG5cdFx0Z2xvYmFsOiB0cnVlLFxuXHRcdHByb2Nlc3NEYXRhOiB0cnVlLFxuXHRcdGFzeW5jOiB0cnVlLFxuXHRcdGNvbnRlbnRUeXBlOiBcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZDsgY2hhcnNldD1VVEYtOFwiLFxuXG5cdFx0Lypcblx0XHR0aW1lb3V0OiAwLFxuXHRcdGRhdGE6IG51bGwsXG5cdFx0ZGF0YVR5cGU6IG51bGwsXG5cdFx0dXNlcm5hbWU6IG51bGwsXG5cdFx0cGFzc3dvcmQ6IG51bGwsXG5cdFx0Y2FjaGU6IG51bGwsXG5cdFx0dGhyb3dzOiBmYWxzZSxcblx0XHR0cmFkaXRpb25hbDogZmFsc2UsXG5cdFx0aGVhZGVyczoge30sXG5cdFx0Ki9cblxuXHRcdGFjY2VwdHM6IHtcblx0XHRcdFwiKlwiOiBhbGxUeXBlcyxcblx0XHRcdHRleHQ6IFwidGV4dC9wbGFpblwiLFxuXHRcdFx0aHRtbDogXCJ0ZXh0L2h0bWxcIixcblx0XHRcdHhtbDogXCJhcHBsaWNhdGlvbi94bWwsIHRleHQveG1sXCIsXG5cdFx0XHRqc29uOiBcImFwcGxpY2F0aW9uL2pzb24sIHRleHQvamF2YXNjcmlwdFwiXG5cdFx0fSxcblxuXHRcdGNvbnRlbnRzOiB7XG5cdFx0XHR4bWw6IC9cXGJ4bWxcXGIvLFxuXHRcdFx0aHRtbDogL1xcYmh0bWwvLFxuXHRcdFx0anNvbjogL1xcYmpzb25cXGIvXG5cdFx0fSxcblxuXHRcdHJlc3BvbnNlRmllbGRzOiB7XG5cdFx0XHR4bWw6IFwicmVzcG9uc2VYTUxcIixcblx0XHRcdHRleHQ6IFwicmVzcG9uc2VUZXh0XCIsXG5cdFx0XHRqc29uOiBcInJlc3BvbnNlSlNPTlwiXG5cdFx0fSxcblxuXHRcdC8vIERhdGEgY29udmVydGVyc1xuXHRcdC8vIEtleXMgc2VwYXJhdGUgc291cmNlIChvciBjYXRjaGFsbCBcIipcIikgYW5kIGRlc3RpbmF0aW9uIHR5cGVzIHdpdGggYSBzaW5nbGUgc3BhY2Vcblx0XHRjb252ZXJ0ZXJzOiB7XG5cblx0XHRcdC8vIENvbnZlcnQgYW55dGhpbmcgdG8gdGV4dFxuXHRcdFx0XCIqIHRleHRcIjogU3RyaW5nLFxuXG5cdFx0XHQvLyBUZXh0IHRvIGh0bWwgKHRydWUgPSBubyB0cmFuc2Zvcm1hdGlvbilcblx0XHRcdFwidGV4dCBodG1sXCI6IHRydWUsXG5cblx0XHRcdC8vIEV2YWx1YXRlIHRleHQgYXMgYSBqc29uIGV4cHJlc3Npb25cblx0XHRcdFwidGV4dCBqc29uXCI6IEpTT04ucGFyc2UsXG5cblx0XHRcdC8vIFBhcnNlIHRleHQgYXMgeG1sXG5cdFx0XHRcInRleHQgeG1sXCI6IGpRdWVyeS5wYXJzZVhNTFxuXHRcdH0sXG5cblx0XHQvLyBGb3Igb3B0aW9ucyB0aGF0IHNob3VsZG4ndCBiZSBkZWVwIGV4dGVuZGVkOlxuXHRcdC8vIHlvdSBjYW4gYWRkIHlvdXIgb3duIGN1c3RvbSBvcHRpb25zIGhlcmUgaWZcblx0XHQvLyBhbmQgd2hlbiB5b3UgY3JlYXRlIG9uZSB0aGF0IHNob3VsZG4ndCBiZVxuXHRcdC8vIGRlZXAgZXh0ZW5kZWQgKHNlZSBhamF4RXh0ZW5kKVxuXHRcdGZsYXRPcHRpb25zOiB7XG5cdFx0XHR1cmw6IHRydWUsXG5cdFx0XHRjb250ZXh0OiB0cnVlXG5cdFx0fVxuXHR9LFxuXG5cdC8vIENyZWF0ZXMgYSBmdWxsIGZsZWRnZWQgc2V0dGluZ3Mgb2JqZWN0IGludG8gdGFyZ2V0XG5cdC8vIHdpdGggYm90aCBhamF4U2V0dGluZ3MgYW5kIHNldHRpbmdzIGZpZWxkcy5cblx0Ly8gSWYgdGFyZ2V0IGlzIG9taXR0ZWQsIHdyaXRlcyBpbnRvIGFqYXhTZXR0aW5ncy5cblx0YWpheFNldHVwOiBmdW5jdGlvbiggdGFyZ2V0LCBzZXR0aW5ncyApIHtcblx0XHRyZXR1cm4gc2V0dGluZ3MgP1xuXG5cdFx0XHQvLyBCdWlsZGluZyBhIHNldHRpbmdzIG9iamVjdFxuXHRcdFx0YWpheEV4dGVuZCggYWpheEV4dGVuZCggdGFyZ2V0LCBqUXVlcnkuYWpheFNldHRpbmdzICksIHNldHRpbmdzICkgOlxuXG5cdFx0XHQvLyBFeHRlbmRpbmcgYWpheFNldHRpbmdzXG5cdFx0XHRhamF4RXh0ZW5kKCBqUXVlcnkuYWpheFNldHRpbmdzLCB0YXJnZXQgKTtcblx0fSxcblxuXHRhamF4UHJlZmlsdGVyOiBhZGRUb1ByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHByZWZpbHRlcnMgKSxcblx0YWpheFRyYW5zcG9ydDogYWRkVG9QcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKCB0cmFuc3BvcnRzICksXG5cblx0Ly8gTWFpbiBtZXRob2Rcblx0YWpheDogZnVuY3Rpb24oIHVybCwgb3B0aW9ucyApIHtcblxuXHRcdC8vIElmIHVybCBpcyBhbiBvYmplY3QsIHNpbXVsYXRlIHByZS0xLjUgc2lnbmF0dXJlXG5cdFx0aWYgKCB0eXBlb2YgdXJsID09PSBcIm9iamVjdFwiICkge1xuXHRcdFx0b3B0aW9ucyA9IHVybDtcblx0XHRcdHVybCA9IHVuZGVmaW5lZDtcblx0XHR9XG5cblx0XHQvLyBGb3JjZSBvcHRpb25zIHRvIGJlIGFuIG9iamVjdFxuXHRcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG5cdFx0dmFyIHRyYW5zcG9ydCxcblxuXHRcdFx0Ly8gVVJMIHdpdGhvdXQgYW50aS1jYWNoZSBwYXJhbVxuXHRcdFx0Y2FjaGVVUkwsXG5cblx0XHRcdC8vIFJlc3BvbnNlIGhlYWRlcnNcblx0XHRcdHJlc3BvbnNlSGVhZGVyc1N0cmluZyxcblx0XHRcdHJlc3BvbnNlSGVhZGVycyxcblxuXHRcdFx0Ly8gdGltZW91dCBoYW5kbGVcblx0XHRcdHRpbWVvdXRUaW1lcixcblxuXHRcdFx0Ly8gVXJsIGNsZWFudXAgdmFyXG5cdFx0XHR1cmxBbmNob3IsXG5cblx0XHRcdC8vIFJlcXVlc3Qgc3RhdGUgKGJlY29tZXMgZmFsc2UgdXBvbiBzZW5kIGFuZCB0cnVlIHVwb24gY29tcGxldGlvbilcblx0XHRcdGNvbXBsZXRlZCxcblxuXHRcdFx0Ly8gVG8ga25vdyBpZiBnbG9iYWwgZXZlbnRzIGFyZSB0byBiZSBkaXNwYXRjaGVkXG5cdFx0XHRmaXJlR2xvYmFscyxcblxuXHRcdFx0Ly8gTG9vcCB2YXJpYWJsZVxuXHRcdFx0aSxcblxuXHRcdFx0Ly8gdW5jYWNoZWQgcGFydCBvZiB0aGUgdXJsXG5cdFx0XHR1bmNhY2hlZCxcblxuXHRcdFx0Ly8gQ3JlYXRlIHRoZSBmaW5hbCBvcHRpb25zIG9iamVjdFxuXHRcdFx0cyA9IGpRdWVyeS5hamF4U2V0dXAoIHt9LCBvcHRpb25zICksXG5cblx0XHRcdC8vIENhbGxiYWNrcyBjb250ZXh0XG5cdFx0XHRjYWxsYmFja0NvbnRleHQgPSBzLmNvbnRleHQgfHwgcyxcblxuXHRcdFx0Ly8gQ29udGV4dCBmb3IgZ2xvYmFsIGV2ZW50cyBpcyBjYWxsYmFja0NvbnRleHQgaWYgaXQgaXMgYSBET00gbm9kZSBvciBqUXVlcnkgY29sbGVjdGlvblxuXHRcdFx0Z2xvYmFsRXZlbnRDb250ZXh0ID0gcy5jb250ZXh0ICYmXG5cdFx0XHRcdCggY2FsbGJhY2tDb250ZXh0Lm5vZGVUeXBlIHx8IGNhbGxiYWNrQ29udGV4dC5qcXVlcnkgKSA/XG5cdFx0XHRcdGpRdWVyeSggY2FsbGJhY2tDb250ZXh0ICkgOlxuXHRcdFx0XHRqUXVlcnkuZXZlbnQsXG5cblx0XHRcdC8vIERlZmVycmVkc1xuXHRcdFx0ZGVmZXJyZWQgPSBqUXVlcnkuRGVmZXJyZWQoKSxcblx0XHRcdGNvbXBsZXRlRGVmZXJyZWQgPSBqUXVlcnkuQ2FsbGJhY2tzKCBcIm9uY2UgbWVtb3J5XCIgKSxcblxuXHRcdFx0Ly8gU3RhdHVzLWRlcGVuZGVudCBjYWxsYmFja3Ncblx0XHRcdHN0YXR1c0NvZGUgPSBzLnN0YXR1c0NvZGUgfHwge30sXG5cblx0XHRcdC8vIEhlYWRlcnMgKHRoZXkgYXJlIHNlbnQgYWxsIGF0IG9uY2UpXG5cdFx0XHRyZXF1ZXN0SGVhZGVycyA9IHt9LFxuXHRcdFx0cmVxdWVzdEhlYWRlcnNOYW1lcyA9IHt9LFxuXG5cdFx0XHQvLyBEZWZhdWx0IGFib3J0IG1lc3NhZ2Vcblx0XHRcdHN0ckFib3J0ID0gXCJjYW5jZWxlZFwiLFxuXG5cdFx0XHQvLyBGYWtlIHhoclxuXHRcdFx0anFYSFIgPSB7XG5cdFx0XHRcdHJlYWR5U3RhdGU6IDAsXG5cblx0XHRcdFx0Ly8gQnVpbGRzIGhlYWRlcnMgaGFzaHRhYmxlIGlmIG5lZWRlZFxuXHRcdFx0XHRnZXRSZXNwb25zZUhlYWRlcjogZnVuY3Rpb24oIGtleSApIHtcblx0XHRcdFx0XHR2YXIgbWF0Y2g7XG5cdFx0XHRcdFx0aWYgKCBjb21wbGV0ZWQgKSB7XG5cdFx0XHRcdFx0XHRpZiAoICFyZXNwb25zZUhlYWRlcnMgKSB7XG5cdFx0XHRcdFx0XHRcdHJlc3BvbnNlSGVhZGVycyA9IHt9O1xuXHRcdFx0XHRcdFx0XHR3aGlsZSAoICggbWF0Y2ggPSByaGVhZGVycy5leGVjKCByZXNwb25zZUhlYWRlcnNTdHJpbmcgKSApICkge1xuXHRcdFx0XHRcdFx0XHRcdHJlc3BvbnNlSGVhZGVyc1sgbWF0Y2hbIDEgXS50b0xvd2VyQ2FzZSgpICsgXCIgXCIgXSA9XG5cdFx0XHRcdFx0XHRcdFx0XHQoIHJlc3BvbnNlSGVhZGVyc1sgbWF0Y2hbIDEgXS50b0xvd2VyQ2FzZSgpICsgXCIgXCIgXSB8fCBbXSApXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC5jb25jYXQoIG1hdGNoWyAyIF0gKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0bWF0Y2ggPSByZXNwb25zZUhlYWRlcnNbIGtleS50b0xvd2VyQ2FzZSgpICsgXCIgXCIgXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIG1hdGNoID09IG51bGwgPyBudWxsIDogbWF0Y2guam9pbiggXCIsIFwiICk7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gUmF3IHN0cmluZ1xuXHRcdFx0XHRnZXRBbGxSZXNwb25zZUhlYWRlcnM6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHJldHVybiBjb21wbGV0ZWQgPyByZXNwb25zZUhlYWRlcnNTdHJpbmcgOiBudWxsO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdC8vIENhY2hlcyB0aGUgaGVhZGVyXG5cdFx0XHRcdHNldFJlcXVlc3RIZWFkZXI6IGZ1bmN0aW9uKCBuYW1lLCB2YWx1ZSApIHtcblx0XHRcdFx0XHRpZiAoIGNvbXBsZXRlZCA9PSBudWxsICkge1xuXHRcdFx0XHRcdFx0bmFtZSA9IHJlcXVlc3RIZWFkZXJzTmFtZXNbIG5hbWUudG9Mb3dlckNhc2UoKSBdID1cblx0XHRcdFx0XHRcdFx0cmVxdWVzdEhlYWRlcnNOYW1lc1sgbmFtZS50b0xvd2VyQ2FzZSgpIF0gfHwgbmFtZTtcblx0XHRcdFx0XHRcdHJlcXVlc3RIZWFkZXJzWyBuYW1lIF0gPSB2YWx1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gT3ZlcnJpZGVzIHJlc3BvbnNlIGNvbnRlbnQtdHlwZSBoZWFkZXJcblx0XHRcdFx0b3ZlcnJpZGVNaW1lVHlwZTogZnVuY3Rpb24oIHR5cGUgKSB7XG5cdFx0XHRcdFx0aWYgKCBjb21wbGV0ZWQgPT0gbnVsbCApIHtcblx0XHRcdFx0XHRcdHMubWltZVR5cGUgPSB0eXBlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBTdGF0dXMtZGVwZW5kZW50IGNhbGxiYWNrc1xuXHRcdFx0XHRzdGF0dXNDb2RlOiBmdW5jdGlvbiggbWFwICkge1xuXHRcdFx0XHRcdHZhciBjb2RlO1xuXHRcdFx0XHRcdGlmICggbWFwICkge1xuXHRcdFx0XHRcdFx0aWYgKCBjb21wbGV0ZWQgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gRXhlY3V0ZSB0aGUgYXBwcm9wcmlhdGUgY2FsbGJhY2tzXG5cdFx0XHRcdFx0XHRcdGpxWEhSLmFsd2F5cyggbWFwWyBqcVhIUi5zdGF0dXMgXSApO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBMYXp5LWFkZCB0aGUgbmV3IGNhbGxiYWNrcyBpbiBhIHdheSB0aGF0IHByZXNlcnZlcyBvbGQgb25lc1xuXHRcdFx0XHRcdFx0XHRmb3IgKCBjb2RlIGluIG1hcCApIHtcblx0XHRcdFx0XHRcdFx0XHRzdGF0dXNDb2RlWyBjb2RlIF0gPSBbIHN0YXR1c0NvZGVbIGNvZGUgXSwgbWFwWyBjb2RlIF0gXTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBDYW5jZWwgdGhlIHJlcXVlc3Rcblx0XHRcdFx0YWJvcnQ6IGZ1bmN0aW9uKCBzdGF0dXNUZXh0ICkge1xuXHRcdFx0XHRcdHZhciBmaW5hbFRleHQgPSBzdGF0dXNUZXh0IHx8IHN0ckFib3J0O1xuXHRcdFx0XHRcdGlmICggdHJhbnNwb3J0ICkge1xuXHRcdFx0XHRcdFx0dHJhbnNwb3J0LmFib3J0KCBmaW5hbFRleHQgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZG9uZSggMCwgZmluYWxUZXh0ICk7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cblx0XHQvLyBBdHRhY2ggZGVmZXJyZWRzXG5cdFx0ZGVmZXJyZWQucHJvbWlzZSgganFYSFIgKTtcblxuXHRcdC8vIEFkZCBwcm90b2NvbCBpZiBub3QgcHJvdmlkZWQgKHByZWZpbHRlcnMgbWlnaHQgZXhwZWN0IGl0KVxuXHRcdC8vIEhhbmRsZSBmYWxzeSB1cmwgaW4gdGhlIHNldHRpbmdzIG9iamVjdCAodHJhYy0xMDA5MzogY29uc2lzdGVuY3kgd2l0aCBvbGQgc2lnbmF0dXJlKVxuXHRcdC8vIFdlIGFsc28gdXNlIHRoZSB1cmwgcGFyYW1ldGVyIGlmIGF2YWlsYWJsZVxuXHRcdHMudXJsID0gKCAoIHVybCB8fCBzLnVybCB8fCBsb2NhdGlvbi5ocmVmICkgKyBcIlwiIClcblx0XHRcdC5yZXBsYWNlKCBycHJvdG9jb2wsIGxvY2F0aW9uLnByb3RvY29sICsgXCIvL1wiICk7XG5cblx0XHQvLyBBbGlhcyBtZXRob2Qgb3B0aW9uIHRvIHR5cGUgYXMgcGVyIHRpY2tldCB0cmFjLTEyMDA0XG5cdFx0cy50eXBlID0gb3B0aW9ucy5tZXRob2QgfHwgb3B0aW9ucy50eXBlIHx8IHMubWV0aG9kIHx8IHMudHlwZTtcblxuXHRcdC8vIEV4dHJhY3QgZGF0YVR5cGVzIGxpc3Rcblx0XHRzLmRhdGFUeXBlcyA9ICggcy5kYXRhVHlwZSB8fCBcIipcIiApLnRvTG93ZXJDYXNlKCkubWF0Y2goIHJub3RodG1sd2hpdGUgKSB8fCBbIFwiXCIgXTtcblxuXHRcdC8vIEEgY3Jvc3MtZG9tYWluIHJlcXVlc3QgaXMgaW4gb3JkZXIgd2hlbiB0aGUgb3JpZ2luIGRvZXNuJ3QgbWF0Y2ggdGhlIGN1cnJlbnQgb3JpZ2luLlxuXHRcdGlmICggcy5jcm9zc0RvbWFpbiA9PSBudWxsICkge1xuXHRcdFx0dXJsQW5jaG9yID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJhXCIgKTtcblxuXHRcdFx0Ly8gU3VwcG9ydDogSUUgPD04IC0gMTEsIEVkZ2UgMTIgLSAxNVxuXHRcdFx0Ly8gSUUgdGhyb3dzIGV4Y2VwdGlvbiBvbiBhY2Nlc3NpbmcgdGhlIGhyZWYgcHJvcGVydHkgaWYgdXJsIGlzIG1hbGZvcm1lZCxcblx0XHRcdC8vIGUuZy4gaHR0cDovL2V4YW1wbGUuY29tOjgweC9cblx0XHRcdHRyeSB7XG5cdFx0XHRcdHVybEFuY2hvci5ocmVmID0gcy51cmw7XG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPD04IC0gMTEgb25seVxuXHRcdFx0XHQvLyBBbmNob3IncyBob3N0IHByb3BlcnR5IGlzbid0IGNvcnJlY3RseSBzZXQgd2hlbiBzLnVybCBpcyByZWxhdGl2ZVxuXHRcdFx0XHR1cmxBbmNob3IuaHJlZiA9IHVybEFuY2hvci5ocmVmO1xuXHRcdFx0XHRzLmNyb3NzRG9tYWluID0gb3JpZ2luQW5jaG9yLnByb3RvY29sICsgXCIvL1wiICsgb3JpZ2luQW5jaG9yLmhvc3QgIT09XG5cdFx0XHRcdFx0dXJsQW5jaG9yLnByb3RvY29sICsgXCIvL1wiICsgdXJsQW5jaG9yLmhvc3Q7XG5cdFx0XHR9IGNhdGNoICggZSApIHtcblxuXHRcdFx0XHQvLyBJZiB0aGVyZSBpcyBhbiBlcnJvciBwYXJzaW5nIHRoZSBVUkwsIGFzc3VtZSBpdCBpcyBjcm9zc0RvbWFpbixcblx0XHRcdFx0Ly8gaXQgY2FuIGJlIHJlamVjdGVkIGJ5IHRoZSB0cmFuc3BvcnQgaWYgaXQgaXMgaW52YWxpZFxuXHRcdFx0XHRzLmNyb3NzRG9tYWluID0gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBDb252ZXJ0IGRhdGEgaWYgbm90IGFscmVhZHkgYSBzdHJpbmdcblx0XHRpZiAoIHMuZGF0YSAmJiBzLnByb2Nlc3NEYXRhICYmIHR5cGVvZiBzLmRhdGEgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRzLmRhdGEgPSBqUXVlcnkucGFyYW0oIHMuZGF0YSwgcy50cmFkaXRpb25hbCApO1xuXHRcdH1cblxuXHRcdC8vIEFwcGx5IHByZWZpbHRlcnNcblx0XHRpbnNwZWN0UHJlZmlsdGVyc09yVHJhbnNwb3J0cyggcHJlZmlsdGVycywgcywgb3B0aW9ucywganFYSFIgKTtcblxuXHRcdC8vIElmIHJlcXVlc3Qgd2FzIGFib3J0ZWQgaW5zaWRlIGEgcHJlZmlsdGVyLCBzdG9wIHRoZXJlXG5cdFx0aWYgKCBjb21wbGV0ZWQgKSB7XG5cdFx0XHRyZXR1cm4ganFYSFI7XG5cdFx0fVxuXG5cdFx0Ly8gV2UgY2FuIGZpcmUgZ2xvYmFsIGV2ZW50cyBhcyBvZiBub3cgaWYgYXNrZWQgdG9cblx0XHQvLyBEb24ndCBmaXJlIGV2ZW50cyBpZiBqUXVlcnkuZXZlbnQgaXMgdW5kZWZpbmVkIGluIGFuIEFNRC11c2FnZSBzY2VuYXJpbyAodHJhYy0xNTExOClcblx0XHRmaXJlR2xvYmFscyA9IGpRdWVyeS5ldmVudCAmJiBzLmdsb2JhbDtcblxuXHRcdC8vIFdhdGNoIGZvciBhIG5ldyBzZXQgb2YgcmVxdWVzdHNcblx0XHRpZiAoIGZpcmVHbG9iYWxzICYmIGpRdWVyeS5hY3RpdmUrKyA9PT0gMCApIHtcblx0XHRcdGpRdWVyeS5ldmVudC50cmlnZ2VyKCBcImFqYXhTdGFydFwiICk7XG5cdFx0fVxuXG5cdFx0Ly8gVXBwZXJjYXNlIHRoZSB0eXBlXG5cdFx0cy50eXBlID0gcy50eXBlLnRvVXBwZXJDYXNlKCk7XG5cblx0XHQvLyBEZXRlcm1pbmUgaWYgcmVxdWVzdCBoYXMgY29udGVudFxuXHRcdHMuaGFzQ29udGVudCA9ICFybm9Db250ZW50LnRlc3QoIHMudHlwZSApO1xuXG5cdFx0Ly8gU2F2ZSB0aGUgVVJMIGluIGNhc2Ugd2UncmUgdG95aW5nIHdpdGggdGhlIElmLU1vZGlmaWVkLVNpbmNlXG5cdFx0Ly8gYW5kL29yIElmLU5vbmUtTWF0Y2ggaGVhZGVyIGxhdGVyIG9uXG5cdFx0Ly8gUmVtb3ZlIGhhc2ggdG8gc2ltcGxpZnkgdXJsIG1hbmlwdWxhdGlvblxuXHRcdGNhY2hlVVJMID0gcy51cmwucmVwbGFjZSggcmhhc2gsIFwiXCIgKTtcblxuXHRcdC8vIE1vcmUgb3B0aW9ucyBoYW5kbGluZyBmb3IgcmVxdWVzdHMgd2l0aCBubyBjb250ZW50XG5cdFx0aWYgKCAhcy5oYXNDb250ZW50ICkge1xuXG5cdFx0XHQvLyBSZW1lbWJlciB0aGUgaGFzaCBzbyB3ZSBjYW4gcHV0IGl0IGJhY2tcblx0XHRcdHVuY2FjaGVkID0gcy51cmwuc2xpY2UoIGNhY2hlVVJMLmxlbmd0aCApO1xuXG5cdFx0XHQvLyBJZiBkYXRhIGlzIGF2YWlsYWJsZSBhbmQgc2hvdWxkIGJlIHByb2Nlc3NlZCwgYXBwZW5kIGRhdGEgdG8gdXJsXG5cdFx0XHRpZiAoIHMuZGF0YSAmJiAoIHMucHJvY2Vzc0RhdGEgfHwgdHlwZW9mIHMuZGF0YSA9PT0gXCJzdHJpbmdcIiApICkge1xuXHRcdFx0XHRjYWNoZVVSTCArPSAoIHJxdWVyeS50ZXN0KCBjYWNoZVVSTCApID8gXCImXCIgOiBcIj9cIiApICsgcy5kYXRhO1xuXG5cdFx0XHRcdC8vIHRyYWMtOTY4MjogcmVtb3ZlIGRhdGEgc28gdGhhdCBpdCdzIG5vdCB1c2VkIGluIGFuIGV2ZW50dWFsIHJldHJ5XG5cdFx0XHRcdGRlbGV0ZSBzLmRhdGE7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEFkZCBvciB1cGRhdGUgYW50aS1jYWNoZSBwYXJhbSBpZiBuZWVkZWRcblx0XHRcdGlmICggcy5jYWNoZSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdGNhY2hlVVJMID0gY2FjaGVVUkwucmVwbGFjZSggcmFudGlDYWNoZSwgXCIkMVwiICk7XG5cdFx0XHRcdHVuY2FjaGVkID0gKCBycXVlcnkudGVzdCggY2FjaGVVUkwgKSA/IFwiJlwiIDogXCI/XCIgKSArIFwiXz1cIiArICggbm9uY2UuZ3VpZCsrICkgK1xuXHRcdFx0XHRcdHVuY2FjaGVkO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBQdXQgaGFzaCBhbmQgYW50aS1jYWNoZSBvbiB0aGUgVVJMIHRoYXQgd2lsbCBiZSByZXF1ZXN0ZWQgKGdoLTE3MzIpXG5cdFx0XHRzLnVybCA9IGNhY2hlVVJMICsgdW5jYWNoZWQ7XG5cblx0XHQvLyBDaGFuZ2UgJyUyMCcgdG8gJysnIGlmIHRoaXMgaXMgZW5jb2RlZCBmb3JtIGJvZHkgY29udGVudCAoZ2gtMjY1OClcblx0XHR9IGVsc2UgaWYgKCBzLmRhdGEgJiYgcy5wcm9jZXNzRGF0YSAmJlxuXHRcdFx0KCBzLmNvbnRlbnRUeXBlIHx8IFwiXCIgKS5pbmRleE9mKCBcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZFwiICkgPT09IDAgKSB7XG5cdFx0XHRzLmRhdGEgPSBzLmRhdGEucmVwbGFjZSggcjIwLCBcIitcIiApO1xuXHRcdH1cblxuXHRcdC8vIFNldCB0aGUgSWYtTW9kaWZpZWQtU2luY2UgYW5kL29yIElmLU5vbmUtTWF0Y2ggaGVhZGVyLCBpZiBpbiBpZk1vZGlmaWVkIG1vZGUuXG5cdFx0aWYgKCBzLmlmTW9kaWZpZWQgKSB7XG5cdFx0XHRpZiAoIGpRdWVyeS5sYXN0TW9kaWZpZWRbIGNhY2hlVVJMIF0gKSB7XG5cdFx0XHRcdGpxWEhSLnNldFJlcXVlc3RIZWFkZXIoIFwiSWYtTW9kaWZpZWQtU2luY2VcIiwgalF1ZXJ5Lmxhc3RNb2RpZmllZFsgY2FjaGVVUkwgXSApO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCBqUXVlcnkuZXRhZ1sgY2FjaGVVUkwgXSApIHtcblx0XHRcdFx0anFYSFIuc2V0UmVxdWVzdEhlYWRlciggXCJJZi1Ob25lLU1hdGNoXCIsIGpRdWVyeS5ldGFnWyBjYWNoZVVSTCBdICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gU2V0IHRoZSBjb3JyZWN0IGhlYWRlciwgaWYgZGF0YSBpcyBiZWluZyBzZW50XG5cdFx0aWYgKCBzLmRhdGEgJiYgcy5oYXNDb250ZW50ICYmIHMuY29udGVudFR5cGUgIT09IGZhbHNlIHx8IG9wdGlvbnMuY29udGVudFR5cGUgKSB7XG5cdFx0XHRqcVhIUi5zZXRSZXF1ZXN0SGVhZGVyKCBcIkNvbnRlbnQtVHlwZVwiLCBzLmNvbnRlbnRUeXBlICk7XG5cdFx0fVxuXG5cdFx0Ly8gU2V0IHRoZSBBY2NlcHRzIGhlYWRlciBmb3IgdGhlIHNlcnZlciwgZGVwZW5kaW5nIG9uIHRoZSBkYXRhVHlwZVxuXHRcdGpxWEhSLnNldFJlcXVlc3RIZWFkZXIoXG5cdFx0XHRcIkFjY2VwdFwiLFxuXHRcdFx0cy5kYXRhVHlwZXNbIDAgXSAmJiBzLmFjY2VwdHNbIHMuZGF0YVR5cGVzWyAwIF0gXSA/XG5cdFx0XHRcdHMuYWNjZXB0c1sgcy5kYXRhVHlwZXNbIDAgXSBdICtcblx0XHRcdFx0XHQoIHMuZGF0YVR5cGVzWyAwIF0gIT09IFwiKlwiID8gXCIsIFwiICsgYWxsVHlwZXMgKyBcIjsgcT0wLjAxXCIgOiBcIlwiICkgOlxuXHRcdFx0XHRzLmFjY2VwdHNbIFwiKlwiIF1cblx0XHQpO1xuXG5cdFx0Ly8gQ2hlY2sgZm9yIGhlYWRlcnMgb3B0aW9uXG5cdFx0Zm9yICggaSBpbiBzLmhlYWRlcnMgKSB7XG5cdFx0XHRqcVhIUi5zZXRSZXF1ZXN0SGVhZGVyKCBpLCBzLmhlYWRlcnNbIGkgXSApO1xuXHRcdH1cblxuXHRcdC8vIEFsbG93IGN1c3RvbSBoZWFkZXJzL21pbWV0eXBlcyBhbmQgZWFybHkgYWJvcnRcblx0XHRpZiAoIHMuYmVmb3JlU2VuZCAmJlxuXHRcdFx0KCBzLmJlZm9yZVNlbmQuY2FsbCggY2FsbGJhY2tDb250ZXh0LCBqcVhIUiwgcyApID09PSBmYWxzZSB8fCBjb21wbGV0ZWQgKSApIHtcblxuXHRcdFx0Ly8gQWJvcnQgaWYgbm90IGRvbmUgYWxyZWFkeSBhbmQgcmV0dXJuXG5cdFx0XHRyZXR1cm4ganFYSFIuYWJvcnQoKTtcblx0XHR9XG5cblx0XHQvLyBBYm9ydGluZyBpcyBubyBsb25nZXIgYSBjYW5jZWxsYXRpb25cblx0XHRzdHJBYm9ydCA9IFwiYWJvcnRcIjtcblxuXHRcdC8vIEluc3RhbGwgY2FsbGJhY2tzIG9uIGRlZmVycmVkc1xuXHRcdGNvbXBsZXRlRGVmZXJyZWQuYWRkKCBzLmNvbXBsZXRlICk7XG5cdFx0anFYSFIuZG9uZSggcy5zdWNjZXNzICk7XG5cdFx0anFYSFIuZmFpbCggcy5lcnJvciApO1xuXG5cdFx0Ly8gR2V0IHRyYW5zcG9ydFxuXHRcdHRyYW5zcG9ydCA9IGluc3BlY3RQcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKCB0cmFuc3BvcnRzLCBzLCBvcHRpb25zLCBqcVhIUiApO1xuXG5cdFx0Ly8gSWYgbm8gdHJhbnNwb3J0LCB3ZSBhdXRvLWFib3J0XG5cdFx0aWYgKCAhdHJhbnNwb3J0ICkge1xuXHRcdFx0ZG9uZSggLTEsIFwiTm8gVHJhbnNwb3J0XCIgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0anFYSFIucmVhZHlTdGF0ZSA9IDE7XG5cblx0XHRcdC8vIFNlbmQgZ2xvYmFsIGV2ZW50XG5cdFx0XHRpZiAoIGZpcmVHbG9iYWxzICkge1xuXHRcdFx0XHRnbG9iYWxFdmVudENvbnRleHQudHJpZ2dlciggXCJhamF4U2VuZFwiLCBbIGpxWEhSLCBzIF0gKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgcmVxdWVzdCB3YXMgYWJvcnRlZCBpbnNpZGUgYWpheFNlbmQsIHN0b3AgdGhlcmVcblx0XHRcdGlmICggY29tcGxldGVkICkge1xuXHRcdFx0XHRyZXR1cm4ganFYSFI7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFRpbWVvdXRcblx0XHRcdGlmICggcy5hc3luYyAmJiBzLnRpbWVvdXQgPiAwICkge1xuXHRcdFx0XHR0aW1lb3V0VGltZXIgPSB3aW5kb3cuc2V0VGltZW91dCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0anFYSFIuYWJvcnQoIFwidGltZW91dFwiICk7XG5cdFx0XHRcdH0sIHMudGltZW91dCApO1xuXHRcdFx0fVxuXG5cdFx0XHR0cnkge1xuXHRcdFx0XHRjb21wbGV0ZWQgPSBmYWxzZTtcblx0XHRcdFx0dHJhbnNwb3J0LnNlbmQoIHJlcXVlc3RIZWFkZXJzLCBkb25lICk7XG5cdFx0XHR9IGNhdGNoICggZSApIHtcblxuXHRcdFx0XHQvLyBSZXRocm93IHBvc3QtY29tcGxldGlvbiBleGNlcHRpb25zXG5cdFx0XHRcdGlmICggY29tcGxldGVkICkge1xuXHRcdFx0XHRcdHRocm93IGU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBQcm9wYWdhdGUgb3RoZXJzIGFzIHJlc3VsdHNcblx0XHRcdFx0ZG9uZSggLTEsIGUgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBDYWxsYmFjayBmb3Igd2hlbiBldmVyeXRoaW5nIGlzIGRvbmVcblx0XHRmdW5jdGlvbiBkb25lKCBzdGF0dXMsIG5hdGl2ZVN0YXR1c1RleHQsIHJlc3BvbnNlcywgaGVhZGVycyApIHtcblx0XHRcdHZhciBpc1N1Y2Nlc3MsIHN1Y2Nlc3MsIGVycm9yLCByZXNwb25zZSwgbW9kaWZpZWQsXG5cdFx0XHRcdHN0YXR1c1RleHQgPSBuYXRpdmVTdGF0dXNUZXh0O1xuXG5cdFx0XHQvLyBJZ25vcmUgcmVwZWF0IGludm9jYXRpb25zXG5cdFx0XHRpZiAoIGNvbXBsZXRlZCApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRjb21wbGV0ZWQgPSB0cnVlO1xuXG5cdFx0XHQvLyBDbGVhciB0aW1lb3V0IGlmIGl0IGV4aXN0c1xuXHRcdFx0aWYgKCB0aW1lb3V0VGltZXIgKSB7XG5cdFx0XHRcdHdpbmRvdy5jbGVhclRpbWVvdXQoIHRpbWVvdXRUaW1lciApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBEZXJlZmVyZW5jZSB0cmFuc3BvcnQgZm9yIGVhcmx5IGdhcmJhZ2UgY29sbGVjdGlvblxuXHRcdFx0Ly8gKG5vIG1hdHRlciBob3cgbG9uZyB0aGUganFYSFIgb2JqZWN0IHdpbGwgYmUgdXNlZClcblx0XHRcdHRyYW5zcG9ydCA9IHVuZGVmaW5lZDtcblxuXHRcdFx0Ly8gQ2FjaGUgcmVzcG9uc2UgaGVhZGVyc1xuXHRcdFx0cmVzcG9uc2VIZWFkZXJzU3RyaW5nID0gaGVhZGVycyB8fCBcIlwiO1xuXG5cdFx0XHQvLyBTZXQgcmVhZHlTdGF0ZVxuXHRcdFx0anFYSFIucmVhZHlTdGF0ZSA9IHN0YXR1cyA+IDAgPyA0IDogMDtcblxuXHRcdFx0Ly8gRGV0ZXJtaW5lIGlmIHN1Y2Nlc3NmdWxcblx0XHRcdGlzU3VjY2VzcyA9IHN0YXR1cyA+PSAyMDAgJiYgc3RhdHVzIDwgMzAwIHx8IHN0YXR1cyA9PT0gMzA0O1xuXG5cdFx0XHQvLyBHZXQgcmVzcG9uc2UgZGF0YVxuXHRcdFx0aWYgKCByZXNwb25zZXMgKSB7XG5cdFx0XHRcdHJlc3BvbnNlID0gYWpheEhhbmRsZVJlc3BvbnNlcyggcywganFYSFIsIHJlc3BvbnNlcyApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBVc2UgYSBub29wIGNvbnZlcnRlciBmb3IgbWlzc2luZyBzY3JpcHQgYnV0IG5vdCBpZiBqc29ucFxuXHRcdFx0aWYgKCAhaXNTdWNjZXNzICYmXG5cdFx0XHRcdGpRdWVyeS5pbkFycmF5KCBcInNjcmlwdFwiLCBzLmRhdGFUeXBlcyApID4gLTEgJiZcblx0XHRcdFx0alF1ZXJ5LmluQXJyYXkoIFwianNvblwiLCBzLmRhdGFUeXBlcyApIDwgMCApIHtcblx0XHRcdFx0cy5jb252ZXJ0ZXJzWyBcInRleHQgc2NyaXB0XCIgXSA9IGZ1bmN0aW9uKCkge307XG5cdFx0XHR9XG5cblx0XHRcdC8vIENvbnZlcnQgbm8gbWF0dGVyIHdoYXQgKHRoYXQgd2F5IHJlc3BvbnNlWFhYIGZpZWxkcyBhcmUgYWx3YXlzIHNldClcblx0XHRcdHJlc3BvbnNlID0gYWpheENvbnZlcnQoIHMsIHJlc3BvbnNlLCBqcVhIUiwgaXNTdWNjZXNzICk7XG5cblx0XHRcdC8vIElmIHN1Y2Nlc3NmdWwsIGhhbmRsZSB0eXBlIGNoYWluaW5nXG5cdFx0XHRpZiAoIGlzU3VjY2VzcyApIHtcblxuXHRcdFx0XHQvLyBTZXQgdGhlIElmLU1vZGlmaWVkLVNpbmNlIGFuZC9vciBJZi1Ob25lLU1hdGNoIGhlYWRlciwgaWYgaW4gaWZNb2RpZmllZCBtb2RlLlxuXHRcdFx0XHRpZiAoIHMuaWZNb2RpZmllZCApIHtcblx0XHRcdFx0XHRtb2RpZmllZCA9IGpxWEhSLmdldFJlc3BvbnNlSGVhZGVyKCBcIkxhc3QtTW9kaWZpZWRcIiApO1xuXHRcdFx0XHRcdGlmICggbW9kaWZpZWQgKSB7XG5cdFx0XHRcdFx0XHRqUXVlcnkubGFzdE1vZGlmaWVkWyBjYWNoZVVSTCBdID0gbW9kaWZpZWQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdG1vZGlmaWVkID0ganFYSFIuZ2V0UmVzcG9uc2VIZWFkZXIoIFwiZXRhZ1wiICk7XG5cdFx0XHRcdFx0aWYgKCBtb2RpZmllZCApIHtcblx0XHRcdFx0XHRcdGpRdWVyeS5ldGFnWyBjYWNoZVVSTCBdID0gbW9kaWZpZWQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gaWYgbm8gY29udGVudFxuXHRcdFx0XHRpZiAoIHN0YXR1cyA9PT0gMjA0IHx8IHMudHlwZSA9PT0gXCJIRUFEXCIgKSB7XG5cdFx0XHRcdFx0c3RhdHVzVGV4dCA9IFwibm9jb250ZW50XCI7XG5cblx0XHRcdFx0Ly8gaWYgbm90IG1vZGlmaWVkXG5cdFx0XHRcdH0gZWxzZSBpZiAoIHN0YXR1cyA9PT0gMzA0ICkge1xuXHRcdFx0XHRcdHN0YXR1c1RleHQgPSBcIm5vdG1vZGlmaWVkXCI7XG5cblx0XHRcdFx0Ly8gSWYgd2UgaGF2ZSBkYXRhLCBsZXQncyBjb252ZXJ0IGl0XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0c3RhdHVzVGV4dCA9IHJlc3BvbnNlLnN0YXRlO1xuXHRcdFx0XHRcdHN1Y2Nlc3MgPSByZXNwb25zZS5kYXRhO1xuXHRcdFx0XHRcdGVycm9yID0gcmVzcG9uc2UuZXJyb3I7XG5cdFx0XHRcdFx0aXNTdWNjZXNzID0gIWVycm9yO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdC8vIEV4dHJhY3QgZXJyb3IgZnJvbSBzdGF0dXNUZXh0IGFuZCBub3JtYWxpemUgZm9yIG5vbi1hYm9ydHNcblx0XHRcdFx0ZXJyb3IgPSBzdGF0dXNUZXh0O1xuXHRcdFx0XHRpZiAoIHN0YXR1cyB8fCAhc3RhdHVzVGV4dCApIHtcblx0XHRcdFx0XHRzdGF0dXNUZXh0ID0gXCJlcnJvclwiO1xuXHRcdFx0XHRcdGlmICggc3RhdHVzIDwgMCApIHtcblx0XHRcdFx0XHRcdHN0YXR1cyA9IDA7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIFNldCBkYXRhIGZvciB0aGUgZmFrZSB4aHIgb2JqZWN0XG5cdFx0XHRqcVhIUi5zdGF0dXMgPSBzdGF0dXM7XG5cdFx0XHRqcVhIUi5zdGF0dXNUZXh0ID0gKCBuYXRpdmVTdGF0dXNUZXh0IHx8IHN0YXR1c1RleHQgKSArIFwiXCI7XG5cblx0XHRcdC8vIFN1Y2Nlc3MvRXJyb3Jcblx0XHRcdGlmICggaXNTdWNjZXNzICkge1xuXHRcdFx0XHRkZWZlcnJlZC5yZXNvbHZlV2l0aCggY2FsbGJhY2tDb250ZXh0LCBbIHN1Y2Nlc3MsIHN0YXR1c1RleHQsIGpxWEhSIF0gKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGRlZmVycmVkLnJlamVjdFdpdGgoIGNhbGxiYWNrQ29udGV4dCwgWyBqcVhIUiwgc3RhdHVzVGV4dCwgZXJyb3IgXSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdGF0dXMtZGVwZW5kZW50IGNhbGxiYWNrc1xuXHRcdFx0anFYSFIuc3RhdHVzQ29kZSggc3RhdHVzQ29kZSApO1xuXHRcdFx0c3RhdHVzQ29kZSA9IHVuZGVmaW5lZDtcblxuXHRcdFx0aWYgKCBmaXJlR2xvYmFscyApIHtcblx0XHRcdFx0Z2xvYmFsRXZlbnRDb250ZXh0LnRyaWdnZXIoIGlzU3VjY2VzcyA/IFwiYWpheFN1Y2Nlc3NcIiA6IFwiYWpheEVycm9yXCIsXG5cdFx0XHRcdFx0WyBqcVhIUiwgcywgaXNTdWNjZXNzID8gc3VjY2VzcyA6IGVycm9yIF0gKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ29tcGxldGVcblx0XHRcdGNvbXBsZXRlRGVmZXJyZWQuZmlyZVdpdGgoIGNhbGxiYWNrQ29udGV4dCwgWyBqcVhIUiwgc3RhdHVzVGV4dCBdICk7XG5cblx0XHRcdGlmICggZmlyZUdsb2JhbHMgKSB7XG5cdFx0XHRcdGdsb2JhbEV2ZW50Q29udGV4dC50cmlnZ2VyKCBcImFqYXhDb21wbGV0ZVwiLCBbIGpxWEhSLCBzIF0gKTtcblxuXHRcdFx0XHQvLyBIYW5kbGUgdGhlIGdsb2JhbCBBSkFYIGNvdW50ZXJcblx0XHRcdFx0aWYgKCAhKCAtLWpRdWVyeS5hY3RpdmUgKSApIHtcblx0XHRcdFx0XHRqUXVlcnkuZXZlbnQudHJpZ2dlciggXCJhamF4U3RvcFwiICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4ganFYSFI7XG5cdH0sXG5cblx0Z2V0SlNPTjogZnVuY3Rpb24oIHVybCwgZGF0YSwgY2FsbGJhY2sgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5nZXQoIHVybCwgZGF0YSwgY2FsbGJhY2ssIFwianNvblwiICk7XG5cdH0sXG5cblx0Z2V0U2NyaXB0OiBmdW5jdGlvbiggdXJsLCBjYWxsYmFjayApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmdldCggdXJsLCB1bmRlZmluZWQsIGNhbGxiYWNrLCBcInNjcmlwdFwiICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmVhY2goIFsgXCJnZXRcIiwgXCJwb3N0XCIgXSwgZnVuY3Rpb24oIF9pLCBtZXRob2QgKSB7XG5cdGpRdWVyeVsgbWV0aG9kIF0gPSBmdW5jdGlvbiggdXJsLCBkYXRhLCBjYWxsYmFjaywgdHlwZSApIHtcblxuXHRcdC8vIFNoaWZ0IGFyZ3VtZW50cyBpZiBkYXRhIGFyZ3VtZW50IHdhcyBvbWl0dGVkXG5cdFx0aWYgKCBpc0Z1bmN0aW9uKCBkYXRhICkgKSB7XG5cdFx0XHR0eXBlID0gdHlwZSB8fCBjYWxsYmFjaztcblx0XHRcdGNhbGxiYWNrID0gZGF0YTtcblx0XHRcdGRhdGEgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXG5cdFx0Ly8gVGhlIHVybCBjYW4gYmUgYW4gb3B0aW9ucyBvYmplY3QgKHdoaWNoIHRoZW4gbXVzdCBoYXZlIC51cmwpXG5cdFx0cmV0dXJuIGpRdWVyeS5hamF4KCBqUXVlcnkuZXh0ZW5kKCB7XG5cdFx0XHR1cmw6IHVybCxcblx0XHRcdHR5cGU6IG1ldGhvZCxcblx0XHRcdGRhdGFUeXBlOiB0eXBlLFxuXHRcdFx0ZGF0YTogZGF0YSxcblx0XHRcdHN1Y2Nlc3M6IGNhbGxiYWNrXG5cdFx0fSwgalF1ZXJ5LmlzUGxhaW5PYmplY3QoIHVybCApICYmIHVybCApICk7XG5cdH07XG59ICk7XG5cbmpRdWVyeS5hamF4UHJlZmlsdGVyKCBmdW5jdGlvbiggcyApIHtcblx0dmFyIGk7XG5cdGZvciAoIGkgaW4gcy5oZWFkZXJzICkge1xuXHRcdGlmICggaS50b0xvd2VyQ2FzZSgpID09PSBcImNvbnRlbnQtdHlwZVwiICkge1xuXHRcdFx0cy5jb250ZW50VHlwZSA9IHMuaGVhZGVyc1sgaSBdIHx8IFwiXCI7XG5cdFx0fVxuXHR9XG59ICk7XG5cblxualF1ZXJ5Ll9ldmFsVXJsID0gZnVuY3Rpb24oIHVybCwgb3B0aW9ucywgZG9jICkge1xuXHRyZXR1cm4galF1ZXJ5LmFqYXgoIHtcblx0XHR1cmw6IHVybCxcblxuXHRcdC8vIE1ha2UgdGhpcyBleHBsaWNpdCwgc2luY2UgdXNlciBjYW4gb3ZlcnJpZGUgdGhpcyB0aHJvdWdoIGFqYXhTZXR1cCAodHJhYy0xMTI2NClcblx0XHR0eXBlOiBcIkdFVFwiLFxuXHRcdGRhdGFUeXBlOiBcInNjcmlwdFwiLFxuXHRcdGNhY2hlOiB0cnVlLFxuXHRcdGFzeW5jOiBmYWxzZSxcblx0XHRnbG9iYWw6IGZhbHNlLFxuXG5cdFx0Ly8gT25seSBldmFsdWF0ZSB0aGUgcmVzcG9uc2UgaWYgaXQgaXMgc3VjY2Vzc2Z1bCAoZ2gtNDEyNilcblx0XHQvLyBkYXRhRmlsdGVyIGlzIG5vdCBpbnZva2VkIGZvciBmYWlsdXJlIHJlc3BvbnNlcywgc28gdXNpbmcgaXQgaW5zdGVhZFxuXHRcdC8vIG9mIHRoZSBkZWZhdWx0IGNvbnZlcnRlciBpcyBrbHVkZ3kgYnV0IGl0IHdvcmtzLlxuXHRcdGNvbnZlcnRlcnM6IHtcblx0XHRcdFwidGV4dCBzY3JpcHRcIjogZnVuY3Rpb24oKSB7fVxuXHRcdH0sXG5cdFx0ZGF0YUZpbHRlcjogZnVuY3Rpb24oIHJlc3BvbnNlICkge1xuXHRcdFx0alF1ZXJ5Lmdsb2JhbEV2YWwoIHJlc3BvbnNlLCBvcHRpb25zLCBkb2MgKTtcblx0XHR9XG5cdH0gKTtcbn07XG5cblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHR3cmFwQWxsOiBmdW5jdGlvbiggaHRtbCApIHtcblx0XHR2YXIgd3JhcDtcblxuXHRcdGlmICggdGhpc1sgMCBdICkge1xuXHRcdFx0aWYgKCBpc0Z1bmN0aW9uKCBodG1sICkgKSB7XG5cdFx0XHRcdGh0bWwgPSBodG1sLmNhbGwoIHRoaXNbIDAgXSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBUaGUgZWxlbWVudHMgdG8gd3JhcCB0aGUgdGFyZ2V0IGFyb3VuZFxuXHRcdFx0d3JhcCA9IGpRdWVyeSggaHRtbCwgdGhpc1sgMCBdLm93bmVyRG9jdW1lbnQgKS5lcSggMCApLmNsb25lKCB0cnVlICk7XG5cblx0XHRcdGlmICggdGhpc1sgMCBdLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdHdyYXAuaW5zZXJ0QmVmb3JlKCB0aGlzWyAwIF0gKTtcblx0XHRcdH1cblxuXHRcdFx0d3JhcC5tYXAoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgZWxlbSA9IHRoaXM7XG5cblx0XHRcdFx0d2hpbGUgKCBlbGVtLmZpcnN0RWxlbWVudENoaWxkICkge1xuXHRcdFx0XHRcdGVsZW0gPSBlbGVtLmZpcnN0RWxlbWVudENoaWxkO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIGVsZW07XG5cdFx0XHR9ICkuYXBwZW5kKCB0aGlzICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0d3JhcElubmVyOiBmdW5jdGlvbiggaHRtbCApIHtcblx0XHRpZiAoIGlzRnVuY3Rpb24oIGh0bWwgKSApIHtcblx0XHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCBpICkge1xuXHRcdFx0XHRqUXVlcnkoIHRoaXMgKS53cmFwSW5uZXIoIGh0bWwuY2FsbCggdGhpcywgaSApICk7XG5cdFx0XHR9ICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgc2VsZiA9IGpRdWVyeSggdGhpcyApLFxuXHRcdFx0XHRjb250ZW50cyA9IHNlbGYuY29udGVudHMoKTtcblxuXHRcdFx0aWYgKCBjb250ZW50cy5sZW5ndGggKSB7XG5cdFx0XHRcdGNvbnRlbnRzLndyYXBBbGwoIGh0bWwgKTtcblxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0c2VsZi5hcHBlbmQoIGh0bWwgKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cblx0d3JhcDogZnVuY3Rpb24oIGh0bWwgKSB7XG5cdFx0dmFyIGh0bWxJc0Z1bmN0aW9uID0gaXNGdW5jdGlvbiggaHRtbCApO1xuXG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oIGkgKSB7XG5cdFx0XHRqUXVlcnkoIHRoaXMgKS53cmFwQWxsKCBodG1sSXNGdW5jdGlvbiA/IGh0bWwuY2FsbCggdGhpcywgaSApIDogaHRtbCApO1xuXHRcdH0gKTtcblx0fSxcblxuXHR1bndyYXA6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHR0aGlzLnBhcmVudCggc2VsZWN0b3IgKS5ub3QoIFwiYm9keVwiICkuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRqUXVlcnkoIHRoaXMgKS5yZXBsYWNlV2l0aCggdGhpcy5jaGlsZE5vZGVzICk7XG5cdFx0fSApO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG59ICk7XG5cblxualF1ZXJ5LmV4cHIucHNldWRvcy5oaWRkZW4gPSBmdW5jdGlvbiggZWxlbSApIHtcblx0cmV0dXJuICFqUXVlcnkuZXhwci5wc2V1ZG9zLnZpc2libGUoIGVsZW0gKTtcbn07XG5qUXVlcnkuZXhwci5wc2V1ZG9zLnZpc2libGUgPSBmdW5jdGlvbiggZWxlbSApIHtcblx0cmV0dXJuICEhKCBlbGVtLm9mZnNldFdpZHRoIHx8IGVsZW0ub2Zmc2V0SGVpZ2h0IHx8IGVsZW0uZ2V0Q2xpZW50UmVjdHMoKS5sZW5ndGggKTtcbn07XG5cblxuXG5cbmpRdWVyeS5hamF4U2V0dGluZ3MueGhyID0gZnVuY3Rpb24oKSB7XG5cdHRyeSB7XG5cdFx0cmV0dXJuIG5ldyB3aW5kb3cuWE1MSHR0cFJlcXVlc3QoKTtcblx0fSBjYXRjaCAoIGUgKSB7fVxufTtcblxudmFyIHhoclN1Y2Nlc3NTdGF0dXMgPSB7XG5cblx0XHQvLyBGaWxlIHByb3RvY29sIGFsd2F5cyB5aWVsZHMgc3RhdHVzIGNvZGUgMCwgYXNzdW1lIDIwMFxuXHRcdDA6IDIwMCxcblxuXHRcdC8vIFN1cHBvcnQ6IElFIDw9OSBvbmx5XG5cdFx0Ly8gdHJhYy0xNDUwOiBzb21ldGltZXMgSUUgcmV0dXJucyAxMjIzIHdoZW4gaXQgc2hvdWxkIGJlIDIwNFxuXHRcdDEyMjM6IDIwNFxuXHR9LFxuXHR4aHJTdXBwb3J0ZWQgPSBqUXVlcnkuYWpheFNldHRpbmdzLnhocigpO1xuXG5zdXBwb3J0LmNvcnMgPSAhIXhoclN1cHBvcnRlZCAmJiAoIFwid2l0aENyZWRlbnRpYWxzXCIgaW4geGhyU3VwcG9ydGVkICk7XG5zdXBwb3J0LmFqYXggPSB4aHJTdXBwb3J0ZWQgPSAhIXhoclN1cHBvcnRlZDtcblxualF1ZXJ5LmFqYXhUcmFuc3BvcnQoIGZ1bmN0aW9uKCBvcHRpb25zICkge1xuXHR2YXIgY2FsbGJhY2ssIGVycm9yQ2FsbGJhY2s7XG5cblx0Ly8gQ3Jvc3MgZG9tYWluIG9ubHkgYWxsb3dlZCBpZiBzdXBwb3J0ZWQgdGhyb3VnaCBYTUxIdHRwUmVxdWVzdFxuXHRpZiAoIHN1cHBvcnQuY29ycyB8fCB4aHJTdXBwb3J0ZWQgJiYgIW9wdGlvbnMuY3Jvc3NEb21haW4gKSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdHNlbmQ6IGZ1bmN0aW9uKCBoZWFkZXJzLCBjb21wbGV0ZSApIHtcblx0XHRcdFx0dmFyIGksXG5cdFx0XHRcdFx0eGhyID0gb3B0aW9ucy54aHIoKTtcblxuXHRcdFx0XHR4aHIub3Blbihcblx0XHRcdFx0XHRvcHRpb25zLnR5cGUsXG5cdFx0XHRcdFx0b3B0aW9ucy51cmwsXG5cdFx0XHRcdFx0b3B0aW9ucy5hc3luYyxcblx0XHRcdFx0XHRvcHRpb25zLnVzZXJuYW1lLFxuXHRcdFx0XHRcdG9wdGlvbnMucGFzc3dvcmRcblx0XHRcdFx0KTtcblxuXHRcdFx0XHQvLyBBcHBseSBjdXN0b20gZmllbGRzIGlmIHByb3ZpZGVkXG5cdFx0XHRcdGlmICggb3B0aW9ucy54aHJGaWVsZHMgKSB7XG5cdFx0XHRcdFx0Zm9yICggaSBpbiBvcHRpb25zLnhockZpZWxkcyApIHtcblx0XHRcdFx0XHRcdHhoclsgaSBdID0gb3B0aW9ucy54aHJGaWVsZHNbIGkgXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBPdmVycmlkZSBtaW1lIHR5cGUgaWYgbmVlZGVkXG5cdFx0XHRcdGlmICggb3B0aW9ucy5taW1lVHlwZSAmJiB4aHIub3ZlcnJpZGVNaW1lVHlwZSApIHtcblx0XHRcdFx0XHR4aHIub3ZlcnJpZGVNaW1lVHlwZSggb3B0aW9ucy5taW1lVHlwZSApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gWC1SZXF1ZXN0ZWQtV2l0aCBoZWFkZXJcblx0XHRcdFx0Ly8gRm9yIGNyb3NzLWRvbWFpbiByZXF1ZXN0cywgc2VlaW5nIGFzIGNvbmRpdGlvbnMgZm9yIGEgcHJlZmxpZ2h0IGFyZVxuXHRcdFx0XHQvLyBha2luIHRvIGEgamlnc2F3IHB1enpsZSwgd2Ugc2ltcGx5IG5ldmVyIHNldCBpdCB0byBiZSBzdXJlLlxuXHRcdFx0XHQvLyAoaXQgY2FuIGFsd2F5cyBiZSBzZXQgb24gYSBwZXItcmVxdWVzdCBiYXNpcyBvciBldmVuIHVzaW5nIGFqYXhTZXR1cClcblx0XHRcdFx0Ly8gRm9yIHNhbWUtZG9tYWluIHJlcXVlc3RzLCB3b24ndCBjaGFuZ2UgaGVhZGVyIGlmIGFscmVhZHkgcHJvdmlkZWQuXG5cdFx0XHRcdGlmICggIW9wdGlvbnMuY3Jvc3NEb21haW4gJiYgIWhlYWRlcnNbIFwiWC1SZXF1ZXN0ZWQtV2l0aFwiIF0gKSB7XG5cdFx0XHRcdFx0aGVhZGVyc1sgXCJYLVJlcXVlc3RlZC1XaXRoXCIgXSA9IFwiWE1MSHR0cFJlcXVlc3RcIjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFNldCBoZWFkZXJzXG5cdFx0XHRcdGZvciAoIGkgaW4gaGVhZGVycyApIHtcblx0XHRcdFx0XHR4aHIuc2V0UmVxdWVzdEhlYWRlciggaSwgaGVhZGVyc1sgaSBdICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBDYWxsYmFja1xuXHRcdFx0XHRjYWxsYmFjayA9IGZ1bmN0aW9uKCB0eXBlICkge1xuXHRcdFx0XHRcdHJldHVybiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdGlmICggY2FsbGJhY2sgKSB7XG5cdFx0XHRcdFx0XHRcdGNhbGxiYWNrID0gZXJyb3JDYWxsYmFjayA9IHhoci5vbmxvYWQgPVxuXHRcdFx0XHRcdFx0XHRcdHhoci5vbmVycm9yID0geGhyLm9uYWJvcnQgPSB4aHIub250aW1lb3V0ID1cblx0XHRcdFx0XHRcdFx0XHRcdHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBudWxsO1xuXG5cdFx0XHRcdFx0XHRcdGlmICggdHlwZSA9PT0gXCJhYm9ydFwiICkge1xuXHRcdFx0XHRcdFx0XHRcdHhoci5hYm9ydCgpO1xuXHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKCB0eXBlID09PSBcImVycm9yXCIgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTkgb25seVxuXHRcdFx0XHRcdFx0XHRcdC8vIE9uIGEgbWFudWFsIG5hdGl2ZSBhYm9ydCwgSUU5IHRocm93c1xuXHRcdFx0XHRcdFx0XHRcdC8vIGVycm9ycyBvbiBhbnkgcHJvcGVydHkgYWNjZXNzIHRoYXQgaXMgbm90IHJlYWR5U3RhdGVcblx0XHRcdFx0XHRcdFx0XHRpZiAoIHR5cGVvZiB4aHIuc3RhdHVzICE9PSBcIm51bWJlclwiICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0Y29tcGxldGUoIDAsIFwiZXJyb3JcIiApO1xuXHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRjb21wbGV0ZShcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBGaWxlOiBwcm90b2NvbCBhbHdheXMgeWllbGRzIHN0YXR1cyAwOyBzZWUgdHJhYy04NjA1LCB0cmFjLTE0MjA3XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHhoci5zdGF0dXMsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHhoci5zdGF0dXNUZXh0XG5cdFx0XHRcdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRjb21wbGV0ZShcblx0XHRcdFx0XHRcdFx0XHRcdHhoclN1Y2Nlc3NTdGF0dXNbIHhoci5zdGF0dXMgXSB8fCB4aHIuc3RhdHVzLFxuXHRcdFx0XHRcdFx0XHRcdFx0eGhyLnN0YXR1c1RleHQsXG5cblx0XHRcdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9OSBvbmx5XG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBJRTkgaGFzIG5vIFhIUjIgYnV0IHRocm93cyBvbiBiaW5hcnkgKHRyYWMtMTE0MjYpXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBGb3IgWEhSMiBub24tdGV4dCwgbGV0IHRoZSBjYWxsZXIgaGFuZGxlIGl0IChnaC0yNDk4KVxuXHRcdFx0XHRcdFx0XHRcdFx0KCB4aHIucmVzcG9uc2VUeXBlIHx8IFwidGV4dFwiICkgIT09IFwidGV4dFwiICB8fFxuXHRcdFx0XHRcdFx0XHRcdFx0dHlwZW9mIHhoci5yZXNwb25zZVRleHQgIT09IFwic3RyaW5nXCIgP1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR7IGJpbmFyeTogeGhyLnJlc3BvbnNlIH0gOlxuXHRcdFx0XHRcdFx0XHRcdFx0XHR7IHRleHQ6IHhoci5yZXNwb25zZVRleHQgfSxcblx0XHRcdFx0XHRcdFx0XHRcdHhoci5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKVxuXHRcdFx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9O1xuXG5cdFx0XHRcdC8vIExpc3RlbiB0byBldmVudHNcblx0XHRcdFx0eGhyLm9ubG9hZCA9IGNhbGxiYWNrKCk7XG5cdFx0XHRcdGVycm9yQ2FsbGJhY2sgPSB4aHIub25lcnJvciA9IHhoci5vbnRpbWVvdXQgPSBjYWxsYmFjayggXCJlcnJvclwiICk7XG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgOSBvbmx5XG5cdFx0XHRcdC8vIFVzZSBvbnJlYWR5c3RhdGVjaGFuZ2UgdG8gcmVwbGFjZSBvbmFib3J0XG5cdFx0XHRcdC8vIHRvIGhhbmRsZSB1bmNhdWdodCBhYm9ydHNcblx0XHRcdFx0aWYgKCB4aHIub25hYm9ydCAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdHhoci5vbmFib3J0ID0gZXJyb3JDYWxsYmFjaztcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24oKSB7XG5cblx0XHRcdFx0XHRcdC8vIENoZWNrIHJlYWR5U3RhdGUgYmVmb3JlIHRpbWVvdXQgYXMgaXQgY2hhbmdlc1xuXHRcdFx0XHRcdFx0aWYgKCB4aHIucmVhZHlTdGF0ZSA9PT0gNCApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBBbGxvdyBvbmVycm9yIHRvIGJlIGNhbGxlZCBmaXJzdCxcblx0XHRcdFx0XHRcdFx0Ly8gYnV0IHRoYXQgd2lsbCBub3QgaGFuZGxlIGEgbmF0aXZlIGFib3J0XG5cdFx0XHRcdFx0XHRcdC8vIEFsc28sIHNhdmUgZXJyb3JDYWxsYmFjayB0byBhIHZhcmlhYmxlXG5cdFx0XHRcdFx0XHRcdC8vIGFzIHhoci5vbmVycm9yIGNhbm5vdCBiZSBhY2Nlc3NlZFxuXHRcdFx0XHRcdFx0XHR3aW5kb3cuc2V0VGltZW91dCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKCBjYWxsYmFjayApIHtcblx0XHRcdFx0XHRcdFx0XHRcdGVycm9yQ2FsbGJhY2soKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gQ3JlYXRlIHRoZSBhYm9ydCBjYWxsYmFja1xuXHRcdFx0XHRjYWxsYmFjayA9IGNhbGxiYWNrKCBcImFib3J0XCIgKTtcblxuXHRcdFx0XHR0cnkge1xuXG5cdFx0XHRcdFx0Ly8gRG8gc2VuZCB0aGUgcmVxdWVzdCAodGhpcyBtYXkgcmFpc2UgYW4gZXhjZXB0aW9uKVxuXHRcdFx0XHRcdHhoci5zZW5kKCBvcHRpb25zLmhhc0NvbnRlbnQgJiYgb3B0aW9ucy5kYXRhIHx8IG51bGwgKTtcblx0XHRcdFx0fSBjYXRjaCAoIGUgKSB7XG5cblx0XHRcdFx0XHQvLyB0cmFjLTE0NjgzOiBPbmx5IHJldGhyb3cgaWYgdGhpcyBoYXNuJ3QgYmVlbiBub3RpZmllZCBhcyBhbiBlcnJvciB5ZXRcblx0XHRcdFx0XHRpZiAoIGNhbGxiYWNrICkge1xuXHRcdFx0XHRcdFx0dGhyb3cgZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cblx0XHRcdGFib3J0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCBjYWxsYmFjayApIHtcblx0XHRcdFx0XHRjYWxsYmFjaygpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblx0fVxufSApO1xuXG5cblxuXG4vLyBQcmV2ZW50IGF1dG8tZXhlY3V0aW9uIG9mIHNjcmlwdHMgd2hlbiBubyBleHBsaWNpdCBkYXRhVHlwZSB3YXMgcHJvdmlkZWQgKFNlZSBnaC0yNDMyKVxualF1ZXJ5LmFqYXhQcmVmaWx0ZXIoIGZ1bmN0aW9uKCBzICkge1xuXHRpZiAoIHMuY3Jvc3NEb21haW4gKSB7XG5cdFx0cy5jb250ZW50cy5zY3JpcHQgPSBmYWxzZTtcblx0fVxufSApO1xuXG4vLyBJbnN0YWxsIHNjcmlwdCBkYXRhVHlwZVxualF1ZXJ5LmFqYXhTZXR1cCgge1xuXHRhY2NlcHRzOiB7XG5cdFx0c2NyaXB0OiBcInRleHQvamF2YXNjcmlwdCwgYXBwbGljYXRpb24vamF2YXNjcmlwdCwgXCIgK1xuXHRcdFx0XCJhcHBsaWNhdGlvbi9lY21hc2NyaXB0LCBhcHBsaWNhdGlvbi94LWVjbWFzY3JpcHRcIlxuXHR9LFxuXHRjb250ZW50czoge1xuXHRcdHNjcmlwdDogL1xcYig/OmphdmF8ZWNtYSlzY3JpcHRcXGIvXG5cdH0sXG5cdGNvbnZlcnRlcnM6IHtcblx0XHRcInRleHQgc2NyaXB0XCI6IGZ1bmN0aW9uKCB0ZXh0ICkge1xuXHRcdFx0alF1ZXJ5Lmdsb2JhbEV2YWwoIHRleHQgKTtcblx0XHRcdHJldHVybiB0ZXh0O1xuXHRcdH1cblx0fVxufSApO1xuXG4vLyBIYW5kbGUgY2FjaGUncyBzcGVjaWFsIGNhc2UgYW5kIGNyb3NzRG9tYWluXG5qUXVlcnkuYWpheFByZWZpbHRlciggXCJzY3JpcHRcIiwgZnVuY3Rpb24oIHMgKSB7XG5cdGlmICggcy5jYWNoZSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdHMuY2FjaGUgPSBmYWxzZTtcblx0fVxuXHRpZiAoIHMuY3Jvc3NEb21haW4gKSB7XG5cdFx0cy50eXBlID0gXCJHRVRcIjtcblx0fVxufSApO1xuXG4vLyBCaW5kIHNjcmlwdCB0YWcgaGFjayB0cmFuc3BvcnRcbmpRdWVyeS5hamF4VHJhbnNwb3J0KCBcInNjcmlwdFwiLCBmdW5jdGlvbiggcyApIHtcblxuXHQvLyBUaGlzIHRyYW5zcG9ydCBvbmx5IGRlYWxzIHdpdGggY3Jvc3MgZG9tYWluIG9yIGZvcmNlZC1ieS1hdHRycyByZXF1ZXN0c1xuXHRpZiAoIHMuY3Jvc3NEb21haW4gfHwgcy5zY3JpcHRBdHRycyApIHtcblx0XHR2YXIgc2NyaXB0LCBjYWxsYmFjaztcblx0XHRyZXR1cm4ge1xuXHRcdFx0c2VuZDogZnVuY3Rpb24oIF8sIGNvbXBsZXRlICkge1xuXHRcdFx0XHRzY3JpcHQgPSBqUXVlcnkoIFwiPHNjcmlwdD5cIiApXG5cdFx0XHRcdFx0LmF0dHIoIHMuc2NyaXB0QXR0cnMgfHwge30gKVxuXHRcdFx0XHRcdC5wcm9wKCB7IGNoYXJzZXQ6IHMuc2NyaXB0Q2hhcnNldCwgc3JjOiBzLnVybCB9IClcblx0XHRcdFx0XHQub24oIFwibG9hZCBlcnJvclwiLCBjYWxsYmFjayA9IGZ1bmN0aW9uKCBldnQgKSB7XG5cdFx0XHRcdFx0XHRzY3JpcHQucmVtb3ZlKCk7XG5cdFx0XHRcdFx0XHRjYWxsYmFjayA9IG51bGw7XG5cdFx0XHRcdFx0XHRpZiAoIGV2dCApIHtcblx0XHRcdFx0XHRcdFx0Y29tcGxldGUoIGV2dC50eXBlID09PSBcImVycm9yXCIgPyA0MDQgOiAyMDAsIGV2dC50eXBlICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSApO1xuXG5cdFx0XHRcdC8vIFVzZSBuYXRpdmUgRE9NIG1hbmlwdWxhdGlvbiB0byBhdm9pZCBvdXIgZG9tTWFuaXAgQUpBWCB0cmlja2VyeVxuXHRcdFx0XHRkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKCBzY3JpcHRbIDAgXSApO1xuXHRcdFx0fSxcblx0XHRcdGFib3J0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCBjYWxsYmFjayApIHtcblx0XHRcdFx0XHRjYWxsYmFjaygpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblx0fVxufSApO1xuXG5cblxuXG52YXIgb2xkQ2FsbGJhY2tzID0gW10sXG5cdHJqc29ucCA9IC8oPSlcXD8oPz0mfCQpfFxcP1xcPy87XG5cbi8vIERlZmF1bHQganNvbnAgc2V0dGluZ3NcbmpRdWVyeS5hamF4U2V0dXAoIHtcblx0anNvbnA6IFwiY2FsbGJhY2tcIixcblx0anNvbnBDYWxsYmFjazogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGNhbGxiYWNrID0gb2xkQ2FsbGJhY2tzLnBvcCgpIHx8ICggalF1ZXJ5LmV4cGFuZG8gKyBcIl9cIiArICggbm9uY2UuZ3VpZCsrICkgKTtcblx0XHR0aGlzWyBjYWxsYmFjayBdID0gdHJ1ZTtcblx0XHRyZXR1cm4gY2FsbGJhY2s7XG5cdH1cbn0gKTtcblxuLy8gRGV0ZWN0LCBub3JtYWxpemUgb3B0aW9ucyBhbmQgaW5zdGFsbCBjYWxsYmFja3MgZm9yIGpzb25wIHJlcXVlc3RzXG5qUXVlcnkuYWpheFByZWZpbHRlciggXCJqc29uIGpzb25wXCIsIGZ1bmN0aW9uKCBzLCBvcmlnaW5hbFNldHRpbmdzLCBqcVhIUiApIHtcblxuXHR2YXIgY2FsbGJhY2tOYW1lLCBvdmVyd3JpdHRlbiwgcmVzcG9uc2VDb250YWluZXIsXG5cdFx0anNvblByb3AgPSBzLmpzb25wICE9PSBmYWxzZSAmJiAoIHJqc29ucC50ZXN0KCBzLnVybCApID9cblx0XHRcdFwidXJsXCIgOlxuXHRcdFx0dHlwZW9mIHMuZGF0YSA9PT0gXCJzdHJpbmdcIiAmJlxuXHRcdFx0XHQoIHMuY29udGVudFR5cGUgfHwgXCJcIiApXG5cdFx0XHRcdFx0LmluZGV4T2YoIFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCIgKSA9PT0gMCAmJlxuXHRcdFx0XHRyanNvbnAudGVzdCggcy5kYXRhICkgJiYgXCJkYXRhXCJcblx0XHQpO1xuXG5cdC8vIEhhbmRsZSBpZmYgdGhlIGV4cGVjdGVkIGRhdGEgdHlwZSBpcyBcImpzb25wXCIgb3Igd2UgaGF2ZSBhIHBhcmFtZXRlciB0byBzZXRcblx0aWYgKCBqc29uUHJvcCB8fCBzLmRhdGFUeXBlc1sgMCBdID09PSBcImpzb25wXCIgKSB7XG5cblx0XHQvLyBHZXQgY2FsbGJhY2sgbmFtZSwgcmVtZW1iZXJpbmcgcHJlZXhpc3RpbmcgdmFsdWUgYXNzb2NpYXRlZCB3aXRoIGl0XG5cdFx0Y2FsbGJhY2tOYW1lID0gcy5qc29ucENhbGxiYWNrID0gaXNGdW5jdGlvbiggcy5qc29ucENhbGxiYWNrICkgP1xuXHRcdFx0cy5qc29ucENhbGxiYWNrKCkgOlxuXHRcdFx0cy5qc29ucENhbGxiYWNrO1xuXG5cdFx0Ly8gSW5zZXJ0IGNhbGxiYWNrIGludG8gdXJsIG9yIGZvcm0gZGF0YVxuXHRcdGlmICgganNvblByb3AgKSB7XG5cdFx0XHRzWyBqc29uUHJvcCBdID0gc1sganNvblByb3AgXS5yZXBsYWNlKCByanNvbnAsIFwiJDFcIiArIGNhbGxiYWNrTmFtZSApO1xuXHRcdH0gZWxzZSBpZiAoIHMuanNvbnAgIT09IGZhbHNlICkge1xuXHRcdFx0cy51cmwgKz0gKCBycXVlcnkudGVzdCggcy51cmwgKSA/IFwiJlwiIDogXCI/XCIgKSArIHMuanNvbnAgKyBcIj1cIiArIGNhbGxiYWNrTmFtZTtcblx0XHR9XG5cblx0XHQvLyBVc2UgZGF0YSBjb252ZXJ0ZXIgdG8gcmV0cmlldmUganNvbiBhZnRlciBzY3JpcHQgZXhlY3V0aW9uXG5cdFx0cy5jb252ZXJ0ZXJzWyBcInNjcmlwdCBqc29uXCIgXSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKCAhcmVzcG9uc2VDb250YWluZXIgKSB7XG5cdFx0XHRcdGpRdWVyeS5lcnJvciggY2FsbGJhY2tOYW1lICsgXCIgd2FzIG5vdCBjYWxsZWRcIiApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJlc3BvbnNlQ29udGFpbmVyWyAwIF07XG5cdFx0fTtcblxuXHRcdC8vIEZvcmNlIGpzb24gZGF0YVR5cGVcblx0XHRzLmRhdGFUeXBlc1sgMCBdID0gXCJqc29uXCI7XG5cblx0XHQvLyBJbnN0YWxsIGNhbGxiYWNrXG5cdFx0b3ZlcndyaXR0ZW4gPSB3aW5kb3dbIGNhbGxiYWNrTmFtZSBdO1xuXHRcdHdpbmRvd1sgY2FsbGJhY2tOYW1lIF0gPSBmdW5jdGlvbigpIHtcblx0XHRcdHJlc3BvbnNlQ29udGFpbmVyID0gYXJndW1lbnRzO1xuXHRcdH07XG5cblx0XHQvLyBDbGVhbi11cCBmdW5jdGlvbiAoZmlyZXMgYWZ0ZXIgY29udmVydGVycylcblx0XHRqcVhIUi5hbHdheXMoIGZ1bmN0aW9uKCkge1xuXG5cdFx0XHQvLyBJZiBwcmV2aW91cyB2YWx1ZSBkaWRuJ3QgZXhpc3QgLSByZW1vdmUgaXRcblx0XHRcdGlmICggb3ZlcndyaXR0ZW4gPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0alF1ZXJ5KCB3aW5kb3cgKS5yZW1vdmVQcm9wKCBjYWxsYmFja05hbWUgKTtcblxuXHRcdFx0Ly8gT3RoZXJ3aXNlIHJlc3RvcmUgcHJlZXhpc3RpbmcgdmFsdWVcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHdpbmRvd1sgY2FsbGJhY2tOYW1lIF0gPSBvdmVyd3JpdHRlbjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU2F2ZSBiYWNrIGFzIGZyZWVcblx0XHRcdGlmICggc1sgY2FsbGJhY2tOYW1lIF0gKSB7XG5cblx0XHRcdFx0Ly8gTWFrZSBzdXJlIHRoYXQgcmUtdXNpbmcgdGhlIG9wdGlvbnMgZG9lc24ndCBzY3JldyB0aGluZ3MgYXJvdW5kXG5cdFx0XHRcdHMuanNvbnBDYWxsYmFjayA9IG9yaWdpbmFsU2V0dGluZ3MuanNvbnBDYWxsYmFjaztcblxuXHRcdFx0XHQvLyBTYXZlIHRoZSBjYWxsYmFjayBuYW1lIGZvciBmdXR1cmUgdXNlXG5cdFx0XHRcdG9sZENhbGxiYWNrcy5wdXNoKCBjYWxsYmFja05hbWUgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ2FsbCBpZiBpdCB3YXMgYSBmdW5jdGlvbiBhbmQgd2UgaGF2ZSBhIHJlc3BvbnNlXG5cdFx0XHRpZiAoIHJlc3BvbnNlQ29udGFpbmVyICYmIGlzRnVuY3Rpb24oIG92ZXJ3cml0dGVuICkgKSB7XG5cdFx0XHRcdG92ZXJ3cml0dGVuKCByZXNwb25zZUNvbnRhaW5lclsgMCBdICk7XG5cdFx0XHR9XG5cblx0XHRcdHJlc3BvbnNlQ29udGFpbmVyID0gb3ZlcndyaXR0ZW4gPSB1bmRlZmluZWQ7XG5cdFx0fSApO1xuXG5cdFx0Ly8gRGVsZWdhdGUgdG8gc2NyaXB0XG5cdFx0cmV0dXJuIFwic2NyaXB0XCI7XG5cdH1cbn0gKTtcblxuXG5cblxuLy8gU3VwcG9ydDogU2FmYXJpIDggb25seVxuLy8gSW4gU2FmYXJpIDggZG9jdW1lbnRzIGNyZWF0ZWQgdmlhIGRvY3VtZW50LmltcGxlbWVudGF0aW9uLmNyZWF0ZUhUTUxEb2N1bWVudFxuLy8gY29sbGFwc2Ugc2libGluZyBmb3JtczogdGhlIHNlY29uZCBvbmUgYmVjb21lcyBhIGNoaWxkIG9mIHRoZSBmaXJzdCBvbmUuXG4vLyBCZWNhdXNlIG9mIHRoYXQsIHRoaXMgc2VjdXJpdHkgbWVhc3VyZSBoYXMgdG8gYmUgZGlzYWJsZWQgaW4gU2FmYXJpIDguXG4vLyBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTM3MzM3XG5zdXBwb3J0LmNyZWF0ZUhUTUxEb2N1bWVudCA9ICggZnVuY3Rpb24oKSB7XG5cdHZhciBib2R5ID0gZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uY3JlYXRlSFRNTERvY3VtZW50KCBcIlwiICkuYm9keTtcblx0Ym9keS5pbm5lckhUTUwgPSBcIjxmb3JtPjwvZm9ybT48Zm9ybT48L2Zvcm0+XCI7XG5cdHJldHVybiBib2R5LmNoaWxkTm9kZXMubGVuZ3RoID09PSAyO1xufSApKCk7XG5cblxuLy8gQXJndW1lbnQgXCJkYXRhXCIgc2hvdWxkIGJlIHN0cmluZyBvZiBodG1sXG4vLyBjb250ZXh0IChvcHRpb25hbCk6IElmIHNwZWNpZmllZCwgdGhlIGZyYWdtZW50IHdpbGwgYmUgY3JlYXRlZCBpbiB0aGlzIGNvbnRleHQsXG4vLyBkZWZhdWx0cyB0byBkb2N1bWVudFxuLy8ga2VlcFNjcmlwdHMgKG9wdGlvbmFsKTogSWYgdHJ1ZSwgd2lsbCBpbmNsdWRlIHNjcmlwdHMgcGFzc2VkIGluIHRoZSBodG1sIHN0cmluZ1xualF1ZXJ5LnBhcnNlSFRNTCA9IGZ1bmN0aW9uKCBkYXRhLCBjb250ZXh0LCBrZWVwU2NyaXB0cyApIHtcblx0aWYgKCB0eXBlb2YgZGF0YSAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRyZXR1cm4gW107XG5cdH1cblx0aWYgKCB0eXBlb2YgY29udGV4dCA9PT0gXCJib29sZWFuXCIgKSB7XG5cdFx0a2VlcFNjcmlwdHMgPSBjb250ZXh0O1xuXHRcdGNvbnRleHQgPSBmYWxzZTtcblx0fVxuXG5cdHZhciBiYXNlLCBwYXJzZWQsIHNjcmlwdHM7XG5cblx0aWYgKCAhY29udGV4dCApIHtcblxuXHRcdC8vIFN0b3Agc2NyaXB0cyBvciBpbmxpbmUgZXZlbnQgaGFuZGxlcnMgZnJvbSBiZWluZyBleGVjdXRlZCBpbW1lZGlhdGVseVxuXHRcdC8vIGJ5IHVzaW5nIGRvY3VtZW50LmltcGxlbWVudGF0aW9uXG5cdFx0aWYgKCBzdXBwb3J0LmNyZWF0ZUhUTUxEb2N1bWVudCApIHtcblx0XHRcdGNvbnRleHQgPSBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5jcmVhdGVIVE1MRG9jdW1lbnQoIFwiXCIgKTtcblxuXHRcdFx0Ly8gU2V0IHRoZSBiYXNlIGhyZWYgZm9yIHRoZSBjcmVhdGVkIGRvY3VtZW50XG5cdFx0XHQvLyBzbyBhbnkgcGFyc2VkIGVsZW1lbnRzIHdpdGggVVJMc1xuXHRcdFx0Ly8gYXJlIGJhc2VkIG9uIHRoZSBkb2N1bWVudCdzIFVSTCAoZ2gtMjk2NSlcblx0XHRcdGJhc2UgPSBjb250ZXh0LmNyZWF0ZUVsZW1lbnQoIFwiYmFzZVwiICk7XG5cdFx0XHRiYXNlLmhyZWYgPSBkb2N1bWVudC5sb2NhdGlvbi5ocmVmO1xuXHRcdFx0Y29udGV4dC5oZWFkLmFwcGVuZENoaWxkKCBiYXNlICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGNvbnRleHQgPSBkb2N1bWVudDtcblx0XHR9XG5cdH1cblxuXHRwYXJzZWQgPSByc2luZ2xlVGFnLmV4ZWMoIGRhdGEgKTtcblx0c2NyaXB0cyA9ICFrZWVwU2NyaXB0cyAmJiBbXTtcblxuXHQvLyBTaW5nbGUgdGFnXG5cdGlmICggcGFyc2VkICkge1xuXHRcdHJldHVybiBbIGNvbnRleHQuY3JlYXRlRWxlbWVudCggcGFyc2VkWyAxIF0gKSBdO1xuXHR9XG5cblx0cGFyc2VkID0gYnVpbGRGcmFnbWVudCggWyBkYXRhIF0sIGNvbnRleHQsIHNjcmlwdHMgKTtcblxuXHRpZiAoIHNjcmlwdHMgJiYgc2NyaXB0cy5sZW5ndGggKSB7XG5cdFx0alF1ZXJ5KCBzY3JpcHRzICkucmVtb3ZlKCk7XG5cdH1cblxuXHRyZXR1cm4galF1ZXJ5Lm1lcmdlKCBbXSwgcGFyc2VkLmNoaWxkTm9kZXMgKTtcbn07XG5cblxuLyoqXG4gKiBMb2FkIGEgdXJsIGludG8gYSBwYWdlXG4gKi9cbmpRdWVyeS5mbi5sb2FkID0gZnVuY3Rpb24oIHVybCwgcGFyYW1zLCBjYWxsYmFjayApIHtcblx0dmFyIHNlbGVjdG9yLCB0eXBlLCByZXNwb25zZSxcblx0XHRzZWxmID0gdGhpcyxcblx0XHRvZmYgPSB1cmwuaW5kZXhPZiggXCIgXCIgKTtcblxuXHRpZiAoIG9mZiA+IC0xICkge1xuXHRcdHNlbGVjdG9yID0gc3RyaXBBbmRDb2xsYXBzZSggdXJsLnNsaWNlKCBvZmYgKSApO1xuXHRcdHVybCA9IHVybC5zbGljZSggMCwgb2ZmICk7XG5cdH1cblxuXHQvLyBJZiBpdCdzIGEgZnVuY3Rpb25cblx0aWYgKCBpc0Z1bmN0aW9uKCBwYXJhbXMgKSApIHtcblxuXHRcdC8vIFdlIGFzc3VtZSB0aGF0IGl0J3MgdGhlIGNhbGxiYWNrXG5cdFx0Y2FsbGJhY2sgPSBwYXJhbXM7XG5cdFx0cGFyYW1zID0gdW5kZWZpbmVkO1xuXG5cdC8vIE90aGVyd2lzZSwgYnVpbGQgYSBwYXJhbSBzdHJpbmdcblx0fSBlbHNlIGlmICggcGFyYW1zICYmIHR5cGVvZiBwYXJhbXMgPT09IFwib2JqZWN0XCIgKSB7XG5cdFx0dHlwZSA9IFwiUE9TVFwiO1xuXHR9XG5cblx0Ly8gSWYgd2UgaGF2ZSBlbGVtZW50cyB0byBtb2RpZnksIG1ha2UgdGhlIHJlcXVlc3Rcblx0aWYgKCBzZWxmLmxlbmd0aCA+IDAgKSB7XG5cdFx0alF1ZXJ5LmFqYXgoIHtcblx0XHRcdHVybDogdXJsLFxuXG5cdFx0XHQvLyBJZiBcInR5cGVcIiB2YXJpYWJsZSBpcyB1bmRlZmluZWQsIHRoZW4gXCJHRVRcIiBtZXRob2Qgd2lsbCBiZSB1c2VkLlxuXHRcdFx0Ly8gTWFrZSB2YWx1ZSBvZiB0aGlzIGZpZWxkIGV4cGxpY2l0IHNpbmNlXG5cdFx0XHQvLyB1c2VyIGNhbiBvdmVycmlkZSBpdCB0aHJvdWdoIGFqYXhTZXR1cCBtZXRob2Rcblx0XHRcdHR5cGU6IHR5cGUgfHwgXCJHRVRcIixcblx0XHRcdGRhdGFUeXBlOiBcImh0bWxcIixcblx0XHRcdGRhdGE6IHBhcmFtc1xuXHRcdH0gKS5kb25lKCBmdW5jdGlvbiggcmVzcG9uc2VUZXh0ICkge1xuXG5cdFx0XHQvLyBTYXZlIHJlc3BvbnNlIGZvciB1c2UgaW4gY29tcGxldGUgY2FsbGJhY2tcblx0XHRcdHJlc3BvbnNlID0gYXJndW1lbnRzO1xuXG5cdFx0XHRzZWxmLmh0bWwoIHNlbGVjdG9yID9cblxuXHRcdFx0XHQvLyBJZiBhIHNlbGVjdG9yIHdhcyBzcGVjaWZpZWQsIGxvY2F0ZSB0aGUgcmlnaHQgZWxlbWVudHMgaW4gYSBkdW1teSBkaXZcblx0XHRcdFx0Ly8gRXhjbHVkZSBzY3JpcHRzIHRvIGF2b2lkIElFICdQZXJtaXNzaW9uIERlbmllZCcgZXJyb3JzXG5cdFx0XHRcdGpRdWVyeSggXCI8ZGl2PlwiICkuYXBwZW5kKCBqUXVlcnkucGFyc2VIVE1MKCByZXNwb25zZVRleHQgKSApLmZpbmQoIHNlbGVjdG9yICkgOlxuXG5cdFx0XHRcdC8vIE90aGVyd2lzZSB1c2UgdGhlIGZ1bGwgcmVzdWx0XG5cdFx0XHRcdHJlc3BvbnNlVGV4dCApO1xuXG5cdFx0Ly8gSWYgdGhlIHJlcXVlc3Qgc3VjY2VlZHMsIHRoaXMgZnVuY3Rpb24gZ2V0cyBcImRhdGFcIiwgXCJzdGF0dXNcIiwgXCJqcVhIUlwiXG5cdFx0Ly8gYnV0IHRoZXkgYXJlIGlnbm9yZWQgYmVjYXVzZSByZXNwb25zZSB3YXMgc2V0IGFib3ZlLlxuXHRcdC8vIElmIGl0IGZhaWxzLCB0aGlzIGZ1bmN0aW9uIGdldHMgXCJqcVhIUlwiLCBcInN0YXR1c1wiLCBcImVycm9yXCJcblx0XHR9ICkuYWx3YXlzKCBjYWxsYmFjayAmJiBmdW5jdGlvbigganFYSFIsIHN0YXR1cyApIHtcblx0XHRcdHNlbGYuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGNhbGxiYWNrLmFwcGx5KCB0aGlzLCByZXNwb25zZSB8fCBbIGpxWEhSLnJlc3BvbnNlVGV4dCwgc3RhdHVzLCBqcVhIUiBdICk7XG5cdFx0XHR9ICk7XG5cdFx0fSApO1xuXHR9XG5cblx0cmV0dXJuIHRoaXM7XG59O1xuXG5cblxuXG5qUXVlcnkuZXhwci5wc2V1ZG9zLmFuaW1hdGVkID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdHJldHVybiBqUXVlcnkuZ3JlcCggalF1ZXJ5LnRpbWVycywgZnVuY3Rpb24oIGZuICkge1xuXHRcdHJldHVybiBlbGVtID09PSBmbi5lbGVtO1xuXHR9ICkubGVuZ3RoO1xufTtcblxuXG5cblxualF1ZXJ5Lm9mZnNldCA9IHtcblx0c2V0T2Zmc2V0OiBmdW5jdGlvbiggZWxlbSwgb3B0aW9ucywgaSApIHtcblx0XHR2YXIgY3VyUG9zaXRpb24sIGN1ckxlZnQsIGN1ckNTU1RvcCwgY3VyVG9wLCBjdXJPZmZzZXQsIGN1ckNTU0xlZnQsIGNhbGN1bGF0ZVBvc2l0aW9uLFxuXHRcdFx0cG9zaXRpb24gPSBqUXVlcnkuY3NzKCBlbGVtLCBcInBvc2l0aW9uXCIgKSxcblx0XHRcdGN1ckVsZW0gPSBqUXVlcnkoIGVsZW0gKSxcblx0XHRcdHByb3BzID0ge307XG5cblx0XHQvLyBTZXQgcG9zaXRpb24gZmlyc3QsIGluLWNhc2UgdG9wL2xlZnQgYXJlIHNldCBldmVuIG9uIHN0YXRpYyBlbGVtXG5cdFx0aWYgKCBwb3NpdGlvbiA9PT0gXCJzdGF0aWNcIiApIHtcblx0XHRcdGVsZW0uc3R5bGUucG9zaXRpb24gPSBcInJlbGF0aXZlXCI7XG5cdFx0fVxuXG5cdFx0Y3VyT2Zmc2V0ID0gY3VyRWxlbS5vZmZzZXQoKTtcblx0XHRjdXJDU1NUb3AgPSBqUXVlcnkuY3NzKCBlbGVtLCBcInRvcFwiICk7XG5cdFx0Y3VyQ1NTTGVmdCA9IGpRdWVyeS5jc3MoIGVsZW0sIFwibGVmdFwiICk7XG5cdFx0Y2FsY3VsYXRlUG9zaXRpb24gPSAoIHBvc2l0aW9uID09PSBcImFic29sdXRlXCIgfHwgcG9zaXRpb24gPT09IFwiZml4ZWRcIiApICYmXG5cdFx0XHQoIGN1ckNTU1RvcCArIGN1ckNTU0xlZnQgKS5pbmRleE9mKCBcImF1dG9cIiApID4gLTE7XG5cblx0XHQvLyBOZWVkIHRvIGJlIGFibGUgdG8gY2FsY3VsYXRlIHBvc2l0aW9uIGlmIGVpdGhlclxuXHRcdC8vIHRvcCBvciBsZWZ0IGlzIGF1dG8gYW5kIHBvc2l0aW9uIGlzIGVpdGhlciBhYnNvbHV0ZSBvciBmaXhlZFxuXHRcdGlmICggY2FsY3VsYXRlUG9zaXRpb24gKSB7XG5cdFx0XHRjdXJQb3NpdGlvbiA9IGN1ckVsZW0ucG9zaXRpb24oKTtcblx0XHRcdGN1clRvcCA9IGN1clBvc2l0aW9uLnRvcDtcblx0XHRcdGN1ckxlZnQgPSBjdXJQb3NpdGlvbi5sZWZ0O1xuXG5cdFx0fSBlbHNlIHtcblx0XHRcdGN1clRvcCA9IHBhcnNlRmxvYXQoIGN1ckNTU1RvcCApIHx8IDA7XG5cdFx0XHRjdXJMZWZ0ID0gcGFyc2VGbG9hdCggY3VyQ1NTTGVmdCApIHx8IDA7XG5cdFx0fVxuXG5cdFx0aWYgKCBpc0Z1bmN0aW9uKCBvcHRpb25zICkgKSB7XG5cblx0XHRcdC8vIFVzZSBqUXVlcnkuZXh0ZW5kIGhlcmUgdG8gYWxsb3cgbW9kaWZpY2F0aW9uIG9mIGNvb3JkaW5hdGVzIGFyZ3VtZW50IChnaC0xODQ4KVxuXHRcdFx0b3B0aW9ucyA9IG9wdGlvbnMuY2FsbCggZWxlbSwgaSwgalF1ZXJ5LmV4dGVuZCgge30sIGN1ck9mZnNldCApICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBvcHRpb25zLnRvcCAhPSBudWxsICkge1xuXHRcdFx0cHJvcHMudG9wID0gKCBvcHRpb25zLnRvcCAtIGN1ck9mZnNldC50b3AgKSArIGN1clRvcDtcblx0XHR9XG5cdFx0aWYgKCBvcHRpb25zLmxlZnQgIT0gbnVsbCApIHtcblx0XHRcdHByb3BzLmxlZnQgPSAoIG9wdGlvbnMubGVmdCAtIGN1ck9mZnNldC5sZWZ0ICkgKyBjdXJMZWZ0O1xuXHRcdH1cblxuXHRcdGlmICggXCJ1c2luZ1wiIGluIG9wdGlvbnMgKSB7XG5cdFx0XHRvcHRpb25zLnVzaW5nLmNhbGwoIGVsZW0sIHByb3BzICk7XG5cblx0XHR9IGVsc2Uge1xuXHRcdFx0Y3VyRWxlbS5jc3MoIHByb3BzICk7XG5cdFx0fVxuXHR9XG59O1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cblx0Ly8gb2Zmc2V0KCkgcmVsYXRlcyBhbiBlbGVtZW50J3MgYm9yZGVyIGJveCB0byB0aGUgZG9jdW1lbnQgb3JpZ2luXG5cdG9mZnNldDogZnVuY3Rpb24oIG9wdGlvbnMgKSB7XG5cblx0XHQvLyBQcmVzZXJ2ZSBjaGFpbmluZyBmb3Igc2V0dGVyXG5cdFx0aWYgKCBhcmd1bWVudHMubGVuZ3RoICkge1xuXHRcdFx0cmV0dXJuIG9wdGlvbnMgPT09IHVuZGVmaW5lZCA/XG5cdFx0XHRcdHRoaXMgOlxuXHRcdFx0XHR0aGlzLmVhY2goIGZ1bmN0aW9uKCBpICkge1xuXHRcdFx0XHRcdGpRdWVyeS5vZmZzZXQuc2V0T2Zmc2V0KCB0aGlzLCBvcHRpb25zLCBpICk7XG5cdFx0XHRcdH0gKTtcblx0XHR9XG5cblx0XHR2YXIgcmVjdCwgd2luLFxuXHRcdFx0ZWxlbSA9IHRoaXNbIDAgXTtcblxuXHRcdGlmICggIWVsZW0gKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gUmV0dXJuIHplcm9zIGZvciBkaXNjb25uZWN0ZWQgYW5kIGhpZGRlbiAoZGlzcGxheTogbm9uZSkgZWxlbWVudHMgKGdoLTIzMTApXG5cdFx0Ly8gU3VwcG9ydDogSUUgPD0xMSBvbmx5XG5cdFx0Ly8gUnVubmluZyBnZXRCb3VuZGluZ0NsaWVudFJlY3Qgb24gYVxuXHRcdC8vIGRpc2Nvbm5lY3RlZCBub2RlIGluIElFIHRocm93cyBhbiBlcnJvclxuXHRcdGlmICggIWVsZW0uZ2V0Q2xpZW50UmVjdHMoKS5sZW5ndGggKSB7XG5cdFx0XHRyZXR1cm4geyB0b3A6IDAsIGxlZnQ6IDAgfTtcblx0XHR9XG5cblx0XHQvLyBHZXQgZG9jdW1lbnQtcmVsYXRpdmUgcG9zaXRpb24gYnkgYWRkaW5nIHZpZXdwb3J0IHNjcm9sbCB0byB2aWV3cG9ydC1yZWxhdGl2ZSBnQkNSXG5cdFx0cmVjdCA9IGVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cdFx0d2luID0gZWxlbS5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3O1xuXHRcdHJldHVybiB7XG5cdFx0XHR0b3A6IHJlY3QudG9wICsgd2luLnBhZ2VZT2Zmc2V0LFxuXHRcdFx0bGVmdDogcmVjdC5sZWZ0ICsgd2luLnBhZ2VYT2Zmc2V0XG5cdFx0fTtcblx0fSxcblxuXHQvLyBwb3NpdGlvbigpIHJlbGF0ZXMgYW4gZWxlbWVudCdzIG1hcmdpbiBib3ggdG8gaXRzIG9mZnNldCBwYXJlbnQncyBwYWRkaW5nIGJveFxuXHQvLyBUaGlzIGNvcnJlc3BvbmRzIHRvIHRoZSBiZWhhdmlvciBvZiBDU1MgYWJzb2x1dGUgcG9zaXRpb25pbmdcblx0cG9zaXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdGlmICggIXRoaXNbIDAgXSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YXIgb2Zmc2V0UGFyZW50LCBvZmZzZXQsIGRvYyxcblx0XHRcdGVsZW0gPSB0aGlzWyAwIF0sXG5cdFx0XHRwYXJlbnRPZmZzZXQgPSB7IHRvcDogMCwgbGVmdDogMCB9O1xuXG5cdFx0Ly8gcG9zaXRpb246Zml4ZWQgZWxlbWVudHMgYXJlIG9mZnNldCBmcm9tIHRoZSB2aWV3cG9ydCwgd2hpY2ggaXRzZWxmIGFsd2F5cyBoYXMgemVybyBvZmZzZXRcblx0XHRpZiAoIGpRdWVyeS5jc3MoIGVsZW0sIFwicG9zaXRpb25cIiApID09PSBcImZpeGVkXCIgKSB7XG5cblx0XHRcdC8vIEFzc3VtZSBwb3NpdGlvbjpmaXhlZCBpbXBsaWVzIGF2YWlsYWJpbGl0eSBvZiBnZXRCb3VuZGluZ0NsaWVudFJlY3Rcblx0XHRcdG9mZnNldCA9IGVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cblx0XHR9IGVsc2Uge1xuXHRcdFx0b2Zmc2V0ID0gdGhpcy5vZmZzZXQoKTtcblxuXHRcdFx0Ly8gQWNjb3VudCBmb3IgdGhlICpyZWFsKiBvZmZzZXQgcGFyZW50LCB3aGljaCBjYW4gYmUgdGhlIGRvY3VtZW50IG9yIGl0cyByb290IGVsZW1lbnRcblx0XHRcdC8vIHdoZW4gYSBzdGF0aWNhbGx5IHBvc2l0aW9uZWQgZWxlbWVudCBpcyBpZGVudGlmaWVkXG5cdFx0XHRkb2MgPSBlbGVtLm93bmVyRG9jdW1lbnQ7XG5cdFx0XHRvZmZzZXRQYXJlbnQgPSBlbGVtLm9mZnNldFBhcmVudCB8fCBkb2MuZG9jdW1lbnRFbGVtZW50O1xuXHRcdFx0d2hpbGUgKCBvZmZzZXRQYXJlbnQgJiZcblx0XHRcdFx0KCBvZmZzZXRQYXJlbnQgPT09IGRvYy5ib2R5IHx8IG9mZnNldFBhcmVudCA9PT0gZG9jLmRvY3VtZW50RWxlbWVudCApICYmXG5cdFx0XHRcdGpRdWVyeS5jc3MoIG9mZnNldFBhcmVudCwgXCJwb3NpdGlvblwiICkgPT09IFwic3RhdGljXCIgKSB7XG5cblx0XHRcdFx0b2Zmc2V0UGFyZW50ID0gb2Zmc2V0UGFyZW50LnBhcmVudE5vZGU7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIG9mZnNldFBhcmVudCAmJiBvZmZzZXRQYXJlbnQgIT09IGVsZW0gJiYgb2Zmc2V0UGFyZW50Lm5vZGVUeXBlID09PSAxICkge1xuXG5cdFx0XHRcdC8vIEluY29ycG9yYXRlIGJvcmRlcnMgaW50byBpdHMgb2Zmc2V0LCBzaW5jZSB0aGV5IGFyZSBvdXRzaWRlIGl0cyBjb250ZW50IG9yaWdpblxuXHRcdFx0XHRwYXJlbnRPZmZzZXQgPSBqUXVlcnkoIG9mZnNldFBhcmVudCApLm9mZnNldCgpO1xuXHRcdFx0XHRwYXJlbnRPZmZzZXQudG9wICs9IGpRdWVyeS5jc3MoIG9mZnNldFBhcmVudCwgXCJib3JkZXJUb3BXaWR0aFwiLCB0cnVlICk7XG5cdFx0XHRcdHBhcmVudE9mZnNldC5sZWZ0ICs9IGpRdWVyeS5jc3MoIG9mZnNldFBhcmVudCwgXCJib3JkZXJMZWZ0V2lkdGhcIiwgdHJ1ZSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFN1YnRyYWN0IHBhcmVudCBvZmZzZXRzIGFuZCBlbGVtZW50IG1hcmdpbnNcblx0XHRyZXR1cm4ge1xuXHRcdFx0dG9wOiBvZmZzZXQudG9wIC0gcGFyZW50T2Zmc2V0LnRvcCAtIGpRdWVyeS5jc3MoIGVsZW0sIFwibWFyZ2luVG9wXCIsIHRydWUgKSxcblx0XHRcdGxlZnQ6IG9mZnNldC5sZWZ0IC0gcGFyZW50T2Zmc2V0LmxlZnQgLSBqUXVlcnkuY3NzKCBlbGVtLCBcIm1hcmdpbkxlZnRcIiwgdHJ1ZSApXG5cdFx0fTtcblx0fSxcblxuXHQvLyBUaGlzIG1ldGhvZCB3aWxsIHJldHVybiBkb2N1bWVudEVsZW1lbnQgaW4gdGhlIGZvbGxvd2luZyBjYXNlczpcblx0Ly8gMSkgRm9yIHRoZSBlbGVtZW50IGluc2lkZSB0aGUgaWZyYW1lIHdpdGhvdXQgb2Zmc2V0UGFyZW50LCB0aGlzIG1ldGhvZCB3aWxsIHJldHVyblxuXHQvLyAgICBkb2N1bWVudEVsZW1lbnQgb2YgdGhlIHBhcmVudCB3aW5kb3dcblx0Ly8gMikgRm9yIHRoZSBoaWRkZW4gb3IgZGV0YWNoZWQgZWxlbWVudFxuXHQvLyAzKSBGb3IgYm9keSBvciBodG1sIGVsZW1lbnQsIGkuZS4gaW4gY2FzZSBvZiB0aGUgaHRtbCBub2RlIC0gaXQgd2lsbCByZXR1cm4gaXRzZWxmXG5cdC8vXG5cdC8vIGJ1dCB0aG9zZSBleGNlcHRpb25zIHdlcmUgbmV2ZXIgcHJlc2VudGVkIGFzIGEgcmVhbCBsaWZlIHVzZS1jYXNlc1xuXHQvLyBhbmQgbWlnaHQgYmUgY29uc2lkZXJlZCBhcyBtb3JlIHByZWZlcmFibGUgcmVzdWx0cy5cblx0Ly9cblx0Ly8gVGhpcyBsb2dpYywgaG93ZXZlciwgaXMgbm90IGd1YXJhbnRlZWQgYW5kIGNhbiBjaGFuZ2UgYXQgYW55IHBvaW50IGluIHRoZSBmdXR1cmVcblx0b2Zmc2V0UGFyZW50OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5tYXAoIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG9mZnNldFBhcmVudCA9IHRoaXMub2Zmc2V0UGFyZW50O1xuXG5cdFx0XHR3aGlsZSAoIG9mZnNldFBhcmVudCAmJiBqUXVlcnkuY3NzKCBvZmZzZXRQYXJlbnQsIFwicG9zaXRpb25cIiApID09PSBcInN0YXRpY1wiICkge1xuXHRcdFx0XHRvZmZzZXRQYXJlbnQgPSBvZmZzZXRQYXJlbnQub2Zmc2V0UGFyZW50O1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gb2Zmc2V0UGFyZW50IHx8IGRvY3VtZW50RWxlbWVudDtcblx0XHR9ICk7XG5cdH1cbn0gKTtcblxuLy8gQ3JlYXRlIHNjcm9sbExlZnQgYW5kIHNjcm9sbFRvcCBtZXRob2RzXG5qUXVlcnkuZWFjaCggeyBzY3JvbGxMZWZ0OiBcInBhZ2VYT2Zmc2V0XCIsIHNjcm9sbFRvcDogXCJwYWdlWU9mZnNldFwiIH0sIGZ1bmN0aW9uKCBtZXRob2QsIHByb3AgKSB7XG5cdHZhciB0b3AgPSBcInBhZ2VZT2Zmc2V0XCIgPT09IHByb3A7XG5cblx0alF1ZXJ5LmZuWyBtZXRob2QgXSA9IGZ1bmN0aW9uKCB2YWwgKSB7XG5cdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgZnVuY3Rpb24oIGVsZW0sIG1ldGhvZCwgdmFsICkge1xuXG5cdFx0XHQvLyBDb2FsZXNjZSBkb2N1bWVudHMgYW5kIHdpbmRvd3Ncblx0XHRcdHZhciB3aW47XG5cdFx0XHRpZiAoIGlzV2luZG93KCBlbGVtICkgKSB7XG5cdFx0XHRcdHdpbiA9IGVsZW07XG5cdFx0XHR9IGVsc2UgaWYgKCBlbGVtLm5vZGVUeXBlID09PSA5ICkge1xuXHRcdFx0XHR3aW4gPSBlbGVtLmRlZmF1bHRWaWV3O1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHZhbCA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRyZXR1cm4gd2luID8gd2luWyBwcm9wIF0gOiBlbGVtWyBtZXRob2QgXTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCB3aW4gKSB7XG5cdFx0XHRcdHdpbi5zY3JvbGxUbyhcblx0XHRcdFx0XHQhdG9wID8gdmFsIDogd2luLnBhZ2VYT2Zmc2V0LFxuXHRcdFx0XHRcdHRvcCA/IHZhbCA6IHdpbi5wYWdlWU9mZnNldFxuXHRcdFx0XHQpO1xuXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRlbGVtWyBtZXRob2QgXSA9IHZhbDtcblx0XHRcdH1cblx0XHR9LCBtZXRob2QsIHZhbCwgYXJndW1lbnRzLmxlbmd0aCApO1xuXHR9O1xufSApO1xuXG4vLyBTdXBwb3J0OiBTYWZhcmkgPD03IC0gOS4xLCBDaHJvbWUgPD0zNyAtIDQ5XG4vLyBBZGQgdGhlIHRvcC9sZWZ0IGNzc0hvb2tzIHVzaW5nIGpRdWVyeS5mbi5wb3NpdGlvblxuLy8gV2Via2l0IGJ1ZzogaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTI5MDg0XG4vLyBCbGluayBidWc6IGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTU4OTM0N1xuLy8gZ2V0Q29tcHV0ZWRTdHlsZSByZXR1cm5zIHBlcmNlbnQgd2hlbiBzcGVjaWZpZWQgZm9yIHRvcC9sZWZ0L2JvdHRvbS9yaWdodDtcbi8vIHJhdGhlciB0aGFuIG1ha2UgdGhlIGNzcyBtb2R1bGUgZGVwZW5kIG9uIHRoZSBvZmZzZXQgbW9kdWxlLCBqdXN0IGNoZWNrIGZvciBpdCBoZXJlXG5qUXVlcnkuZWFjaCggWyBcInRvcFwiLCBcImxlZnRcIiBdLCBmdW5jdGlvbiggX2ksIHByb3AgKSB7XG5cdGpRdWVyeS5jc3NIb29rc1sgcHJvcCBdID0gYWRkR2V0SG9va0lmKCBzdXBwb3J0LnBpeGVsUG9zaXRpb24sXG5cdFx0ZnVuY3Rpb24oIGVsZW0sIGNvbXB1dGVkICkge1xuXHRcdFx0aWYgKCBjb21wdXRlZCApIHtcblx0XHRcdFx0Y29tcHV0ZWQgPSBjdXJDU1MoIGVsZW0sIHByb3AgKTtcblxuXHRcdFx0XHQvLyBJZiBjdXJDU1MgcmV0dXJucyBwZXJjZW50YWdlLCBmYWxsYmFjayB0byBvZmZzZXRcblx0XHRcdFx0cmV0dXJuIHJudW1ub25weC50ZXN0KCBjb21wdXRlZCApID9cblx0XHRcdFx0XHRqUXVlcnkoIGVsZW0gKS5wb3NpdGlvbigpWyBwcm9wIF0gKyBcInB4XCIgOlxuXHRcdFx0XHRcdGNvbXB1dGVkO1xuXHRcdFx0fVxuXHRcdH1cblx0KTtcbn0gKTtcblxuXG4vLyBDcmVhdGUgaW5uZXJIZWlnaHQsIGlubmVyV2lkdGgsIGhlaWdodCwgd2lkdGgsIG91dGVySGVpZ2h0IGFuZCBvdXRlcldpZHRoIG1ldGhvZHNcbmpRdWVyeS5lYWNoKCB7IEhlaWdodDogXCJoZWlnaHRcIiwgV2lkdGg6IFwid2lkdGhcIiB9LCBmdW5jdGlvbiggbmFtZSwgdHlwZSApIHtcblx0alF1ZXJ5LmVhY2goIHtcblx0XHRwYWRkaW5nOiBcImlubmVyXCIgKyBuYW1lLFxuXHRcdGNvbnRlbnQ6IHR5cGUsXG5cdFx0XCJcIjogXCJvdXRlclwiICsgbmFtZVxuXHR9LCBmdW5jdGlvbiggZGVmYXVsdEV4dHJhLCBmdW5jTmFtZSApIHtcblxuXHRcdC8vIE1hcmdpbiBpcyBvbmx5IGZvciBvdXRlckhlaWdodCwgb3V0ZXJXaWR0aFxuXHRcdGpRdWVyeS5mblsgZnVuY05hbWUgXSA9IGZ1bmN0aW9uKCBtYXJnaW4sIHZhbHVlICkge1xuXHRcdFx0dmFyIGNoYWluYWJsZSA9IGFyZ3VtZW50cy5sZW5ndGggJiYgKCBkZWZhdWx0RXh0cmEgfHwgdHlwZW9mIG1hcmdpbiAhPT0gXCJib29sZWFuXCIgKSxcblx0XHRcdFx0ZXh0cmEgPSBkZWZhdWx0RXh0cmEgfHwgKCBtYXJnaW4gPT09IHRydWUgfHwgdmFsdWUgPT09IHRydWUgPyBcIm1hcmdpblwiIDogXCJib3JkZXJcIiApO1xuXG5cdFx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBmdW5jdGlvbiggZWxlbSwgdHlwZSwgdmFsdWUgKSB7XG5cdFx0XHRcdHZhciBkb2M7XG5cblx0XHRcdFx0aWYgKCBpc1dpbmRvdyggZWxlbSApICkge1xuXG5cdFx0XHRcdFx0Ly8gJCggd2luZG93ICkub3V0ZXJXaWR0aC9IZWlnaHQgcmV0dXJuIHcvaCBpbmNsdWRpbmcgc2Nyb2xsYmFycyAoZ2gtMTcyOSlcblx0XHRcdFx0XHRyZXR1cm4gZnVuY05hbWUuaW5kZXhPZiggXCJvdXRlclwiICkgPT09IDAgP1xuXHRcdFx0XHRcdFx0ZWxlbVsgXCJpbm5lclwiICsgbmFtZSBdIDpcblx0XHRcdFx0XHRcdGVsZW0uZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50WyBcImNsaWVudFwiICsgbmFtZSBdO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gR2V0IGRvY3VtZW50IHdpZHRoIG9yIGhlaWdodFxuXHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDkgKSB7XG5cdFx0XHRcdFx0ZG9jID0gZWxlbS5kb2N1bWVudEVsZW1lbnQ7XG5cblx0XHRcdFx0XHQvLyBFaXRoZXIgc2Nyb2xsW1dpZHRoL0hlaWdodF0gb3Igb2Zmc2V0W1dpZHRoL0hlaWdodF0gb3IgY2xpZW50W1dpZHRoL0hlaWdodF0sXG5cdFx0XHRcdFx0Ly8gd2hpY2hldmVyIGlzIGdyZWF0ZXN0XG5cdFx0XHRcdFx0cmV0dXJuIE1hdGgubWF4KFxuXHRcdFx0XHRcdFx0ZWxlbS5ib2R5WyBcInNjcm9sbFwiICsgbmFtZSBdLCBkb2NbIFwic2Nyb2xsXCIgKyBuYW1lIF0sXG5cdFx0XHRcdFx0XHRlbGVtLmJvZHlbIFwib2Zmc2V0XCIgKyBuYW1lIF0sIGRvY1sgXCJvZmZzZXRcIiArIG5hbWUgXSxcblx0XHRcdFx0XHRcdGRvY1sgXCJjbGllbnRcIiArIG5hbWUgXVxuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZCA/XG5cblx0XHRcdFx0XHQvLyBHZXQgd2lkdGggb3IgaGVpZ2h0IG9uIHRoZSBlbGVtZW50LCByZXF1ZXN0aW5nIGJ1dCBub3QgZm9yY2luZyBwYXJzZUZsb2F0XG5cdFx0XHRcdFx0alF1ZXJ5LmNzcyggZWxlbSwgdHlwZSwgZXh0cmEgKSA6XG5cblx0XHRcdFx0XHQvLyBTZXQgd2lkdGggb3IgaGVpZ2h0IG9uIHRoZSBlbGVtZW50XG5cdFx0XHRcdFx0alF1ZXJ5LnN0eWxlKCBlbGVtLCB0eXBlLCB2YWx1ZSwgZXh0cmEgKTtcblx0XHRcdH0sIHR5cGUsIGNoYWluYWJsZSA/IG1hcmdpbiA6IHVuZGVmaW5lZCwgY2hhaW5hYmxlICk7XG5cdFx0fTtcblx0fSApO1xufSApO1xuXG5cbmpRdWVyeS5lYWNoKCBbXG5cdFwiYWpheFN0YXJ0XCIsXG5cdFwiYWpheFN0b3BcIixcblx0XCJhamF4Q29tcGxldGVcIixcblx0XCJhamF4RXJyb3JcIixcblx0XCJhamF4U3VjY2Vzc1wiLFxuXHRcImFqYXhTZW5kXCJcbl0sIGZ1bmN0aW9uKCBfaSwgdHlwZSApIHtcblx0alF1ZXJ5LmZuWyB0eXBlIF0gPSBmdW5jdGlvbiggZm4gKSB7XG5cdFx0cmV0dXJuIHRoaXMub24oIHR5cGUsIGZuICk7XG5cdH07XG59ICk7XG5cblxuXG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblxuXHRiaW5kOiBmdW5jdGlvbiggdHlwZXMsIGRhdGEsIGZuICkge1xuXHRcdHJldHVybiB0aGlzLm9uKCB0eXBlcywgbnVsbCwgZGF0YSwgZm4gKTtcblx0fSxcblx0dW5iaW5kOiBmdW5jdGlvbiggdHlwZXMsIGZuICkge1xuXHRcdHJldHVybiB0aGlzLm9mZiggdHlwZXMsIG51bGwsIGZuICk7XG5cdH0sXG5cblx0ZGVsZWdhdGU6IGZ1bmN0aW9uKCBzZWxlY3RvciwgdHlwZXMsIGRhdGEsIGZuICkge1xuXHRcdHJldHVybiB0aGlzLm9uKCB0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuICk7XG5cdH0sXG5cdHVuZGVsZWdhdGU6IGZ1bmN0aW9uKCBzZWxlY3RvciwgdHlwZXMsIGZuICkge1xuXG5cdFx0Ly8gKCBuYW1lc3BhY2UgKSBvciAoIHNlbGVjdG9yLCB0eXBlcyBbLCBmbl0gKVxuXHRcdHJldHVybiBhcmd1bWVudHMubGVuZ3RoID09PSAxID9cblx0XHRcdHRoaXMub2ZmKCBzZWxlY3RvciwgXCIqKlwiICkgOlxuXHRcdFx0dGhpcy5vZmYoIHR5cGVzLCBzZWxlY3RvciB8fCBcIioqXCIsIGZuICk7XG5cdH0sXG5cblx0aG92ZXI6IGZ1bmN0aW9uKCBmbk92ZXIsIGZuT3V0ICkge1xuXHRcdHJldHVybiB0aGlzXG5cdFx0XHQub24oIFwibW91c2VlbnRlclwiLCBmbk92ZXIgKVxuXHRcdFx0Lm9uKCBcIm1vdXNlbGVhdmVcIiwgZm5PdXQgfHwgZm5PdmVyICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmVhY2goXG5cdCggXCJibHVyIGZvY3VzIGZvY3VzaW4gZm9jdXNvdXQgcmVzaXplIHNjcm9sbCBjbGljayBkYmxjbGljayBcIiArXG5cdFwibW91c2Vkb3duIG1vdXNldXAgbW91c2Vtb3ZlIG1vdXNlb3ZlciBtb3VzZW91dCBtb3VzZWVudGVyIG1vdXNlbGVhdmUgXCIgK1xuXHRcImNoYW5nZSBzZWxlY3Qgc3VibWl0IGtleWRvd24ga2V5cHJlc3Mga2V5dXAgY29udGV4dG1lbnVcIiApLnNwbGl0KCBcIiBcIiApLFxuXHRmdW5jdGlvbiggX2ksIG5hbWUgKSB7XG5cblx0XHQvLyBIYW5kbGUgZXZlbnQgYmluZGluZ1xuXHRcdGpRdWVyeS5mblsgbmFtZSBdID0gZnVuY3Rpb24oIGRhdGEsIGZuICkge1xuXHRcdFx0cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPiAwID9cblx0XHRcdFx0dGhpcy5vbiggbmFtZSwgbnVsbCwgZGF0YSwgZm4gKSA6XG5cdFx0XHRcdHRoaXMudHJpZ2dlciggbmFtZSApO1xuXHRcdH07XG5cdH1cbik7XG5cblxuXG5cbi8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjAgb25seVxuLy8gTWFrZSBzdXJlIHdlIHRyaW0gQk9NIGFuZCBOQlNQXG4vLyBSZXF1aXJlIHRoYXQgdGhlIFwid2hpdGVzcGFjZSBydW5cIiBzdGFydHMgZnJvbSBhIG5vbi13aGl0ZXNwYWNlXG4vLyB0byBhdm9pZCBPKE5eMikgYmVoYXZpb3Igd2hlbiB0aGUgZW5naW5lIHdvdWxkIHRyeSBtYXRjaGluZyBcIlxccyskXCIgYXQgZWFjaCBzcGFjZSBwb3NpdGlvbi5cbnZhciBydHJpbSA9IC9eW1xcc1xcdUZFRkZcXHhBMF0rfChbXlxcc1xcdUZFRkZcXHhBMF0pW1xcc1xcdUZFRkZcXHhBMF0rJC9nO1xuXG4vLyBCaW5kIGEgZnVuY3Rpb24gdG8gYSBjb250ZXh0LCBvcHRpb25hbGx5IHBhcnRpYWxseSBhcHBseWluZyBhbnlcbi8vIGFyZ3VtZW50cy5cbi8vIGpRdWVyeS5wcm94eSBpcyBkZXByZWNhdGVkIHRvIHByb21vdGUgc3RhbmRhcmRzIChzcGVjaWZpY2FsbHkgRnVuY3Rpb24jYmluZClcbi8vIEhvd2V2ZXIsIGl0IGlzIG5vdCBzbGF0ZWQgZm9yIHJlbW92YWwgYW55IHRpbWUgc29vblxualF1ZXJ5LnByb3h5ID0gZnVuY3Rpb24oIGZuLCBjb250ZXh0ICkge1xuXHR2YXIgdG1wLCBhcmdzLCBwcm94eTtcblxuXHRpZiAoIHR5cGVvZiBjb250ZXh0ID09PSBcInN0cmluZ1wiICkge1xuXHRcdHRtcCA9IGZuWyBjb250ZXh0IF07XG5cdFx0Y29udGV4dCA9IGZuO1xuXHRcdGZuID0gdG1wO1xuXHR9XG5cblx0Ly8gUXVpY2sgY2hlY2sgdG8gZGV0ZXJtaW5lIGlmIHRhcmdldCBpcyBjYWxsYWJsZSwgaW4gdGhlIHNwZWNcblx0Ly8gdGhpcyB0aHJvd3MgYSBUeXBlRXJyb3IsIGJ1dCB3ZSB3aWxsIGp1c3QgcmV0dXJuIHVuZGVmaW5lZC5cblx0aWYgKCAhaXNGdW5jdGlvbiggZm4gKSApIHtcblx0XHRyZXR1cm4gdW5kZWZpbmVkO1xuXHR9XG5cblx0Ly8gU2ltdWxhdGVkIGJpbmRcblx0YXJncyA9IHNsaWNlLmNhbGwoIGFyZ3VtZW50cywgMiApO1xuXHRwcm94eSA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBmbi5hcHBseSggY29udGV4dCB8fCB0aGlzLCBhcmdzLmNvbmNhdCggc2xpY2UuY2FsbCggYXJndW1lbnRzICkgKSApO1xuXHR9O1xuXG5cdC8vIFNldCB0aGUgZ3VpZCBvZiB1bmlxdWUgaGFuZGxlciB0byB0aGUgc2FtZSBvZiBvcmlnaW5hbCBoYW5kbGVyLCBzbyBpdCBjYW4gYmUgcmVtb3ZlZFxuXHRwcm94eS5ndWlkID0gZm4uZ3VpZCA9IGZuLmd1aWQgfHwgalF1ZXJ5Lmd1aWQrKztcblxuXHRyZXR1cm4gcHJveHk7XG59O1xuXG5qUXVlcnkuaG9sZFJlYWR5ID0gZnVuY3Rpb24oIGhvbGQgKSB7XG5cdGlmICggaG9sZCApIHtcblx0XHRqUXVlcnkucmVhZHlXYWl0Kys7XG5cdH0gZWxzZSB7XG5cdFx0alF1ZXJ5LnJlYWR5KCB0cnVlICk7XG5cdH1cbn07XG5qUXVlcnkuaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG5qUXVlcnkucGFyc2VKU09OID0gSlNPTi5wYXJzZTtcbmpRdWVyeS5ub2RlTmFtZSA9IG5vZGVOYW1lO1xualF1ZXJ5LmlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uO1xualF1ZXJ5LmlzV2luZG93ID0gaXNXaW5kb3c7XG5qUXVlcnkuY2FtZWxDYXNlID0gY2FtZWxDYXNlO1xualF1ZXJ5LnR5cGUgPSB0b1R5cGU7XG5cbmpRdWVyeS5ub3cgPSBEYXRlLm5vdztcblxualF1ZXJ5LmlzTnVtZXJpYyA9IGZ1bmN0aW9uKCBvYmogKSB7XG5cblx0Ly8gQXMgb2YgalF1ZXJ5IDMuMCwgaXNOdW1lcmljIGlzIGxpbWl0ZWQgdG9cblx0Ly8gc3RyaW5ncyBhbmQgbnVtYmVycyAocHJpbWl0aXZlcyBvciBvYmplY3RzKVxuXHQvLyB0aGF0IGNhbiBiZSBjb2VyY2VkIHRvIGZpbml0ZSBudW1iZXJzIChnaC0yNjYyKVxuXHR2YXIgdHlwZSA9IGpRdWVyeS50eXBlKCBvYmogKTtcblx0cmV0dXJuICggdHlwZSA9PT0gXCJudW1iZXJcIiB8fCB0eXBlID09PSBcInN0cmluZ1wiICkgJiZcblxuXHRcdC8vIHBhcnNlRmxvYXQgTmFOcyBudW1lcmljLWNhc3QgZmFsc2UgcG9zaXRpdmVzIChcIlwiKVxuXHRcdC8vIC4uLmJ1dCBtaXNpbnRlcnByZXRzIGxlYWRpbmctbnVtYmVyIHN0cmluZ3MsIHBhcnRpY3VsYXJseSBoZXggbGl0ZXJhbHMgKFwiMHguLi5cIilcblx0XHQvLyBzdWJ0cmFjdGlvbiBmb3JjZXMgaW5maW5pdGllcyB0byBOYU5cblx0XHQhaXNOYU4oIG9iaiAtIHBhcnNlRmxvYXQoIG9iaiApICk7XG59O1xuXG5qUXVlcnkudHJpbSA9IGZ1bmN0aW9uKCB0ZXh0ICkge1xuXHRyZXR1cm4gdGV4dCA9PSBudWxsID9cblx0XHRcIlwiIDpcblx0XHQoIHRleHQgKyBcIlwiICkucmVwbGFjZSggcnRyaW0sIFwiJDFcIiApO1xufTtcblxuXG5cbi8vIFJlZ2lzdGVyIGFzIGEgbmFtZWQgQU1EIG1vZHVsZSwgc2luY2UgalF1ZXJ5IGNhbiBiZSBjb25jYXRlbmF0ZWQgd2l0aCBvdGhlclxuLy8gZmlsZXMgdGhhdCBtYXkgdXNlIGRlZmluZSwgYnV0IG5vdCB2aWEgYSBwcm9wZXIgY29uY2F0ZW5hdGlvbiBzY3JpcHQgdGhhdFxuLy8gdW5kZXJzdGFuZHMgYW5vbnltb3VzIEFNRCBtb2R1bGVzLiBBIG5hbWVkIEFNRCBpcyBzYWZlc3QgYW5kIG1vc3Qgcm9idXN0XG4vLyB3YXkgdG8gcmVnaXN0ZXIuIExvd2VyY2FzZSBqcXVlcnkgaXMgdXNlZCBiZWNhdXNlIEFNRCBtb2R1bGUgbmFtZXMgYXJlXG4vLyBkZXJpdmVkIGZyb20gZmlsZSBuYW1lcywgYW5kIGpRdWVyeSBpcyBub3JtYWxseSBkZWxpdmVyZWQgaW4gYSBsb3dlcmNhc2Vcbi8vIGZpbGUgbmFtZS4gRG8gdGhpcyBhZnRlciBjcmVhdGluZyB0aGUgZ2xvYmFsIHNvIHRoYXQgaWYgYW4gQU1EIG1vZHVsZSB3YW50c1xuLy8gdG8gY2FsbCBub0NvbmZsaWN0IHRvIGhpZGUgdGhpcyB2ZXJzaW9uIG9mIGpRdWVyeSwgaXQgd2lsbCB3b3JrLlxuXG4vLyBOb3RlIHRoYXQgZm9yIG1heGltdW0gcG9ydGFiaWxpdHksIGxpYnJhcmllcyB0aGF0IGFyZSBub3QgalF1ZXJ5IHNob3VsZFxuLy8gZGVjbGFyZSB0aGVtc2VsdmVzIGFzIGFub255bW91cyBtb2R1bGVzLCBhbmQgYXZvaWQgc2V0dGluZyBhIGdsb2JhbCBpZiBhblxuLy8gQU1EIGxvYWRlciBpcyBwcmVzZW50LiBqUXVlcnkgaXMgYSBzcGVjaWFsIGNhc2UuIEZvciBtb3JlIGluZm9ybWF0aW9uLCBzZWVcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9qcmJ1cmtlL3JlcXVpcmVqcy93aWtpL1VwZGF0aW5nLWV4aXN0aW5nLWxpYnJhcmllcyN3aWtpLWFub25cblxuaWYgKCB0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCApIHtcblx0ZGVmaW5lKCBcImpxdWVyeVwiLCBbXSwgZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGpRdWVyeTtcblx0fSApO1xufVxuXG5cblxuXG52YXJcblxuXHQvLyBNYXAgb3ZlciBqUXVlcnkgaW4gY2FzZSBvZiBvdmVyd3JpdGVcblx0X2pRdWVyeSA9IHdpbmRvdy5qUXVlcnksXG5cblx0Ly8gTWFwIG92ZXIgdGhlICQgaW4gY2FzZSBvZiBvdmVyd3JpdGVcblx0XyQgPSB3aW5kb3cuJDtcblxualF1ZXJ5Lm5vQ29uZmxpY3QgPSBmdW5jdGlvbiggZGVlcCApIHtcblx0aWYgKCB3aW5kb3cuJCA9PT0galF1ZXJ5ICkge1xuXHRcdHdpbmRvdy4kID0gXyQ7XG5cdH1cblxuXHRpZiAoIGRlZXAgJiYgd2luZG93LmpRdWVyeSA9PT0galF1ZXJ5ICkge1xuXHRcdHdpbmRvdy5qUXVlcnkgPSBfalF1ZXJ5O1xuXHR9XG5cblx0cmV0dXJuIGpRdWVyeTtcbn07XG5cbi8vIEV4cG9zZSBqUXVlcnkgYW5kICQgaWRlbnRpZmllcnMsIGV2ZW4gaW4gQU1EXG4vLyAodHJhYy03MTAyI2NvbW1lbnQ6MTAsIGh0dHBzOi8vZ2l0aHViLmNvbS9qcXVlcnkvanF1ZXJ5L3B1bGwvNTU3KVxuLy8gYW5kIENvbW1vbkpTIGZvciBicm93c2VyIGVtdWxhdG9ycyAodHJhYy0xMzU2NilcbmlmICggdHlwZW9mIG5vR2xvYmFsID09PSBcInVuZGVmaW5lZFwiICkge1xuXHR3aW5kb3cualF1ZXJ5ID0gd2luZG93LiQgPSBqUXVlcnk7XG59XG5cblxuXG5cbnJldHVybiBqUXVlcnk7XG59ICk7XG4iXSwibmFtZXMiOlsiZ2xvYmFsIiwiZmFjdG9yeSIsIm1vZHVsZSIsImV4cG9ydHMiLCJkb2N1bWVudCIsInciLCJFcnJvciIsIndpbmRvdyIsIm5vR2xvYmFsIiwiYXJyIiwiZ2V0UHJvdG8iLCJPYmplY3QiLCJnZXRQcm90b3R5cGVPZiIsInNsaWNlIiwiZmxhdCIsImFycmF5IiwiY2FsbCIsImNvbmNhdCIsImFwcGx5IiwicHVzaCIsImluZGV4T2YiLCJjbGFzczJ0eXBlIiwidG9TdHJpbmciLCJoYXNPd24iLCJoYXNPd25Qcm9wZXJ0eSIsImZuVG9TdHJpbmciLCJPYmplY3RGdW5jdGlvblN0cmluZyIsInN1cHBvcnQiLCJpc0Z1bmN0aW9uIiwib2JqIiwibm9kZVR5cGUiLCJpdGVtIiwiaXNXaW5kb3ciLCJwcmVzZXJ2ZWRTY3JpcHRBdHRyaWJ1dGVzIiwidHlwZSIsInNyYyIsIm5vbmNlIiwibm9Nb2R1bGUiLCJET01FdmFsIiwiY29kZSIsIm5vZGUiLCJkb2MiLCJpIiwidmFsIiwic2NyaXB0IiwiY3JlYXRlRWxlbWVudCIsInRleHQiLCJnZXRBdHRyaWJ1dGUiLCJzZXRBdHRyaWJ1dGUiLCJoZWFkIiwiYXBwZW5kQ2hpbGQiLCJwYXJlbnROb2RlIiwicmVtb3ZlQ2hpbGQiLCJ0b1R5cGUiLCJ2ZXJzaW9uIiwicmh0bWxTdWZmaXgiLCJqUXVlcnkiLCJzZWxlY3RvciIsImNvbnRleHQiLCJmbiIsImluaXQiLCJwcm90b3R5cGUiLCJqcXVlcnkiLCJjb25zdHJ1Y3RvciIsImxlbmd0aCIsInRvQXJyYXkiLCJnZXQiLCJudW0iLCJwdXNoU3RhY2siLCJlbGVtcyIsInJldCIsIm1lcmdlIiwicHJldk9iamVjdCIsImVhY2giLCJjYWxsYmFjayIsIm1hcCIsImVsZW0iLCJhcmd1bWVudHMiLCJmaXJzdCIsImVxIiwibGFzdCIsImV2ZW4iLCJncmVwIiwiX2VsZW0iLCJvZGQiLCJsZW4iLCJqIiwiZW5kIiwic29ydCIsInNwbGljZSIsImV4dGVuZCIsIm9wdGlvbnMiLCJuYW1lIiwiY29weSIsImNvcHlJc0FycmF5IiwiY2xvbmUiLCJ0YXJnZXQiLCJkZWVwIiwiaXNQbGFpbk9iamVjdCIsIkFycmF5IiwiaXNBcnJheSIsInVuZGVmaW5lZCIsImV4cGFuZG8iLCJNYXRoIiwicmFuZG9tIiwicmVwbGFjZSIsImlzUmVhZHkiLCJlcnJvciIsIm1zZyIsIm5vb3AiLCJwcm90byIsIkN0b3IiLCJpc0VtcHR5T2JqZWN0IiwiZ2xvYmFsRXZhbCIsImlzQXJyYXlMaWtlIiwidGV4dENvbnRlbnQiLCJkb2N1bWVudEVsZW1lbnQiLCJub2RlVmFsdWUiLCJtYWtlQXJyYXkiLCJyZXN1bHRzIiwiaW5BcnJheSIsImlzWE1MRG9jIiwibmFtZXNwYWNlIiwibmFtZXNwYWNlVVJJIiwiZG9jRWxlbSIsIm93bmVyRG9jdW1lbnQiLCJ0ZXN0Iiwibm9kZU5hbWUiLCJzZWNvbmQiLCJpbnZlcnQiLCJjYWxsYmFja0ludmVyc2UiLCJtYXRjaGVzIiwiY2FsbGJhY2tFeHBlY3QiLCJhcmciLCJ2YWx1ZSIsImd1aWQiLCJTeW1ib2wiLCJpdGVyYXRvciIsInNwbGl0IiwiX2kiLCJ0b0xvd2VyQ2FzZSIsInBvcCIsIndoaXRlc3BhY2UiLCJydHJpbUNTUyIsIlJlZ0V4cCIsImNvbnRhaW5zIiwiYSIsImIiLCJidXAiLCJjb21wYXJlRG9jdW1lbnRQb3NpdGlvbiIsInJjc3Nlc2NhcGUiLCJmY3NzZXNjYXBlIiwiY2giLCJhc0NvZGVQb2ludCIsImNoYXJDb2RlQXQiLCJlc2NhcGVTZWxlY3RvciIsInNlbCIsInByZWZlcnJlZERvYyIsInB1c2hOYXRpdmUiLCJFeHByIiwib3V0ZXJtb3N0Q29udGV4dCIsInNvcnRJbnB1dCIsImhhc0R1cGxpY2F0ZSIsImRvY3VtZW50SXNIVE1MIiwicmJ1Z2d5UVNBIiwiZGlycnVucyIsImRvbmUiLCJjbGFzc0NhY2hlIiwiY3JlYXRlQ2FjaGUiLCJ0b2tlbkNhY2hlIiwiY29tcGlsZXJDYWNoZSIsIm5vbm5hdGl2ZVNlbGVjdG9yQ2FjaGUiLCJzb3J0T3JkZXIiLCJib29sZWFucyIsImlkZW50aWZpZXIiLCJhdHRyaWJ1dGVzIiwicHNldWRvcyIsInJ3aGl0ZXNwYWNlIiwicmNvbW1hIiwicmxlYWRpbmdDb21iaW5hdG9yIiwicmRlc2NlbmQiLCJycHNldWRvIiwicmlkZW50aWZpZXIiLCJtYXRjaEV4cHIiLCJJRCIsIkNMQVNTIiwiVEFHIiwiQVRUUiIsIlBTRVVETyIsIkNISUxEIiwiYm9vbCIsIm5lZWRzQ29udGV4dCIsInJpbnB1dHMiLCJyaGVhZGVyIiwicnF1aWNrRXhwciIsInJzaWJsaW5nIiwicnVuZXNjYXBlIiwiZnVuZXNjYXBlIiwiZXNjYXBlIiwibm9uSGV4IiwiaGlnaCIsIlN0cmluZyIsImZyb21DaGFyQ29kZSIsInVubG9hZEhhbmRsZXIiLCJzZXREb2N1bWVudCIsImluRGlzYWJsZWRGaWVsZHNldCIsImFkZENvbWJpbmF0b3IiLCJkaXNhYmxlZCIsImRpciIsIm5leHQiLCJzYWZlQWN0aXZlRWxlbWVudCIsImFjdGl2ZUVsZW1lbnQiLCJlcnIiLCJjaGlsZE5vZGVzIiwiZSIsImVscyIsImZpbmQiLCJzZWVkIiwibSIsIm5pZCIsIm1hdGNoIiwiZ3JvdXBzIiwibmV3U2VsZWN0b3IiLCJuZXdDb250ZXh0IiwiZXhlYyIsImdldEVsZW1lbnRCeUlkIiwiaWQiLCJnZXRFbGVtZW50c0J5VGFnTmFtZSIsImdldEVsZW1lbnRzQnlDbGFzc05hbWUiLCJ0ZXN0Q29udGV4dCIsInNjb3BlIiwidG9rZW5pemUiLCJ0b1NlbGVjdG9yIiwiam9pbiIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJxc2FFcnJvciIsInJlbW92ZUF0dHJpYnV0ZSIsInNlbGVjdCIsImtleXMiLCJjYWNoZSIsImtleSIsImNhY2hlTGVuZ3RoIiwic2hpZnQiLCJtYXJrRnVuY3Rpb24iLCJhc3NlcnQiLCJlbCIsImNyZWF0ZUlucHV0UHNldWRvIiwiY3JlYXRlQnV0dG9uUHNldWRvIiwiY3JlYXRlRGlzYWJsZWRQc2V1ZG8iLCJpc0Rpc2FibGVkIiwiY3JlYXRlUG9zaXRpb25hbFBzZXVkbyIsImFyZ3VtZW50IiwibWF0Y2hJbmRleGVzIiwic3ViV2luZG93Iiwid2Via2l0TWF0Y2hlc1NlbGVjdG9yIiwibXNNYXRjaGVzU2VsZWN0b3IiLCJkZWZhdWx0VmlldyIsInRvcCIsImFkZEV2ZW50TGlzdGVuZXIiLCJnZXRCeUlkIiwiZ2V0RWxlbWVudHNCeU5hbWUiLCJkaXNjb25uZWN0ZWRNYXRjaCIsImNzc0hhcyIsInF1ZXJ5U2VsZWN0b3IiLCJmaWx0ZXIiLCJhdHRySWQiLCJnZXRBdHRyaWJ1dGVOb2RlIiwidGFnIiwiY2xhc3NOYW1lIiwiaW5wdXQiLCJpbm5lckhUTUwiLCJjb21wYXJlIiwic29ydERldGFjaGVkIiwiZXhwciIsImVsZW1lbnRzIiwibWF0Y2hlc1NlbGVjdG9yIiwiYXR0ciIsImF0dHJIYW5kbGUiLCJ1bmlxdWVTb3J0IiwiZHVwbGljYXRlcyIsInNvcnRTdGFibGUiLCJjcmVhdGVQc2V1ZG8iLCJyZWxhdGl2ZSIsInByZUZpbHRlciIsImV4Y2VzcyIsInVucXVvdGVkIiwibm9kZU5hbWVTZWxlY3RvciIsImV4cGVjdGVkTm9kZU5hbWUiLCJwYXR0ZXJuIiwib3BlcmF0b3IiLCJjaGVjayIsInJlc3VsdCIsIndoYXQiLCJfYXJndW1lbnQiLCJzaW1wbGUiLCJmb3J3YXJkIiwib2ZUeXBlIiwiX2NvbnRleHQiLCJ4bWwiLCJvdXRlckNhY2hlIiwibm9kZUluZGV4Iiwic3RhcnQiLCJwYXJlbnQiLCJ1c2VDYWNoZSIsImRpZmYiLCJmaXJzdENoaWxkIiwibGFzdENoaWxkIiwicHNldWRvIiwiYXJncyIsInNldEZpbHRlcnMiLCJpZHgiLCJtYXRjaGVkIiwibm90IiwibWF0Y2hlciIsImNvbXBpbGUiLCJ1bm1hdGNoZWQiLCJoYXMiLCJsYW5nIiwiZWxlbUxhbmciLCJoYXNoIiwibG9jYXRpb24iLCJyb290IiwiZm9jdXMiLCJoYXNGb2N1cyIsImhyZWYiLCJ0YWJJbmRleCIsImVuYWJsZWQiLCJjaGVja2VkIiwic2VsZWN0ZWQiLCJzZWxlY3RlZEluZGV4IiwiZW1wdHkiLCJuZXh0U2libGluZyIsImhlYWRlciIsImJ1dHRvbiIsIl9tYXRjaEluZGV4ZXMiLCJsdCIsImd0IiwibnRoIiwicmFkaW8iLCJjaGVja2JveCIsImZpbGUiLCJwYXNzd29yZCIsImltYWdlIiwic3VibWl0IiwicmVzZXQiLCJmaWx0ZXJzIiwicGFyc2VPbmx5IiwidG9rZW5zIiwic29GYXIiLCJwcmVGaWx0ZXJzIiwiY2FjaGVkIiwiY29tYmluYXRvciIsImJhc2UiLCJza2lwIiwiY2hlY2tOb25FbGVtZW50cyIsImRvbmVOYW1lIiwib2xkQ2FjaGUiLCJuZXdDYWNoZSIsImVsZW1lbnRNYXRjaGVyIiwibWF0Y2hlcnMiLCJtdWx0aXBsZUNvbnRleHRzIiwiY29udGV4dHMiLCJjb25kZW5zZSIsIm5ld1VubWF0Y2hlZCIsIm1hcHBlZCIsInNldE1hdGNoZXIiLCJwb3N0RmlsdGVyIiwicG9zdEZpbmRlciIsInBvc3RTZWxlY3RvciIsInRlbXAiLCJtYXRjaGVyT3V0IiwicHJlTWFwIiwicG9zdE1hcCIsInByZWV4aXN0aW5nIiwibWF0Y2hlckluIiwibWF0Y2hlckZyb21Ub2tlbnMiLCJjaGVja0NvbnRleHQiLCJsZWFkaW5nUmVsYXRpdmUiLCJpbXBsaWNpdFJlbGF0aXZlIiwibWF0Y2hDb250ZXh0IiwibWF0Y2hBbnlDb250ZXh0IiwibWF0Y2hlckZyb21Hcm91cE1hdGNoZXJzIiwiZWxlbWVudE1hdGNoZXJzIiwic2V0TWF0Y2hlcnMiLCJieVNldCIsImJ5RWxlbWVudCIsInN1cGVyTWF0Y2hlciIsIm91dGVybW9zdCIsIm1hdGNoZWRDb3VudCIsInNldE1hdGNoZWQiLCJjb250ZXh0QmFja3VwIiwiZGlycnVuc1VuaXF1ZSIsInRva2VuIiwiY29tcGlsZWQiLCJ1bmlxdWUiLCJnZXRUZXh0IiwiaXNYTUwiLCJzZWxlY3RvcnMiLCJ1bnRpbCIsInRydW5jYXRlIiwiaXMiLCJzaWJsaW5ncyIsIm4iLCJybmVlZHNDb250ZXh0IiwicnNpbmdsZVRhZyIsIndpbm5vdyIsInF1YWxpZmllciIsInNlbGYiLCJyb290alF1ZXJ5IiwicGFyc2VIVE1MIiwicmVhZHkiLCJycGFyZW50c3ByZXYiLCJndWFyYW50ZWVkVW5pcXVlIiwiY2hpbGRyZW4iLCJjb250ZW50cyIsInByZXYiLCJ0YXJnZXRzIiwibCIsImNsb3Nlc3QiLCJjdXIiLCJpbmRleCIsInByZXZBbGwiLCJhZGQiLCJhZGRCYWNrIiwic2libGluZyIsInBhcmVudHMiLCJwYXJlbnRzVW50aWwiLCJuZXh0QWxsIiwibmV4dFVudGlsIiwicHJldlVudGlsIiwiY29udGVudERvY3VtZW50IiwiY29udGVudCIsInJldmVyc2UiLCJybm90aHRtbHdoaXRlIiwiY3JlYXRlT3B0aW9ucyIsIm9iamVjdCIsIl8iLCJmbGFnIiwiQ2FsbGJhY2tzIiwiZmlyaW5nIiwibWVtb3J5IiwiZmlyZWQiLCJsb2NrZWQiLCJsaXN0IiwicXVldWUiLCJmaXJpbmdJbmRleCIsImZpcmUiLCJvbmNlIiwic3RvcE9uRmFsc2UiLCJyZW1vdmUiLCJkaXNhYmxlIiwibG9jayIsImZpcmVXaXRoIiwiSWRlbnRpdHkiLCJ2IiwiVGhyb3dlciIsImV4IiwiYWRvcHRWYWx1ZSIsInJlc29sdmUiLCJyZWplY3QiLCJub1ZhbHVlIiwibWV0aG9kIiwicHJvbWlzZSIsImZhaWwiLCJ0aGVuIiwiRGVmZXJyZWQiLCJmdW5jIiwidHVwbGVzIiwic3RhdGUiLCJhbHdheXMiLCJkZWZlcnJlZCIsInBpcGUiLCJmbnMiLCJuZXdEZWZlciIsInR1cGxlIiwicmV0dXJuZWQiLCJwcm9ncmVzcyIsIm5vdGlmeSIsIm9uRnVsZmlsbGVkIiwib25SZWplY3RlZCIsIm9uUHJvZ3Jlc3MiLCJtYXhEZXB0aCIsImRlcHRoIiwiaGFuZGxlciIsInNwZWNpYWwiLCJ0aGF0IiwibWlnaHRUaHJvdyIsIlR5cGVFcnJvciIsIm5vdGlmeVdpdGgiLCJyZXNvbHZlV2l0aCIsInByb2Nlc3MiLCJleGNlcHRpb25Ib29rIiwicmVqZWN0V2l0aCIsImdldEVycm9ySG9vayIsImdldFN0YWNrSG9vayIsInNldFRpbWVvdXQiLCJzdGF0ZVN0cmluZyIsIndoZW4iLCJzaW5nbGVWYWx1ZSIsInJlbWFpbmluZyIsInJlc29sdmVDb250ZXh0cyIsInJlc29sdmVWYWx1ZXMiLCJwcmltYXJ5IiwidXBkYXRlRnVuYyIsInJlcnJvck5hbWVzIiwiYXN5bmNFcnJvciIsImNvbnNvbGUiLCJ3YXJuIiwibWVzc2FnZSIsInN0YWNrIiwicmVhZHlFeGNlcHRpb24iLCJyZWFkeUxpc3QiLCJjYXRjaCIsInJlYWR5V2FpdCIsIndhaXQiLCJjb21wbGV0ZWQiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwicmVhZHlTdGF0ZSIsImRvU2Nyb2xsIiwiYWNjZXNzIiwiY2hhaW5hYmxlIiwiZW1wdHlHZXQiLCJyYXciLCJidWxrIiwiX2tleSIsInJtc1ByZWZpeCIsInJkYXNoQWxwaGEiLCJmY2FtZWxDYXNlIiwiX2FsbCIsImxldHRlciIsInRvVXBwZXJDYXNlIiwiY2FtZWxDYXNlIiwic3RyaW5nIiwiYWNjZXB0RGF0YSIsIm93bmVyIiwiRGF0YSIsInVpZCIsImRlZmluZVByb3BlcnR5IiwiY29uZmlndXJhYmxlIiwic2V0IiwiZGF0YSIsInByb3AiLCJoYXNEYXRhIiwiZGF0YVByaXYiLCJkYXRhVXNlciIsInJicmFjZSIsInJtdWx0aURhc2giLCJnZXREYXRhIiwiSlNPTiIsInBhcnNlIiwiZGF0YUF0dHIiLCJyZW1vdmVEYXRhIiwiX2RhdGEiLCJfcmVtb3ZlRGF0YSIsImF0dHJzIiwiZGVxdWV1ZSIsInN0YXJ0TGVuZ3RoIiwiaG9va3MiLCJfcXVldWVIb29rcyIsInVuc2hpZnQiLCJzdG9wIiwic2V0dGVyIiwiY2xlYXJRdWV1ZSIsInRtcCIsImNvdW50IiwiZGVmZXIiLCJwbnVtIiwic291cmNlIiwicmNzc051bSIsImNzc0V4cGFuZCIsImlzQXR0YWNoZWQiLCJjb21wb3NlZCIsImdldFJvb3ROb2RlIiwiaXNIaWRkZW5XaXRoaW5UcmVlIiwic3R5bGUiLCJkaXNwbGF5IiwiY3NzIiwiYWRqdXN0Q1NTIiwidmFsdWVQYXJ0cyIsInR3ZWVuIiwiYWRqdXN0ZWQiLCJzY2FsZSIsIm1heEl0ZXJhdGlvbnMiLCJjdXJyZW50VmFsdWUiLCJpbml0aWFsIiwidW5pdCIsImNzc051bWJlciIsImluaXRpYWxJblVuaXQiLCJkZWZhdWx0RGlzcGxheU1hcCIsImdldERlZmF1bHREaXNwbGF5IiwiYm9keSIsInNob3dIaWRlIiwic2hvdyIsInZhbHVlcyIsImhpZGUiLCJ0b2dnbGUiLCJyY2hlY2thYmxlVHlwZSIsInJ0YWdOYW1lIiwicnNjcmlwdFR5cGUiLCJmcmFnbWVudCIsImNyZWF0ZURvY3VtZW50RnJhZ21lbnQiLCJkaXYiLCJjaGVja0Nsb25lIiwiY2xvbmVOb2RlIiwibm9DbG9uZUNoZWNrZWQiLCJkZWZhdWx0VmFsdWUiLCJvcHRpb24iLCJ3cmFwTWFwIiwidGhlYWQiLCJjb2wiLCJ0ciIsInRkIiwiX2RlZmF1bHQiLCJ0Ym9keSIsInRmb290IiwiY29sZ3JvdXAiLCJjYXB0aW9uIiwidGgiLCJvcHRncm91cCIsImdldEFsbCIsInNldEdsb2JhbEV2YWwiLCJyZWZFbGVtZW50cyIsInJodG1sIiwiYnVpbGRGcmFnbWVudCIsInNjcmlwdHMiLCJzZWxlY3Rpb24iLCJpZ25vcmVkIiwid3JhcCIsImF0dGFjaGVkIiwibm9kZXMiLCJjcmVhdGVUZXh0Tm9kZSIsImh0bWxQcmVmaWx0ZXIiLCJydHlwZW5hbWVzcGFjZSIsInJldHVyblRydWUiLCJyZXR1cm5GYWxzZSIsIm9uIiwidHlwZXMiLCJvbmUiLCJvcmlnRm4iLCJldmVudCIsIm9mZiIsImhhbmRsZU9iakluIiwiZXZlbnRIYW5kbGUiLCJldmVudHMiLCJ0IiwiaGFuZGxlT2JqIiwiaGFuZGxlcnMiLCJuYW1lc3BhY2VzIiwib3JpZ1R5cGUiLCJlbGVtRGF0YSIsImNyZWF0ZSIsImhhbmRsZSIsInRyaWdnZXJlZCIsImRpc3BhdGNoIiwiZGVsZWdhdGVUeXBlIiwiYmluZFR5cGUiLCJkZWxlZ2F0ZUNvdW50Iiwic2V0dXAiLCJtYXBwZWRUeXBlcyIsIm9yaWdDb3VudCIsInRlYXJkb3duIiwicmVtb3ZlRXZlbnQiLCJuYXRpdmVFdmVudCIsImhhbmRsZXJRdWV1ZSIsImZpeCIsImRlbGVnYXRlVGFyZ2V0IiwicHJlRGlzcGF0Y2giLCJpc1Byb3BhZ2F0aW9uU3RvcHBlZCIsImN1cnJlbnRUYXJnZXQiLCJpc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZCIsInJuYW1lc3BhY2UiLCJwcmV2ZW50RGVmYXVsdCIsInN0b3BQcm9wYWdhdGlvbiIsInBvc3REaXNwYXRjaCIsIm1hdGNoZWRIYW5kbGVycyIsIm1hdGNoZWRTZWxlY3RvcnMiLCJhZGRQcm9wIiwiaG9vayIsIkV2ZW50IiwiZW51bWVyYWJsZSIsIm9yaWdpbmFsRXZlbnQiLCJ3cml0YWJsZSIsImxvYWQiLCJub0J1YmJsZSIsImNsaWNrIiwibGV2ZXJhZ2VOYXRpdmUiLCJ0cmlnZ2VyIiwiYmVmb3JldW5sb2FkIiwicmV0dXJuVmFsdWUiLCJpc1NldHVwIiwic2F2ZWQiLCJpc1RyaWdnZXIiLCJzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24iLCJwcm9wcyIsImlzRGVmYXVsdFByZXZlbnRlZCIsImRlZmF1bHRQcmV2ZW50ZWQiLCJyZWxhdGVkVGFyZ2V0IiwidGltZVN0YW1wIiwiRGF0ZSIsIm5vdyIsImlzU2ltdWxhdGVkIiwiYWx0S2V5IiwiYnViYmxlcyIsImNhbmNlbGFibGUiLCJjaGFuZ2VkVG91Y2hlcyIsImN0cmxLZXkiLCJkZXRhaWwiLCJldmVudFBoYXNlIiwibWV0YUtleSIsInBhZ2VYIiwicGFnZVkiLCJzaGlmdEtleSIsInZpZXciLCJjaGFyQ29kZSIsImtleUNvZGUiLCJidXR0b25zIiwiY2xpZW50WCIsImNsaWVudFkiLCJvZmZzZXRYIiwib2Zmc2V0WSIsInBvaW50ZXJJZCIsInBvaW50ZXJUeXBlIiwic2NyZWVuWCIsInNjcmVlblkiLCJ0YXJnZXRUb3VjaGVzIiwidG9FbGVtZW50IiwidG91Y2hlcyIsIndoaWNoIiwiYmx1ciIsImZvY3VzTWFwcGVkSGFuZGxlciIsImRvY3VtZW50TW9kZSIsInNpbXVsYXRlIiwiYXR0YWNoZXMiLCJkYXRhSG9sZGVyIiwibW91c2VlbnRlciIsIm1vdXNlbGVhdmUiLCJwb2ludGVyZW50ZXIiLCJwb2ludGVybGVhdmUiLCJvcmlnIiwicmVsYXRlZCIsInJub0lubmVyaHRtbCIsInJjaGVja2VkIiwicmNsZWFuU2NyaXB0IiwibWFuaXB1bGF0aW9uVGFyZ2V0IiwiZGlzYWJsZVNjcmlwdCIsInJlc3RvcmVTY3JpcHQiLCJjbG9uZUNvcHlFdmVudCIsImRlc3QiLCJwZGF0YU9sZCIsInVkYXRhT2xkIiwidWRhdGFDdXIiLCJmaXhJbnB1dCIsImRvbU1hbmlwIiwiY29sbGVjdGlvbiIsImhhc1NjcmlwdHMiLCJpTm9DbG9uZSIsInZhbHVlSXNGdW5jdGlvbiIsImh0bWwiLCJfZXZhbFVybCIsImtlZXBEYXRhIiwiY2xlYW5EYXRhIiwiZGF0YUFuZEV2ZW50cyIsImRlZXBEYXRhQW5kRXZlbnRzIiwic3JjRWxlbWVudHMiLCJkZXN0RWxlbWVudHMiLCJpblBhZ2UiLCJkZXRhY2giLCJhcHBlbmQiLCJwcmVwZW5kIiwiaW5zZXJ0QmVmb3JlIiwiYmVmb3JlIiwiYWZ0ZXIiLCJyZXBsYWNlV2l0aCIsInJlcGxhY2VDaGlsZCIsImFwcGVuZFRvIiwicHJlcGVuZFRvIiwiaW5zZXJ0QWZ0ZXIiLCJyZXBsYWNlQWxsIiwib3JpZ2luYWwiLCJpbnNlcnQiLCJybnVtbm9ucHgiLCJyY3VzdG9tUHJvcCIsImdldFN0eWxlcyIsIm9wZW5lciIsImdldENvbXB1dGVkU3R5bGUiLCJzd2FwIiwib2xkIiwicmJveFN0eWxlIiwiY29tcHV0ZVN0eWxlVGVzdHMiLCJjb250YWluZXIiLCJjc3NUZXh0IiwiZGl2U3R5bGUiLCJwaXhlbFBvc2l0aW9uVmFsIiwicmVsaWFibGVNYXJnaW5MZWZ0VmFsIiwicm91bmRQaXhlbE1lYXN1cmVzIiwibWFyZ2luTGVmdCIsInJpZ2h0IiwicGl4ZWxCb3hTdHlsZXNWYWwiLCJib3hTaXppbmdSZWxpYWJsZVZhbCIsIndpZHRoIiwicG9zaXRpb24iLCJzY3JvbGxib3hTaXplVmFsIiwib2Zmc2V0V2lkdGgiLCJtZWFzdXJlIiwicm91bmQiLCJwYXJzZUZsb2F0IiwicmVsaWFibGVUckRpbWVuc2lvbnNWYWwiLCJiYWNrZ3JvdW5kQ2xpcCIsImNsZWFyQ2xvbmVTdHlsZSIsImJveFNpemluZ1JlbGlhYmxlIiwicGl4ZWxCb3hTdHlsZXMiLCJwaXhlbFBvc2l0aW9uIiwicmVsaWFibGVNYXJnaW5MZWZ0Iiwic2Nyb2xsYm94U2l6ZSIsInJlbGlhYmxlVHJEaW1lbnNpb25zIiwidGFibGUiLCJ0ckNoaWxkIiwidHJTdHlsZSIsImhlaWdodCIsInBhcnNlSW50IiwiYm9yZGVyVG9wV2lkdGgiLCJib3JkZXJCb3R0b21XaWR0aCIsIm9mZnNldEhlaWdodCIsImN1ckNTUyIsImNvbXB1dGVkIiwibWluV2lkdGgiLCJtYXhXaWR0aCIsImlzQ3VzdG9tUHJvcCIsImdldFByb3BlcnR5VmFsdWUiLCJhZGRHZXRIb29rSWYiLCJjb25kaXRpb25GbiIsImhvb2tGbiIsImNzc1ByZWZpeGVzIiwiZW1wdHlTdHlsZSIsInZlbmRvclByb3BzIiwidmVuZG9yUHJvcE5hbWUiLCJjYXBOYW1lIiwiZmluYWxQcm9wTmFtZSIsImZpbmFsIiwiY3NzUHJvcHMiLCJyZGlzcGxheXN3YXAiLCJjc3NTaG93IiwidmlzaWJpbGl0eSIsImNzc05vcm1hbFRyYW5zZm9ybSIsImxldHRlclNwYWNpbmciLCJmb250V2VpZ2h0Iiwic2V0UG9zaXRpdmVOdW1iZXIiLCJzdWJ0cmFjdCIsIm1heCIsImJveE1vZGVsQWRqdXN0bWVudCIsImRpbWVuc2lvbiIsImJveCIsImlzQm9yZGVyQm94Iiwic3R5bGVzIiwiY29tcHV0ZWRWYWwiLCJleHRyYSIsImRlbHRhIiwibWFyZ2luRGVsdGEiLCJjZWlsIiwiZ2V0V2lkdGhPckhlaWdodCIsImJveFNpemluZ05lZWRlZCIsInZhbHVlSXNCb3JkZXJCb3giLCJvZmZzZXRQcm9wIiwiZ2V0Q2xpZW50UmVjdHMiLCJjc3NIb29rcyIsIm9wYWNpdHkiLCJhbmltYXRpb25JdGVyYXRpb25Db3VudCIsImFzcGVjdFJhdGlvIiwiYm9yZGVySW1hZ2VTbGljZSIsImNvbHVtbkNvdW50IiwiZmxleEdyb3ciLCJmbGV4U2hyaW5rIiwiZ3JpZEFyZWEiLCJncmlkQ29sdW1uIiwiZ3JpZENvbHVtbkVuZCIsImdyaWRDb2x1bW5TdGFydCIsImdyaWRSb3ciLCJncmlkUm93RW5kIiwiZ3JpZFJvd1N0YXJ0IiwibGluZUhlaWdodCIsIm9yZGVyIiwib3JwaGFucyIsIndpZG93cyIsInpJbmRleCIsInpvb20iLCJmaWxsT3BhY2l0eSIsImZsb29kT3BhY2l0eSIsInN0b3BPcGFjaXR5Iiwic3Ryb2tlTWl0ZXJsaW1pdCIsInN0cm9rZU9wYWNpdHkiLCJvcmlnTmFtZSIsInNldFByb3BlcnR5IiwiaXNGaW5pdGUiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJzY3JvbGxib3hTaXplQnVnZ3kiLCJsZWZ0IiwibWFyZ2luIiwicGFkZGluZyIsImJvcmRlciIsInByZWZpeCIsInN1ZmZpeCIsImV4cGFuZCIsImV4cGFuZGVkIiwicGFydHMiLCJUd2VlbiIsImVhc2luZyIsInByb3BIb29rcyIsInJ1biIsInBlcmNlbnQiLCJlYXNlZCIsImR1cmF0aW9uIiwicG9zIiwic3RlcCIsImZ4Iiwic2Nyb2xsVG9wIiwic2Nyb2xsTGVmdCIsImxpbmVhciIsInAiLCJzd2luZyIsImNvcyIsIlBJIiwiZnhOb3ciLCJpblByb2dyZXNzIiwicmZ4dHlwZXMiLCJycnVuIiwic2NoZWR1bGUiLCJoaWRkZW4iLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJpbnRlcnZhbCIsInRpY2siLCJjcmVhdGVGeE5vdyIsImdlbkZ4IiwiaW5jbHVkZVdpZHRoIiwiY3JlYXRlVHdlZW4iLCJhbmltYXRpb24iLCJBbmltYXRpb24iLCJ0d2VlbmVycyIsImRlZmF1bHRQcmVmaWx0ZXIiLCJvcHRzIiwib2xkZmlyZSIsInByb3BUd2VlbiIsInJlc3RvcmVEaXNwbGF5IiwiaXNCb3giLCJhbmltIiwiZGF0YVNob3ciLCJ1bnF1ZXVlZCIsIm92ZXJmbG93Iiwib3ZlcmZsb3dYIiwib3ZlcmZsb3dZIiwicHJvcEZpbHRlciIsInNwZWNpYWxFYXNpbmciLCJwcm9wZXJ0aWVzIiwic3RvcHBlZCIsInByZWZpbHRlcnMiLCJjdXJyZW50VGltZSIsInN0YXJ0VGltZSIsInR3ZWVucyIsIm9yaWdpbmFsUHJvcGVydGllcyIsIm9yaWdpbmFsT3B0aW9ucyIsImdvdG9FbmQiLCJiaW5kIiwiY29tcGxldGUiLCJ0aW1lciIsInR3ZWVuZXIiLCJwcmVmaWx0ZXIiLCJzcGVlZCIsIm9wdCIsInNwZWVkcyIsImZhZGVUbyIsInRvIiwiYW5pbWF0ZSIsIm9wdGFsbCIsImRvQW5pbWF0aW9uIiwiZmluaXNoIiwic3RvcFF1ZXVlIiwidGltZXJzIiwiY3NzRm4iLCJzbGlkZURvd24iLCJzbGlkZVVwIiwic2xpZGVUb2dnbGUiLCJmYWRlSW4iLCJmYWRlT3V0IiwiZmFkZVRvZ2dsZSIsInNsb3ciLCJmYXN0IiwiZGVsYXkiLCJ0aW1lIiwidGltZW91dCIsImNsZWFyVGltZW91dCIsImNoZWNrT24iLCJvcHRTZWxlY3RlZCIsInJhZGlvVmFsdWUiLCJib29sSG9vayIsInJlbW92ZUF0dHIiLCJuVHlwZSIsImF0dHJIb29rcyIsImF0dHJOYW1lcyIsImdldHRlciIsImxvd2VyY2FzZU5hbWUiLCJyZm9jdXNhYmxlIiwicmNsaWNrYWJsZSIsInJlbW92ZVByb3AiLCJwcm9wRml4IiwidGFiaW5kZXgiLCJzdHJpcEFuZENvbGxhcHNlIiwiZ2V0Q2xhc3MiLCJjbGFzc2VzVG9BcnJheSIsImFkZENsYXNzIiwiY2xhc3NOYW1lcyIsImN1clZhbHVlIiwiZmluYWxWYWx1ZSIsInJlbW92ZUNsYXNzIiwidG9nZ2xlQ2xhc3MiLCJzdGF0ZVZhbCIsImlzVmFsaWRWYWx1ZSIsImhhc0NsYXNzIiwicnJldHVybiIsInZhbEhvb2tzIiwib3B0aW9uU2V0IiwicnF1ZXJ5IiwicGFyc2VYTUwiLCJwYXJzZXJFcnJvckVsZW0iLCJET01QYXJzZXIiLCJwYXJzZUZyb21TdHJpbmciLCJyZm9jdXNNb3JwaCIsInN0b3BQcm9wYWdhdGlvbkNhbGxiYWNrIiwib25seUhhbmRsZXJzIiwiYnViYmxlVHlwZSIsIm9udHlwZSIsImxhc3RFbGVtZW50IiwiZXZlbnRQYXRoIiwicGFyZW50V2luZG93IiwidHJpZ2dlckhhbmRsZXIiLCJyYnJhY2tldCIsInJDUkxGIiwicnN1Ym1pdHRlclR5cGVzIiwicnN1Ym1pdHRhYmxlIiwiYnVpbGRQYXJhbXMiLCJ0cmFkaXRpb25hbCIsInBhcmFtIiwicyIsInZhbHVlT3JGdW5jdGlvbiIsImVuY29kZVVSSUNvbXBvbmVudCIsInNlcmlhbGl6ZSIsInNlcmlhbGl6ZUFycmF5IiwicjIwIiwicmhhc2giLCJyYW50aUNhY2hlIiwicmhlYWRlcnMiLCJybG9jYWxQcm90b2NvbCIsInJub0NvbnRlbnQiLCJycHJvdG9jb2wiLCJ0cmFuc3BvcnRzIiwiYWxsVHlwZXMiLCJvcmlnaW5BbmNob3IiLCJhZGRUb1ByZWZpbHRlcnNPclRyYW5zcG9ydHMiLCJzdHJ1Y3R1cmUiLCJkYXRhVHlwZUV4cHJlc3Npb24iLCJkYXRhVHlwZSIsImRhdGFUeXBlcyIsImluc3BlY3RQcmVmaWx0ZXJzT3JUcmFuc3BvcnRzIiwianFYSFIiLCJpbnNwZWN0ZWQiLCJzZWVraW5nVHJhbnNwb3J0IiwiaW5zcGVjdCIsInByZWZpbHRlck9yRmFjdG9yeSIsImRhdGFUeXBlT3JUcmFuc3BvcnQiLCJhamF4RXh0ZW5kIiwiZmxhdE9wdGlvbnMiLCJhamF4U2V0dGluZ3MiLCJhamF4SGFuZGxlUmVzcG9uc2VzIiwicmVzcG9uc2VzIiwiY3QiLCJmaW5hbERhdGFUeXBlIiwiZmlyc3REYXRhVHlwZSIsIm1pbWVUeXBlIiwiZ2V0UmVzcG9uc2VIZWFkZXIiLCJjb252ZXJ0ZXJzIiwiYWpheENvbnZlcnQiLCJyZXNwb25zZSIsImlzU3VjY2VzcyIsImNvbnYyIiwiY3VycmVudCIsImNvbnYiLCJyZXNwb25zZUZpZWxkcyIsImRhdGFGaWx0ZXIiLCJ0aHJvd3MiLCJhY3RpdmUiLCJsYXN0TW9kaWZpZWQiLCJldGFnIiwidXJsIiwiaXNMb2NhbCIsInByb3RvY29sIiwicHJvY2Vzc0RhdGEiLCJhc3luYyIsImNvbnRlbnRUeXBlIiwiYWNjZXB0cyIsImpzb24iLCJhamF4U2V0dXAiLCJzZXR0aW5ncyIsImFqYXhQcmVmaWx0ZXIiLCJhamF4VHJhbnNwb3J0IiwiYWpheCIsInRyYW5zcG9ydCIsImNhY2hlVVJMIiwicmVzcG9uc2VIZWFkZXJzU3RyaW5nIiwicmVzcG9uc2VIZWFkZXJzIiwidGltZW91dFRpbWVyIiwidXJsQW5jaG9yIiwiZmlyZUdsb2JhbHMiLCJ1bmNhY2hlZCIsImNhbGxiYWNrQ29udGV4dCIsImdsb2JhbEV2ZW50Q29udGV4dCIsImNvbXBsZXRlRGVmZXJyZWQiLCJzdGF0dXNDb2RlIiwicmVxdWVzdEhlYWRlcnMiLCJyZXF1ZXN0SGVhZGVyc05hbWVzIiwic3RyQWJvcnQiLCJnZXRBbGxSZXNwb25zZUhlYWRlcnMiLCJzZXRSZXF1ZXN0SGVhZGVyIiwib3ZlcnJpZGVNaW1lVHlwZSIsInN0YXR1cyIsImFib3J0Iiwic3RhdHVzVGV4dCIsImZpbmFsVGV4dCIsImNyb3NzRG9tYWluIiwiaG9zdCIsImhhc0NvbnRlbnQiLCJpZk1vZGlmaWVkIiwiaGVhZGVycyIsImJlZm9yZVNlbmQiLCJzdWNjZXNzIiwic2VuZCIsIm5hdGl2ZVN0YXR1c1RleHQiLCJtb2RpZmllZCIsImdldEpTT04iLCJnZXRTY3JpcHQiLCJ3cmFwQWxsIiwiZmlyc3RFbGVtZW50Q2hpbGQiLCJ3cmFwSW5uZXIiLCJodG1sSXNGdW5jdGlvbiIsInVud3JhcCIsInZpc2libGUiLCJ4aHIiLCJYTUxIdHRwUmVxdWVzdCIsInhoclN1Y2Nlc3NTdGF0dXMiLCJ4aHJTdXBwb3J0ZWQiLCJjb3JzIiwiZXJyb3JDYWxsYmFjayIsIm9wZW4iLCJ1c2VybmFtZSIsInhockZpZWxkcyIsIm9ubG9hZCIsIm9uZXJyb3IiLCJvbmFib3J0Iiwib250aW1lb3V0Iiwib25yZWFkeXN0YXRlY2hhbmdlIiwicmVzcG9uc2VUeXBlIiwicmVzcG9uc2VUZXh0IiwiYmluYXJ5Iiwic2NyaXB0QXR0cnMiLCJjaGFyc2V0Iiwic2NyaXB0Q2hhcnNldCIsImV2dCIsIm9sZENhbGxiYWNrcyIsInJqc29ucCIsImpzb25wIiwianNvbnBDYWxsYmFjayIsIm9yaWdpbmFsU2V0dGluZ3MiLCJjYWxsYmFja05hbWUiLCJvdmVyd3JpdHRlbiIsInJlc3BvbnNlQ29udGFpbmVyIiwianNvblByb3AiLCJjcmVhdGVIVE1MRG9jdW1lbnQiLCJpbXBsZW1lbnRhdGlvbiIsImtlZXBTY3JpcHRzIiwicGFyc2VkIiwicGFyYW1zIiwiYW5pbWF0ZWQiLCJvZmZzZXQiLCJzZXRPZmZzZXQiLCJjdXJQb3NpdGlvbiIsImN1ckxlZnQiLCJjdXJDU1NUb3AiLCJjdXJUb3AiLCJjdXJPZmZzZXQiLCJjdXJDU1NMZWZ0IiwiY2FsY3VsYXRlUG9zaXRpb24iLCJjdXJFbGVtIiwidXNpbmciLCJyZWN0Iiwid2luIiwicGFnZVlPZmZzZXQiLCJwYWdlWE9mZnNldCIsIm9mZnNldFBhcmVudCIsInBhcmVudE9mZnNldCIsInNjcm9sbFRvIiwiSGVpZ2h0IiwiV2lkdGgiLCJkZWZhdWx0RXh0cmEiLCJmdW5jTmFtZSIsInVuYmluZCIsImRlbGVnYXRlIiwidW5kZWxlZ2F0ZSIsImhvdmVyIiwiZm5PdmVyIiwiZm5PdXQiLCJydHJpbSIsInByb3h5IiwiaG9sZFJlYWR5IiwiaG9sZCIsInBhcnNlSlNPTiIsImlzTnVtZXJpYyIsImlzTmFOIiwidHJpbSIsImRlZmluZSIsImFtZCIsIl9qUXVlcnkiLCJfJCIsIiQiLCJub0NvbmZsaWN0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jquery/dist/jquery.js\n");

/***/ })

};
;