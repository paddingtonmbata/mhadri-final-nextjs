/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/react-responsive";
exports.ids = ["vendor-chunks/react-responsive"];
exports.modules = {

/***/ "(ssr)/./node_modules/react-responsive/dist/react-responsive.js":
/*!****************************************************************!*\
  !*** ./node_modules/react-responsive/dist/react-responsive.js ***!
  \****************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("(function webpackUniversalModuleDefinition(root, factory) {\n    if (true) module.exports = factory(__webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\"));\n    else {}\n})(this, (__WEBPACK_EXTERNAL_MODULE_react__)=>{\n    return /******/ (()=>{\n        /******/ var __webpack_modules__ = {\n            /***/ \"./node_modules/css-mediaquery/index.js\": /*!**********************************************!*\\\n  !*** ./node_modules/css-mediaquery/index.js ***!\n  \\**********************************************/ /***/ (__unused_webpack_module, exports1)=>{\n                \"use strict\";\n                /*\nCopyright (c) 2014, Yahoo! Inc. All rights reserved.\nCopyrights licensed under the New BSD License.\nSee the accompanying LICENSE file for terms.\n*/ exports1.match = matchQuery;\n                exports1.parse = parseQuery;\n                // -----------------------------------------------------------------------------\n                var RE_MEDIA_QUERY = /(?:(only|not)?\\s*([^\\s\\(\\)]+)(?:\\s*and)?\\s*)?(.+)?/i, RE_MQ_EXPRESSION = /\\(\\s*([^\\s\\:\\)]+)\\s*(?:\\:\\s*([^\\s\\)]+))?\\s*\\)/, RE_MQ_FEATURE = /^(?:(min|max)-)?(.+)/, RE_LENGTH_UNIT = /(em|rem|px|cm|mm|in|pt|pc)?$/, RE_RESOLUTION_UNIT = /(dpi|dpcm|dppx)?$/;\n                function matchQuery(mediaQuery, values) {\n                    return parseQuery(mediaQuery).some(function(query) {\n                        var inverse = query.inverse;\n                        // Either the parsed or specified `type` is \"all\", or the types must be\n                        // equal for a match.\n                        var typeMatch = query.type === \"all\" || values.type === query.type;\n                        // Quit early when `type` doesn't match, but take \"not\" into account.\n                        if (typeMatch && inverse || !(typeMatch || inverse)) {\n                            return false;\n                        }\n                        var expressionsMatch = query.expressions.every(function(expression) {\n                            var feature = expression.feature, modifier = expression.modifier, expValue = expression.value, value = values[feature];\n                            // Missing or falsy values don't match.\n                            if (!value) {\n                                return false;\n                            }\n                            switch(feature){\n                                case \"orientation\":\n                                case \"scan\":\n                                    return value.toLowerCase() === expValue.toLowerCase();\n                                case \"width\":\n                                case \"height\":\n                                case \"device-width\":\n                                case \"device-height\":\n                                    expValue = toPx(expValue);\n                                    value = toPx(value);\n                                    break;\n                                case \"resolution\":\n                                    expValue = toDpi(expValue);\n                                    value = toDpi(value);\n                                    break;\n                                case \"aspect-ratio\":\n                                case \"device-aspect-ratio\":\n                                case /* Deprecated */ \"device-pixel-ratio\":\n                                    expValue = toDecimal(expValue);\n                                    value = toDecimal(value);\n                                    break;\n                                case \"grid\":\n                                case \"color\":\n                                case \"color-index\":\n                                case \"monochrome\":\n                                    expValue = parseInt(expValue, 10) || 1;\n                                    value = parseInt(value, 10) || 0;\n                                    break;\n                            }\n                            switch(modifier){\n                                case \"min\":\n                                    return value >= expValue;\n                                case \"max\":\n                                    return value <= expValue;\n                                default:\n                                    return value === expValue;\n                            }\n                        });\n                        return expressionsMatch && !inverse || !expressionsMatch && inverse;\n                    });\n                }\n                function parseQuery(mediaQuery) {\n                    return mediaQuery.split(\",\").map(function(query) {\n                        query = query.trim();\n                        var captures = query.match(RE_MEDIA_QUERY), modifier = captures[1], type = captures[2], expressions = captures[3] || \"\", parsed = {};\n                        parsed.inverse = !!modifier && modifier.toLowerCase() === \"not\";\n                        parsed.type = type ? type.toLowerCase() : \"all\";\n                        // Split expressions into a list.\n                        expressions = expressions.match(/\\([^\\)]+\\)/g) || [];\n                        parsed.expressions = expressions.map(function(expression) {\n                            var captures = expression.match(RE_MQ_EXPRESSION), feature = captures[1].toLowerCase().match(RE_MQ_FEATURE);\n                            return {\n                                modifier: feature[1],\n                                feature: feature[2],\n                                value: captures[2]\n                            };\n                        });\n                        return parsed;\n                    });\n                }\n                // -- Utilities ----------------------------------------------------------------\n                function toDecimal(ratio) {\n                    var decimal = Number(ratio), numbers;\n                    if (!decimal) {\n                        numbers = ratio.match(/^(\\d+)\\s*\\/\\s*(\\d+)$/);\n                        decimal = numbers[1] / numbers[2];\n                    }\n                    return decimal;\n                }\n                function toDpi(resolution) {\n                    var value = parseFloat(resolution), units = String(resolution).match(RE_RESOLUTION_UNIT)[1];\n                    switch(units){\n                        case \"dpcm\":\n                            return value / 2.54;\n                        case \"dppx\":\n                            return value * 96;\n                        default:\n                            return value;\n                    }\n                }\n                function toPx(length) {\n                    var value = parseFloat(length), units = String(length).match(RE_LENGTH_UNIT)[1];\n                    switch(units){\n                        case \"em\":\n                            return value * 16;\n                        case \"rem\":\n                            return value * 16;\n                        case \"cm\":\n                            return value * 96 / 2.54;\n                        case \"mm\":\n                            return value * 96 / 2.54 / 10;\n                        case \"in\":\n                            return value * 96;\n                        case \"pt\":\n                            return value * 72;\n                        case \"pc\":\n                            return value * 72 / 12;\n                        default:\n                            return value;\n                    }\n                }\n            /***/ },\n            /***/ \"./node_modules/hyphenate-style-name/index.js\": /*!****************************************************!*\\\n  !*** ./node_modules/hyphenate-style-name/index.js ***!\n  \\****************************************************/ /***/ (__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_7986__)=>{\n                \"use strict\";\n                __nested_webpack_require_7986__.r(__nested_webpack_exports__);\n                /* harmony export */ __nested_webpack_require_7986__.d(__nested_webpack_exports__, {\n                    /* harmony export */ \"default\": ()=>__WEBPACK_DEFAULT_EXPORT__\n                });\n                /* eslint-disable no-var, prefer-template */ var uppercasePattern = /[A-Z]/g;\n                var msPattern = /^ms-/;\n                var cache = {};\n                function toHyphenLower(match) {\n                    return \"-\" + match.toLowerCase();\n                }\n                function hyphenateStyleName(name) {\n                    if (cache.hasOwnProperty(name)) {\n                        return cache[name];\n                    }\n                    var hName = name.replace(uppercasePattern, toHyphenLower);\n                    return cache[name] = msPattern.test(hName) ? \"-\" + hName : hName;\n                }\n                /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = hyphenateStyleName;\n            /***/ },\n            /***/ \"./node_modules/matchmediaquery/index.js\": /*!***********************************************!*\\\n  !*** ./node_modules/matchmediaquery/index.js ***!\n  \\***********************************************/ /***/ (module1, __unused_webpack_exports, __nested_webpack_require_9308__)=>{\n                \"use strict\";\n                var staticMatch = __nested_webpack_require_9308__(/*! css-mediaquery */ \"./node_modules/css-mediaquery/index.js\").match;\n                var dynamicMatch =  false ? 0 : null;\n                // our fake MediaQueryList\n                function Mql(query, values, forceStatic) {\n                    var self = this;\n                    if (dynamicMatch && !forceStatic) {\n                        var mql = dynamicMatch.call(window, query);\n                        this.matches = mql.matches;\n                        this.media = mql.media;\n                        // TODO: is there a time it makes sense to remove this listener?\n                        mql.addListener(update);\n                    } else {\n                        this.matches = staticMatch(query, values);\n                        this.media = query;\n                    }\n                    this.addListener = addListener;\n                    this.removeListener = removeListener;\n                    this.dispose = dispose;\n                    function addListener(listener) {\n                        if (mql) {\n                            mql.addListener(listener);\n                        }\n                    }\n                    function removeListener(listener) {\n                        if (mql) {\n                            mql.removeListener(listener);\n                        }\n                    }\n                    // update ourselves!\n                    function update(evt) {\n                        self.matches = evt.matches;\n                        self.media = evt.media;\n                    }\n                    function dispose() {\n                        if (mql) {\n                            mql.removeListener(update);\n                        }\n                    }\n                }\n                function matchMedia(query, values, forceStatic) {\n                    return new Mql(query, values, forceStatic);\n                }\n                module1.exports = matchMedia;\n            /***/ },\n            /***/ \"./node_modules/object-assign/index.js\": /*!*********************************************!*\\\n  !*** ./node_modules/object-assign/index.js ***!\n  \\*********************************************/ /***/ (module1)=>{\n                \"use strict\";\n                /*\nobject-assign\n(c) Sindre Sorhus\n@license MIT\n*/ /* eslint-disable no-unused-vars */ var getOwnPropertySymbols = Object.getOwnPropertySymbols;\n                var hasOwnProperty = Object.prototype.hasOwnProperty;\n                var propIsEnumerable = Object.prototype.propertyIsEnumerable;\n                function toObject(val) {\n                    if (val === null || val === undefined) {\n                        throw new TypeError(\"Object.assign cannot be called with null or undefined\");\n                    }\n                    return Object(val);\n                }\n                function shouldUseNative() {\n                    try {\n                        if (!Object.assign) {\n                            return false;\n                        }\n                        // Detect buggy property enumeration order in older V8 versions.\n                        // https://bugs.chromium.org/p/v8/issues/detail?id=4118\n                        var test1 = new String(\"abc\"); // eslint-disable-line no-new-wrappers\n                        test1[5] = \"de\";\n                        if (Object.getOwnPropertyNames(test1)[0] === \"5\") {\n                            return false;\n                        }\n                        // https://bugs.chromium.org/p/v8/issues/detail?id=3056\n                        var test2 = {};\n                        for(var i = 0; i < 10; i++){\n                            test2[\"_\" + String.fromCharCode(i)] = i;\n                        }\n                        var order2 = Object.getOwnPropertyNames(test2).map(function(n) {\n                            return test2[n];\n                        });\n                        if (order2.join(\"\") !== \"0123456789\") {\n                            return false;\n                        }\n                        // https://bugs.chromium.org/p/v8/issues/detail?id=3056\n                        var test3 = {};\n                        \"abcdefghijklmnopqrst\".split(\"\").forEach(function(letter) {\n                            test3[letter] = letter;\n                        });\n                        if (Object.keys(Object.assign({}, test3)).join(\"\") !== \"abcdefghijklmnopqrst\") {\n                            return false;\n                        }\n                        return true;\n                    } catch (err) {\n                        // We don't expect any of the above to throw, but better to be safe.\n                        return false;\n                    }\n                }\n                module1.exports = shouldUseNative() ? Object.assign : function(target, source) {\n                    var from;\n                    var to = toObject(target);\n                    var symbols;\n                    for(var s = 1; s < arguments.length; s++){\n                        from = Object(arguments[s]);\n                        for(var key in from){\n                            if (hasOwnProperty.call(from, key)) {\n                                to[key] = from[key];\n                            }\n                        }\n                        if (getOwnPropertySymbols) {\n                            symbols = getOwnPropertySymbols(from);\n                            for(var i = 0; i < symbols.length; i++){\n                                if (propIsEnumerable.call(from, symbols[i])) {\n                                    to[symbols[i]] = from[symbols[i]];\n                                }\n                            }\n                        }\n                    }\n                    return to;\n                };\n            /***/ },\n            /***/ \"./node_modules/prop-types/checkPropTypes.js\": /*!***************************************************!*\\\n  !*** ./node_modules/prop-types/checkPropTypes.js ***!\n  \\***************************************************/ /***/ (module1, __unused_webpack_exports, __nested_webpack_require_15494__)=>{\n                \"use strict\";\n                /**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */ var printWarning = function() {};\n                if (true) {\n                    var ReactPropTypesSecret = __nested_webpack_require_15494__(/*! ./lib/ReactPropTypesSecret */ \"./node_modules/prop-types/lib/ReactPropTypesSecret.js\");\n                    var loggedTypeFailures = {};\n                    var has = __nested_webpack_require_15494__(/*! ./lib/has */ \"./node_modules/prop-types/lib/has.js\");\n                    printWarning = function(text) {\n                        var message = \"Warning: \" + text;\n                        if (typeof console !== \"undefined\") {\n                            console.error(message);\n                        }\n                        try {\n                            // --- Welcome to debugging React ---\n                            // This error was thrown as a convenience so that you can use this stack\n                            // to find the callsite that caused this warning to fire.\n                            throw new Error(message);\n                        } catch (x) {}\n                    };\n                }\n                /**\n * Assert that the values match with the type specs.\n * Error messages are memorized and will only be shown once.\n *\n * @param {object} typeSpecs Map of name to a ReactPropType\n * @param {object} values Runtime values that need to be type-checked\n * @param {string} location e.g. \"prop\", \"context\", \"child context\"\n * @param {string} componentName Name of the component for error messages.\n * @param {?Function} getStack Returns the component stack.\n * @private\n */ function checkPropTypes(typeSpecs, values, location, componentName, getStack) {\n                    if (true) {\n                        for(var typeSpecName in typeSpecs){\n                            if (has(typeSpecs, typeSpecName)) {\n                                var error;\n                                // Prop type validation may throw. In case they do, we don't want to\n                                // fail the render phase where it didn't fail before. So we log it.\n                                // After these have been cleaned up, we'll let them throw.\n                                try {\n                                    // This is intentionally an invariant that gets caught. It's the same\n                                    // behavior as without this statement except with a better message.\n                                    if (typeof typeSpecs[typeSpecName] !== \"function\") {\n                                        var err = Error((componentName || \"React class\") + \": \" + location + \" type `\" + typeSpecName + \"` is invalid; \" + \"it must be a function, usually from the `prop-types` package, but received `\" + typeof typeSpecs[typeSpecName] + \"`.\" + \"This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.\");\n                                        err.name = \"Invariant Violation\";\n                                        throw err;\n                                    }\n                                    error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);\n                                } catch (ex) {\n                                    error = ex;\n                                }\n                                if (error && !(error instanceof Error)) {\n                                    printWarning((componentName || \"React class\") + \": type specification of \" + location + \" `\" + typeSpecName + \"` is invalid; the type checker \" + \"function must return `null` or an `Error` but returned a \" + typeof error + \". \" + \"You may have forgotten to pass an argument to the type checker \" + \"creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and \" + \"shape all require an argument).\");\n                                }\n                                if (error instanceof Error && !(error.message in loggedTypeFailures)) {\n                                    // Only monitor this failure once because there tends to be a lot of the\n                                    // same error.\n                                    loggedTypeFailures[error.message] = true;\n                                    var stack = getStack ? getStack() : \"\";\n                                    printWarning(\"Failed \" + location + \" type: \" + error.message + (stack != null ? stack : \"\"));\n                                }\n                            }\n                        }\n                    }\n                }\n                /**\n * Resets warning cache when testing.\n *\n * @private\n */ checkPropTypes.resetWarningCache = function() {\n                    if (true) {\n                        loggedTypeFailures = {};\n                    }\n                };\n                module1.exports = checkPropTypes;\n            /***/ },\n            /***/ \"./node_modules/prop-types/factoryWithTypeCheckers.js\": /*!************************************************************!*\\\n  !*** ./node_modules/prop-types/factoryWithTypeCheckers.js ***!\n  \\************************************************************/ /***/ (module1, __unused_webpack_exports, __nested_webpack_require_20851__)=>{\n                \"use strict\";\n                /**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */ var ReactIs = __nested_webpack_require_20851__(/*! react-is */ \"./node_modules/react-is/index.js\");\n                var assign = __nested_webpack_require_20851__(/*! object-assign */ \"./node_modules/object-assign/index.js\");\n                var ReactPropTypesSecret = __nested_webpack_require_20851__(/*! ./lib/ReactPropTypesSecret */ \"./node_modules/prop-types/lib/ReactPropTypesSecret.js\");\n                var has = __nested_webpack_require_20851__(/*! ./lib/has */ \"./node_modules/prop-types/lib/has.js\");\n                var checkPropTypes = __nested_webpack_require_20851__(/*! ./checkPropTypes */ \"./node_modules/prop-types/checkPropTypes.js\");\n                var printWarning = function() {};\n                if (true) {\n                    printWarning = function(text) {\n                        var message = \"Warning: \" + text;\n                        if (typeof console !== \"undefined\") {\n                            console.error(message);\n                        }\n                        try {\n                            // --- Welcome to debugging React ---\n                            // This error was thrown as a convenience so that you can use this stack\n                            // to find the callsite that caused this warning to fire.\n                            throw new Error(message);\n                        } catch (x) {}\n                    };\n                }\n                function emptyFunctionThatReturnsNull() {\n                    return null;\n                }\n                module1.exports = function(isValidElement, throwOnDirectAccess) {\n                    /* global Symbol */ var ITERATOR_SYMBOL = typeof Symbol === \"function\" && Symbol.iterator;\n                    var FAUX_ITERATOR_SYMBOL = \"@@iterator\"; // Before Symbol spec.\n                    /**\n   * Returns the iterator method function contained on the iterable object.\n   *\n   * Be sure to invoke the function with the iterable as context:\n   *\n   *     var iteratorFn = getIteratorFn(myIterable);\n   *     if (iteratorFn) {\n   *       var iterator = iteratorFn.call(myIterable);\n   *       ...\n   *     }\n   *\n   * @param {?object} maybeIterable\n   * @return {?function}\n   */ function getIteratorFn(maybeIterable) {\n                        var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);\n                        if (typeof iteratorFn === \"function\") {\n                            return iteratorFn;\n                        }\n                    }\n                    /**\n   * Collection of methods that allow declaration and validation of props that are\n   * supplied to React components. Example usage:\n   *\n   *   var Props = require('ReactPropTypes');\n   *   var MyArticle = React.createClass({\n   *     propTypes: {\n   *       // An optional string prop named \"description\".\n   *       description: Props.string,\n   *\n   *       // A required enum prop named \"category\".\n   *       category: Props.oneOf(['News','Photos']).isRequired,\n   *\n   *       // A prop named \"dialog\" that requires an instance of Dialog.\n   *       dialog: Props.instanceOf(Dialog).isRequired\n   *     },\n   *     render: function() { ... }\n   *   });\n   *\n   * A more formal specification of how these methods are used:\n   *\n   *   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)\n   *   decl := ReactPropTypes.{type}(.isRequired)?\n   *\n   * Each and every declaration produces a function with the same signature. This\n   * allows the creation of custom validation functions. For example:\n   *\n   *  var MyLink = React.createClass({\n   *    propTypes: {\n   *      // An optional string or URI prop named \"href\".\n   *      href: function(props, propName, componentName) {\n   *        var propValue = props[propName];\n   *        if (propValue != null && typeof propValue !== 'string' &&\n   *            !(propValue instanceof URI)) {\n   *          return new Error(\n   *            'Expected a string or an URI for ' + propName + ' in ' +\n   *            componentName\n   *          );\n   *        }\n   *      }\n   *    },\n   *    render: function() {...}\n   *  });\n   *\n   * @internal\n   */ var ANONYMOUS = \"<<anonymous>>\";\n                    // Important!\n                    // Keep this list in sync with production version in `./factoryWithThrowingShims.js`.\n                    var ReactPropTypes = {\n                        array: createPrimitiveTypeChecker(\"array\"),\n                        bigint: createPrimitiveTypeChecker(\"bigint\"),\n                        bool: createPrimitiveTypeChecker(\"boolean\"),\n                        func: createPrimitiveTypeChecker(\"function\"),\n                        number: createPrimitiveTypeChecker(\"number\"),\n                        object: createPrimitiveTypeChecker(\"object\"),\n                        string: createPrimitiveTypeChecker(\"string\"),\n                        symbol: createPrimitiveTypeChecker(\"symbol\"),\n                        any: createAnyTypeChecker(),\n                        arrayOf: createArrayOfTypeChecker,\n                        element: createElementTypeChecker(),\n                        elementType: createElementTypeTypeChecker(),\n                        instanceOf: createInstanceTypeChecker,\n                        node: createNodeChecker(),\n                        objectOf: createObjectOfTypeChecker,\n                        oneOf: createEnumTypeChecker,\n                        oneOfType: createUnionTypeChecker,\n                        shape: createShapeTypeChecker,\n                        exact: createStrictShapeTypeChecker\n                    };\n                    /**\n   * inlined Object.is polyfill to avoid requiring consumers ship their own\n   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is\n   */ /*eslint-disable no-self-compare*/ function is(x, y) {\n                        // SameValue algorithm\n                        if (x === y) {\n                            // Steps 1-5, 7-10\n                            // Steps 6.b-6.e: +0 != -0\n                            return x !== 0 || 1 / x === 1 / y;\n                        } else {\n                            // Step 6.a: NaN == NaN\n                            return x !== x && y !== y;\n                        }\n                    }\n                    /*eslint-enable no-self-compare*/ /**\n   * We use an Error-like object for backward compatibility as people may call\n   * PropTypes directly and inspect their output. However, we don't use real\n   * Errors anymore. We don't inspect their stack anyway, and creating them\n   * is prohibitively expensive if they are created too often, such as what\n   * happens in oneOfType() for any type before the one that matched.\n   */ function PropTypeError(message, data) {\n                        this.message = message;\n                        this.data = data && typeof data === \"object\" ? data : {};\n                        this.stack = \"\";\n                    }\n                    // Make `instanceof Error` still work for returned errors.\n                    PropTypeError.prototype = Error.prototype;\n                    function createChainableTypeChecker(validate) {\n                        if (true) {\n                            var manualPropTypeCallCache = {};\n                            var manualPropTypeWarningCount = 0;\n                        }\n                        function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {\n                            componentName = componentName || ANONYMOUS;\n                            propFullName = propFullName || propName;\n                            if (secret !== ReactPropTypesSecret) {\n                                if (throwOnDirectAccess) {\n                                    // New behavior only for users of `prop-types` package\n                                    var err = new Error(\"Calling PropTypes validators directly is not supported by the `prop-types` package. \" + \"Use `PropTypes.checkPropTypes()` to call them. \" + \"Read more at http://fb.me/use-check-prop-types\");\n                                    err.name = \"Invariant Violation\";\n                                    throw err;\n                                } else if ( true && typeof console !== \"undefined\") {\n                                    // Old behavior for people using React.PropTypes\n                                    var cacheKey = componentName + \":\" + propName;\n                                    if (!manualPropTypeCallCache[cacheKey] && // Avoid spamming the console because they are often not actionable except for lib authors\n                                    manualPropTypeWarningCount < 3) {\n                                        printWarning(\"You are manually calling a React.PropTypes validation \" + \"function for the `\" + propFullName + \"` prop on `\" + componentName + \"`. This is deprecated \" + \"and will throw in the standalone `prop-types` package. \" + \"You may be seeing this warning due to a third-party PropTypes \" + \"library. See https://fb.me/react-warning-dont-call-proptypes \" + \"for details.\");\n                                        manualPropTypeCallCache[cacheKey] = true;\n                                        manualPropTypeWarningCount++;\n                                    }\n                                }\n                            }\n                            if (props[propName] == null) {\n                                if (isRequired) {\n                                    if (props[propName] === null) {\n                                        return new PropTypeError(\"The \" + location + \" `\" + propFullName + \"` is marked as required \" + (\"in `\" + componentName + \"`, but its value is `null`.\"));\n                                    }\n                                    return new PropTypeError(\"The \" + location + \" `\" + propFullName + \"` is marked as required in \" + (\"`\" + componentName + \"`, but its value is `undefined`.\"));\n                                }\n                                return null;\n                            } else {\n                                return validate(props, propName, componentName, location, propFullName);\n                            }\n                        }\n                        var chainedCheckType = checkType.bind(null, false);\n                        chainedCheckType.isRequired = checkType.bind(null, true);\n                        return chainedCheckType;\n                    }\n                    function createPrimitiveTypeChecker(expectedType) {\n                        function validate(props, propName, componentName, location, propFullName, secret) {\n                            var propValue = props[propName];\n                            var propType = getPropType(propValue);\n                            if (propType !== expectedType) {\n                                // `propValue` being instance of, say, date/regexp, pass the 'object'\n                                // check, but we can offer a more precise error message here rather than\n                                // 'of type `object`'.\n                                var preciseType = getPreciseType(propValue);\n                                return new PropTypeError(\"Invalid \" + location + \" `\" + propFullName + \"` of type \" + (\"`\" + preciseType + \"` supplied to `\" + componentName + \"`, expected \") + (\"`\" + expectedType + \"`.\"), {\n                                    expectedType: expectedType\n                                });\n                            }\n                            return null;\n                        }\n                        return createChainableTypeChecker(validate);\n                    }\n                    function createAnyTypeChecker() {\n                        return createChainableTypeChecker(emptyFunctionThatReturnsNull);\n                    }\n                    function createArrayOfTypeChecker(typeChecker) {\n                        function validate(props, propName, componentName, location, propFullName) {\n                            if (typeof typeChecker !== \"function\") {\n                                return new PropTypeError(\"Property `\" + propFullName + \"` of component `\" + componentName + \"` has invalid PropType notation inside arrayOf.\");\n                            }\n                            var propValue = props[propName];\n                            if (!Array.isArray(propValue)) {\n                                var propType = getPropType(propValue);\n                                return new PropTypeError(\"Invalid \" + location + \" `\" + propFullName + \"` of type \" + (\"`\" + propType + \"` supplied to `\" + componentName + \"`, expected an array.\"));\n                            }\n                            for(var i = 0; i < propValue.length; i++){\n                                var error = typeChecker(propValue, i, componentName, location, propFullName + \"[\" + i + \"]\", ReactPropTypesSecret);\n                                if (error instanceof Error) {\n                                    return error;\n                                }\n                            }\n                            return null;\n                        }\n                        return createChainableTypeChecker(validate);\n                    }\n                    function createElementTypeChecker() {\n                        function validate(props, propName, componentName, location, propFullName) {\n                            var propValue = props[propName];\n                            if (!isValidElement(propValue)) {\n                                var propType = getPropType(propValue);\n                                return new PropTypeError(\"Invalid \" + location + \" `\" + propFullName + \"` of type \" + (\"`\" + propType + \"` supplied to `\" + componentName + \"`, expected a single ReactElement.\"));\n                            }\n                            return null;\n                        }\n                        return createChainableTypeChecker(validate);\n                    }\n                    function createElementTypeTypeChecker() {\n                        function validate(props, propName, componentName, location, propFullName) {\n                            var propValue = props[propName];\n                            if (!ReactIs.isValidElementType(propValue)) {\n                                var propType = getPropType(propValue);\n                                return new PropTypeError(\"Invalid \" + location + \" `\" + propFullName + \"` of type \" + (\"`\" + propType + \"` supplied to `\" + componentName + \"`, expected a single ReactElement type.\"));\n                            }\n                            return null;\n                        }\n                        return createChainableTypeChecker(validate);\n                    }\n                    function createInstanceTypeChecker(expectedClass) {\n                        function validate(props, propName, componentName, location, propFullName) {\n                            if (!(props[propName] instanceof expectedClass)) {\n                                var expectedClassName = expectedClass.name || ANONYMOUS;\n                                var actualClassName = getClassName(props[propName]);\n                                return new PropTypeError(\"Invalid \" + location + \" `\" + propFullName + \"` of type \" + (\"`\" + actualClassName + \"` supplied to `\" + componentName + \"`, expected \") + (\"instance of `\" + expectedClassName + \"`.\"));\n                            }\n                            return null;\n                        }\n                        return createChainableTypeChecker(validate);\n                    }\n                    function createEnumTypeChecker(expectedValues) {\n                        if (!Array.isArray(expectedValues)) {\n                            if (true) {\n                                if (arguments.length > 1) {\n                                    printWarning(\"Invalid arguments supplied to oneOf, expected an array, got \" + arguments.length + \" arguments. \" + \"A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z]).\");\n                                } else {\n                                    printWarning(\"Invalid argument supplied to oneOf, expected an array.\");\n                                }\n                            }\n                            return emptyFunctionThatReturnsNull;\n                        }\n                        function validate(props, propName, componentName, location, propFullName) {\n                            var propValue = props[propName];\n                            for(var i = 0; i < expectedValues.length; i++){\n                                if (is(propValue, expectedValues[i])) {\n                                    return null;\n                                }\n                            }\n                            var valuesString = JSON.stringify(expectedValues, function replacer(key, value) {\n                                var type = getPreciseType(value);\n                                if (type === \"symbol\") {\n                                    return String(value);\n                                }\n                                return value;\n                            });\n                            return new PropTypeError(\"Invalid \" + location + \" `\" + propFullName + \"` of value `\" + String(propValue) + \"` \" + (\"supplied to `\" + componentName + \"`, expected one of \" + valuesString + \".\"));\n                        }\n                        return createChainableTypeChecker(validate);\n                    }\n                    function createObjectOfTypeChecker(typeChecker) {\n                        function validate(props, propName, componentName, location, propFullName) {\n                            if (typeof typeChecker !== \"function\") {\n                                return new PropTypeError(\"Property `\" + propFullName + \"` of component `\" + componentName + \"` has invalid PropType notation inside objectOf.\");\n                            }\n                            var propValue = props[propName];\n                            var propType = getPropType(propValue);\n                            if (propType !== \"object\") {\n                                return new PropTypeError(\"Invalid \" + location + \" `\" + propFullName + \"` of type \" + (\"`\" + propType + \"` supplied to `\" + componentName + \"`, expected an object.\"));\n                            }\n                            for(var key in propValue){\n                                if (has(propValue, key)) {\n                                    var error = typeChecker(propValue, key, componentName, location, propFullName + \".\" + key, ReactPropTypesSecret);\n                                    if (error instanceof Error) {\n                                        return error;\n                                    }\n                                }\n                            }\n                            return null;\n                        }\n                        return createChainableTypeChecker(validate);\n                    }\n                    function createUnionTypeChecker(arrayOfTypeCheckers) {\n                        if (!Array.isArray(arrayOfTypeCheckers)) {\n                             true ? printWarning(\"Invalid argument supplied to oneOfType, expected an instance of array.\") : 0;\n                            return emptyFunctionThatReturnsNull;\n                        }\n                        for(var i = 0; i < arrayOfTypeCheckers.length; i++){\n                            var checker = arrayOfTypeCheckers[i];\n                            if (typeof checker !== \"function\") {\n                                printWarning(\"Invalid argument supplied to oneOfType. Expected an array of check functions, but \" + \"received \" + getPostfixForTypeWarning(checker) + \" at index \" + i + \".\");\n                                return emptyFunctionThatReturnsNull;\n                            }\n                        }\n                        function validate(props, propName, componentName, location, propFullName) {\n                            var expectedTypes = [];\n                            for(var i = 0; i < arrayOfTypeCheckers.length; i++){\n                                var checker = arrayOfTypeCheckers[i];\n                                var checkerResult = checker(props, propName, componentName, location, propFullName, ReactPropTypesSecret);\n                                if (checkerResult == null) {\n                                    return null;\n                                }\n                                if (checkerResult.data && has(checkerResult.data, \"expectedType\")) {\n                                    expectedTypes.push(checkerResult.data.expectedType);\n                                }\n                            }\n                            var expectedTypesMessage = expectedTypes.length > 0 ? \", expected one of type [\" + expectedTypes.join(\", \") + \"]\" : \"\";\n                            return new PropTypeError(\"Invalid \" + location + \" `\" + propFullName + \"` supplied to \" + (\"`\" + componentName + \"`\" + expectedTypesMessage + \".\"));\n                        }\n                        return createChainableTypeChecker(validate);\n                    }\n                    function createNodeChecker() {\n                        function validate(props, propName, componentName, location, propFullName) {\n                            if (!isNode(props[propName])) {\n                                return new PropTypeError(\"Invalid \" + location + \" `\" + propFullName + \"` supplied to \" + (\"`\" + componentName + \"`, expected a ReactNode.\"));\n                            }\n                            return null;\n                        }\n                        return createChainableTypeChecker(validate);\n                    }\n                    function invalidValidatorError(componentName, location, propFullName, key, type) {\n                        return new PropTypeError((componentName || \"React class\") + \": \" + location + \" type `\" + propFullName + \".\" + key + \"` is invalid; \" + \"it must be a function, usually from the `prop-types` package, but received `\" + type + \"`.\");\n                    }\n                    function createShapeTypeChecker(shapeTypes) {\n                        function validate(props, propName, componentName, location, propFullName) {\n                            var propValue = props[propName];\n                            var propType = getPropType(propValue);\n                            if (propType !== \"object\") {\n                                return new PropTypeError(\"Invalid \" + location + \" `\" + propFullName + \"` of type `\" + propType + \"` \" + (\"supplied to `\" + componentName + \"`, expected `object`.\"));\n                            }\n                            for(var key in shapeTypes){\n                                var checker = shapeTypes[key];\n                                if (typeof checker !== \"function\") {\n                                    return invalidValidatorError(componentName, location, propFullName, key, getPreciseType(checker));\n                                }\n                                var error = checker(propValue, key, componentName, location, propFullName + \".\" + key, ReactPropTypesSecret);\n                                if (error) {\n                                    return error;\n                                }\n                            }\n                            return null;\n                        }\n                        return createChainableTypeChecker(validate);\n                    }\n                    function createStrictShapeTypeChecker(shapeTypes) {\n                        function validate(props, propName, componentName, location, propFullName) {\n                            var propValue = props[propName];\n                            var propType = getPropType(propValue);\n                            if (propType !== \"object\") {\n                                return new PropTypeError(\"Invalid \" + location + \" `\" + propFullName + \"` of type `\" + propType + \"` \" + (\"supplied to `\" + componentName + \"`, expected `object`.\"));\n                            }\n                            // We need to check all keys in case some are required but missing from props.\n                            var allKeys = assign({}, props[propName], shapeTypes);\n                            for(var key in allKeys){\n                                var checker = shapeTypes[key];\n                                if (has(shapeTypes, key) && typeof checker !== \"function\") {\n                                    return invalidValidatorError(componentName, location, propFullName, key, getPreciseType(checker));\n                                }\n                                if (!checker) {\n                                    return new PropTypeError(\"Invalid \" + location + \" `\" + propFullName + \"` key `\" + key + \"` supplied to `\" + componentName + \"`.\" + \"\\nBad object: \" + JSON.stringify(props[propName], null, \"  \") + \"\\nValid keys: \" + JSON.stringify(Object.keys(shapeTypes), null, \"  \"));\n                                }\n                                var error = checker(propValue, key, componentName, location, propFullName + \".\" + key, ReactPropTypesSecret);\n                                if (error) {\n                                    return error;\n                                }\n                            }\n                            return null;\n                        }\n                        return createChainableTypeChecker(validate);\n                    }\n                    function isNode(propValue) {\n                        switch(typeof propValue){\n                            case \"number\":\n                            case \"string\":\n                            case \"undefined\":\n                                return true;\n                            case \"boolean\":\n                                return !propValue;\n                            case \"object\":\n                                if (Array.isArray(propValue)) {\n                                    return propValue.every(isNode);\n                                }\n                                if (propValue === null || isValidElement(propValue)) {\n                                    return true;\n                                }\n                                var iteratorFn = getIteratorFn(propValue);\n                                if (iteratorFn) {\n                                    var iterator = iteratorFn.call(propValue);\n                                    var step;\n                                    if (iteratorFn !== propValue.entries) {\n                                        while(!(step = iterator.next()).done){\n                                            if (!isNode(step.value)) {\n                                                return false;\n                                            }\n                                        }\n                                    } else {\n                                        // Iterator will provide entry [k,v] tuples rather than values.\n                                        while(!(step = iterator.next()).done){\n                                            var entry = step.value;\n                                            if (entry) {\n                                                if (!isNode(entry[1])) {\n                                                    return false;\n                                                }\n                                            }\n                                        }\n                                    }\n                                } else {\n                                    return false;\n                                }\n                                return true;\n                            default:\n                                return false;\n                        }\n                    }\n                    function isSymbol(propType, propValue) {\n                        // Native Symbol.\n                        if (propType === \"symbol\") {\n                            return true;\n                        }\n                        // falsy value can't be a Symbol\n                        if (!propValue) {\n                            return false;\n                        }\n                        // 19.4.3.5 Symbol.prototype[@@toStringTag] === 'Symbol'\n                        if (propValue[\"@@toStringTag\"] === \"Symbol\") {\n                            return true;\n                        }\n                        // Fallback for non-spec compliant Symbols which are polyfilled.\n                        if (typeof Symbol === \"function\" && propValue instanceof Symbol) {\n                            return true;\n                        }\n                        return false;\n                    }\n                    // Equivalent of `typeof` but with special handling for array and regexp.\n                    function getPropType(propValue) {\n                        var propType = typeof propValue;\n                        if (Array.isArray(propValue)) {\n                            return \"array\";\n                        }\n                        if (propValue instanceof RegExp) {\n                            // Old webkits (at least until Android 4.0) return 'function' rather than\n                            // 'object' for typeof a RegExp. We'll normalize this here so that /bla/\n                            // passes PropTypes.object.\n                            return \"object\";\n                        }\n                        if (isSymbol(propType, propValue)) {\n                            return \"symbol\";\n                        }\n                        return propType;\n                    }\n                    // This handles more types than `getPropType`. Only used for error messages.\n                    // See `createPrimitiveTypeChecker`.\n                    function getPreciseType(propValue) {\n                        if (typeof propValue === \"undefined\" || propValue === null) {\n                            return \"\" + propValue;\n                        }\n                        var propType = getPropType(propValue);\n                        if (propType === \"object\") {\n                            if (propValue instanceof Date) {\n                                return \"date\";\n                            } else if (propValue instanceof RegExp) {\n                                return \"regexp\";\n                            }\n                        }\n                        return propType;\n                    }\n                    // Returns a string that is postfixed to a warning about an invalid type.\n                    // For example, \"undefined\" or \"of type array\"\n                    function getPostfixForTypeWarning(value) {\n                        var type = getPreciseType(value);\n                        switch(type){\n                            case \"array\":\n                            case \"object\":\n                                return \"an \" + type;\n                            case \"boolean\":\n                            case \"date\":\n                            case \"regexp\":\n                                return \"a \" + type;\n                            default:\n                                return type;\n                        }\n                    }\n                    // Returns class name of the object, if any.\n                    function getClassName(propValue) {\n                        if (!propValue.constructor || !propValue.constructor.name) {\n                            return ANONYMOUS;\n                        }\n                        return propValue.constructor.name;\n                    }\n                    ReactPropTypes.checkPropTypes = checkPropTypes;\n                    ReactPropTypes.resetWarningCache = checkPropTypes.resetWarningCache;\n                    ReactPropTypes.PropTypes = ReactPropTypes;\n                    return ReactPropTypes;\n                };\n            /***/ },\n            /***/ \"./node_modules/prop-types/index.js\": /*!******************************************!*\\\n  !*** ./node_modules/prop-types/index.js ***!\n  \\******************************************/ /***/ (module1, __unused_webpack_exports, __nested_webpack_require_53393__)=>{\n                /**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */ if (true) {\n                    var ReactIs = __nested_webpack_require_53393__(/*! react-is */ \"./node_modules/react-is/index.js\");\n                    // By explicitly using `prop-types` you are opting into new development behavior.\n                    // http://fb.me/prop-types-in-prod\n                    var throwOnDirectAccess = true;\n                    module1.exports = __nested_webpack_require_53393__(/*! ./factoryWithTypeCheckers */ \"./node_modules/prop-types/factoryWithTypeCheckers.js\")(ReactIs.isElement, throwOnDirectAccess);\n                } else {}\n            /***/ },\n            /***/ \"./node_modules/prop-types/lib/ReactPropTypesSecret.js\": /*!*************************************************************!*\\\n  !*** ./node_modules/prop-types/lib/ReactPropTypesSecret.js ***!\n  \\*************************************************************/ /***/ (module1)=>{\n                \"use strict\";\n                /**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */ var ReactPropTypesSecret = \"SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED\";\n                module1.exports = ReactPropTypesSecret;\n            /***/ },\n            /***/ \"./node_modules/prop-types/lib/has.js\": /*!********************************************!*\\\n  !*** ./node_modules/prop-types/lib/has.js ***!\n  \\********************************************/ /***/ (module1)=>{\n                module1.exports = Function.call.bind(Object.prototype.hasOwnProperty);\n            /***/ },\n            /***/ \"./node_modules/react-is/cjs/react-is.development.js\": /*!***********************************************************!*\\\n  !*** ./node_modules/react-is/cjs/react-is.development.js ***!\n  \\***********************************************************/ /***/ (__unused_webpack_module, exports1)=>{\n                \"use strict\";\n                /** @license React v16.13.1\n * react-is.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */ if (true) {\n                    (function() {\n                        \"use strict\";\n                        // The Symbol used to tag the ReactElement-like types. If there is no native Symbol\n                        // nor polyfill, then a plain number is used for performance.\n                        var hasSymbol = typeof Symbol === \"function\" && Symbol.for;\n                        var REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for(\"react.element\") : 0xeac7;\n                        var REACT_PORTAL_TYPE = hasSymbol ? Symbol.for(\"react.portal\") : 0xeaca;\n                        var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for(\"react.fragment\") : 0xeacb;\n                        var REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for(\"react.strict_mode\") : 0xeacc;\n                        var REACT_PROFILER_TYPE = hasSymbol ? Symbol.for(\"react.profiler\") : 0xead2;\n                        var REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for(\"react.provider\") : 0xeacd;\n                        var REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for(\"react.context\") : 0xeace; // TODO: We don't use AsyncMode or ConcurrentMode anymore. They were temporary\n                        // (unstable) APIs that have been removed. Can we remove the symbols?\n                        var REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for(\"react.async_mode\") : 0xeacf;\n                        var REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for(\"react.concurrent_mode\") : 0xeacf;\n                        var REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for(\"react.forward_ref\") : 0xead0;\n                        var REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for(\"react.suspense\") : 0xead1;\n                        var REACT_SUSPENSE_LIST_TYPE = hasSymbol ? Symbol.for(\"react.suspense_list\") : 0xead8;\n                        var REACT_MEMO_TYPE = hasSymbol ? Symbol.for(\"react.memo\") : 0xead3;\n                        var REACT_LAZY_TYPE = hasSymbol ? Symbol.for(\"react.lazy\") : 0xead4;\n                        var REACT_BLOCK_TYPE = hasSymbol ? Symbol.for(\"react.block\") : 0xead9;\n                        var REACT_FUNDAMENTAL_TYPE = hasSymbol ? Symbol.for(\"react.fundamental\") : 0xead5;\n                        var REACT_RESPONDER_TYPE = hasSymbol ? Symbol.for(\"react.responder\") : 0xead6;\n                        var REACT_SCOPE_TYPE = hasSymbol ? Symbol.for(\"react.scope\") : 0xead7;\n                        function isValidElementType(type) {\n                            return typeof type === \"string\" || typeof type === \"function\" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.\n                            type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || typeof type === \"object\" && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_RESPONDER_TYPE || type.$$typeof === REACT_SCOPE_TYPE || type.$$typeof === REACT_BLOCK_TYPE);\n                        }\n                        function typeOf(object) {\n                            if (typeof object === \"object\" && object !== null) {\n                                var $$typeof = object.$$typeof;\n                                switch($$typeof){\n                                    case REACT_ELEMENT_TYPE:\n                                        var type = object.type;\n                                        switch(type){\n                                            case REACT_ASYNC_MODE_TYPE:\n                                            case REACT_CONCURRENT_MODE_TYPE:\n                                            case REACT_FRAGMENT_TYPE:\n                                            case REACT_PROFILER_TYPE:\n                                            case REACT_STRICT_MODE_TYPE:\n                                            case REACT_SUSPENSE_TYPE:\n                                                return type;\n                                            default:\n                                                var $$typeofType = type && type.$$typeof;\n                                                switch($$typeofType){\n                                                    case REACT_CONTEXT_TYPE:\n                                                    case REACT_FORWARD_REF_TYPE:\n                                                    case REACT_LAZY_TYPE:\n                                                    case REACT_MEMO_TYPE:\n                                                    case REACT_PROVIDER_TYPE:\n                                                        return $$typeofType;\n                                                    default:\n                                                        return $$typeof;\n                                                }\n                                        }\n                                    case REACT_PORTAL_TYPE:\n                                        return $$typeof;\n                                }\n                            }\n                            return undefined;\n                        } // AsyncMode is deprecated along with isAsyncMode\n                        var AsyncMode = REACT_ASYNC_MODE_TYPE;\n                        var ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;\n                        var ContextConsumer = REACT_CONTEXT_TYPE;\n                        var ContextProvider = REACT_PROVIDER_TYPE;\n                        var Element = REACT_ELEMENT_TYPE;\n                        var ForwardRef = REACT_FORWARD_REF_TYPE;\n                        var Fragment = REACT_FRAGMENT_TYPE;\n                        var Lazy = REACT_LAZY_TYPE;\n                        var Memo = REACT_MEMO_TYPE;\n                        var Portal = REACT_PORTAL_TYPE;\n                        var Profiler = REACT_PROFILER_TYPE;\n                        var StrictMode = REACT_STRICT_MODE_TYPE;\n                        var Suspense = REACT_SUSPENSE_TYPE;\n                        var hasWarnedAboutDeprecatedIsAsyncMode = false; // AsyncMode should be deprecated\n                        function isAsyncMode(object) {\n                            {\n                                if (!hasWarnedAboutDeprecatedIsAsyncMode) {\n                                    hasWarnedAboutDeprecatedIsAsyncMode = true; // Using console['warn'] to evade Babel and ESLint\n                                    console[\"warn\"](\"The ReactIs.isAsyncMode() alias has been deprecated, \" + \"and will be removed in React 17+. Update your code to use \" + \"ReactIs.isConcurrentMode() instead. It has the exact same API.\");\n                                }\n                            }\n                            return isConcurrentMode(object) || typeOf(object) === REACT_ASYNC_MODE_TYPE;\n                        }\n                        function isConcurrentMode(object) {\n                            return typeOf(object) === REACT_CONCURRENT_MODE_TYPE;\n                        }\n                        function isContextConsumer(object) {\n                            return typeOf(object) === REACT_CONTEXT_TYPE;\n                        }\n                        function isContextProvider(object) {\n                            return typeOf(object) === REACT_PROVIDER_TYPE;\n                        }\n                        function isElement(object) {\n                            return typeof object === \"object\" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;\n                        }\n                        function isForwardRef(object) {\n                            return typeOf(object) === REACT_FORWARD_REF_TYPE;\n                        }\n                        function isFragment(object) {\n                            return typeOf(object) === REACT_FRAGMENT_TYPE;\n                        }\n                        function isLazy(object) {\n                            return typeOf(object) === REACT_LAZY_TYPE;\n                        }\n                        function isMemo(object) {\n                            return typeOf(object) === REACT_MEMO_TYPE;\n                        }\n                        function isPortal(object) {\n                            return typeOf(object) === REACT_PORTAL_TYPE;\n                        }\n                        function isProfiler(object) {\n                            return typeOf(object) === REACT_PROFILER_TYPE;\n                        }\n                        function isStrictMode(object) {\n                            return typeOf(object) === REACT_STRICT_MODE_TYPE;\n                        }\n                        function isSuspense(object) {\n                            return typeOf(object) === REACT_SUSPENSE_TYPE;\n                        }\n                        exports1.AsyncMode = AsyncMode;\n                        exports1.ConcurrentMode = ConcurrentMode;\n                        exports1.ContextConsumer = ContextConsumer;\n                        exports1.ContextProvider = ContextProvider;\n                        exports1.Element = Element;\n                        exports1.ForwardRef = ForwardRef;\n                        exports1.Fragment = Fragment;\n                        exports1.Lazy = Lazy;\n                        exports1.Memo = Memo;\n                        exports1.Portal = Portal;\n                        exports1.Profiler = Profiler;\n                        exports1.StrictMode = StrictMode;\n                        exports1.Suspense = Suspense;\n                        exports1.isAsyncMode = isAsyncMode;\n                        exports1.isConcurrentMode = isConcurrentMode;\n                        exports1.isContextConsumer = isContextConsumer;\n                        exports1.isContextProvider = isContextProvider;\n                        exports1.isElement = isElement;\n                        exports1.isForwardRef = isForwardRef;\n                        exports1.isFragment = isFragment;\n                        exports1.isLazy = isLazy;\n                        exports1.isMemo = isMemo;\n                        exports1.isPortal = isPortal;\n                        exports1.isProfiler = isProfiler;\n                        exports1.isStrictMode = isStrictMode;\n                        exports1.isSuspense = isSuspense;\n                        exports1.isValidElementType = isValidElementType;\n                        exports1.typeOf = typeOf;\n                    })();\n                }\n            /***/ },\n            /***/ \"./node_modules/react-is/index.js\": /*!****************************************!*\\\n  !*** ./node_modules/react-is/index.js ***!\n  \\****************************************/ /***/ (module1, __unused_webpack_exports, __nested_webpack_require_66664__)=>{\n                \"use strict\";\n                if (false) {} else {\n                    module1.exports = __nested_webpack_require_66664__(/*! ./cjs/react-is.development.js */ \"./node_modules/react-is/cjs/react-is.development.js\");\n                }\n            /***/ },\n            /***/ \"./node_modules/shallow-equal/dist/index.esm.js\": /*!******************************************************!*\\\n  !*** ./node_modules/shallow-equal/dist/index.esm.js ***!\n  \\******************************************************/ /***/ (__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_67245__)=>{\n                \"use strict\";\n                __nested_webpack_require_67245__.r(__nested_webpack_exports__);\n                /* harmony export */ __nested_webpack_require_67245__.d(__nested_webpack_exports__, {\n                    /* harmony export */ \"shallowEqualArrays\": ()=>/* binding */ shallowEqualArrays,\n                    /* harmony export */ \"shallowEqualObjects\": ()=>/* binding */ shallowEqualObjects\n                });\n                function shallowEqualObjects(objA, objB) {\n                    if (objA === objB) {\n                        return true;\n                    }\n                    if (!objA || !objB) {\n                        return false;\n                    }\n                    var aKeys = Object.keys(objA);\n                    var bKeys = Object.keys(objB);\n                    var len = aKeys.length;\n                    if (bKeys.length !== len) {\n                        return false;\n                    }\n                    for(var i = 0; i < len; i++){\n                        var key = aKeys[i];\n                        if (objA[key] !== objB[key] || !Object.prototype.hasOwnProperty.call(objB, key)) {\n                            return false;\n                        }\n                    }\n                    return true;\n                }\n                function shallowEqualArrays(arrA, arrB) {\n                    if (arrA === arrB) {\n                        return true;\n                    }\n                    if (!arrA || !arrB) {\n                        return false;\n                    }\n                    var len = arrA.length;\n                    if (arrB.length !== len) {\n                        return false;\n                    }\n                    for(var i = 0; i < len; i++){\n                        if (arrA[i] !== arrB[i]) {\n                            return false;\n                        }\n                    }\n                    return true;\n                }\n            /***/ },\n            /***/ \"./src/Component.ts\": /*!**************************!*\\\n  !*** ./src/Component.ts ***!\n  \\**************************/ /***/ function(__unused_webpack_module, exports1, __nested_webpack_require_69379__) {\n                \"use strict\";\n                var __rest = this && this.__rest || function(s, e) {\n                    var t = {};\n                    for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n                    if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for(var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++){\n                        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n                    }\n                    return t;\n                };\n                var __importDefault = this && this.__importDefault || function(mod) {\n                    return mod && mod.__esModule ? mod : {\n                        \"default\": mod\n                    };\n                };\n                Object.defineProperty(exports1, \"__esModule\", {\n                    value: true\n                });\n                var useMediaQuery_1 = __importDefault(__nested_webpack_require_69379__(/*! ./useMediaQuery */ \"./src/useMediaQuery.ts\"));\n                // ReactNode and ReactElement typings are a little funky for functional components, so the ReactElement cast is needed on the return\n                var MediaQuery = function(_a) {\n                    var children = _a.children, device = _a.device, onChange = _a.onChange, settings = __rest(_a, [\n                        \"children\",\n                        \"device\",\n                        \"onChange\"\n                    ]);\n                    var matches = (0, useMediaQuery_1.default)(settings, device, onChange);\n                    if (typeof children === \"function\") {\n                        return children(matches);\n                    }\n                    return matches ? children : null;\n                };\n                exports1[\"default\"] = MediaQuery;\n            /***/ },\n            /***/ \"./src/Context.ts\": /*!************************!*\\\n  !*** ./src/Context.ts ***!\n  \\************************/ /***/ (__unused_webpack_module, exports1, __nested_webpack_require_71448__)=>{\n                \"use strict\";\n                Object.defineProperty(exports1, \"__esModule\", {\n                    value: true\n                });\n                var react_1 = __nested_webpack_require_71448__(/*! react */ \"react\");\n                var Context = (0, react_1.createContext)(undefined);\n                exports1[\"default\"] = Context;\n            /***/ },\n            /***/ \"./src/index.ts\": /*!**********************!*\\\n  !*** ./src/index.ts ***!\n  \\**********************/ /***/ function(__unused_webpack_module, exports1, __nested_webpack_require_71997__) {\n                \"use strict\";\n                var __importDefault = this && this.__importDefault || function(mod) {\n                    return mod && mod.__esModule ? mod : {\n                        \"default\": mod\n                    };\n                };\n                Object.defineProperty(exports1, \"__esModule\", {\n                    value: true\n                });\n                exports1.Context = exports1.toQuery = exports1.useMediaQuery = exports1[\"default\"] = void 0;\n                var useMediaQuery_1 = __importDefault(__nested_webpack_require_71997__(/*! ./useMediaQuery */ \"./src/useMediaQuery.ts\"));\n                exports1.useMediaQuery = useMediaQuery_1.default;\n                var Component_1 = __importDefault(__nested_webpack_require_71997__(/*! ./Component */ \"./src/Component.ts\"));\n                exports1[\"default\"] = Component_1.default;\n                var toQuery_1 = __importDefault(__nested_webpack_require_71997__(/*! ./toQuery */ \"./src/toQuery.ts\"));\n                exports1.toQuery = toQuery_1.default;\n                var Context_1 = __importDefault(__nested_webpack_require_71997__(/*! ./Context */ \"./src/Context.ts\"));\n                exports1.Context = Context_1.default;\n            /***/ },\n            /***/ \"./src/mediaQuery.ts\": /*!***************************!*\\\n  !*** ./src/mediaQuery.ts ***!\n  \\***************************/ /***/ function(__unused_webpack_module, exports1, __nested_webpack_require_73396__) {\n                \"use strict\";\n                var __assign = this && this.__assign || function() {\n                    __assign = Object.assign || function(t) {\n                        for(var s, i = 1, n = arguments.length; i < n; i++){\n                            s = arguments[i];\n                            for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n                        }\n                        return t;\n                    };\n                    return __assign.apply(this, arguments);\n                };\n                var __rest = this && this.__rest || function(s, e) {\n                    var t = {};\n                    for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n                    if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for(var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++){\n                        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n                    }\n                    return t;\n                };\n                var __importDefault = this && this.__importDefault || function(mod) {\n                    return mod && mod.__esModule ? mod : {\n                        \"default\": mod\n                    };\n                };\n                Object.defineProperty(exports1, \"__esModule\", {\n                    value: true\n                });\n                var prop_types_1 = __importDefault(__nested_webpack_require_73396__(/*! prop-types */ \"./node_modules/prop-types/index.js\"));\n                var stringOrNumber = prop_types_1.default.oneOfType([\n                    prop_types_1.default.string,\n                    prop_types_1.default.number\n                ]);\n                // media types\n                var types = {\n                    all: prop_types_1.default.bool,\n                    grid: prop_types_1.default.bool,\n                    aural: prop_types_1.default.bool,\n                    braille: prop_types_1.default.bool,\n                    handheld: prop_types_1.default.bool,\n                    print: prop_types_1.default.bool,\n                    projection: prop_types_1.default.bool,\n                    screen: prop_types_1.default.bool,\n                    tty: prop_types_1.default.bool,\n                    tv: prop_types_1.default.bool,\n                    embossed: prop_types_1.default.bool\n                };\n                // properties that match media queries\n                var matchers = {\n                    orientation: prop_types_1.default.oneOf([\n                        \"portrait\",\n                        \"landscape\"\n                    ]),\n                    scan: prop_types_1.default.oneOf([\n                        \"progressive\",\n                        \"interlace\"\n                    ]),\n                    aspectRatio: prop_types_1.default.string,\n                    deviceAspectRatio: prop_types_1.default.string,\n                    height: stringOrNumber,\n                    deviceHeight: stringOrNumber,\n                    width: stringOrNumber,\n                    deviceWidth: stringOrNumber,\n                    color: prop_types_1.default.bool,\n                    colorIndex: prop_types_1.default.bool,\n                    monochrome: prop_types_1.default.bool,\n                    resolution: stringOrNumber,\n                    type: Object.keys(types)\n                };\n                // eslint-disable-next-line @typescript-eslint/no-unused-vars\n                var type = matchers.type, featureMatchers = __rest(matchers, [\n                    \"type\"\n                ]);\n                // media features\n                var features = __assign({\n                    minAspectRatio: prop_types_1.default.string,\n                    maxAspectRatio: prop_types_1.default.string,\n                    minDeviceAspectRatio: prop_types_1.default.string,\n                    maxDeviceAspectRatio: prop_types_1.default.string,\n                    minHeight: stringOrNumber,\n                    maxHeight: stringOrNumber,\n                    minDeviceHeight: stringOrNumber,\n                    maxDeviceHeight: stringOrNumber,\n                    minWidth: stringOrNumber,\n                    maxWidth: stringOrNumber,\n                    minDeviceWidth: stringOrNumber,\n                    maxDeviceWidth: stringOrNumber,\n                    minColor: prop_types_1.default.number,\n                    maxColor: prop_types_1.default.number,\n                    minColorIndex: prop_types_1.default.number,\n                    maxColorIndex: prop_types_1.default.number,\n                    minMonochrome: prop_types_1.default.number,\n                    maxMonochrome: prop_types_1.default.number,\n                    minResolution: stringOrNumber,\n                    maxResolution: stringOrNumber\n                }, featureMatchers);\n                var all = __assign(__assign({}, types), features);\n                exports1[\"default\"] = {\n                    all: all,\n                    types: types,\n                    matchers: matchers,\n                    features: features\n                };\n            /***/ },\n            /***/ \"./src/toQuery.ts\": /*!************************!*\\\n  !*** ./src/toQuery.ts ***!\n  \\************************/ /***/ function(__unused_webpack_module, exports1, __nested_webpack_require_78805__) {\n                \"use strict\";\n                var __importDefault = this && this.__importDefault || function(mod) {\n                    return mod && mod.__esModule ? mod : {\n                        \"default\": mod\n                    };\n                };\n                Object.defineProperty(exports1, \"__esModule\", {\n                    value: true\n                });\n                var hyphenate_style_name_1 = __importDefault(__nested_webpack_require_78805__(/*! hyphenate-style-name */ \"./node_modules/hyphenate-style-name/index.js\"));\n                var mediaQuery_1 = __importDefault(__nested_webpack_require_78805__(/*! ./mediaQuery */ \"./src/mediaQuery.ts\"));\n                var negate = function(cond) {\n                    return \"not \".concat(cond);\n                };\n                var keyVal = function(k, v) {\n                    var realKey = (0, hyphenate_style_name_1.default)(k);\n                    // px shorthand\n                    if (typeof v === \"number\") {\n                        v = \"\".concat(v, \"px\");\n                    }\n                    if (v === true) {\n                        return realKey;\n                    }\n                    if (v === false) {\n                        return negate(realKey);\n                    }\n                    return \"(\".concat(realKey, \": \").concat(v, \")\");\n                };\n                var join = function(conds) {\n                    return conds.join(\" and \");\n                };\n                var toQuery = function(obj) {\n                    var rules = [];\n                    Object.keys(mediaQuery_1.default.all).forEach(function(k) {\n                        var v = obj[k];\n                        if (v != null) {\n                            rules.push(keyVal(k, v));\n                        }\n                    });\n                    return join(rules);\n                };\n                exports1[\"default\"] = toQuery;\n            /***/ },\n            /***/ \"./src/useMediaQuery.ts\": /*!******************************!*\\\n  !*** ./src/useMediaQuery.ts ***!\n  \\******************************/ /***/ function(__unused_webpack_module, exports1, __nested_webpack_require_80947__) {\n                \"use strict\";\n                var __importDefault = this && this.__importDefault || function(mod) {\n                    return mod && mod.__esModule ? mod : {\n                        \"default\": mod\n                    };\n                };\n                Object.defineProperty(exports1, \"__esModule\", {\n                    value: true\n                });\n                var react_1 = __nested_webpack_require_80947__(/*! react */ \"react\");\n                var matchmediaquery_1 = __importDefault(__nested_webpack_require_80947__(/*! matchmediaquery */ \"./node_modules/matchmediaquery/index.js\"));\n                var hyphenate_style_name_1 = __importDefault(__nested_webpack_require_80947__(/*! hyphenate-style-name */ \"./node_modules/hyphenate-style-name/index.js\"));\n                var shallow_equal_1 = __nested_webpack_require_80947__(/*! shallow-equal */ \"./node_modules/shallow-equal/dist/index.esm.js\");\n                var toQuery_1 = __importDefault(__nested_webpack_require_80947__(/*! ./toQuery */ \"./src/toQuery.ts\"));\n                var Context_1 = __importDefault(__nested_webpack_require_80947__(/*! ./Context */ \"./src/Context.ts\"));\n                var makeQuery = function(settings) {\n                    return settings.query || (0, toQuery_1.default)(settings);\n                };\n                var hyphenateKeys = function(obj) {\n                    if (!obj) return undefined;\n                    var keys = Object.keys(obj);\n                    return keys.reduce(function(result, key) {\n                        result[(0, hyphenate_style_name_1.default)(key)] = obj[key];\n                        return result;\n                    }, {});\n                };\n                var useIsUpdate = function() {\n                    var ref = (0, react_1.useRef)(false);\n                    (0, react_1.useEffect)(function() {\n                        ref.current = true;\n                    }, []);\n                    return ref.current;\n                };\n                var useDevice = function(deviceFromProps) {\n                    var deviceFromContext = (0, react_1.useContext)(Context_1.default);\n                    var getDevice = function() {\n                        return hyphenateKeys(deviceFromProps) || hyphenateKeys(deviceFromContext);\n                    };\n                    var _a = (0, react_1.useState)(getDevice), device = _a[0], setDevice = _a[1];\n                    (0, react_1.useEffect)(function() {\n                        var newDevice = getDevice();\n                        if (!(0, shallow_equal_1.shallowEqualObjects)(device, newDevice)) {\n                            setDevice(newDevice);\n                        }\n                    }, [\n                        deviceFromProps,\n                        deviceFromContext\n                    ]);\n                    return device;\n                };\n                var useQuery = function(settings) {\n                    var getQuery = function() {\n                        return makeQuery(settings);\n                    };\n                    var _a = (0, react_1.useState)(getQuery), query = _a[0], setQuery = _a[1];\n                    (0, react_1.useEffect)(function() {\n                        var newQuery = getQuery();\n                        if (query !== newQuery) {\n                            setQuery(newQuery);\n                        }\n                    }, [\n                        settings\n                    ]);\n                    return query;\n                };\n                var useMatchMedia = function(query, device) {\n                    var getMatchMedia = function() {\n                        return (0, matchmediaquery_1.default)(query, device || {}, !!device);\n                    };\n                    var _a = (0, react_1.useState)(getMatchMedia), mq = _a[0], setMq = _a[1];\n                    var isUpdate = useIsUpdate();\n                    (0, react_1.useEffect)(function() {\n                        if (isUpdate) {\n                            // skip on mounting, it has already been set\n                            var newMq_1 = getMatchMedia();\n                            setMq(newMq_1);\n                            return function() {\n                                if (newMq_1) {\n                                    newMq_1.dispose();\n                                }\n                            };\n                        }\n                    }, [\n                        query,\n                        device\n                    ]);\n                    return mq;\n                };\n                var useMatches = function(mediaQuery) {\n                    var _a = (0, react_1.useState)(mediaQuery.matches), matches = _a[0], setMatches = _a[1];\n                    (0, react_1.useEffect)(function() {\n                        var updateMatches = function(ev) {\n                            setMatches(ev.matches);\n                        };\n                        mediaQuery.addListener(updateMatches);\n                        setMatches(mediaQuery.matches);\n                        return function() {\n                            mediaQuery.removeListener(updateMatches);\n                        };\n                    }, [\n                        mediaQuery\n                    ]);\n                    return matches;\n                };\n                var useMediaQuery = function(settings, device, onChange) {\n                    var deviceSettings = useDevice(device);\n                    var query = useQuery(settings);\n                    if (!query) throw new Error(\"Invalid or missing MediaQuery!\");\n                    var mq = useMatchMedia(query, deviceSettings);\n                    var matches = useMatches(mq);\n                    var isUpdate = useIsUpdate();\n                    (0, react_1.useEffect)(function() {\n                        if (isUpdate && onChange) {\n                            onChange(matches);\n                        }\n                    }, [\n                        matches\n                    ]);\n                    (0, react_1.useEffect)(function() {\n                        return function() {\n                            if (mq) {\n                                mq.dispose();\n                            }\n                        };\n                    }, []);\n                    return matches;\n                };\n                exports1[\"default\"] = useMediaQuery;\n            /***/ },\n            /***/ \"react\": /*!**************************************************************************************!*\\\n  !*** external {\"commonjs\":\"react\",\"commonjs2\":\"react\",\"amd\":\"react\",\"root\":\"React\"} ***!\n  \\**************************************************************************************/ /***/ (module1)=>{\n                \"use strict\";\n                module1.exports = __WEBPACK_EXTERNAL_MODULE_react__;\n            /***/ }\n        };\n        /************************************************************************/ /******/ // The module cache\n        /******/ var __webpack_module_cache__ = {};\n        /******/ /******/ // The require function\n        /******/ function __nested_webpack_require_87991__(moduleId) {\n            /******/ // Check if module is in cache\n            /******/ var cachedModule = __webpack_module_cache__[moduleId];\n            /******/ if (cachedModule !== undefined) {\n                /******/ return cachedModule.exports;\n            /******/ }\n            /******/ // Create a new module (and put it into the cache)\n            /******/ var module1 = __webpack_module_cache__[moduleId] = {\n                /******/ // no module.id needed\n                /******/ // no module.loaded needed\n                /******/ exports: {}\n            };\n            /******/ /******/ // Execute the module function\n            /******/ __webpack_modules__[moduleId].call(module1.exports, module1, module1.exports, __nested_webpack_require_87991__);\n            /******/ /******/ // Return the exports of the module\n            /******/ return module1.exports;\n        /******/ }\n        /******/ /************************************************************************/ /******/ /* webpack/runtime/define property getters */ /******/ (()=>{\n            /******/ // define getter functions for harmony exports\n            /******/ __nested_webpack_require_87991__.d = (exports1, definition)=>{\n                /******/ for(var key in definition){\n                    /******/ if (__nested_webpack_require_87991__.o(definition, key) && !__nested_webpack_require_87991__.o(exports1, key)) {\n                        /******/ Object.defineProperty(exports1, key, {\n                            enumerable: true,\n                            get: definition[key]\n                        });\n                    /******/ }\n                /******/ }\n            /******/ };\n        /******/ })();\n        /******/ /******/ /* webpack/runtime/hasOwnProperty shorthand */ /******/ (()=>{\n            /******/ __nested_webpack_require_87991__.o = (obj, prop)=>Object.prototype.hasOwnProperty.call(obj, prop);\n        /******/ })();\n        /******/ /******/ /* webpack/runtime/make namespace object */ /******/ (()=>{\n            /******/ // define __esModule on exports\n            /******/ __nested_webpack_require_87991__.r = (exports1)=>{\n                /******/ if (typeof Symbol !== \"undefined\" && Symbol.toStringTag) {\n                    /******/ Object.defineProperty(exports1, Symbol.toStringTag, {\n                        value: \"Module\"\n                    });\n                /******/ }\n                /******/ Object.defineProperty(exports1, \"__esModule\", {\n                    value: true\n                });\n            /******/ };\n        /******/ })();\n        /******/ /************************************************************************/ /******/ /******/ // startup\n        /******/ // Load entry module and return exports\n        /******/ // This entry module is referenced by other modules so it can't be inlined\n        /******/ var __nested_webpack_exports__ = __nested_webpack_require_87991__(\"./src/index.ts\");\n        /******/ /******/ return __nested_webpack_exports__;\n    /******/ })();\n}); //# sourceMappingURL=react-responsive.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtcmVzcG9uc2l2ZS9kaXN0L3JlYWN0LXJlc3BvbnNpdmUuanMiLCJtYXBwaW5ncyI6IkFBQUMsVUFBU0EsaUNBQWlDQyxJQUFJLEVBQUVDLE9BQU87SUFDdkQsSUFBRyxJQUFpRCxFQUNuREUsT0FBT0QsT0FBTyxHQUFHRCxRQUFRRyxtQkFBT0EsQ0FBQyx3R0FBTztTQUNwQyxFQUt3QztBQUM5QyxHQUFHLElBQUksRUFBRSxDQUFDRztJQUNWLE9BQWdCLE1BQUgsR0FBSTtRQUNqQixNQUFNLEdBQUksSUFBSUMsc0JBQXVCO1lBRXJDLEdBQUcsR0FBRywwQ0FDTjs7Z0RBRWdELEdBQ2hELEdBQUcsR0FBSSxDQUFDQyx5QkFBeUJQO2dCQUVqQztnQkFDQTs7OztBQUlBLEdBSUFBLFNBQVFRLEtBQUssR0FBR0M7Z0JBQ2hCVCxTQUFRVSxLQUFLLEdBQUdDO2dCQUVoQixnRkFBZ0Y7Z0JBRWhGLElBQUlDLGlCQUFxQix1REFDckJDLG1CQUFxQixpREFDckJDLGdCQUFxQix3QkFDckJDLGlCQUFxQixnQ0FDckJDLHFCQUFxQjtnQkFFekIsU0FBU1AsV0FBV1EsVUFBVSxFQUFFQyxNQUFNO29CQUNsQyxPQUFPUCxXQUFXTSxZQUFZRSxJQUFJLENBQUMsU0FBVUMsS0FBSzt3QkFDOUMsSUFBSUMsVUFBVUQsTUFBTUMsT0FBTzt3QkFFM0IsdUVBQXVFO3dCQUN2RSxxQkFBcUI7d0JBQ3JCLElBQUlDLFlBQVlGLE1BQU1HLElBQUksS0FBSyxTQUFTTCxPQUFPSyxJQUFJLEtBQUtILE1BQU1HLElBQUk7d0JBRWxFLHFFQUFxRTt3QkFDckUsSUFBSSxhQUFjRixXQUFZLENBQUVDLENBQUFBLGFBQWFELE9BQU0sR0FBSTs0QkFDbkQsT0FBTzt3QkFDWDt3QkFFQSxJQUFJRyxtQkFBbUJKLE1BQU1LLFdBQVcsQ0FBQ0MsS0FBSyxDQUFDLFNBQVVDLFVBQVU7NEJBQy9ELElBQUlDLFVBQVdELFdBQVdDLE9BQU8sRUFDN0JDLFdBQVdGLFdBQVdFLFFBQVEsRUFDOUJDLFdBQVdILFdBQVdJLEtBQUssRUFDM0JBLFFBQVdiLE1BQU0sQ0FBQ1UsUUFBUTs0QkFFOUIsdUNBQXVDOzRCQUN2QyxJQUFJLENBQUNHLE9BQU87Z0NBQUUsT0FBTzs0QkFBTzs0QkFFNUIsT0FBUUg7Z0NBQ0osS0FBSztnQ0FDTCxLQUFLO29DQUNELE9BQU9HLE1BQU1DLFdBQVcsT0FBT0YsU0FBU0UsV0FBVztnQ0FFdkQsS0FBSztnQ0FDTCxLQUFLO2dDQUNMLEtBQUs7Z0NBQ0wsS0FBSztvQ0FDREYsV0FBV0csS0FBS0g7b0NBQ2hCQyxRQUFXRSxLQUFLRjtvQ0FDaEI7Z0NBRUosS0FBSztvQ0FDREQsV0FBV0ksTUFBTUo7b0NBQ2pCQyxRQUFXRyxNQUFNSDtvQ0FDakI7Z0NBRUosS0FBSztnQ0FDTCxLQUFLO2dDQUNMLEtBQUssY0FBYyxHQUFHO29DQUNsQkQsV0FBV0ssVUFBVUw7b0NBQ3JCQyxRQUFXSSxVQUFVSjtvQ0FDckI7Z0NBRUosS0FBSztnQ0FDTCxLQUFLO2dDQUNMLEtBQUs7Z0NBQ0wsS0FBSztvQ0FDREQsV0FBV00sU0FBU04sVUFBVSxPQUFPO29DQUNyQ0MsUUFBV0ssU0FBU0wsT0FBTyxPQUFPO29DQUNsQzs0QkFDUjs0QkFFQSxPQUFRRjtnQ0FDSixLQUFLO29DQUFPLE9BQU9FLFNBQVNEO2dDQUM1QixLQUFLO29DQUFPLE9BQU9DLFNBQVNEO2dDQUM1QjtvQ0FBWSxPQUFPQyxVQUFVRDs0QkFDakM7d0JBQ0o7d0JBRUEsT0FBTyxvQkFBcUIsQ0FBQ1QsV0FBYSxDQUFDRyxvQkFBb0JIO29CQUNuRTtnQkFDSjtnQkFFQSxTQUFTVixXQUFXTSxVQUFVO29CQUMxQixPQUFPQSxXQUFXb0IsS0FBSyxDQUFDLEtBQUtDLEdBQUcsQ0FBQyxTQUFVbEIsS0FBSzt3QkFDNUNBLFFBQVFBLE1BQU1tQixJQUFJO3dCQUVsQixJQUFJQyxXQUFjcEIsTUFBTVosS0FBSyxDQUFDSSxpQkFDMUJpQixXQUFjVyxRQUFRLENBQUMsRUFBRSxFQUN6QmpCLE9BQWNpQixRQUFRLENBQUMsRUFBRSxFQUN6QmYsY0FBY2UsUUFBUSxDQUFDLEVBQUUsSUFBSSxJQUM3QkMsU0FBYyxDQUFDO3dCQUVuQkEsT0FBT3BCLE9BQU8sR0FBRyxDQUFDLENBQUNRLFlBQVlBLFNBQVNHLFdBQVcsT0FBTzt3QkFDMURTLE9BQU9sQixJQUFJLEdBQU1BLE9BQU9BLEtBQUtTLFdBQVcsS0FBSzt3QkFFN0MsaUNBQWlDO3dCQUNqQ1AsY0FBY0EsWUFBWWpCLEtBQUssQ0FBQyxrQkFBa0IsRUFBRTt3QkFFcERpQyxPQUFPaEIsV0FBVyxHQUFHQSxZQUFZYSxHQUFHLENBQUMsU0FBVVgsVUFBVTs0QkFDckQsSUFBSWEsV0FBV2IsV0FBV25CLEtBQUssQ0FBQ0ssbUJBQzVCZSxVQUFXWSxRQUFRLENBQUMsRUFBRSxDQUFDUixXQUFXLEdBQUd4QixLQUFLLENBQUNNOzRCQUUvQyxPQUFPO2dDQUNIZSxVQUFVRCxPQUFPLENBQUMsRUFBRTtnQ0FDcEJBLFNBQVVBLE9BQU8sQ0FBQyxFQUFFO2dDQUNwQkcsT0FBVVMsUUFBUSxDQUFDLEVBQUU7NEJBQ3pCO3dCQUNKO3dCQUVBLE9BQU9DO29CQUNYO2dCQUNKO2dCQUVBLGdGQUFnRjtnQkFFaEYsU0FBU04sVUFBVU8sS0FBSztvQkFDcEIsSUFBSUMsVUFBVUMsT0FBT0YsUUFDakJHO29CQUVKLElBQUksQ0FBQ0YsU0FBUzt3QkFDVkUsVUFBVUgsTUFBTWxDLEtBQUssQ0FBQzt3QkFDdEJtQyxVQUFVRSxPQUFPLENBQUMsRUFBRSxHQUFHQSxPQUFPLENBQUMsRUFBRTtvQkFDckM7b0JBRUEsT0FBT0Y7Z0JBQ1g7Z0JBRUEsU0FBU1QsTUFBTVksVUFBVTtvQkFDckIsSUFBSWYsUUFBUWdCLFdBQVdELGFBQ25CRSxRQUFRQyxPQUFPSCxZQUFZdEMsS0FBSyxDQUFDUSxtQkFBbUIsQ0FBQyxFQUFFO29CQUUzRCxPQUFRZ0M7d0JBQ0osS0FBSzs0QkFBUSxPQUFPakIsUUFBUTt3QkFDNUIsS0FBSzs0QkFBUSxPQUFPQSxRQUFRO3dCQUM1Qjs0QkFBYSxPQUFPQTtvQkFDeEI7Z0JBQ0o7Z0JBRUEsU0FBU0UsS0FBS2lCLE1BQU07b0JBQ2hCLElBQUluQixRQUFRZ0IsV0FBV0csU0FDbkJGLFFBQVFDLE9BQU9DLFFBQVExQyxLQUFLLENBQUNPLGVBQWUsQ0FBQyxFQUFFO29CQUVuRCxPQUFRaUM7d0JBQ0osS0FBSzs0QkFBTyxPQUFPakIsUUFBUTt3QkFDM0IsS0FBSzs0QkFBTyxPQUFPQSxRQUFRO3dCQUMzQixLQUFLOzRCQUFPLE9BQU9BLFFBQVEsS0FBSzt3QkFDaEMsS0FBSzs0QkFBTyxPQUFPQSxRQUFRLEtBQUssT0FBTzt3QkFDdkMsS0FBSzs0QkFBTyxPQUFPQSxRQUFRO3dCQUMzQixLQUFLOzRCQUFPLE9BQU9BLFFBQVE7d0JBQzNCLEtBQUs7NEJBQU8sT0FBT0EsUUFBUSxLQUFLO3dCQUNoQzs0QkFBWSxPQUFPQTtvQkFDdkI7Z0JBQ0o7WUFHQSxHQUFHLEdBQUc7WUFFTixHQUFHLEdBQUcsZ0RBQ047O3NEQUVzRCxHQUN0RCxHQUFHLEdBQUksQ0FBQ3hCLHlCQUF5QjRDLDBCQUFtQkEsRUFBRUMsK0JBQW1CQTtnQkFFekU7Z0JBQ0FBLCtCQUFtQkEsQ0FBQ0MsQ0FBQyxDQUFDRiwwQkFBbUJBO2dCQUN6QyxrQkFBa0IsR0FBR0MsK0JBQW1CQSxDQUFDRSxDQUFDLENBQUNILDBCQUFtQkEsRUFBRTtvQkFDaEUsa0JBQWtCLEdBQUssV0FBVyxJQUFPSTtnQkFDcEI7Z0JBQ3JCLDBDQUEwQyxHQUMxQyxJQUFJQyxtQkFBbUI7Z0JBQ3ZCLElBQUlDLFlBQVk7Z0JBQ2hCLElBQUlDLFFBQVEsQ0FBQztnQkFFYixTQUFTQyxjQUFjbkQsS0FBSztvQkFDMUIsT0FBTyxNQUFNQSxNQUFNd0IsV0FBVztnQkFDaEM7Z0JBRUEsU0FBUzRCLG1CQUFtQkMsSUFBSTtvQkFDOUIsSUFBSUgsTUFBTUksY0FBYyxDQUFDRCxPQUFPO3dCQUM5QixPQUFPSCxLQUFLLENBQUNHLEtBQUs7b0JBQ3BCO29CQUVBLElBQUlFLFFBQVFGLEtBQUtHLE9BQU8sQ0FBQ1Isa0JBQWtCRztvQkFDM0MsT0FBUUQsS0FBSyxDQUFDRyxLQUFLLEdBQUdKLFVBQVVRLElBQUksQ0FBQ0YsU0FBUyxNQUFNQSxRQUFRQTtnQkFDOUQ7Z0JBRUEsMEJBQTBCLEdBQUcsTUFBTVIsNkJBQThCSztZQUdqRSxHQUFHLEdBQUc7WUFFTixHQUFHLEdBQUcsMkNBQ047O2lEQUVpRCxHQUNqRCxHQUFHLEdBQUksQ0FBQzNELFNBQVFpRSwwQkFBMEJkLCtCQUFtQkE7Z0JBRTdEO2dCQUdBLElBQUllLGNBQWVmLCtCQUFtQkEsQ0FBQyxtQkFBbUIsR0FBRywwQ0FBMEM1QyxLQUFLO2dCQUM1RyxJQUFJNEQsZUFBZSxNQUFrQixHQUFjQyxDQUFpQixHQUFHO2dCQUV2RSwwQkFBMEI7Z0JBQzFCLFNBQVNFLElBQUluRCxLQUFLLEVBQUVGLE1BQU0sRUFBRXNELFdBQVc7b0JBQ3JDLElBQUlDLE9BQU8sSUFBSTtvQkFDZixJQUFHTCxnQkFBZ0IsQ0FBQ0ksYUFBWTt3QkFDOUIsSUFBSUUsTUFBTU4sYUFBYU8sSUFBSSxDQUFDTixRQUFRakQ7d0JBQ3BDLElBQUksQ0FBQ3dELE9BQU8sR0FBR0YsSUFBSUUsT0FBTzt3QkFDMUIsSUFBSSxDQUFDQyxLQUFLLEdBQUdILElBQUlHLEtBQUs7d0JBQ3RCLGdFQUFnRTt3QkFDaEVILElBQUlJLFdBQVcsQ0FBQ0M7b0JBQ2xCLE9BQU87d0JBQ0wsSUFBSSxDQUFDSCxPQUFPLEdBQUdULFlBQVkvQyxPQUFPRjt3QkFDbEMsSUFBSSxDQUFDMkQsS0FBSyxHQUFHekQ7b0JBQ2Y7b0JBRUEsSUFBSSxDQUFDMEQsV0FBVyxHQUFHQTtvQkFDbkIsSUFBSSxDQUFDRSxjQUFjLEdBQUdBO29CQUN0QixJQUFJLENBQUNDLE9BQU8sR0FBR0E7b0JBRWYsU0FBU0gsWUFBWUksUUFBUTt3QkFDM0IsSUFBR1IsS0FBSTs0QkFDTEEsSUFBSUksV0FBVyxDQUFDSTt3QkFDbEI7b0JBQ0Y7b0JBRUEsU0FBU0YsZUFBZUUsUUFBUTt3QkFDOUIsSUFBR1IsS0FBSTs0QkFDTEEsSUFBSU0sY0FBYyxDQUFDRTt3QkFDckI7b0JBQ0Y7b0JBRUEsb0JBQW9CO29CQUNwQixTQUFTSCxPQUFPSSxHQUFHO3dCQUNqQlYsS0FBS0csT0FBTyxHQUFHTyxJQUFJUCxPQUFPO3dCQUMxQkgsS0FBS0ksS0FBSyxHQUFHTSxJQUFJTixLQUFLO29CQUN4QjtvQkFFQSxTQUFTSTt3QkFDUCxJQUFHUCxLQUFJOzRCQUNMQSxJQUFJTSxjQUFjLENBQUNEO3dCQUNyQjtvQkFDRjtnQkFDRjtnQkFFQSxTQUFTVCxXQUFXbEQsS0FBSyxFQUFFRixNQUFNLEVBQUVzRCxXQUFXO29CQUM1QyxPQUFPLElBQUlELElBQUluRCxPQUFPRixRQUFRc0Q7Z0JBQ2hDO2dCQUVBdkUsUUFBT0QsT0FBTyxHQUFHc0U7WUFHakIsR0FBRyxHQUFHO1lBRU4sR0FBRyxHQUFHLHlDQUNOOzsrQ0FFK0MsR0FDL0MsR0FBRyxHQUFJLENBQUNyRTtnQkFFUjtnQkFDQTs7OztBQUlBLEdBR0EsaUNBQWlDLEdBQ2pDLElBQUltRix3QkFBd0JDLE9BQU9ELHFCQUFxQjtnQkFDeEQsSUFBSXRCLGlCQUFpQnVCLE9BQU9DLFNBQVMsQ0FBQ3hCLGNBQWM7Z0JBQ3BELElBQUl5QixtQkFBbUJGLE9BQU9DLFNBQVMsQ0FBQ0Usb0JBQW9CO2dCQUU1RCxTQUFTQyxTQUFTQyxHQUFHO29CQUNwQixJQUFJQSxRQUFRLFFBQVFBLFFBQVFDLFdBQVc7d0JBQ3RDLE1BQU0sSUFBSUMsVUFBVTtvQkFDckI7b0JBRUEsT0FBT1AsT0FBT0s7Z0JBQ2Y7Z0JBRUEsU0FBU0c7b0JBQ1IsSUFBSTt3QkFDSCxJQUFJLENBQUNSLE9BQU9TLE1BQU0sRUFBRTs0QkFDbkIsT0FBTzt3QkFDUjt3QkFFQSxnRUFBZ0U7d0JBRWhFLHVEQUF1RDt3QkFDdkQsSUFBSUMsUUFBUSxJQUFJOUMsT0FBTyxRQUFTLHNDQUFzQzt3QkFDdEU4QyxLQUFLLENBQUMsRUFBRSxHQUFHO3dCQUNYLElBQUlWLE9BQU9XLG1CQUFtQixDQUFDRCxNQUFNLENBQUMsRUFBRSxLQUFLLEtBQUs7NEJBQ2pELE9BQU87d0JBQ1I7d0JBRUEsdURBQXVEO3dCQUN2RCxJQUFJRSxRQUFRLENBQUM7d0JBQ2IsSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUksSUFBSUEsSUFBSzs0QkFDNUJELEtBQUssQ0FBQyxNQUFNaEQsT0FBT2tELFlBQVksQ0FBQ0QsR0FBRyxHQUFHQTt3QkFDdkM7d0JBQ0EsSUFBSUUsU0FBU2YsT0FBT1csbUJBQW1CLENBQUNDLE9BQU8zRCxHQUFHLENBQUMsU0FBVStELENBQUM7NEJBQzdELE9BQU9KLEtBQUssQ0FBQ0ksRUFBRTt3QkFDaEI7d0JBQ0EsSUFBSUQsT0FBT0UsSUFBSSxDQUFDLFFBQVEsY0FBYzs0QkFDckMsT0FBTzt3QkFDUjt3QkFFQSx1REFBdUQ7d0JBQ3ZELElBQUlDLFFBQVEsQ0FBQzt3QkFDYix1QkFBdUJsRSxLQUFLLENBQUMsSUFBSW1FLE9BQU8sQ0FBQyxTQUFVQyxNQUFNOzRCQUN4REYsS0FBSyxDQUFDRSxPQUFPLEdBQUdBO3dCQUNqQjt3QkFDQSxJQUFJcEIsT0FBT3FCLElBQUksQ0FBQ3JCLE9BQU9TLE1BQU0sQ0FBQyxDQUFDLEdBQUdTLFFBQVFELElBQUksQ0FBQyxRQUM3Qyx3QkFBd0I7NEJBQ3pCLE9BQU87d0JBQ1I7d0JBRUEsT0FBTztvQkFDUixFQUFFLE9BQU9LLEtBQUs7d0JBQ2Isb0VBQW9FO3dCQUNwRSxPQUFPO29CQUNSO2dCQUNEO2dCQUVBMUcsUUFBT0QsT0FBTyxHQUFHNkYsb0JBQW9CUixPQUFPUyxNQUFNLEdBQUcsU0FBVWMsTUFBTSxFQUFFQyxNQUFNO29CQUM1RSxJQUFJQztvQkFDSixJQUFJQyxLQUFLdEIsU0FBU21CO29CQUNsQixJQUFJSTtvQkFFSixJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSUMsVUFBVWhFLE1BQU0sRUFBRStELElBQUs7d0JBQzFDSCxPQUFPekIsT0FBTzZCLFNBQVMsQ0FBQ0QsRUFBRTt3QkFFMUIsSUFBSyxJQUFJRSxPQUFPTCxLQUFNOzRCQUNyQixJQUFJaEQsZUFBZWEsSUFBSSxDQUFDbUMsTUFBTUssTUFBTTtnQ0FDbkNKLEVBQUUsQ0FBQ0ksSUFBSSxHQUFHTCxJQUFJLENBQUNLLElBQUk7NEJBQ3BCO3dCQUNEO3dCQUVBLElBQUkvQix1QkFBdUI7NEJBQzFCNEIsVUFBVTVCLHNCQUFzQjBCOzRCQUNoQyxJQUFLLElBQUlaLElBQUksR0FBR0EsSUFBSWMsUUFBUTlELE1BQU0sRUFBRWdELElBQUs7Z0NBQ3hDLElBQUlYLGlCQUFpQlosSUFBSSxDQUFDbUMsTUFBTUUsT0FBTyxDQUFDZCxFQUFFLEdBQUc7b0NBQzVDYSxFQUFFLENBQUNDLE9BQU8sQ0FBQ2QsRUFBRSxDQUFDLEdBQUdZLElBQUksQ0FBQ0UsT0FBTyxDQUFDZCxFQUFFLENBQUM7Z0NBQ2xDOzRCQUNEO3dCQUNEO29CQUNEO29CQUVBLE9BQU9hO2dCQUNSO1lBR0EsR0FBRyxHQUFHO1lBRU4sR0FBRyxHQUFHLCtDQUNOOztxREFFcUQsR0FDckQsR0FBRyxHQUFJLENBQUM5RyxTQUFRaUUsMEJBQTBCZCxnQ0FBbUJBO2dCQUU3RDtnQkFDQTs7Ozs7Q0FLQyxHQUlELElBQUlnRSxlQUFlLFlBQVk7Z0JBRS9CLElBQUksSUFBSSxFQUFFO29CQUNSLElBQUlDLHVCQUF1QmpFLGdDQUFtQkEsQ0FBQywrQkFBK0IsR0FBRztvQkFDakYsSUFBSWtFLHFCQUFxQixDQUFDO29CQUMxQixJQUFJQyxNQUFNbkUsZ0NBQW1CQSxDQUFDLGNBQWMsR0FBRztvQkFFL0NnRSxlQUFlLFNBQVNJLElBQUk7d0JBQzFCLElBQUlDLFVBQVUsY0FBY0Q7d0JBQzVCLElBQUksT0FBT0UsWUFBWSxhQUFhOzRCQUNsQ0EsUUFBUUMsS0FBSyxDQUFDRjt3QkFDaEI7d0JBQ0EsSUFBSTs0QkFDRixxQ0FBcUM7NEJBQ3JDLHdFQUF3RTs0QkFDeEUseURBQXlEOzRCQUN6RCxNQUFNLElBQUlHLE1BQU1IO3dCQUNsQixFQUFFLE9BQU9JLEdBQUcsQ0FBTztvQkFDckI7Z0JBQ0Y7Z0JBRUE7Ozs7Ozs7Ozs7Q0FVQyxHQUNELFNBQVNDLGVBQWVDLFNBQVMsRUFBRTdHLE1BQU0sRUFBRThHLFFBQVEsRUFBRUMsYUFBYSxFQUFFQyxRQUFRO29CQUMxRSxJQUFJLElBQUksRUFBRTt3QkFDUixJQUFLLElBQUlDLGdCQUFnQkosVUFBVzs0QkFDbEMsSUFBSVIsSUFBSVEsV0FBV0ksZUFBZTtnQ0FDaEMsSUFBSVI7Z0NBQ0osb0VBQW9FO2dDQUNwRSxtRUFBbUU7Z0NBQ25FLDBEQUEwRDtnQ0FDMUQsSUFBSTtvQ0FDRixxRUFBcUU7b0NBQ3JFLG1FQUFtRTtvQ0FDbkUsSUFBSSxPQUFPSSxTQUFTLENBQUNJLGFBQWEsS0FBSyxZQUFZO3dDQUNqRCxJQUFJeEIsTUFBTWlCLE1BQ1IsQ0FBQ0ssaUJBQWlCLGFBQVksSUFBSyxPQUFPRCxXQUFXLFlBQVlHLGVBQWUsbUJBQ2hGLGlGQUFpRixPQUFPSixTQUFTLENBQUNJLGFBQWEsR0FBRyxPQUNsSDt3Q0FFRnhCLElBQUk5QyxJQUFJLEdBQUc7d0NBQ1gsTUFBTThDO29DQUNSO29DQUNBZ0IsUUFBUUksU0FBUyxDQUFDSSxhQUFhLENBQUNqSCxRQUFRaUgsY0FBY0YsZUFBZUQsVUFBVSxNQUFNWDtnQ0FDdkYsRUFBRSxPQUFPZSxJQUFJO29DQUNYVCxRQUFRUztnQ0FDVjtnQ0FDQSxJQUFJVCxTQUFTLENBQUVBLENBQUFBLGlCQUFpQkMsS0FBSSxHQUFJO29DQUN0Q1IsYUFDRSxDQUFDYSxpQkFBaUIsYUFBWSxJQUFLLDZCQUNuQ0QsV0FBVyxPQUFPRyxlQUFlLG9DQUNqQyw4REFBOEQsT0FBT1IsUUFBUSxPQUM3RSxvRUFDQSxtRUFDQTtnQ0FFSjtnQ0FDQSxJQUFJQSxpQkFBaUJDLFNBQVMsQ0FBRUQsQ0FBQUEsTUFBTUYsT0FBTyxJQUFJSCxrQkFBaUIsR0FBSTtvQ0FDcEUsd0VBQXdFO29DQUN4RSxjQUFjO29DQUNkQSxrQkFBa0IsQ0FBQ0ssTUFBTUYsT0FBTyxDQUFDLEdBQUc7b0NBRXBDLElBQUlZLFFBQVFILFdBQVdBLGFBQWE7b0NBRXBDZCxhQUNFLFlBQVlZLFdBQVcsWUFBWUwsTUFBTUYsT0FBTyxHQUFJWSxDQUFBQSxTQUFTLE9BQU9BLFFBQVEsRUFBQztnQ0FFakY7NEJBQ0Y7d0JBQ0Y7b0JBQ0Y7Z0JBQ0Y7Z0JBRUE7Ozs7Q0FJQyxHQUNEUCxlQUFlUSxpQkFBaUIsR0FBRztvQkFDakMsSUFBSSxJQUFJLEVBQUU7d0JBQ1JoQixxQkFBcUIsQ0FBQztvQkFDeEI7Z0JBQ0Y7Z0JBRUFySCxRQUFPRCxPQUFPLEdBQUc4SDtZQUdqQixHQUFHLEdBQUc7WUFFTixHQUFHLEdBQUcsd0RBQ047OzhEQUU4RCxHQUM5RCxHQUFHLEdBQUksQ0FBQzdILFNBQVFpRSwwQkFBMEJkLGdDQUFtQkE7Z0JBRTdEO2dCQUNBOzs7OztDQUtDLEdBSUQsSUFBSW1GLFVBQVVuRixnQ0FBbUJBLENBQUMsYUFBYSxHQUFHO2dCQUNsRCxJQUFJMEMsU0FBUzFDLGdDQUFtQkEsQ0FBQyxrQkFBa0IsR0FBRztnQkFFdEQsSUFBSWlFLHVCQUF1QmpFLGdDQUFtQkEsQ0FBQywrQkFBK0IsR0FBRztnQkFDakYsSUFBSW1FLE1BQU1uRSxnQ0FBbUJBLENBQUMsY0FBYyxHQUFHO2dCQUMvQyxJQUFJMEUsaUJBQWlCMUUsZ0NBQW1CQSxDQUFDLHFCQUFxQixHQUFHO2dCQUVqRSxJQUFJZ0UsZUFBZSxZQUFZO2dCQUUvQixJQUFJLElBQUksRUFBRTtvQkFDUkEsZUFBZSxTQUFTSSxJQUFJO3dCQUMxQixJQUFJQyxVQUFVLGNBQWNEO3dCQUM1QixJQUFJLE9BQU9FLFlBQVksYUFBYTs0QkFDbENBLFFBQVFDLEtBQUssQ0FBQ0Y7d0JBQ2hCO3dCQUNBLElBQUk7NEJBQ0YscUNBQXFDOzRCQUNyQyx3RUFBd0U7NEJBQ3hFLHlEQUF5RDs0QkFDekQsTUFBTSxJQUFJRyxNQUFNSDt3QkFDbEIsRUFBRSxPQUFPSSxHQUFHLENBQUM7b0JBQ2Y7Z0JBQ0Y7Z0JBRUEsU0FBU1c7b0JBQ1AsT0FBTztnQkFDVDtnQkFFQXZJLFFBQU9ELE9BQU8sR0FBRyxTQUFTeUksY0FBYyxFQUFFQyxtQkFBbUI7b0JBQzNELGlCQUFpQixHQUNqQixJQUFJQyxrQkFBa0IsT0FBT0MsV0FBVyxjQUFjQSxPQUFPQyxRQUFRO29CQUNyRSxJQUFJQyx1QkFBdUIsY0FBYyxzQkFBc0I7b0JBRS9EOzs7Ozs7Ozs7Ozs7O0dBYUMsR0FDRCxTQUFTQyxjQUFjQyxhQUFhO3dCQUNsQyxJQUFJQyxhQUFhRCxpQkFBa0JMLENBQUFBLG1CQUFtQkssYUFBYSxDQUFDTCxnQkFBZ0IsSUFBSUssYUFBYSxDQUFDRixxQkFBcUI7d0JBQzNILElBQUksT0FBT0csZUFBZSxZQUFZOzRCQUNwQyxPQUFPQTt3QkFDVDtvQkFDRjtvQkFFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBNkNDLEdBRUQsSUFBSUMsWUFBWTtvQkFFaEIsYUFBYTtvQkFDYixxRkFBcUY7b0JBQ3JGLElBQUlDLGlCQUFpQjt3QkFDbkJDLE9BQU9DLDJCQUEyQjt3QkFDbENDLFFBQVFELDJCQUEyQjt3QkFDbkNFLE1BQU1GLDJCQUEyQjt3QkFDakNHLE1BQU1ILDJCQUEyQjt3QkFDakNJLFFBQVFKLDJCQUEyQjt3QkFDbkNLLFFBQVFMLDJCQUEyQjt3QkFDbkNNLFFBQVFOLDJCQUEyQjt3QkFDbkNPLFFBQVFQLDJCQUEyQjt3QkFFbkNRLEtBQUtDO3dCQUNMQyxTQUFTQzt3QkFDVEMsU0FBU0M7d0JBQ1RDLGFBQWFDO3dCQUNiQyxZQUFZQzt3QkFDWkMsTUFBTUM7d0JBQ05DLFVBQVVDO3dCQUNWQyxPQUFPQzt3QkFDUEMsV0FBV0M7d0JBQ1hDLE9BQU9DO3dCQUNQQyxPQUFPQztvQkFDVDtvQkFFQTs7O0dBR0MsR0FDRCxnQ0FBZ0MsR0FDaEMsU0FBU0MsR0FBR3RELENBQUMsRUFBRXVELENBQUM7d0JBQ2Qsc0JBQXNCO3dCQUN0QixJQUFJdkQsTUFBTXVELEdBQUc7NEJBQ1gsa0JBQWtCOzRCQUNsQiwwQkFBMEI7NEJBQzFCLE9BQU92RCxNQUFNLEtBQUssSUFBSUEsTUFBTSxJQUFJdUQ7d0JBQ2xDLE9BQU87NEJBQ0wsdUJBQXVCOzRCQUN2QixPQUFPdkQsTUFBTUEsS0FBS3VELE1BQU1BO3dCQUMxQjtvQkFDRjtvQkFDQSwrQkFBK0IsR0FFL0I7Ozs7OztHQU1DLEdBQ0QsU0FBU0MsY0FBYzVELE9BQU8sRUFBRTZELElBQUk7d0JBQ2xDLElBQUksQ0FBQzdELE9BQU8sR0FBR0E7d0JBQ2YsSUFBSSxDQUFDNkQsSUFBSSxHQUFHQSxRQUFRLE9BQU9BLFNBQVMsV0FBV0EsT0FBTSxDQUFDO3dCQUN0RCxJQUFJLENBQUNqRCxLQUFLLEdBQUc7b0JBQ2Y7b0JBQ0EsMERBQTBEO29CQUMxRGdELGNBQWMvRixTQUFTLEdBQUdzQyxNQUFNdEMsU0FBUztvQkFFekMsU0FBU2lHLDJCQUEyQkMsUUFBUTt3QkFDMUMsSUFBSSxJQUFJLEVBQUU7NEJBQ1IsSUFBSUMsMEJBQTBCLENBQUM7NEJBQy9CLElBQUlDLDZCQUE2Qjt3QkFDbkM7d0JBQ0EsU0FBU0MsVUFBVUMsVUFBVSxFQUFFQyxLQUFLLEVBQUVDLFFBQVEsRUFBRTdELGFBQWEsRUFBRUQsUUFBUSxFQUFFK0QsWUFBWSxFQUFFQyxNQUFNOzRCQUMzRi9ELGdCQUFnQkEsaUJBQWlCaUI7NEJBQ2pDNkMsZUFBZUEsZ0JBQWdCRDs0QkFFL0IsSUFBSUUsV0FBVzNFLHNCQUFzQjtnQ0FDbkMsSUFBSXFCLHFCQUFxQjtvQ0FDdkIsc0RBQXNEO29DQUN0RCxJQUFJL0IsTUFBTSxJQUFJaUIsTUFDWix5RkFDQSxvREFDQTtvQ0FFRmpCLElBQUk5QyxJQUFJLEdBQUc7b0NBQ1gsTUFBTThDO2dDQUNSLE9BQU8sSUFBSyxLQUFJLElBQUksT0FBT2UsWUFBWSxhQUFhO29DQUNsRCxnREFBZ0Q7b0NBQ2hELElBQUl1RSxXQUFXaEUsZ0JBQWdCLE1BQU02RDtvQ0FDckMsSUFDRSxDQUFDTCx1QkFBdUIsQ0FBQ1EsU0FBUyxJQUNsQywwRkFBMEY7b0NBQzFGUCw2QkFBNkIsR0FDN0I7d0NBQ0F0RSxhQUNFLDJEQUNBLHVCQUF1QjJFLGVBQWUsZ0JBQWdCOUQsZ0JBQWdCLDJCQUN0RSw0REFDQSxtRUFDQSxrRUFBa0U7d0NBRXBFd0QsdUJBQXVCLENBQUNRLFNBQVMsR0FBRzt3Q0FDcENQO29DQUNGO2dDQUNGOzRCQUNGOzRCQUNBLElBQUlHLEtBQUssQ0FBQ0MsU0FBUyxJQUFJLE1BQU07Z0NBQzNCLElBQUlGLFlBQVk7b0NBQ2QsSUFBSUMsS0FBSyxDQUFDQyxTQUFTLEtBQUssTUFBTTt3Q0FDNUIsT0FBTyxJQUFJVCxjQUFjLFNBQVNyRCxXQUFXLE9BQU8rRCxlQUFlLDZCQUE4QixVQUFTOUQsZ0JBQWdCLDZCQUE0QjtvQ0FDeEo7b0NBQ0EsT0FBTyxJQUFJb0QsY0FBYyxTQUFTckQsV0FBVyxPQUFPK0QsZUFBZSxnQ0FBaUMsT0FBTTlELGdCQUFnQixrQ0FBaUM7Z0NBQzdKO2dDQUNBLE9BQU87NEJBQ1QsT0FBTztnQ0FDTCxPQUFPdUQsU0FBU0ssT0FBT0MsVUFBVTdELGVBQWVELFVBQVUrRDs0QkFDNUQ7d0JBQ0Y7d0JBRUEsSUFBSUcsbUJBQW1CUCxVQUFVUSxJQUFJLENBQUMsTUFBTTt3QkFDNUNELGlCQUFpQk4sVUFBVSxHQUFHRCxVQUFVUSxJQUFJLENBQUMsTUFBTTt3QkFFbkQsT0FBT0Q7b0JBQ1Q7b0JBRUEsU0FBUzdDLDJCQUEyQitDLFlBQVk7d0JBQzlDLFNBQVNaLFNBQVNLLEtBQUssRUFBRUMsUUFBUSxFQUFFN0QsYUFBYSxFQUFFRCxRQUFRLEVBQUUrRCxZQUFZLEVBQUVDLE1BQU07NEJBQzlFLElBQUlLLFlBQVlSLEtBQUssQ0FBQ0MsU0FBUzs0QkFDL0IsSUFBSVEsV0FBV0MsWUFBWUY7NEJBQzNCLElBQUlDLGFBQWFGLGNBQWM7Z0NBQzdCLHFFQUFxRTtnQ0FDckUsd0VBQXdFO2dDQUN4RSxzQkFBc0I7Z0NBQ3RCLElBQUlJLGNBQWNDLGVBQWVKO2dDQUVqQyxPQUFPLElBQUloQixjQUNULGFBQWFyRCxXQUFXLE9BQU8rRCxlQUFlLGVBQWdCLE9BQU1TLGNBQWMsb0JBQW9CdkUsZ0JBQWdCLGNBQWEsSUFBTSxPQUFNbUUsZUFBZSxJQUFHLEdBQ2pLO29DQUFDQSxjQUFjQTtnQ0FBWTs0QkFFL0I7NEJBQ0EsT0FBTzt3QkFDVDt3QkFDQSxPQUFPYiwyQkFBMkJDO29CQUNwQztvQkFFQSxTQUFTMUI7d0JBQ1AsT0FBT3lCLDJCQUEyQi9DO29CQUNwQztvQkFFQSxTQUFTd0IseUJBQXlCMEMsV0FBVzt3QkFDM0MsU0FBU2xCLFNBQVNLLEtBQUssRUFBRUMsUUFBUSxFQUFFN0QsYUFBYSxFQUFFRCxRQUFRLEVBQUUrRCxZQUFZOzRCQUN0RSxJQUFJLE9BQU9XLGdCQUFnQixZQUFZO2dDQUNyQyxPQUFPLElBQUlyQixjQUFjLGVBQWVVLGVBQWUscUJBQXFCOUQsZ0JBQWdCOzRCQUM5Rjs0QkFDQSxJQUFJb0UsWUFBWVIsS0FBSyxDQUFDQyxTQUFTOzRCQUMvQixJQUFJLENBQUNhLE1BQU1DLE9BQU8sQ0FBQ1AsWUFBWTtnQ0FDN0IsSUFBSUMsV0FBV0MsWUFBWUY7Z0NBQzNCLE9BQU8sSUFBSWhCLGNBQWMsYUFBYXJELFdBQVcsT0FBTytELGVBQWUsZUFBZ0IsT0FBTU8sV0FBVyxvQkFBb0JyRSxnQkFBZ0IsdUJBQXNCOzRCQUNwSzs0QkFDQSxJQUFLLElBQUkvQixJQUFJLEdBQUdBLElBQUltRyxVQUFVbkosTUFBTSxFQUFFZ0QsSUFBSztnQ0FDekMsSUFBSXlCLFFBQVErRSxZQUFZTCxXQUFXbkcsR0FBRytCLGVBQWVELFVBQVUrRCxlQUFlLE1BQU03RixJQUFJLEtBQUttQjtnQ0FDN0YsSUFBSU0saUJBQWlCQyxPQUFPO29DQUMxQixPQUFPRDtnQ0FDVDs0QkFDRjs0QkFDQSxPQUFPO3dCQUNUO3dCQUNBLE9BQU80RCwyQkFBMkJDO29CQUNwQztvQkFFQSxTQUFTdEI7d0JBQ1AsU0FBU3NCLFNBQVNLLEtBQUssRUFBRUMsUUFBUSxFQUFFN0QsYUFBYSxFQUFFRCxRQUFRLEVBQUUrRCxZQUFZOzRCQUN0RSxJQUFJTSxZQUFZUixLQUFLLENBQUNDLFNBQVM7NEJBQy9CLElBQUksQ0FBQ3JELGVBQWU0RCxZQUFZO2dDQUM5QixJQUFJQyxXQUFXQyxZQUFZRjtnQ0FDM0IsT0FBTyxJQUFJaEIsY0FBYyxhQUFhckQsV0FBVyxPQUFPK0QsZUFBZSxlQUFnQixPQUFNTyxXQUFXLG9CQUFvQnJFLGdCQUFnQixvQ0FBbUM7NEJBQ2pMOzRCQUNBLE9BQU87d0JBQ1Q7d0JBQ0EsT0FBT3NELDJCQUEyQkM7b0JBQ3BDO29CQUVBLFNBQVNwQjt3QkFDUCxTQUFTb0IsU0FBU0ssS0FBSyxFQUFFQyxRQUFRLEVBQUU3RCxhQUFhLEVBQUVELFFBQVEsRUFBRStELFlBQVk7NEJBQ3RFLElBQUlNLFlBQVlSLEtBQUssQ0FBQ0MsU0FBUzs0QkFDL0IsSUFBSSxDQUFDdkQsUUFBUXNFLGtCQUFrQixDQUFDUixZQUFZO2dDQUMxQyxJQUFJQyxXQUFXQyxZQUFZRjtnQ0FDM0IsT0FBTyxJQUFJaEIsY0FBYyxhQUFhckQsV0FBVyxPQUFPK0QsZUFBZSxlQUFnQixPQUFNTyxXQUFXLG9CQUFvQnJFLGdCQUFnQix5Q0FBd0M7NEJBQ3RMOzRCQUNBLE9BQU87d0JBQ1Q7d0JBQ0EsT0FBT3NELDJCQUEyQkM7b0JBQ3BDO29CQUVBLFNBQVNsQiwwQkFBMEJ3QyxhQUFhO3dCQUM5QyxTQUFTdEIsU0FBU0ssS0FBSyxFQUFFQyxRQUFRLEVBQUU3RCxhQUFhLEVBQUVELFFBQVEsRUFBRStELFlBQVk7NEJBQ3RFLElBQUksQ0FBRUYsQ0FBQUEsS0FBSyxDQUFDQyxTQUFTLFlBQVlnQixhQUFZLEdBQUk7Z0NBQy9DLElBQUlDLG9CQUFvQkQsY0FBY2pKLElBQUksSUFBSXFGO2dDQUM5QyxJQUFJOEQsa0JBQWtCQyxhQUFhcEIsS0FBSyxDQUFDQyxTQUFTO2dDQUNsRCxPQUFPLElBQUlULGNBQWMsYUFBYXJELFdBQVcsT0FBTytELGVBQWUsZUFBZ0IsT0FBTWlCLGtCQUFrQixvQkFBb0IvRSxnQkFBZ0IsY0FBYSxJQUFNLG1CQUFrQjhFLG9CQUFvQixJQUFHOzRCQUNqTjs0QkFDQSxPQUFPO3dCQUNUO3dCQUNBLE9BQU94QiwyQkFBMkJDO29CQUNwQztvQkFFQSxTQUFTWixzQkFBc0JzQyxjQUFjO3dCQUMzQyxJQUFJLENBQUNQLE1BQU1DLE9BQU8sQ0FBQ00saUJBQWlCOzRCQUNsQyxJQUFJLElBQUksRUFBRTtnQ0FDUixJQUFJaEcsVUFBVWhFLE1BQU0sR0FBRyxHQUFHO29DQUN4QmtFLGFBQ0UsaUVBQWlFRixVQUFVaEUsTUFBTSxHQUFHLGlCQUNwRjtnQ0FFSixPQUFPO29DQUNMa0UsYUFBYTtnQ0FDZjs0QkFDRjs0QkFDQSxPQUFPb0I7d0JBQ1Q7d0JBRUEsU0FBU2dELFNBQVNLLEtBQUssRUFBRUMsUUFBUSxFQUFFN0QsYUFBYSxFQUFFRCxRQUFRLEVBQUUrRCxZQUFZOzRCQUN0RSxJQUFJTSxZQUFZUixLQUFLLENBQUNDLFNBQVM7NEJBQy9CLElBQUssSUFBSTVGLElBQUksR0FBR0EsSUFBSWdILGVBQWVoSyxNQUFNLEVBQUVnRCxJQUFLO2dDQUM5QyxJQUFJaUYsR0FBR2tCLFdBQVdhLGNBQWMsQ0FBQ2hILEVBQUUsR0FBRztvQ0FDcEMsT0FBTztnQ0FDVDs0QkFDRjs0QkFFQSxJQUFJaUgsZUFBZUMsS0FBS0MsU0FBUyxDQUFDSCxnQkFBZ0IsU0FBU0ksU0FBU25HLEdBQUcsRUFBRXBGLEtBQUs7Z0NBQzVFLElBQUlSLE9BQU9rTCxlQUFlMUs7Z0NBQzFCLElBQUlSLFNBQVMsVUFBVTtvQ0FDckIsT0FBTzBCLE9BQU9sQjtnQ0FDaEI7Z0NBQ0EsT0FBT0E7NEJBQ1Q7NEJBQ0EsT0FBTyxJQUFJc0osY0FBYyxhQUFhckQsV0FBVyxPQUFPK0QsZUFBZSxpQkFBaUI5SSxPQUFPb0osYUFBYSxPQUFRLG1CQUFrQnBFLGdCQUFnQix3QkFBd0JrRixlQUFlLEdBQUU7d0JBQ2pNO3dCQUNBLE9BQU81QiwyQkFBMkJDO29CQUNwQztvQkFFQSxTQUFTZCwwQkFBMEJnQyxXQUFXO3dCQUM1QyxTQUFTbEIsU0FBU0ssS0FBSyxFQUFFQyxRQUFRLEVBQUU3RCxhQUFhLEVBQUVELFFBQVEsRUFBRStELFlBQVk7NEJBQ3RFLElBQUksT0FBT1csZ0JBQWdCLFlBQVk7Z0NBQ3JDLE9BQU8sSUFBSXJCLGNBQWMsZUFBZVUsZUFBZSxxQkFBcUI5RCxnQkFBZ0I7NEJBQzlGOzRCQUNBLElBQUlvRSxZQUFZUixLQUFLLENBQUNDLFNBQVM7NEJBQy9CLElBQUlRLFdBQVdDLFlBQVlGOzRCQUMzQixJQUFJQyxhQUFhLFVBQVU7Z0NBQ3pCLE9BQU8sSUFBSWpCLGNBQWMsYUFBYXJELFdBQVcsT0FBTytELGVBQWUsZUFBZ0IsT0FBTU8sV0FBVyxvQkFBb0JyRSxnQkFBZ0Isd0JBQXVCOzRCQUNySzs0QkFDQSxJQUFLLElBQUlkLE9BQU9rRixVQUFXO2dDQUN6QixJQUFJOUUsSUFBSThFLFdBQVdsRixNQUFNO29DQUN2QixJQUFJUSxRQUFRK0UsWUFBWUwsV0FBV2xGLEtBQUtjLGVBQWVELFVBQVUrRCxlQUFlLE1BQU01RSxLQUFLRTtvQ0FDM0YsSUFBSU0saUJBQWlCQyxPQUFPO3dDQUMxQixPQUFPRDtvQ0FDVDtnQ0FDRjs0QkFDRjs0QkFDQSxPQUFPO3dCQUNUO3dCQUNBLE9BQU80RCwyQkFBMkJDO29CQUNwQztvQkFFQSxTQUFTVix1QkFBdUJ5QyxtQkFBbUI7d0JBQ2pELElBQUksQ0FBQ1osTUFBTUMsT0FBTyxDQUFDVyxzQkFBc0I7NEJBQ3RDLEtBQUksR0FBR25HLGFBQWEsNEVBQTRFLENBQUM7NEJBQ2xHLE9BQU9vQjt3QkFDVDt3QkFFQSxJQUFLLElBQUl0QyxJQUFJLEdBQUdBLElBQUlxSCxvQkFBb0JySyxNQUFNLEVBQUVnRCxJQUFLOzRCQUNuRCxJQUFJc0gsVUFBVUQsbUJBQW1CLENBQUNySCxFQUFFOzRCQUNwQyxJQUFJLE9BQU9zSCxZQUFZLFlBQVk7Z0NBQ2pDcEcsYUFDRSx1RkFDQSxjQUFjcUcseUJBQXlCRCxXQUFXLGVBQWV0SCxJQUFJO2dDQUV2RSxPQUFPc0M7NEJBQ1Q7d0JBQ0Y7d0JBRUEsU0FBU2dELFNBQVNLLEtBQUssRUFBRUMsUUFBUSxFQUFFN0QsYUFBYSxFQUFFRCxRQUFRLEVBQUUrRCxZQUFZOzRCQUN0RSxJQUFJMkIsZ0JBQWdCLEVBQUU7NEJBQ3RCLElBQUssSUFBSXhILElBQUksR0FBR0EsSUFBSXFILG9CQUFvQnJLLE1BQU0sRUFBRWdELElBQUs7Z0NBQ25ELElBQUlzSCxVQUFVRCxtQkFBbUIsQ0FBQ3JILEVBQUU7Z0NBQ3BDLElBQUl5SCxnQkFBZ0JILFFBQVEzQixPQUFPQyxVQUFVN0QsZUFBZUQsVUFBVStELGNBQWMxRTtnQ0FDcEYsSUFBSXNHLGlCQUFpQixNQUFNO29DQUN6QixPQUFPO2dDQUNUO2dDQUNBLElBQUlBLGNBQWNyQyxJQUFJLElBQUkvRCxJQUFJb0csY0FBY3JDLElBQUksRUFBRSxpQkFBaUI7b0NBQ2pFb0MsY0FBY0UsSUFBSSxDQUFDRCxjQUFjckMsSUFBSSxDQUFDYyxZQUFZO2dDQUNwRDs0QkFDRjs0QkFDQSxJQUFJeUIsdUJBQXVCLGNBQWUzSyxNQUFNLEdBQUcsSUFBSyw2QkFBNkJ3SyxjQUFjcEgsSUFBSSxDQUFDLFFBQVEsTUFBSzs0QkFDckgsT0FBTyxJQUFJK0UsY0FBYyxhQUFhckQsV0FBVyxPQUFPK0QsZUFBZSxtQkFBb0IsT0FBTTlELGdCQUFnQixNQUFNNEYsdUJBQXVCLEdBQUU7d0JBQ2xKO3dCQUNBLE9BQU90QywyQkFBMkJDO29CQUNwQztvQkFFQSxTQUFTaEI7d0JBQ1AsU0FBU2dCLFNBQVNLLEtBQUssRUFBRUMsUUFBUSxFQUFFN0QsYUFBYSxFQUFFRCxRQUFRLEVBQUUrRCxZQUFZOzRCQUN0RSxJQUFJLENBQUMrQixPQUFPakMsS0FBSyxDQUFDQyxTQUFTLEdBQUc7Z0NBQzVCLE9BQU8sSUFBSVQsY0FBYyxhQUFhckQsV0FBVyxPQUFPK0QsZUFBZSxtQkFBb0IsT0FBTTlELGdCQUFnQiwwQkFBeUI7NEJBQzVJOzRCQUNBLE9BQU87d0JBQ1Q7d0JBQ0EsT0FBT3NELDJCQUEyQkM7b0JBQ3BDO29CQUVBLFNBQVN1QyxzQkFBc0I5RixhQUFhLEVBQUVELFFBQVEsRUFBRStELFlBQVksRUFBRTVFLEdBQUcsRUFBRTVGLElBQUk7d0JBQzdFLE9BQU8sSUFBSThKLGNBQ1QsQ0FBQ3BELGlCQUFpQixhQUFZLElBQUssT0FBT0QsV0FBVyxZQUFZK0QsZUFBZSxNQUFNNUUsTUFBTSxtQkFDNUYsaUZBQWlGNUYsT0FBTztvQkFFNUY7b0JBRUEsU0FBU3lKLHVCQUF1QmdELFVBQVU7d0JBQ3hDLFNBQVN4QyxTQUFTSyxLQUFLLEVBQUVDLFFBQVEsRUFBRTdELGFBQWEsRUFBRUQsUUFBUSxFQUFFK0QsWUFBWTs0QkFDdEUsSUFBSU0sWUFBWVIsS0FBSyxDQUFDQyxTQUFTOzRCQUMvQixJQUFJUSxXQUFXQyxZQUFZRjs0QkFDM0IsSUFBSUMsYUFBYSxVQUFVO2dDQUN6QixPQUFPLElBQUlqQixjQUFjLGFBQWFyRCxXQUFXLE9BQU8rRCxlQUFlLGdCQUFnQk8sV0FBVyxPQUFRLG1CQUFrQnJFLGdCQUFnQix1QkFBc0I7NEJBQ3BLOzRCQUNBLElBQUssSUFBSWQsT0FBTzZHLFdBQVk7Z0NBQzFCLElBQUlSLFVBQVVRLFVBQVUsQ0FBQzdHLElBQUk7Z0NBQzdCLElBQUksT0FBT3FHLFlBQVksWUFBWTtvQ0FDakMsT0FBT08sc0JBQXNCOUYsZUFBZUQsVUFBVStELGNBQWM1RSxLQUFLc0YsZUFBZWU7Z0NBQzFGO2dDQUNBLElBQUk3RixRQUFRNkYsUUFBUW5CLFdBQVdsRixLQUFLYyxlQUFlRCxVQUFVK0QsZUFBZSxNQUFNNUUsS0FBS0U7Z0NBQ3ZGLElBQUlNLE9BQU87b0NBQ1QsT0FBT0E7Z0NBQ1Q7NEJBQ0Y7NEJBQ0EsT0FBTzt3QkFDVDt3QkFDQSxPQUFPNEQsMkJBQTJCQztvQkFDcEM7b0JBRUEsU0FBU04sNkJBQTZCOEMsVUFBVTt3QkFDOUMsU0FBU3hDLFNBQVNLLEtBQUssRUFBRUMsUUFBUSxFQUFFN0QsYUFBYSxFQUFFRCxRQUFRLEVBQUUrRCxZQUFZOzRCQUN0RSxJQUFJTSxZQUFZUixLQUFLLENBQUNDLFNBQVM7NEJBQy9CLElBQUlRLFdBQVdDLFlBQVlGOzRCQUMzQixJQUFJQyxhQUFhLFVBQVU7Z0NBQ3pCLE9BQU8sSUFBSWpCLGNBQWMsYUFBYXJELFdBQVcsT0FBTytELGVBQWUsZ0JBQWdCTyxXQUFXLE9BQVEsbUJBQWtCckUsZ0JBQWdCLHVCQUFzQjs0QkFDcEs7NEJBQ0EsOEVBQThFOzRCQUM5RSxJQUFJZ0csVUFBVW5JLE9BQU8sQ0FBQyxHQUFHK0YsS0FBSyxDQUFDQyxTQUFTLEVBQUVrQzs0QkFDMUMsSUFBSyxJQUFJN0csT0FBTzhHLFFBQVM7Z0NBQ3ZCLElBQUlULFVBQVVRLFVBQVUsQ0FBQzdHLElBQUk7Z0NBQzdCLElBQUlJLElBQUl5RyxZQUFZN0csUUFBUSxPQUFPcUcsWUFBWSxZQUFZO29DQUN6RCxPQUFPTyxzQkFBc0I5RixlQUFlRCxVQUFVK0QsY0FBYzVFLEtBQUtzRixlQUFlZTtnQ0FDMUY7Z0NBQ0EsSUFBSSxDQUFDQSxTQUFTO29DQUNaLE9BQU8sSUFBSW5DLGNBQ1QsYUFBYXJELFdBQVcsT0FBTytELGVBQWUsWUFBWTVFLE1BQU0sb0JBQW9CYyxnQkFBZ0IsT0FDcEcsbUJBQW1CbUYsS0FBS0MsU0FBUyxDQUFDeEIsS0FBSyxDQUFDQyxTQUFTLEVBQUUsTUFBTSxRQUN6RCxtQkFBbUJzQixLQUFLQyxTQUFTLENBQUNoSSxPQUFPcUIsSUFBSSxDQUFDc0gsYUFBYSxNQUFNO2dDQUVyRTtnQ0FDQSxJQUFJckcsUUFBUTZGLFFBQVFuQixXQUFXbEYsS0FBS2MsZUFBZUQsVUFBVStELGVBQWUsTUFBTTVFLEtBQUtFO2dDQUN2RixJQUFJTSxPQUFPO29DQUNULE9BQU9BO2dDQUNUOzRCQUNGOzRCQUNBLE9BQU87d0JBQ1Q7d0JBRUEsT0FBTzRELDJCQUEyQkM7b0JBQ3BDO29CQUVBLFNBQVNzQyxPQUFPekIsU0FBUzt3QkFDdkIsT0FBUSxPQUFPQTs0QkFDYixLQUFLOzRCQUNMLEtBQUs7NEJBQ0wsS0FBSztnQ0FDSCxPQUFPOzRCQUNULEtBQUs7Z0NBQ0gsT0FBTyxDQUFDQTs0QkFDVixLQUFLO2dDQUNILElBQUlNLE1BQU1DLE9BQU8sQ0FBQ1AsWUFBWTtvQ0FDNUIsT0FBT0EsVUFBVTNLLEtBQUssQ0FBQ29NO2dDQUN6QjtnQ0FDQSxJQUFJekIsY0FBYyxRQUFRNUQsZUFBZTRELFlBQVk7b0NBQ25ELE9BQU87Z0NBQ1Q7Z0NBRUEsSUFBSXBELGFBQWFGLGNBQWNzRDtnQ0FDL0IsSUFBSXBELFlBQVk7b0NBQ2QsSUFBSUosV0FBV0ksV0FBV3RFLElBQUksQ0FBQzBIO29DQUMvQixJQUFJNkI7b0NBQ0osSUFBSWpGLGVBQWVvRCxVQUFVOEIsT0FBTyxFQUFFO3dDQUNwQyxNQUFPLENBQUMsQ0FBQ0QsT0FBT3JGLFNBQVN1RixJQUFJLEVBQUMsRUFBR0MsSUFBSSxDQUFFOzRDQUNyQyxJQUFJLENBQUNQLE9BQU9JLEtBQUtuTSxLQUFLLEdBQUc7Z0RBQ3ZCLE9BQU87NENBQ1Q7d0NBQ0Y7b0NBQ0YsT0FBTzt3Q0FDTCwrREFBK0Q7d0NBQy9ELE1BQU8sQ0FBQyxDQUFDbU0sT0FBT3JGLFNBQVN1RixJQUFJLEVBQUMsRUFBR0MsSUFBSSxDQUFFOzRDQUNyQyxJQUFJQyxRQUFRSixLQUFLbk0sS0FBSzs0Q0FDdEIsSUFBSXVNLE9BQU87Z0RBQ1QsSUFBSSxDQUFDUixPQUFPUSxLQUFLLENBQUMsRUFBRSxHQUFHO29EQUNyQixPQUFPO2dEQUNUOzRDQUNGO3dDQUNGO29DQUNGO2dDQUNGLE9BQU87b0NBQ0wsT0FBTztnQ0FDVDtnQ0FFQSxPQUFPOzRCQUNUO2dDQUNFLE9BQU87d0JBQ1g7b0JBQ0Y7b0JBRUEsU0FBU0MsU0FBU2pDLFFBQVEsRUFBRUQsU0FBUzt3QkFDbkMsaUJBQWlCO3dCQUNqQixJQUFJQyxhQUFhLFVBQVU7NEJBQ3pCLE9BQU87d0JBQ1Q7d0JBRUEsZ0NBQWdDO3dCQUNoQyxJQUFJLENBQUNELFdBQVc7NEJBQ2QsT0FBTzt3QkFDVDt3QkFFQSx3REFBd0Q7d0JBQ3hELElBQUlBLFNBQVMsQ0FBQyxnQkFBZ0IsS0FBSyxVQUFVOzRCQUMzQyxPQUFPO3dCQUNUO3dCQUVBLGdFQUFnRTt3QkFDaEUsSUFBSSxPQUFPekQsV0FBVyxjQUFjeUQscUJBQXFCekQsUUFBUTs0QkFDL0QsT0FBTzt3QkFDVDt3QkFFQSxPQUFPO29CQUNUO29CQUVBLHlFQUF5RTtvQkFDekUsU0FBUzJELFlBQVlGLFNBQVM7d0JBQzVCLElBQUlDLFdBQVcsT0FBT0Q7d0JBQ3RCLElBQUlNLE1BQU1DLE9BQU8sQ0FBQ1AsWUFBWTs0QkFDNUIsT0FBTzt3QkFDVDt3QkFDQSxJQUFJQSxxQkFBcUJtQyxRQUFROzRCQUMvQix5RUFBeUU7NEJBQ3pFLHdFQUF3RTs0QkFDeEUsMkJBQTJCOzRCQUMzQixPQUFPO3dCQUNUO3dCQUNBLElBQUlELFNBQVNqQyxVQUFVRCxZQUFZOzRCQUNqQyxPQUFPO3dCQUNUO3dCQUNBLE9BQU9DO29CQUNUO29CQUVBLDRFQUE0RTtvQkFDNUUsb0NBQW9DO29CQUNwQyxTQUFTRyxlQUFlSixTQUFTO3dCQUMvQixJQUFJLE9BQU9BLGNBQWMsZUFBZUEsY0FBYyxNQUFNOzRCQUMxRCxPQUFPLEtBQUtBO3dCQUNkO3dCQUNBLElBQUlDLFdBQVdDLFlBQVlGO3dCQUMzQixJQUFJQyxhQUFhLFVBQVU7NEJBQ3pCLElBQUlELHFCQUFxQm9DLE1BQU07Z0NBQzdCLE9BQU87NEJBQ1QsT0FBTyxJQUFJcEMscUJBQXFCbUMsUUFBUTtnQ0FDdEMsT0FBTzs0QkFDVDt3QkFDRjt3QkFDQSxPQUFPbEM7b0JBQ1Q7b0JBRUEseUVBQXlFO29CQUN6RSw4Q0FBOEM7b0JBQzlDLFNBQVNtQix5QkFBeUIxTCxLQUFLO3dCQUNyQyxJQUFJUixPQUFPa0wsZUFBZTFLO3dCQUMxQixPQUFRUjs0QkFDTixLQUFLOzRCQUNMLEtBQUs7Z0NBQ0gsT0FBTyxRQUFRQTs0QkFDakIsS0FBSzs0QkFDTCxLQUFLOzRCQUNMLEtBQUs7Z0NBQ0gsT0FBTyxPQUFPQTs0QkFDaEI7Z0NBQ0UsT0FBT0E7d0JBQ1g7b0JBQ0Y7b0JBRUEsNENBQTRDO29CQUM1QyxTQUFTMEwsYUFBYVosU0FBUzt3QkFDN0IsSUFBSSxDQUFDQSxVQUFVcUMsV0FBVyxJQUFJLENBQUNyQyxVQUFVcUMsV0FBVyxDQUFDN0ssSUFBSSxFQUFFOzRCQUN6RCxPQUFPcUY7d0JBQ1Q7d0JBQ0EsT0FBT21ELFVBQVVxQyxXQUFXLENBQUM3SyxJQUFJO29CQUNuQztvQkFFQXNGLGVBQWVyQixjQUFjLEdBQUdBO29CQUNoQ3FCLGVBQWViLGlCQUFpQixHQUFHUixlQUFlUSxpQkFBaUI7b0JBQ25FYSxlQUFld0YsU0FBUyxHQUFHeEY7b0JBRTNCLE9BQU9BO2dCQUNUO1lBR0EsR0FBRyxHQUFHO1lBRU4sR0FBRyxHQUFHLHNDQUNOOzs0Q0FFNEMsR0FDNUMsR0FBRyxHQUFJLENBQUNsSixTQUFRaUUsMEJBQTBCZCxnQ0FBbUJBO2dCQUU3RDs7Ozs7Q0FLQyxHQUVELElBQUksSUFBSSxFQUFFO29CQUNSLElBQUltRixVQUFVbkYsZ0NBQW1CQSxDQUFDLGFBQWEsR0FBRztvQkFFbEQsaUZBQWlGO29CQUNqRixrQ0FBa0M7b0JBQ2xDLElBQUlzRixzQkFBc0I7b0JBQzFCekksUUFBT0QsT0FBTyxHQUFHb0QsZ0NBQW1CQSxDQUFDLDhCQUE4QixHQUFHLHdEQUF3RG1GLFFBQVFxRyxTQUFTLEVBQUVsRztnQkFDbkosT0FBTyxFQUFFO1lBR1QsR0FBRyxHQUFHO1lBRU4sR0FBRyxHQUFHLHlEQUNOOzsrREFFK0QsR0FDL0QsR0FBRyxHQUFJLENBQUN6STtnQkFFUjtnQkFDQTs7Ozs7Q0FLQyxHQUlELElBQUlvSCx1QkFBdUI7Z0JBRTNCcEgsUUFBT0QsT0FBTyxHQUFHcUg7WUFHakIsR0FBRyxHQUFHO1lBRU4sR0FBRyxHQUFHLHdDQUNOOzs4Q0FFOEMsR0FDOUMsR0FBRyxHQUFJLENBQUNwSDtnQkFFUkEsUUFBT0QsT0FBTyxHQUFHNk8sU0FBU2xLLElBQUksQ0FBQ3dILElBQUksQ0FBQzlHLE9BQU9DLFNBQVMsQ0FBQ3hCLGNBQWM7WUFHbkUsR0FBRyxHQUFHO1lBRU4sR0FBRyxHQUFHLHVEQUNOOzs2REFFNkQsR0FDN0QsR0FBRyxHQUFJLENBQUN2RCx5QkFBeUJQO2dCQUVqQztnQkFDQTs7Ozs7OztDQU9DLEdBTUQsSUFBSSxJQUFJLEVBQUU7b0JBQ1A7d0JBQ0g7d0JBRUEsbUZBQW1GO3dCQUNuRiw2REFBNkQ7d0JBQzdELElBQUk4TyxZQUFZLE9BQU9sRyxXQUFXLGNBQWNBLE9BQU9tRyxHQUFHO3dCQUMxRCxJQUFJQyxxQkFBcUJGLFlBQVlsRyxPQUFPbUcsR0FBRyxDQUFDLG1CQUFtQjt3QkFDbkUsSUFBSUUsb0JBQW9CSCxZQUFZbEcsT0FBT21HLEdBQUcsQ0FBQyxrQkFBa0I7d0JBQ2pFLElBQUlHLHNCQUFzQkosWUFBWWxHLE9BQU9tRyxHQUFHLENBQUMsb0JBQW9CO3dCQUNyRSxJQUFJSSx5QkFBeUJMLFlBQVlsRyxPQUFPbUcsR0FBRyxDQUFDLHVCQUF1Qjt3QkFDM0UsSUFBSUssc0JBQXNCTixZQUFZbEcsT0FBT21HLEdBQUcsQ0FBQyxvQkFBb0I7d0JBQ3JFLElBQUlNLHNCQUFzQlAsWUFBWWxHLE9BQU9tRyxHQUFHLENBQUMsb0JBQW9CO3dCQUNyRSxJQUFJTyxxQkFBcUJSLFlBQVlsRyxPQUFPbUcsR0FBRyxDQUFDLG1CQUFtQixRQUFRLDhFQUE4RTt3QkFDekoscUVBQXFFO3dCQUVyRSxJQUFJUSx3QkFBd0JULFlBQVlsRyxPQUFPbUcsR0FBRyxDQUFDLHNCQUFzQjt3QkFDekUsSUFBSVMsNkJBQTZCVixZQUFZbEcsT0FBT21HLEdBQUcsQ0FBQywyQkFBMkI7d0JBQ25GLElBQUlVLHlCQUF5QlgsWUFBWWxHLE9BQU9tRyxHQUFHLENBQUMsdUJBQXVCO3dCQUMzRSxJQUFJVyxzQkFBc0JaLFlBQVlsRyxPQUFPbUcsR0FBRyxDQUFDLG9CQUFvQjt3QkFDckUsSUFBSVksMkJBQTJCYixZQUFZbEcsT0FBT21HLEdBQUcsQ0FBQyx5QkFBeUI7d0JBQy9FLElBQUlhLGtCQUFrQmQsWUFBWWxHLE9BQU9tRyxHQUFHLENBQUMsZ0JBQWdCO3dCQUM3RCxJQUFJYyxrQkFBa0JmLFlBQVlsRyxPQUFPbUcsR0FBRyxDQUFDLGdCQUFnQjt3QkFDN0QsSUFBSWUsbUJBQW1CaEIsWUFBWWxHLE9BQU9tRyxHQUFHLENBQUMsaUJBQWlCO3dCQUMvRCxJQUFJZ0IseUJBQXlCakIsWUFBWWxHLE9BQU9tRyxHQUFHLENBQUMsdUJBQXVCO3dCQUMzRSxJQUFJaUIsdUJBQXVCbEIsWUFBWWxHLE9BQU9tRyxHQUFHLENBQUMscUJBQXFCO3dCQUN2RSxJQUFJa0IsbUJBQW1CbkIsWUFBWWxHLE9BQU9tRyxHQUFHLENBQUMsaUJBQWlCO3dCQUUvRCxTQUFTbEMsbUJBQW1CdEwsSUFBSTs0QkFDOUIsT0FBTyxPQUFPQSxTQUFTLFlBQVksT0FBT0EsU0FBUyxjQUFjLGdGQUFnRjs0QkFDakpBLFNBQVMyTix1QkFBdUIzTixTQUFTaU8sOEJBQThCak8sU0FBUzZOLHVCQUF1QjdOLFNBQVM0TiwwQkFBMEI1TixTQUFTbU8sdUJBQXVCbk8sU0FBU29PLDRCQUE0QixPQUFPcE8sU0FBUyxZQUFZQSxTQUFTLFFBQVNBLENBQUFBLEtBQUsyTyxRQUFRLEtBQUtMLG1CQUFtQnRPLEtBQUsyTyxRQUFRLEtBQUtOLG1CQUFtQnJPLEtBQUsyTyxRQUFRLEtBQUtiLHVCQUF1QjlOLEtBQUsyTyxRQUFRLEtBQUtaLHNCQUFzQi9OLEtBQUsyTyxRQUFRLEtBQUtULDBCQUEwQmxPLEtBQUsyTyxRQUFRLEtBQUtILDBCQUEwQnhPLEtBQUsyTyxRQUFRLEtBQUtGLHdCQUF3QnpPLEtBQUsyTyxRQUFRLEtBQUtELG9CQUFvQjFPLEtBQUsyTyxRQUFRLEtBQUtKLGdCQUFlO3dCQUNubUI7d0JBRUEsU0FBU0ssT0FBT3pHLE1BQU07NEJBQ3BCLElBQUksT0FBT0EsV0FBVyxZQUFZQSxXQUFXLE1BQU07Z0NBQ2pELElBQUl3RyxXQUFXeEcsT0FBT3dHLFFBQVE7Z0NBRTlCLE9BQVFBO29DQUNOLEtBQUtsQjt3Q0FDSCxJQUFJek4sT0FBT21JLE9BQU9uSSxJQUFJO3dDQUV0QixPQUFRQTs0Q0FDTixLQUFLZ087NENBQ0wsS0FBS0M7NENBQ0wsS0FBS047NENBQ0wsS0FBS0U7NENBQ0wsS0FBS0Q7NENBQ0wsS0FBS087Z0RBQ0gsT0FBT25POzRDQUVUO2dEQUNFLElBQUk2TyxlQUFlN08sUUFBUUEsS0FBSzJPLFFBQVE7Z0RBRXhDLE9BQVFFO29EQUNOLEtBQUtkO29EQUNMLEtBQUtHO29EQUNMLEtBQUtJO29EQUNMLEtBQUtEO29EQUNMLEtBQUtQO3dEQUNILE9BQU9lO29EQUVUO3dEQUNFLE9BQU9GO2dEQUNYO3dDQUVKO29DQUVGLEtBQUtqQjt3Q0FDSCxPQUFPaUI7Z0NBQ1g7NEJBQ0Y7NEJBRUEsT0FBT3ZLO3dCQUNULEVBQUUsaURBQWlEO3dCQUVuRCxJQUFJMEssWUFBWWQ7d0JBQ2hCLElBQUllLGlCQUFpQmQ7d0JBQ3JCLElBQUllLGtCQUFrQmpCO3dCQUN0QixJQUFJa0Isa0JBQWtCbkI7d0JBQ3RCLElBQUlvQixVQUFVekI7d0JBQ2QsSUFBSTBCLGFBQWFqQjt3QkFDakIsSUFBSWtCLFdBQVd6Qjt3QkFDZixJQUFJMEIsT0FBT2Y7d0JBQ1gsSUFBSWdCLE9BQU9qQjt3QkFDWCxJQUFJa0IsU0FBUzdCO3dCQUNiLElBQUk4QixXQUFXM0I7d0JBQ2YsSUFBSTRCLGFBQWE3Qjt3QkFDakIsSUFBSThCLFdBQVd2Qjt3QkFDZixJQUFJd0Isc0NBQXNDLE9BQU8saUNBQWlDO3dCQUVsRixTQUFTQyxZQUFZekgsTUFBTTs0QkFDekI7Z0NBQ0UsSUFBSSxDQUFDd0gscUNBQXFDO29DQUN4Q0Esc0NBQXNDLE1BQU0sa0RBQWtEO29DQUU5RnhKLE9BQU8sQ0FBQyxPQUFPLENBQUMsMERBQTBELCtEQUErRDtnQ0FDM0k7NEJBQ0Y7NEJBRUEsT0FBTzBKLGlCQUFpQjFILFdBQVd5RyxPQUFPekcsWUFBWTZGO3dCQUN4RDt3QkFDQSxTQUFTNkIsaUJBQWlCMUgsTUFBTTs0QkFDOUIsT0FBT3lHLE9BQU96RyxZQUFZOEY7d0JBQzVCO3dCQUNBLFNBQVM2QixrQkFBa0IzSCxNQUFNOzRCQUMvQixPQUFPeUcsT0FBT3pHLFlBQVk0Rjt3QkFDNUI7d0JBQ0EsU0FBU2dDLGtCQUFrQjVILE1BQU07NEJBQy9CLE9BQU95RyxPQUFPekcsWUFBWTJGO3dCQUM1Qjt3QkFDQSxTQUFTVCxVQUFVbEYsTUFBTTs0QkFDdkIsT0FBTyxPQUFPQSxXQUFXLFlBQVlBLFdBQVcsUUFBUUEsT0FBT3dHLFFBQVEsS0FBS2xCO3dCQUM5RTt3QkFDQSxTQUFTdUMsYUFBYTdILE1BQU07NEJBQzFCLE9BQU95RyxPQUFPekcsWUFBWStGO3dCQUM1Qjt3QkFDQSxTQUFTK0IsV0FBVzlILE1BQU07NEJBQ3hCLE9BQU95RyxPQUFPekcsWUFBWXdGO3dCQUM1Qjt3QkFDQSxTQUFTdUMsT0FBTy9ILE1BQU07NEJBQ3BCLE9BQU95RyxPQUFPekcsWUFBWW1HO3dCQUM1Qjt3QkFDQSxTQUFTNkIsT0FBT2hJLE1BQU07NEJBQ3BCLE9BQU95RyxPQUFPekcsWUFBWWtHO3dCQUM1Qjt3QkFDQSxTQUFTK0IsU0FBU2pJLE1BQU07NEJBQ3RCLE9BQU95RyxPQUFPekcsWUFBWXVGO3dCQUM1Qjt3QkFDQSxTQUFTMkMsV0FBV2xJLE1BQU07NEJBQ3hCLE9BQU95RyxPQUFPekcsWUFBWTBGO3dCQUM1Qjt3QkFDQSxTQUFTeUMsYUFBYW5JLE1BQU07NEJBQzFCLE9BQU95RyxPQUFPekcsWUFBWXlGO3dCQUM1Qjt3QkFDQSxTQUFTMkMsV0FBV3BJLE1BQU07NEJBQ3hCLE9BQU95RyxPQUFPekcsWUFBWWdHO3dCQUM1Qjt3QkFFQTFQLFNBQVFxUSxTQUFTLEdBQUdBO3dCQUNwQnJRLFNBQVFzUSxjQUFjLEdBQUdBO3dCQUN6QnRRLFNBQVF1USxlQUFlLEdBQUdBO3dCQUMxQnZRLFNBQVF3USxlQUFlLEdBQUdBO3dCQUMxQnhRLFNBQVF5USxPQUFPLEdBQUdBO3dCQUNsQnpRLFNBQVEwUSxVQUFVLEdBQUdBO3dCQUNyQjFRLFNBQVEyUSxRQUFRLEdBQUdBO3dCQUNuQjNRLFNBQVE0USxJQUFJLEdBQUdBO3dCQUNmNVEsU0FBUTZRLElBQUksR0FBR0E7d0JBQ2Y3USxTQUFROFEsTUFBTSxHQUFHQTt3QkFDakI5USxTQUFRK1EsUUFBUSxHQUFHQTt3QkFDbkIvUSxTQUFRZ1IsVUFBVSxHQUFHQTt3QkFDckJoUixTQUFRaVIsUUFBUSxHQUFHQTt3QkFDbkJqUixTQUFRbVIsV0FBVyxHQUFHQTt3QkFDdEJuUixTQUFRb1IsZ0JBQWdCLEdBQUdBO3dCQUMzQnBSLFNBQVFxUixpQkFBaUIsR0FBR0E7d0JBQzVCclIsU0FBUXNSLGlCQUFpQixHQUFHQTt3QkFDNUJ0UixTQUFRNE8sU0FBUyxHQUFHQTt3QkFDcEI1TyxTQUFRdVIsWUFBWSxHQUFHQTt3QkFDdkJ2UixTQUFRd1IsVUFBVSxHQUFHQTt3QkFDckJ4UixTQUFReVIsTUFBTSxHQUFHQTt3QkFDakJ6UixTQUFRMFIsTUFBTSxHQUFHQTt3QkFDakIxUixTQUFRMlIsUUFBUSxHQUFHQTt3QkFDbkIzUixTQUFRNFIsVUFBVSxHQUFHQTt3QkFDckI1UixTQUFRNlIsWUFBWSxHQUFHQTt3QkFDdkI3UixTQUFROFIsVUFBVSxHQUFHQTt3QkFDckI5UixTQUFRNk0sa0JBQWtCLEdBQUdBO3dCQUM3QjdNLFNBQVFtUSxNQUFNLEdBQUdBO29CQUNmO2dCQUNGO1lBR0EsR0FBRyxHQUFHO1lBRU4sR0FBRyxHQUFHLG9DQUNOOzswQ0FFMEMsR0FDMUMsR0FBRyxHQUFJLENBQUNsUSxTQUFRaUUsMEJBQTBCZCxnQ0FBbUJBO2dCQUU3RDtnQkFHQSxJQUFJLEtBQUssRUFBRSxFQUFFLE1BQU07b0JBQ2pCbkQsUUFBT0QsT0FBTyxHQUFHb0QsZ0NBQW1CQSxDQUFDLGtDQUFrQyxHQUFHO2dCQUM1RTtZQUdBLEdBQUcsR0FBRztZQUVOLEdBQUcsR0FBRyxrREFDTjs7d0RBRXdELEdBQ3hELEdBQUcsR0FBSSxDQUFDN0MseUJBQXlCNEMsMEJBQW1CQSxFQUFFQyxnQ0FBbUJBO2dCQUV6RTtnQkFDQUEsZ0NBQW1CQSxDQUFDQyxDQUFDLENBQUNGLDBCQUFtQkE7Z0JBQ3pDLGtCQUFrQixHQUFHQyxnQ0FBbUJBLENBQUNFLENBQUMsQ0FBQ0gsMEJBQW1CQSxFQUFFO29CQUNoRSxrQkFBa0IsR0FBSyxzQkFBc0IsSUFBTyxXQUFXLEdBQUc0TztvQkFDbEUsa0JBQWtCLEdBQUssdUJBQXVCLElBQU8sV0FBVyxHQUFHQztnQkFDOUM7Z0JBQ3JCLFNBQVNBLG9CQUFvQkMsSUFBSSxFQUFFQyxJQUFJO29CQUNyQyxJQUFJRCxTQUFTQyxNQUFNO3dCQUNqQixPQUFPO29CQUNUO29CQUVBLElBQUksQ0FBQ0QsUUFBUSxDQUFDQyxNQUFNO3dCQUNsQixPQUFPO29CQUNUO29CQUVBLElBQUlDLFFBQVE5TSxPQUFPcUIsSUFBSSxDQUFDdUw7b0JBQ3hCLElBQUlHLFFBQVEvTSxPQUFPcUIsSUFBSSxDQUFDd0w7b0JBQ3hCLElBQUlHLE1BQU1GLE1BQU1qUCxNQUFNO29CQUV0QixJQUFJa1AsTUFBTWxQLE1BQU0sS0FBS21QLEtBQUs7d0JBQ3hCLE9BQU87b0JBQ1Q7b0JBRUEsSUFBSyxJQUFJbk0sSUFBSSxHQUFHQSxJQUFJbU0sS0FBS25NLElBQUs7d0JBQzVCLElBQUlpQixNQUFNZ0wsS0FBSyxDQUFDak0sRUFBRTt3QkFFbEIsSUFBSStMLElBQUksQ0FBQzlLLElBQUksS0FBSytLLElBQUksQ0FBQy9LLElBQUksSUFBSSxDQUFDOUIsT0FBT0MsU0FBUyxDQUFDeEIsY0FBYyxDQUFDYSxJQUFJLENBQUN1TixNQUFNL0ssTUFBTTs0QkFDL0UsT0FBTzt3QkFDVDtvQkFDRjtvQkFFQSxPQUFPO2dCQUNUO2dCQUVBLFNBQVM0SyxtQkFBbUJPLElBQUksRUFBRUMsSUFBSTtvQkFDcEMsSUFBSUQsU0FBU0MsTUFBTTt3QkFDakIsT0FBTztvQkFDVDtvQkFFQSxJQUFJLENBQUNELFFBQVEsQ0FBQ0MsTUFBTTt3QkFDbEIsT0FBTztvQkFDVDtvQkFFQSxJQUFJRixNQUFNQyxLQUFLcFAsTUFBTTtvQkFFckIsSUFBSXFQLEtBQUtyUCxNQUFNLEtBQUttUCxLQUFLO3dCQUN2QixPQUFPO29CQUNUO29CQUVBLElBQUssSUFBSW5NLElBQUksR0FBR0EsSUFBSW1NLEtBQUtuTSxJQUFLO3dCQUM1QixJQUFJb00sSUFBSSxDQUFDcE0sRUFBRSxLQUFLcU0sSUFBSSxDQUFDck0sRUFBRSxFQUFFOzRCQUN2QixPQUFPO3dCQUNUO29CQUNGO29CQUVBLE9BQU87Z0JBQ1Q7WUFLQSxHQUFHLEdBQUc7WUFFTixHQUFHLEdBQUcsc0JBQ047OzRCQUU0QixHQUM1QixHQUFHLEdBQUksU0FBUzNGLHVCQUF1QixFQUFFUCxRQUFPLEVBQUVvRCxnQ0FBbUI7Z0JBRXJFO2dCQUVBLElBQUlvUCxTQUFTLElBQUssSUFBSSxJQUFJLENBQUNBLE1BQU0sSUFBSyxTQUFVdkwsQ0FBQyxFQUFFd0wsQ0FBQztvQkFDaEQsSUFBSUMsSUFBSSxDQUFDO29CQUNULElBQUssSUFBSUMsS0FBSzFMLEVBQUcsSUFBSTVCLE9BQU9DLFNBQVMsQ0FBQ3hCLGNBQWMsQ0FBQ2EsSUFBSSxDQUFDc0MsR0FBRzBMLE1BQU1GLEVBQUVHLE9BQU8sQ0FBQ0QsS0FBSyxHQUM5RUQsQ0FBQyxDQUFDQyxFQUFFLEdBQUcxTCxDQUFDLENBQUMwTCxFQUFFO29CQUNmLElBQUkxTCxLQUFLLFFBQVEsT0FBTzVCLE9BQU9ELHFCQUFxQixLQUFLLFlBQ3JELElBQUssSUFBSWMsSUFBSSxHQUFHeU0sSUFBSXROLE9BQU9ELHFCQUFxQixDQUFDNkIsSUFBSWYsSUFBSXlNLEVBQUV6UCxNQUFNLEVBQUVnRCxJQUFLO3dCQUNwRSxJQUFJdU0sRUFBRUcsT0FBTyxDQUFDRCxDQUFDLENBQUN6TSxFQUFFLElBQUksS0FBS2IsT0FBT0MsU0FBUyxDQUFDRSxvQkFBb0IsQ0FBQ2IsSUFBSSxDQUFDc0MsR0FBRzBMLENBQUMsQ0FBQ3pNLEVBQUUsR0FDekV3TSxDQUFDLENBQUNDLENBQUMsQ0FBQ3pNLEVBQUUsQ0FBQyxHQUFHZSxDQUFDLENBQUMwTCxDQUFDLENBQUN6TSxFQUFFLENBQUM7b0JBQ3pCO29CQUNKLE9BQU93TTtnQkFDWDtnQkFDQSxJQUFJRyxrQkFBa0IsSUFBSyxJQUFJLElBQUksQ0FBQ0EsZUFBZSxJQUFLLFNBQVVDLEdBQUc7b0JBQ2pFLE9BQU8sT0FBUUEsSUFBSUMsVUFBVSxHQUFJRCxNQUFNO3dCQUFFLFdBQVdBO29CQUFJO2dCQUM1RDtnQkFDQXpOLE9BQU8yTixjQUFjLENBQUNoVCxVQUFTLGNBQWU7b0JBQUUrQixPQUFPO2dCQUFLO2dCQUM1RCxJQUFJa1Isa0JBQWtCSixnQkFBZ0J6UCxnQ0FBbUJBLENBQUMsb0JBQW9CLEdBQUc7Z0JBQ2pGLG9JQUFvSTtnQkFDcEksSUFBSThQLGFBQWEsU0FBVUMsRUFBRTtvQkFDekIsSUFBSUMsV0FBV0QsR0FBR0MsUUFBUSxFQUFFQyxTQUFTRixHQUFHRSxNQUFNLEVBQUVDLFdBQVdILEdBQUdHLFFBQVEsRUFBRUMsV0FBV2YsT0FBT1csSUFBSTt3QkFBQzt3QkFBWTt3QkFBVTtxQkFBVztvQkFDaEksSUFBSXZPLFVBQVUsQ0FBQyxHQUFHcU8sZ0JBQWdCTyxPQUFPLEVBQUVELFVBQVVGLFFBQVFDO29CQUM3RCxJQUFJLE9BQU9GLGFBQWEsWUFBWTt3QkFDaEMsT0FBT0EsU0FBU3hPO29CQUNwQjtvQkFDQSxPQUFPQSxVQUFVd08sV0FBVztnQkFDaEM7Z0JBQ0FwVCxRQUFPLENBQUMsVUFBVSxHQUFHa1Q7WUFHckIsR0FBRyxHQUFHO1lBRU4sR0FBRyxHQUFHLG9CQUNOOzswQkFFMEIsR0FDMUIsR0FBRyxHQUFJLENBQUMzUyx5QkFBeUJQLFVBQVNvRCxnQ0FBbUJBO2dCQUU3RDtnQkFFQWlDLE9BQU8yTixjQUFjLENBQUNoVCxVQUFTLGNBQWU7b0JBQUUrQixPQUFPO2dCQUFLO2dCQUM1RCxJQUFJMFIsVUFBVXJRLGdDQUFtQkEsQ0FBQyxVQUFVLEdBQUc7Z0JBQy9DLElBQUlzUSxVQUFVLENBQUMsR0FBR0QsUUFBUUUsYUFBYSxFQUFFaE87Z0JBQ3pDM0YsUUFBTyxDQUFDLFVBQVUsR0FBRzBUO1lBR3JCLEdBQUcsR0FBRztZQUVOLEdBQUcsR0FBRyxrQkFDTjs7d0JBRXdCLEdBQ3hCLEdBQUcsR0FBSSxTQUFTblQsdUJBQXVCLEVBQUVQLFFBQU8sRUFBRW9ELGdDQUFtQjtnQkFFckU7Z0JBRUEsSUFBSXlQLGtCQUFrQixJQUFLLElBQUksSUFBSSxDQUFDQSxlQUFlLElBQUssU0FBVUMsR0FBRztvQkFDakUsT0FBTyxPQUFRQSxJQUFJQyxVQUFVLEdBQUlELE1BQU07d0JBQUUsV0FBV0E7b0JBQUk7Z0JBQzVEO2dCQUNBek4sT0FBTzJOLGNBQWMsQ0FBQ2hULFVBQVMsY0FBZTtvQkFBRStCLE9BQU87Z0JBQUs7Z0JBQzVEL0IsU0FBUTBULE9BQU8sR0FBRzFULFNBQVE0VCxPQUFPLEdBQUc1VCxTQUFRNlQsYUFBYSxHQUFHN1QsUUFBTyxDQUFDLFVBQVUsR0FBRyxLQUFLO2dCQUN0RixJQUFJaVQsa0JBQWtCSixnQkFBZ0J6UCxnQ0FBbUJBLENBQUMsb0JBQW9CLEdBQUc7Z0JBQ2pGcEQsU0FBUTZULGFBQWEsR0FBR1osZ0JBQWdCTyxPQUFPO2dCQUMvQyxJQUFJTSxjQUFjakIsZ0JBQWdCelAsZ0NBQW1CQSxDQUFDLGdCQUFnQixHQUFHO2dCQUN6RXBELFFBQU8sQ0FBQyxVQUFVLEdBQUc4VCxZQUFZTixPQUFPO2dCQUN4QyxJQUFJTyxZQUFZbEIsZ0JBQWdCelAsZ0NBQW1CQSxDQUFDLGNBQWMsR0FBRztnQkFDckVwRCxTQUFRNFQsT0FBTyxHQUFHRyxVQUFVUCxPQUFPO2dCQUNuQyxJQUFJUSxZQUFZbkIsZ0JBQWdCelAsZ0NBQW1CQSxDQUFDLGNBQWMsR0FBRztnQkFDckVwRCxTQUFRMFQsT0FBTyxHQUFHTSxVQUFVUixPQUFPO1lBR25DLEdBQUcsR0FBRztZQUVOLEdBQUcsR0FBRyx1QkFDTjs7NkJBRTZCLEdBQzdCLEdBQUcsR0FBSSxTQUFTalQsdUJBQXVCLEVBQUVQLFFBQU8sRUFBRW9ELGdDQUFtQjtnQkFFckU7Z0JBRUEsSUFBSTZRLFdBQVcsSUFBSyxJQUFJLElBQUksQ0FBQ0EsUUFBUSxJQUFLO29CQUN0Q0EsV0FBVzVPLE9BQU9TLE1BQU0sSUFBSSxTQUFTNE0sQ0FBQzt3QkFDbEMsSUFBSyxJQUFJekwsR0FBR2YsSUFBSSxHQUFHRyxJQUFJYSxVQUFVaEUsTUFBTSxFQUFFZ0QsSUFBSUcsR0FBR0gsSUFBSzs0QkFDakRlLElBQUlDLFNBQVMsQ0FBQ2hCLEVBQUU7NEJBQ2hCLElBQUssSUFBSXlNLEtBQUsxTCxFQUFHLElBQUk1QixPQUFPQyxTQUFTLENBQUN4QixjQUFjLENBQUNhLElBQUksQ0FBQ3NDLEdBQUcwTCxJQUN6REQsQ0FBQyxDQUFDQyxFQUFFLEdBQUcxTCxDQUFDLENBQUMwTCxFQUFFO3dCQUNuQjt3QkFDQSxPQUFPRDtvQkFDWDtvQkFDQSxPQUFPdUIsU0FBU0MsS0FBSyxDQUFDLElBQUksRUFBRWhOO2dCQUNoQztnQkFDQSxJQUFJc0wsU0FBUyxJQUFLLElBQUksSUFBSSxDQUFDQSxNQUFNLElBQUssU0FBVXZMLENBQUMsRUFBRXdMLENBQUM7b0JBQ2hELElBQUlDLElBQUksQ0FBQztvQkFDVCxJQUFLLElBQUlDLEtBQUsxTCxFQUFHLElBQUk1QixPQUFPQyxTQUFTLENBQUN4QixjQUFjLENBQUNhLElBQUksQ0FBQ3NDLEdBQUcwTCxNQUFNRixFQUFFRyxPQUFPLENBQUNELEtBQUssR0FDOUVELENBQUMsQ0FBQ0MsRUFBRSxHQUFHMUwsQ0FBQyxDQUFDMEwsRUFBRTtvQkFDZixJQUFJMUwsS0FBSyxRQUFRLE9BQU81QixPQUFPRCxxQkFBcUIsS0FBSyxZQUNyRCxJQUFLLElBQUljLElBQUksR0FBR3lNLElBQUl0TixPQUFPRCxxQkFBcUIsQ0FBQzZCLElBQUlmLElBQUl5TSxFQUFFelAsTUFBTSxFQUFFZ0QsSUFBSzt3QkFDcEUsSUFBSXVNLEVBQUVHLE9BQU8sQ0FBQ0QsQ0FBQyxDQUFDek0sRUFBRSxJQUFJLEtBQUtiLE9BQU9DLFNBQVMsQ0FBQ0Usb0JBQW9CLENBQUNiLElBQUksQ0FBQ3NDLEdBQUcwTCxDQUFDLENBQUN6TSxFQUFFLEdBQ3pFd00sQ0FBQyxDQUFDQyxDQUFDLENBQUN6TSxFQUFFLENBQUMsR0FBR2UsQ0FBQyxDQUFDMEwsQ0FBQyxDQUFDek0sRUFBRSxDQUFDO29CQUN6QjtvQkFDSixPQUFPd007Z0JBQ1g7Z0JBQ0EsSUFBSUcsa0JBQWtCLElBQUssSUFBSSxJQUFJLENBQUNBLGVBQWUsSUFBSyxTQUFVQyxHQUFHO29CQUNqRSxPQUFPLE9BQVFBLElBQUlDLFVBQVUsR0FBSUQsTUFBTTt3QkFBRSxXQUFXQTtvQkFBSTtnQkFDNUQ7Z0JBQ0F6TixPQUFPMk4sY0FBYyxDQUFDaFQsVUFBUyxjQUFlO29CQUFFK0IsT0FBTztnQkFBSztnQkFDNUQsSUFBSW9TLGVBQWV0QixnQkFBZ0J6UCxnQ0FBbUJBLENBQUMsZUFBZSxHQUFHO2dCQUN6RSxJQUFJZ1IsaUJBQWlCRCxhQUFhWCxPQUFPLENBQUMzSSxTQUFTLENBQUM7b0JBQ2hEc0osYUFBYVgsT0FBTyxDQUFDN0osTUFBTTtvQkFDM0J3SyxhQUFhWCxPQUFPLENBQUMvSixNQUFNO2lCQUM5QjtnQkFDRCxjQUFjO2dCQUNkLElBQUk0SyxRQUFRO29CQUNSQyxLQUFLSCxhQUFhWCxPQUFPLENBQUNqSyxJQUFJO29CQUM5QmdMLE1BQU1KLGFBQWFYLE9BQU8sQ0FBQ2pLLElBQUk7b0JBQy9CaUwsT0FBT0wsYUFBYVgsT0FBTyxDQUFDakssSUFBSTtvQkFDaENrTCxTQUFTTixhQUFhWCxPQUFPLENBQUNqSyxJQUFJO29CQUNsQ21MLFVBQVVQLGFBQWFYLE9BQU8sQ0FBQ2pLLElBQUk7b0JBQ25Db0wsT0FBT1IsYUFBYVgsT0FBTyxDQUFDakssSUFBSTtvQkFDaENxTCxZQUFZVCxhQUFhWCxPQUFPLENBQUNqSyxJQUFJO29CQUNyQ3NMLFFBQVFWLGFBQWFYLE9BQU8sQ0FBQ2pLLElBQUk7b0JBQ2pDdUwsS0FBS1gsYUFBYVgsT0FBTyxDQUFDakssSUFBSTtvQkFDOUJ3TCxJQUFJWixhQUFhWCxPQUFPLENBQUNqSyxJQUFJO29CQUM3QnlMLFVBQVViLGFBQWFYLE9BQU8sQ0FBQ2pLLElBQUk7Z0JBQ3ZDO2dCQUNBLHNDQUFzQztnQkFDdEMsSUFBSTBMLFdBQVc7b0JBQ1hDLGFBQWFmLGFBQWFYLE9BQU8sQ0FBQzdJLEtBQUssQ0FBQzt3QkFDcEM7d0JBQ0E7cUJBQ0g7b0JBQ0R3SyxNQUFNaEIsYUFBYVgsT0FBTyxDQUFDN0ksS0FBSyxDQUFDO3dCQUM3Qjt3QkFDQTtxQkFDSDtvQkFDRHlLLGFBQWFqQixhQUFhWCxPQUFPLENBQUM3SixNQUFNO29CQUN4QzBMLG1CQUFtQmxCLGFBQWFYLE9BQU8sQ0FBQzdKLE1BQU07b0JBQzlDMkwsUUFBUWxCO29CQUNSbUIsY0FBY25CO29CQUNkb0IsT0FBT3BCO29CQUNQcUIsYUFBYXJCO29CQUNic0IsT0FBT3ZCLGFBQWFYLE9BQU8sQ0FBQ2pLLElBQUk7b0JBQ2hDb00sWUFBWXhCLGFBQWFYLE9BQU8sQ0FBQ2pLLElBQUk7b0JBQ3JDcU0sWUFBWXpCLGFBQWFYLE9BQU8sQ0FBQ2pLLElBQUk7b0JBQ3JDekcsWUFBWXNSO29CQUNaN1MsTUFBTThELE9BQU9xQixJQUFJLENBQUMyTjtnQkFDdEI7Z0JBQ0EsNkRBQTZEO2dCQUM3RCxJQUFJOVMsT0FBTzBULFNBQVMxVCxJQUFJLEVBQUVzVSxrQkFBa0JyRCxPQUFPeUMsVUFFakQ7b0JBQUM7aUJBQU87Z0JBQ1YsaUJBQWlCO2dCQUNqQixJQUFJYSxXQUFXN0IsU0FBUztvQkFBRThCLGdCQUFnQjVCLGFBQWFYLE9BQU8sQ0FBQzdKLE1BQU07b0JBQUVxTSxnQkFBZ0I3QixhQUFhWCxPQUFPLENBQUM3SixNQUFNO29CQUFFc00sc0JBQXNCOUIsYUFBYVgsT0FBTyxDQUFDN0osTUFBTTtvQkFBRXVNLHNCQUFzQi9CLGFBQWFYLE9BQU8sQ0FBQzdKLE1BQU07b0JBQUV3TSxXQUFXL0I7b0JBQWdCZ0MsV0FBV2hDO29CQUFnQmlDLGlCQUFpQmpDO29CQUFnQmtDLGlCQUFpQmxDO29CQUFnQm1DLFVBQVVuQztvQkFBZ0JvQyxVQUFVcEM7b0JBQWdCcUMsZ0JBQWdCckM7b0JBQWdCc0MsZ0JBQWdCdEM7b0JBQWdCdUMsVUFBVXhDLGFBQWFYLE9BQU8sQ0FBQy9KLE1BQU07b0JBQUVtTixVQUFVekMsYUFBYVgsT0FBTyxDQUFDL0osTUFBTTtvQkFBRW9OLGVBQWUxQyxhQUFhWCxPQUFPLENBQUMvSixNQUFNO29CQUFFcU4sZUFBZTNDLGFBQWFYLE9BQU8sQ0FBQy9KLE1BQU07b0JBQUVzTixlQUFlNUMsYUFBYVgsT0FBTyxDQUFDL0osTUFBTTtvQkFBRXVOLGVBQWU3QyxhQUFhWCxPQUFPLENBQUMvSixNQUFNO29CQUFFd04sZUFBZTdDO29CQUFnQjhDLGVBQWU5QztnQkFBZSxHQUFHeUI7Z0JBQ3B3QixJQUFJdkIsTUFBTUwsU0FBU0EsU0FBUyxDQUFDLEdBQUdJLFFBQVF5QjtnQkFDeEM5VixRQUFPLENBQUMsVUFBVSxHQUFHO29CQUNqQnNVLEtBQUtBO29CQUNMRCxPQUFPQTtvQkFDUFksVUFBVUE7b0JBQ1ZhLFVBQVVBO2dCQUNkO1lBR0EsR0FBRyxHQUFHO1lBRU4sR0FBRyxHQUFHLG9CQUNOOzswQkFFMEIsR0FDMUIsR0FBRyxHQUFJLFNBQVN2Vix1QkFBdUIsRUFBRVAsUUFBTyxFQUFFb0QsZ0NBQW1CO2dCQUVyRTtnQkFFQSxJQUFJeVAsa0JBQWtCLElBQUssSUFBSSxJQUFJLENBQUNBLGVBQWUsSUFBSyxTQUFVQyxHQUFHO29CQUNqRSxPQUFPLE9BQVFBLElBQUlDLFVBQVUsR0FBSUQsTUFBTTt3QkFBRSxXQUFXQTtvQkFBSTtnQkFDNUQ7Z0JBQ0F6TixPQUFPMk4sY0FBYyxDQUFDaFQsVUFBUyxjQUFlO29CQUFFK0IsT0FBTztnQkFBSztnQkFDNUQsSUFBSW9WLHlCQUF5QnRFLGdCQUFnQnpQLGdDQUFtQkEsQ0FBQyx5QkFBeUIsR0FBRztnQkFDN0YsSUFBSWdVLGVBQWV2RSxnQkFBZ0J6UCxnQ0FBbUJBLENBQUMsaUJBQWlCLEdBQUc7Z0JBQzNFLElBQUlpVSxTQUFTLFNBQVVDLElBQUk7b0JBQUksT0FBTyxPQUFPQyxNQUFNLENBQUNEO2dCQUFPO2dCQUMzRCxJQUFJRSxTQUFTLFNBQVVDLENBQUMsRUFBRUMsQ0FBQztvQkFDdkIsSUFBSUMsVUFBVSxDQUFDLEdBQUdSLHVCQUF1QjNELE9BQU8sRUFBRWlFO29CQUNsRCxlQUFlO29CQUNmLElBQUksT0FBT0MsTUFBTSxVQUFVO3dCQUN2QkEsSUFBSSxHQUFHSCxNQUFNLENBQUNHLEdBQUc7b0JBQ3JCO29CQUNBLElBQUlBLE1BQU0sTUFBTTt3QkFDWixPQUFPQztvQkFDWDtvQkFDQSxJQUFJRCxNQUFNLE9BQU87d0JBQ2IsT0FBT0wsT0FBT007b0JBQ2xCO29CQUNBLE9BQU8sSUFBSUosTUFBTSxDQUFDSSxTQUFTLE1BQU1KLE1BQU0sQ0FBQ0csR0FBRztnQkFDL0M7Z0JBQ0EsSUFBSXBSLE9BQU8sU0FBVXNSLEtBQUs7b0JBQUksT0FBT0EsTUFBTXRSLElBQUksQ0FBQztnQkFBVTtnQkFDMUQsSUFBSXNOLFVBQVUsU0FBVWlFLEdBQUc7b0JBQ3ZCLElBQUlDLFFBQVEsRUFBRTtvQkFDZHpTLE9BQU9xQixJQUFJLENBQUMwUSxhQUFhNUQsT0FBTyxDQUFDYyxHQUFHLEVBQUU5TixPQUFPLENBQUMsU0FBVWlSLENBQUM7d0JBQ3JELElBQUlDLElBQUlHLEdBQUcsQ0FBQ0osRUFBRTt3QkFDZCxJQUFJQyxLQUFLLE1BQU07NEJBQ1hJLE1BQU1sSyxJQUFJLENBQUM0SixPQUFPQyxHQUFHQzt3QkFDekI7b0JBQ0o7b0JBQ0EsT0FBT3BSLEtBQUt3UjtnQkFDaEI7Z0JBQ0E5WCxRQUFPLENBQUMsVUFBVSxHQUFHNFQ7WUFHckIsR0FBRyxHQUFHO1lBRU4sR0FBRyxHQUFHLDBCQUNOOztnQ0FFZ0MsR0FDaEMsR0FBRyxHQUFJLFNBQVNyVCx1QkFBdUIsRUFBRVAsUUFBTyxFQUFFb0QsZ0NBQW1CO2dCQUVyRTtnQkFFQSxJQUFJeVAsa0JBQWtCLElBQUssSUFBSSxJQUFJLENBQUNBLGVBQWUsSUFBSyxTQUFVQyxHQUFHO29CQUNqRSxPQUFPLE9BQVFBLElBQUlDLFVBQVUsR0FBSUQsTUFBTTt3QkFBRSxXQUFXQTtvQkFBSTtnQkFDNUQ7Z0JBQ0F6TixPQUFPMk4sY0FBYyxDQUFDaFQsVUFBUyxjQUFlO29CQUFFK0IsT0FBTztnQkFBSztnQkFDNUQsSUFBSTBSLFVBQVVyUSxnQ0FBbUJBLENBQUMsVUFBVSxHQUFHO2dCQUMvQyxJQUFJMlUsb0JBQW9CbEYsZ0JBQWdCelAsZ0NBQW1CQSxDQUFDLG9CQUFvQixHQUFHO2dCQUNuRixJQUFJK1QseUJBQXlCdEUsZ0JBQWdCelAsZ0NBQW1CQSxDQUFDLHlCQUF5QixHQUFHO2dCQUM3RixJQUFJNFUsa0JBQWtCNVUsZ0NBQW1CQSxDQUFDLGtCQUFrQixHQUFHO2dCQUMvRCxJQUFJMlEsWUFBWWxCLGdCQUFnQnpQLGdDQUFtQkEsQ0FBQyxjQUFjLEdBQUc7Z0JBQ3JFLElBQUk0USxZQUFZbkIsZ0JBQWdCelAsZ0NBQW1CQSxDQUFDLGNBQWMsR0FBRztnQkFDckUsSUFBSTZVLFlBQVksU0FBVTFFLFFBQVE7b0JBQUksT0FBT0EsU0FBU25TLEtBQUssSUFBSSxDQUFDLEdBQUcyUyxVQUFVUCxPQUFPLEVBQUVEO2dCQUFXO2dCQUNqRyxJQUFJMkUsZ0JBQWdCLFNBQVVMLEdBQUc7b0JBQzdCLElBQUksQ0FBQ0EsS0FDRCxPQUFPbFM7b0JBQ1gsSUFBSWUsT0FBT3JCLE9BQU9xQixJQUFJLENBQUNtUjtvQkFDdkIsT0FBT25SLEtBQUt5UixNQUFNLENBQUMsU0FBVUMsTUFBTSxFQUFFalIsR0FBRzt3QkFDcENpUixNQUFNLENBQUMsQ0FBQyxHQUFHakIsdUJBQXVCM0QsT0FBTyxFQUFFck0sS0FBSyxHQUFHMFEsR0FBRyxDQUFDMVEsSUFBSTt3QkFDM0QsT0FBT2lSO29CQUNYLEdBQUcsQ0FBQztnQkFDUjtnQkFDQSxJQUFJQyxjQUFjO29CQUNkLElBQUlDLE1BQU0sQ0FBQyxHQUFHN0UsUUFBUThFLE1BQU0sRUFBRTtvQkFDN0IsSUFBRzlFLFFBQVErRSxTQUFTLEVBQUU7d0JBQ25CRixJQUFJRyxPQUFPLEdBQUc7b0JBQ2xCLEdBQUcsRUFBRTtvQkFDTCxPQUFPSCxJQUFJRyxPQUFPO2dCQUN0QjtnQkFDQSxJQUFJQyxZQUFZLFNBQVVDLGVBQWU7b0JBQ3JDLElBQUlDLG9CQUFvQixDQUFDLEdBQUduRixRQUFRb0YsVUFBVSxFQUFFN0UsVUFBVVIsT0FBTztvQkFDakUsSUFBSXNGLFlBQVk7d0JBQ1osT0FBT1osY0FBY1Msb0JBQW9CVCxjQUFjVTtvQkFDM0Q7b0JBQ0EsSUFBSXpGLEtBQUssQ0FBQyxHQUFHTSxRQUFRc0YsUUFBUSxFQUFFRCxZQUFZekYsU0FBU0YsRUFBRSxDQUFDLEVBQUUsRUFBRTZGLFlBQVk3RixFQUFFLENBQUMsRUFBRTtvQkFDM0UsSUFBR00sUUFBUStFLFNBQVMsRUFBRTt3QkFDbkIsSUFBSVMsWUFBWUg7d0JBQ2hCLElBQUksQ0FBQyxDQUFDLEdBQUdkLGdCQUFnQmhHLG1CQUFtQixFQUFFcUIsUUFBUTRGLFlBQVk7NEJBQzlERCxVQUFVQzt3QkFDZDtvQkFDSixHQUFHO3dCQUFDTjt3QkFBaUJDO3FCQUFrQjtvQkFDdkMsT0FBT3ZGO2dCQUNYO2dCQUNBLElBQUk2RixXQUFXLFNBQVUzRixRQUFRO29CQUM3QixJQUFJNEYsV0FBVzt3QkFBYyxPQUFPbEIsVUFBVTFFO29CQUFXO29CQUN6RCxJQUFJSixLQUFLLENBQUMsR0FBR00sUUFBUXNGLFFBQVEsRUFBRUksV0FBVy9YLFFBQVErUixFQUFFLENBQUMsRUFBRSxFQUFFaUcsV0FBV2pHLEVBQUUsQ0FBQyxFQUFFO29CQUN4RSxJQUFHTSxRQUFRK0UsU0FBUyxFQUFFO3dCQUNuQixJQUFJYSxXQUFXRjt3QkFDZixJQUFJL1gsVUFBVWlZLFVBQVU7NEJBQ3BCRCxTQUFTQzt3QkFDYjtvQkFDSixHQUFHO3dCQUFDOUY7cUJBQVM7b0JBQ2IsT0FBT25TO2dCQUNYO2dCQUNBLElBQUlrWSxnQkFBZ0IsU0FBVWxZLEtBQUssRUFBRWlTLE1BQU07b0JBQ3ZDLElBQUlrRyxnQkFBZ0I7d0JBQWMsT0FBTyxDQUFDLEdBQUd4QixrQkFBa0J2RSxPQUFPLEVBQUVwUyxPQUFPaVMsVUFBVSxDQUFDLEdBQUcsQ0FBQyxDQUFDQTtvQkFBUztvQkFDeEcsSUFBSUYsS0FBSyxDQUFDLEdBQUdNLFFBQVFzRixRQUFRLEVBQUVRLGdCQUFnQkMsS0FBS3JHLEVBQUUsQ0FBQyxFQUFFLEVBQUVzRyxRQUFRdEcsRUFBRSxDQUFDLEVBQUU7b0JBQ3hFLElBQUl1RyxXQUFXckI7b0JBQ2QsSUFBRzVFLFFBQVErRSxTQUFTLEVBQUU7d0JBQ25CLElBQUlrQixVQUFVOzRCQUNWLDRDQUE0Qzs0QkFDNUMsSUFBSUMsVUFBVUo7NEJBQ2RFLE1BQU1FOzRCQUNOLE9BQU87Z0NBQ0gsSUFBSUEsU0FBUztvQ0FDVEEsUUFBUTFVLE9BQU87Z0NBQ25COzRCQUNKO3dCQUNKO29CQUNKLEdBQUc7d0JBQUM3RDt3QkFBT2lTO3FCQUFPO29CQUNsQixPQUFPbUc7Z0JBQ1g7Z0JBQ0EsSUFBSUksYUFBYSxTQUFVM1ksVUFBVTtvQkFDakMsSUFBSWtTLEtBQUssQ0FBQyxHQUFHTSxRQUFRc0YsUUFBUSxFQUFFOVgsV0FBVzJELE9BQU8sR0FBR0EsVUFBVXVPLEVBQUUsQ0FBQyxFQUFFLEVBQUUwRyxhQUFhMUcsRUFBRSxDQUFDLEVBQUU7b0JBQ3RGLElBQUdNLFFBQVErRSxTQUFTLEVBQUU7d0JBQ25CLElBQUlzQixnQkFBZ0IsU0FBVUMsRUFBRTs0QkFDNUJGLFdBQVdFLEdBQUduVixPQUFPO3dCQUN6Qjt3QkFDQTNELFdBQVc2RCxXQUFXLENBQUNnVjt3QkFDdkJELFdBQVc1WSxXQUFXMkQsT0FBTzt3QkFDN0IsT0FBTzs0QkFDSDNELFdBQVcrRCxjQUFjLENBQUM4VTt3QkFDOUI7b0JBQ0osR0FBRzt3QkFBQzdZO3FCQUFXO29CQUNmLE9BQU8yRDtnQkFDWDtnQkFDQSxJQUFJaVAsZ0JBQWdCLFNBQVVOLFFBQVEsRUFBRUYsTUFBTSxFQUFFQyxRQUFRO29CQUNwRCxJQUFJMEcsaUJBQWlCdEIsVUFBVXJGO29CQUMvQixJQUFJalMsUUFBUThYLFNBQVMzRjtvQkFDckIsSUFBSSxDQUFDblMsT0FDRCxNQUFNLElBQUl3RyxNQUFNO29CQUNwQixJQUFJNFIsS0FBS0YsY0FBY2xZLE9BQU80WTtvQkFDOUIsSUFBSXBWLFVBQVVnVixXQUFXSjtvQkFDekIsSUFBSUUsV0FBV3JCO29CQUNkLElBQUc1RSxRQUFRK0UsU0FBUyxFQUFFO3dCQUNuQixJQUFJa0IsWUFBWXBHLFVBQVU7NEJBQ3RCQSxTQUFTMU87d0JBQ2I7b0JBQ0osR0FBRzt3QkFBQ0E7cUJBQVE7b0JBQ1gsSUFBRzZPLFFBQVErRSxTQUFTLEVBQUU7d0JBQWMsT0FBTzs0QkFDeEMsSUFBSWdCLElBQUk7Z0NBQ0pBLEdBQUd2VSxPQUFPOzRCQUNkO3dCQUNKO29CQUFHLEdBQUcsRUFBRTtvQkFDUixPQUFPTDtnQkFDWDtnQkFDQTVFLFFBQU8sQ0FBQyxVQUFVLEdBQUc2VDtZQUdyQixHQUFHLEdBQUc7WUFFTixHQUFHLEdBQUcsU0FDTjs7d0ZBRXdGLEdBQ3hGLEdBQUcsR0FBSSxDQUFDNVQ7Z0JBRVI7Z0JBQ0FBLFFBQU9ELE9BQU8sR0FBR0s7WUFFakIsR0FBRyxHQUFHO1FBRUk7UUFDVix3RUFBd0UsR0FDeEUsTUFBTSxHQUFJLG1CQUFtQjtRQUM3QixNQUFNLEdBQUksSUFBSTRaLDJCQUEyQixDQUFDO1FBQzFDLE1BQU0sR0FDTixNQUFNLEdBQUksdUJBQXVCO1FBQ2pDLE1BQU0sR0FBSSxTQUFTN1csZ0NBQW1CQSxDQUFDOFcsUUFBUTtZQUMvQyxNQUFNLEdBQUssOEJBQThCO1lBQ3pDLE1BQU0sR0FBSyxJQUFJQyxlQUFlRix3QkFBd0IsQ0FBQ0MsU0FBUztZQUNoRSxNQUFNLEdBQUssSUFBSUMsaUJBQWlCeFUsV0FBVztnQkFDM0MsTUFBTSxHQUFNLE9BQU93VSxhQUFhbmEsT0FBTztZQUN2QyxNQUFNLEdBQUs7WUFDWCxNQUFNLEdBQUssa0RBQWtEO1lBQzdELE1BQU0sR0FBSyxJQUFJQyxVQUFTZ2Esd0JBQXdCLENBQUNDLFNBQVMsR0FBRztnQkFDN0QsTUFBTSxHQUFNLHNCQUFzQjtnQkFDbEMsTUFBTSxHQUFNLDBCQUEwQjtnQkFDdEMsTUFBTSxHQUFNbGEsU0FBUyxDQUFDO1lBQ1g7WUFDWCxNQUFNLEdBQ04sTUFBTSxHQUFLLDhCQUE4QjtZQUN6QyxNQUFNLEdBQUtNLG1CQUFtQixDQUFDNFosU0FBUyxDQUFDdlYsSUFBSSxDQUFDMUUsUUFBT0QsT0FBTyxFQUFFQyxTQUFRQSxRQUFPRCxPQUFPLEVBQUVvRCxnQ0FBbUJBO1lBQ3pHLE1BQU0sR0FDTixNQUFNLEdBQUssbUNBQW1DO1lBQzlDLE1BQU0sR0FBSyxPQUFPbkQsUUFBT0QsT0FBTztRQUNoQyxNQUFNLEdBQUk7UUFDVixNQUFNLEdBQ04sd0VBQXdFLEdBQ3hFLE1BQU0sR0FBSSwyQ0FBMkMsR0FDckQsTUFBTSxHQUFLO1lBQ1gsTUFBTSxHQUFLLDhDQUE4QztZQUN6RCxNQUFNLEdBQUtvRCxnQ0FBbUJBLENBQUNFLENBQUMsR0FBRyxDQUFDdEQsVUFBU29hO2dCQUM3QyxNQUFNLEdBQU0sSUFBSSxJQUFJalQsT0FBT2lULFdBQVk7b0JBQ3ZDLE1BQU0sR0FBTyxJQUFHaFgsZ0NBQW1CQSxDQUFDaVgsQ0FBQyxDQUFDRCxZQUFZalQsUUFBUSxDQUFDL0QsZ0NBQW1CQSxDQUFDaVgsQ0FBQyxDQUFDcmEsVUFBU21ILE1BQU07d0JBQ2hHLE1BQU0sR0FBUTlCLE9BQU8yTixjQUFjLENBQUNoVCxVQUFTbUgsS0FBSzs0QkFBRW1ULFlBQVk7NEJBQU1DLEtBQUtILFVBQVUsQ0FBQ2pULElBQUk7d0JBQUM7b0JBQzNGLE1BQU0sR0FBTztnQkFDYixNQUFNLEdBQU07WUFDWixNQUFNLEdBQUs7UUFDWCxNQUFNLEdBQUk7UUFDVixNQUFNLEdBQ04sTUFBTSxHQUFJLDRDQUE0QyxHQUN0RCxNQUFNLEdBQUs7WUFDWCxNQUFNLEdBQUsvRCxnQ0FBbUJBLENBQUNpWCxDQUFDLEdBQUcsQ0FBQ3hDLEtBQUsyQyxPQUFVblYsT0FBT0MsU0FBUyxDQUFDeEIsY0FBYyxDQUFDYSxJQUFJLENBQUNrVCxLQUFLMkM7UUFDN0YsTUFBTSxHQUFJO1FBQ1YsTUFBTSxHQUNOLE1BQU0sR0FBSSx5Q0FBeUMsR0FDbkQsTUFBTSxHQUFLO1lBQ1gsTUFBTSxHQUFLLCtCQUErQjtZQUMxQyxNQUFNLEdBQUtwWCxnQ0FBbUJBLENBQUNDLENBQUMsR0FBRyxDQUFDckQ7Z0JBQ3BDLE1BQU0sR0FBTSxJQUFHLE9BQU80SSxXQUFXLGVBQWVBLE9BQU82UixXQUFXLEVBQUU7b0JBQ3BFLE1BQU0sR0FBT3BWLE9BQU8yTixjQUFjLENBQUNoVCxVQUFTNEksT0FBTzZSLFdBQVcsRUFBRTt3QkFBRTFZLE9BQU87b0JBQVM7Z0JBQ2xGLE1BQU0sR0FBTTtnQkFDWixNQUFNLEdBQU1zRCxPQUFPMk4sY0FBYyxDQUFDaFQsVUFBUyxjQUFjO29CQUFFK0IsT0FBTztnQkFBSztZQUN2RSxNQUFNLEdBQUs7UUFDWCxNQUFNLEdBQUk7UUFDVixNQUFNLEdBQ04sd0VBQXdFLEdBQ3hFLE1BQU0sR0FDTixNQUFNLEdBQUksVUFBVTtRQUNwQixNQUFNLEdBQUksdUNBQXVDO1FBQ2pELE1BQU0sR0FBSSwwRUFBMEU7UUFDcEYsTUFBTSxHQUFJLElBQUlvQiwwQkFBbUJBLEdBQUdDLGdDQUFtQkEsQ0FBQztRQUN4RCxNQUFNLEdBQ04sTUFBTSxHQUFJLE9BQU9ELDBCQUFtQkE7SUFDcEMsTUFBTSxHQUFHO0FBRVQsSUFDQSw0Q0FBNEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9taGFkcmktZmluYWwtbmV4dGpzLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXJlc3BvbnNpdmUvZGlzdC9yZWFjdC1yZXNwb25zaXZlLmpzPzI1MzIiXSwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKVxuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKFwicmVhY3RcIikpO1xuXHRlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcblx0XHRkZWZpbmUoW1wicmVhY3RcIl0sIGZhY3RvcnkpO1xuXHRlbHNlIGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jylcblx0XHRleHBvcnRzW1wiTWVkaWFRdWVyeVwiXSA9IGZhY3RvcnkocmVxdWlyZShcInJlYWN0XCIpKTtcblx0ZWxzZVxuXHRcdHJvb3RbXCJNZWRpYVF1ZXJ5XCJdID0gZmFjdG9yeShyb290W1wiUmVhY3RcIl0pO1xufSkodGhpcywgKF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfcmVhY3RfXykgPT4ge1xucmV0dXJuIC8qKioqKiovICgoKSA9PiB7IC8vIHdlYnBhY2tCb290c3RyYXBcbi8qKioqKiovIFx0dmFyIF9fd2VicGFja19tb2R1bGVzX18gPSAoe1xuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL2Nzcy1tZWRpYXF1ZXJ5L2luZGV4LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2Nzcy1tZWRpYXF1ZXJ5L2luZGV4LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qXG5Db3B5cmlnaHQgKGMpIDIwMTQsIFlhaG9vISBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5Db3B5cmlnaHRzIGxpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIExpY2Vuc2UuXG5TZWUgdGhlIGFjY29tcGFueWluZyBMSUNFTlNFIGZpbGUgZm9yIHRlcm1zLlxuKi9cblxuXG5cbmV4cG9ydHMubWF0Y2ggPSBtYXRjaFF1ZXJ5O1xuZXhwb3J0cy5wYXJzZSA9IHBhcnNlUXVlcnk7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbnZhciBSRV9NRURJQV9RVUVSWSAgICAgPSAvKD86KG9ubHl8bm90KT9cXHMqKFteXFxzXFwoXFwpXSspKD86XFxzKmFuZCk/XFxzKik/KC4rKT8vaSxcbiAgICBSRV9NUV9FWFBSRVNTSU9OICAgPSAvXFwoXFxzKihbXlxcc1xcOlxcKV0rKVxccyooPzpcXDpcXHMqKFteXFxzXFwpXSspKT9cXHMqXFwpLyxcbiAgICBSRV9NUV9GRUFUVVJFICAgICAgPSAvXig/OihtaW58bWF4KS0pPyguKykvLFxuICAgIFJFX0xFTkdUSF9VTklUICAgICA9IC8oZW18cmVtfHB4fGNtfG1tfGlufHB0fHBjKT8kLyxcbiAgICBSRV9SRVNPTFVUSU9OX1VOSVQgPSAvKGRwaXxkcGNtfGRwcHgpPyQvO1xuXG5mdW5jdGlvbiBtYXRjaFF1ZXJ5KG1lZGlhUXVlcnksIHZhbHVlcykge1xuICAgIHJldHVybiBwYXJzZVF1ZXJ5KG1lZGlhUXVlcnkpLnNvbWUoZnVuY3Rpb24gKHF1ZXJ5KSB7XG4gICAgICAgIHZhciBpbnZlcnNlID0gcXVlcnkuaW52ZXJzZTtcblxuICAgICAgICAvLyBFaXRoZXIgdGhlIHBhcnNlZCBvciBzcGVjaWZpZWQgYHR5cGVgIGlzIFwiYWxsXCIsIG9yIHRoZSB0eXBlcyBtdXN0IGJlXG4gICAgICAgIC8vIGVxdWFsIGZvciBhIG1hdGNoLlxuICAgICAgICB2YXIgdHlwZU1hdGNoID0gcXVlcnkudHlwZSA9PT0gJ2FsbCcgfHwgdmFsdWVzLnR5cGUgPT09IHF1ZXJ5LnR5cGU7XG5cbiAgICAgICAgLy8gUXVpdCBlYXJseSB3aGVuIGB0eXBlYCBkb2Vzbid0IG1hdGNoLCBidXQgdGFrZSBcIm5vdFwiIGludG8gYWNjb3VudC5cbiAgICAgICAgaWYgKCh0eXBlTWF0Y2ggJiYgaW52ZXJzZSkgfHwgISh0eXBlTWF0Y2ggfHwgaW52ZXJzZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBleHByZXNzaW9uc01hdGNoID0gcXVlcnkuZXhwcmVzc2lvbnMuZXZlcnkoZnVuY3Rpb24gKGV4cHJlc3Npb24pIHtcbiAgICAgICAgICAgIHZhciBmZWF0dXJlICA9IGV4cHJlc3Npb24uZmVhdHVyZSxcbiAgICAgICAgICAgICAgICBtb2RpZmllciA9IGV4cHJlc3Npb24ubW9kaWZpZXIsXG4gICAgICAgICAgICAgICAgZXhwVmFsdWUgPSBleHByZXNzaW9uLnZhbHVlLFxuICAgICAgICAgICAgICAgIHZhbHVlICAgID0gdmFsdWVzW2ZlYXR1cmVdO1xuXG4gICAgICAgICAgICAvLyBNaXNzaW5nIG9yIGZhbHN5IHZhbHVlcyBkb24ndCBtYXRjaC5cbiAgICAgICAgICAgIGlmICghdmFsdWUpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgICAgICAgICAgIHN3aXRjaCAoZmVhdHVyZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ29yaWVudGF0aW9uJzpcbiAgICAgICAgICAgICAgICBjYXNlICdzY2FuJzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlLnRvTG93ZXJDYXNlKCkgPT09IGV4cFZhbHVlLnRvTG93ZXJDYXNlKCk7XG5cbiAgICAgICAgICAgICAgICBjYXNlICd3aWR0aCc6XG4gICAgICAgICAgICAgICAgY2FzZSAnaGVpZ2h0JzpcbiAgICAgICAgICAgICAgICBjYXNlICdkZXZpY2Utd2lkdGgnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2RldmljZS1oZWlnaHQnOlxuICAgICAgICAgICAgICAgICAgICBleHBWYWx1ZSA9IHRvUHgoZXhwVmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSAgICA9IHRvUHgodmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGNhc2UgJ3Jlc29sdXRpb24nOlxuICAgICAgICAgICAgICAgICAgICBleHBWYWx1ZSA9IHRvRHBpKGV4cFZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgICAgPSB0b0RwaSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgY2FzZSAnYXNwZWN0LXJhdGlvJzpcbiAgICAgICAgICAgICAgICBjYXNlICdkZXZpY2UtYXNwZWN0LXJhdGlvJzpcbiAgICAgICAgICAgICAgICBjYXNlIC8qIERlcHJlY2F0ZWQgKi8gJ2RldmljZS1waXhlbC1yYXRpbyc6XG4gICAgICAgICAgICAgICAgICAgIGV4cFZhbHVlID0gdG9EZWNpbWFsKGV4cFZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgICAgPSB0b0RlY2ltYWwodmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGNhc2UgJ2dyaWQnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2NvbG9yJzpcbiAgICAgICAgICAgICAgICBjYXNlICdjb2xvci1pbmRleCc6XG4gICAgICAgICAgICAgICAgY2FzZSAnbW9ub2Nocm9tZSc6XG4gICAgICAgICAgICAgICAgICAgIGV4cFZhbHVlID0gcGFyc2VJbnQoZXhwVmFsdWUsIDEwKSB8fCAxO1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSAgICA9IHBhcnNlSW50KHZhbHVlLCAxMCkgfHwgMDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHN3aXRjaCAobW9kaWZpZXIpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdtaW4nOiByZXR1cm4gdmFsdWUgPj0gZXhwVmFsdWU7XG4gICAgICAgICAgICAgICAgY2FzZSAnbWF4JzogcmV0dXJuIHZhbHVlIDw9IGV4cFZhbHVlO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQgICA6IHJldHVybiB2YWx1ZSA9PT0gZXhwVmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiAoZXhwcmVzc2lvbnNNYXRjaCAmJiAhaW52ZXJzZSkgfHwgKCFleHByZXNzaW9uc01hdGNoICYmIGludmVyc2UpO1xuICAgIH0pO1xufVxuXG5mdW5jdGlvbiBwYXJzZVF1ZXJ5KG1lZGlhUXVlcnkpIHtcbiAgICByZXR1cm4gbWVkaWFRdWVyeS5zcGxpdCgnLCcpLm1hcChmdW5jdGlvbiAocXVlcnkpIHtcbiAgICAgICAgcXVlcnkgPSBxdWVyeS50cmltKCk7XG5cbiAgICAgICAgdmFyIGNhcHR1cmVzICAgID0gcXVlcnkubWF0Y2goUkVfTUVESUFfUVVFUlkpLFxuICAgICAgICAgICAgbW9kaWZpZXIgICAgPSBjYXB0dXJlc1sxXSxcbiAgICAgICAgICAgIHR5cGUgICAgICAgID0gY2FwdHVyZXNbMl0sXG4gICAgICAgICAgICBleHByZXNzaW9ucyA9IGNhcHR1cmVzWzNdIHx8ICcnLFxuICAgICAgICAgICAgcGFyc2VkICAgICAgPSB7fTtcblxuICAgICAgICBwYXJzZWQuaW52ZXJzZSA9ICEhbW9kaWZpZXIgJiYgbW9kaWZpZXIudG9Mb3dlckNhc2UoKSA9PT0gJ25vdCc7XG4gICAgICAgIHBhcnNlZC50eXBlICAgID0gdHlwZSA/IHR5cGUudG9Mb3dlckNhc2UoKSA6ICdhbGwnO1xuXG4gICAgICAgIC8vIFNwbGl0IGV4cHJlc3Npb25zIGludG8gYSBsaXN0LlxuICAgICAgICBleHByZXNzaW9ucyA9IGV4cHJlc3Npb25zLm1hdGNoKC9cXChbXlxcKV0rXFwpL2cpIHx8IFtdO1xuXG4gICAgICAgIHBhcnNlZC5leHByZXNzaW9ucyA9IGV4cHJlc3Npb25zLm1hcChmdW5jdGlvbiAoZXhwcmVzc2lvbikge1xuICAgICAgICAgICAgdmFyIGNhcHR1cmVzID0gZXhwcmVzc2lvbi5tYXRjaChSRV9NUV9FWFBSRVNTSU9OKSxcbiAgICAgICAgICAgICAgICBmZWF0dXJlICA9IGNhcHR1cmVzWzFdLnRvTG93ZXJDYXNlKCkubWF0Y2goUkVfTVFfRkVBVFVSRSk7XG5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgbW9kaWZpZXI6IGZlYXR1cmVbMV0sXG4gICAgICAgICAgICAgICAgZmVhdHVyZSA6IGZlYXR1cmVbMl0sXG4gICAgICAgICAgICAgICAgdmFsdWUgICA6IGNhcHR1cmVzWzJdXG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gcGFyc2VkO1xuICAgIH0pO1xufVxuXG4vLyAtLSBVdGlsaXRpZXMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5mdW5jdGlvbiB0b0RlY2ltYWwocmF0aW8pIHtcbiAgICB2YXIgZGVjaW1hbCA9IE51bWJlcihyYXRpbyksXG4gICAgICAgIG51bWJlcnM7XG5cbiAgICBpZiAoIWRlY2ltYWwpIHtcbiAgICAgICAgbnVtYmVycyA9IHJhdGlvLm1hdGNoKC9eKFxcZCspXFxzKlxcL1xccyooXFxkKykkLyk7XG4gICAgICAgIGRlY2ltYWwgPSBudW1iZXJzWzFdIC8gbnVtYmVyc1syXTtcbiAgICB9XG5cbiAgICByZXR1cm4gZGVjaW1hbDtcbn1cblxuZnVuY3Rpb24gdG9EcGkocmVzb2x1dGlvbikge1xuICAgIHZhciB2YWx1ZSA9IHBhcnNlRmxvYXQocmVzb2x1dGlvbiksXG4gICAgICAgIHVuaXRzID0gU3RyaW5nKHJlc29sdXRpb24pLm1hdGNoKFJFX1JFU09MVVRJT05fVU5JVClbMV07XG5cbiAgICBzd2l0Y2ggKHVuaXRzKSB7XG4gICAgICAgIGNhc2UgJ2RwY20nOiByZXR1cm4gdmFsdWUgLyAyLjU0O1xuICAgICAgICBjYXNlICdkcHB4JzogcmV0dXJuIHZhbHVlICogOTY7XG4gICAgICAgIGRlZmF1bHQgICAgOiByZXR1cm4gdmFsdWU7XG4gICAgfVxufVxuXG5mdW5jdGlvbiB0b1B4KGxlbmd0aCkge1xuICAgIHZhciB2YWx1ZSA9IHBhcnNlRmxvYXQobGVuZ3RoKSxcbiAgICAgICAgdW5pdHMgPSBTdHJpbmcobGVuZ3RoKS5tYXRjaChSRV9MRU5HVEhfVU5JVClbMV07XG5cbiAgICBzd2l0Y2ggKHVuaXRzKSB7XG4gICAgICAgIGNhc2UgJ2VtJyA6IHJldHVybiB2YWx1ZSAqIDE2O1xuICAgICAgICBjYXNlICdyZW0nOiByZXR1cm4gdmFsdWUgKiAxNjtcbiAgICAgICAgY2FzZSAnY20nIDogcmV0dXJuIHZhbHVlICogOTYgLyAyLjU0O1xuICAgICAgICBjYXNlICdtbScgOiByZXR1cm4gdmFsdWUgKiA5NiAvIDIuNTQgLyAxMDtcbiAgICAgICAgY2FzZSAnaW4nIDogcmV0dXJuIHZhbHVlICogOTY7XG4gICAgICAgIGNhc2UgJ3B0JyA6IHJldHVybiB2YWx1ZSAqIDcyO1xuICAgICAgICBjYXNlICdwYycgOiByZXR1cm4gdmFsdWUgKiA3MiAvIDEyO1xuICAgICAgICBkZWZhdWx0ICAgOiByZXR1cm4gdmFsdWU7XG4gICAgfVxufVxuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL2h5cGhlbmF0ZS1zdHlsZS1uYW1lL2luZGV4LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2h5cGhlbmF0ZS1zdHlsZS1uYW1lL2luZGV4LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgZXhwb3J0ICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCB7XG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFwiZGVmYXVsdFwiOiAoKSA9PiAoX19XRUJQQUNLX0RFRkFVTFRfRVhQT1JUX18pXG4vKiBoYXJtb255IGV4cG9ydCAqLyB9KTtcbi8qIGVzbGludC1kaXNhYmxlIG5vLXZhciwgcHJlZmVyLXRlbXBsYXRlICovXG52YXIgdXBwZXJjYXNlUGF0dGVybiA9IC9bQS1aXS9nXG52YXIgbXNQYXR0ZXJuID0gL15tcy0vXG52YXIgY2FjaGUgPSB7fVxuXG5mdW5jdGlvbiB0b0h5cGhlbkxvd2VyKG1hdGNoKSB7XG4gIHJldHVybiAnLScgKyBtYXRjaC50b0xvd2VyQ2FzZSgpXG59XG5cbmZ1bmN0aW9uIGh5cGhlbmF0ZVN0eWxlTmFtZShuYW1lKSB7XG4gIGlmIChjYWNoZS5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgIHJldHVybiBjYWNoZVtuYW1lXVxuICB9XG5cbiAgdmFyIGhOYW1lID0gbmFtZS5yZXBsYWNlKHVwcGVyY2FzZVBhdHRlcm4sIHRvSHlwaGVuTG93ZXIpXG4gIHJldHVybiAoY2FjaGVbbmFtZV0gPSBtc1BhdHRlcm4udGVzdChoTmFtZSkgPyAnLScgKyBoTmFtZSA6IGhOYW1lKVxufVxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IF9fV0VCUEFDS19ERUZBVUxUX0VYUE9SVF9fID0gKGh5cGhlbmF0ZVN0eWxlTmFtZSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvbWF0Y2htZWRpYXF1ZXJ5L2luZGV4LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9tYXRjaG1lZGlhcXVlcnkvaW5kZXguanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgc3RhdGljTWF0Y2ggPSAoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgY3NzLW1lZGlhcXVlcnkgKi8gXCIuL25vZGVfbW9kdWxlcy9jc3MtbWVkaWFxdWVyeS9pbmRleC5qc1wiKS5tYXRjaCk7XG52YXIgZHluYW1pY01hdGNoID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cubWF0Y2hNZWRpYSA6IG51bGw7XG5cbi8vIG91ciBmYWtlIE1lZGlhUXVlcnlMaXN0XG5mdW5jdGlvbiBNcWwocXVlcnksIHZhbHVlcywgZm9yY2VTdGF0aWMpe1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIGlmKGR5bmFtaWNNYXRjaCAmJiAhZm9yY2VTdGF0aWMpe1xuICAgIHZhciBtcWwgPSBkeW5hbWljTWF0Y2guY2FsbCh3aW5kb3csIHF1ZXJ5KTtcbiAgICB0aGlzLm1hdGNoZXMgPSBtcWwubWF0Y2hlcztcbiAgICB0aGlzLm1lZGlhID0gbXFsLm1lZGlhO1xuICAgIC8vIFRPRE86IGlzIHRoZXJlIGEgdGltZSBpdCBtYWtlcyBzZW5zZSB0byByZW1vdmUgdGhpcyBsaXN0ZW5lcj9cbiAgICBtcWwuYWRkTGlzdGVuZXIodXBkYXRlKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLm1hdGNoZXMgPSBzdGF0aWNNYXRjaChxdWVyeSwgdmFsdWVzKTtcbiAgICB0aGlzLm1lZGlhID0gcXVlcnk7XG4gIH1cblxuICB0aGlzLmFkZExpc3RlbmVyID0gYWRkTGlzdGVuZXI7XG4gIHRoaXMucmVtb3ZlTGlzdGVuZXIgPSByZW1vdmVMaXN0ZW5lcjtcbiAgdGhpcy5kaXNwb3NlID0gZGlzcG9zZTtcblxuICBmdW5jdGlvbiBhZGRMaXN0ZW5lcihsaXN0ZW5lcil7XG4gICAgaWYobXFsKXtcbiAgICAgIG1xbC5hZGRMaXN0ZW5lcihsaXN0ZW5lcik7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVtb3ZlTGlzdGVuZXIobGlzdGVuZXIpe1xuICAgIGlmKG1xbCl7XG4gICAgICBtcWwucmVtb3ZlTGlzdGVuZXIobGlzdGVuZXIpO1xuICAgIH1cbiAgfVxuXG4gIC8vIHVwZGF0ZSBvdXJzZWx2ZXMhXG4gIGZ1bmN0aW9uIHVwZGF0ZShldnQpe1xuICAgIHNlbGYubWF0Y2hlcyA9IGV2dC5tYXRjaGVzO1xuICAgIHNlbGYubWVkaWEgPSBldnQubWVkaWE7XG4gIH1cblxuICBmdW5jdGlvbiBkaXNwb3NlKCl7XG4gICAgaWYobXFsKXtcbiAgICAgIG1xbC5yZW1vdmVMaXN0ZW5lcih1cGRhdGUpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBtYXRjaE1lZGlhKHF1ZXJ5LCB2YWx1ZXMsIGZvcmNlU3RhdGljKXtcbiAgcmV0dXJuIG5ldyBNcWwocXVlcnksIHZhbHVlcywgZm9yY2VTdGF0aWMpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1hdGNoTWVkaWE7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvb2JqZWN0LWFzc2lnbi9pbmRleC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL29iamVjdC1hc3NpZ24vaW5kZXguanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgobW9kdWxlKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuLypcbm9iamVjdC1hc3NpZ25cbihjKSBTaW5kcmUgU29yaHVzXG5AbGljZW5zZSBNSVRcbiovXG5cblxuLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMgKi9cbnZhciBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBwcm9wSXNFbnVtZXJhYmxlID0gT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcblxuZnVuY3Rpb24gdG9PYmplY3QodmFsKSB7XG5cdGlmICh2YWwgPT09IG51bGwgfHwgdmFsID09PSB1bmRlZmluZWQpIHtcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdPYmplY3QuYXNzaWduIGNhbm5vdCBiZSBjYWxsZWQgd2l0aCBudWxsIG9yIHVuZGVmaW5lZCcpO1xuXHR9XG5cblx0cmV0dXJuIE9iamVjdCh2YWwpO1xufVxuXG5mdW5jdGlvbiBzaG91bGRVc2VOYXRpdmUoKSB7XG5cdHRyeSB7XG5cdFx0aWYgKCFPYmplY3QuYXNzaWduKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly8gRGV0ZWN0IGJ1Z2d5IHByb3BlcnR5IGVudW1lcmF0aW9uIG9yZGVyIGluIG9sZGVyIFY4IHZlcnNpb25zLlxuXG5cdFx0Ly8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9NDExOFxuXHRcdHZhciB0ZXN0MSA9IG5ldyBTdHJpbmcoJ2FiYycpOyAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXctd3JhcHBlcnNcblx0XHR0ZXN0MVs1XSA9ICdkZSc7XG5cdFx0aWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRlc3QxKVswXSA9PT0gJzUnKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MzA1NlxuXHRcdHZhciB0ZXN0MiA9IHt9O1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgMTA7IGkrKykge1xuXHRcdFx0dGVzdDJbJ18nICsgU3RyaW5nLmZyb21DaGFyQ29kZShpKV0gPSBpO1xuXHRcdH1cblx0XHR2YXIgb3JkZXIyID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGVzdDIpLm1hcChmdW5jdGlvbiAobikge1xuXHRcdFx0cmV0dXJuIHRlc3QyW25dO1xuXHRcdH0pO1xuXHRcdGlmIChvcmRlcjIuam9pbignJykgIT09ICcwMTIzNDU2Nzg5Jykge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTMwNTZcblx0XHR2YXIgdGVzdDMgPSB7fTtcblx0XHQnYWJjZGVmZ2hpamtsbW5vcHFyc3QnLnNwbGl0KCcnKS5mb3JFYWNoKGZ1bmN0aW9uIChsZXR0ZXIpIHtcblx0XHRcdHRlc3QzW2xldHRlcl0gPSBsZXR0ZXI7XG5cdFx0fSk7XG5cdFx0aWYgKE9iamVjdC5rZXlzKE9iamVjdC5hc3NpZ24oe30sIHRlc3QzKSkuam9pbignJykgIT09XG5cdFx0XHRcdCdhYmNkZWZnaGlqa2xtbm9wcXJzdCcpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSBjYXRjaCAoZXJyKSB7XG5cdFx0Ly8gV2UgZG9uJ3QgZXhwZWN0IGFueSBvZiB0aGUgYWJvdmUgdG8gdGhyb3csIGJ1dCBiZXR0ZXIgdG8gYmUgc2FmZS5cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzaG91bGRVc2VOYXRpdmUoKSA/IE9iamVjdC5hc3NpZ24gOiBmdW5jdGlvbiAodGFyZ2V0LCBzb3VyY2UpIHtcblx0dmFyIGZyb207XG5cdHZhciB0byA9IHRvT2JqZWN0KHRhcmdldCk7XG5cdHZhciBzeW1ib2xzO1xuXG5cdGZvciAodmFyIHMgPSAxOyBzIDwgYXJndW1lbnRzLmxlbmd0aDsgcysrKSB7XG5cdFx0ZnJvbSA9IE9iamVjdChhcmd1bWVudHNbc10pO1xuXG5cdFx0Zm9yICh2YXIga2V5IGluIGZyb20pIHtcblx0XHRcdGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGZyb20sIGtleSkpIHtcblx0XHRcdFx0dG9ba2V5XSA9IGZyb21ba2V5XTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG5cdFx0XHRzeW1ib2xzID0gZ2V0T3duUHJvcGVydHlTeW1ib2xzKGZyb20pO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBzeW1ib2xzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGlmIChwcm9wSXNFbnVtZXJhYmxlLmNhbGwoZnJvbSwgc3ltYm9sc1tpXSkpIHtcblx0XHRcdFx0XHR0b1tzeW1ib2xzW2ldXSA9IGZyb21bc3ltYm9sc1tpXV07XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gdG87XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvY2hlY2tQcm9wVHlwZXMuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL2NoZWNrUHJvcFR5cGVzLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG5cblxudmFyIHByaW50V2FybmluZyA9IGZ1bmN0aW9uKCkge307XG5cbmlmICh0cnVlKSB7XG4gIHZhciBSZWFjdFByb3BUeXBlc1NlY3JldCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vbGliL1JlYWN0UHJvcFR5cGVzU2VjcmV0ICovIFwiLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9saWIvUmVhY3RQcm9wVHlwZXNTZWNyZXQuanNcIik7XG4gIHZhciBsb2dnZWRUeXBlRmFpbHVyZXMgPSB7fTtcbiAgdmFyIGhhcyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vbGliL2hhcyAqLyBcIi4vbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvbGliL2hhcy5qc1wiKTtcblxuICBwcmludFdhcm5pbmcgPSBmdW5jdGlvbih0ZXh0KSB7XG4gICAgdmFyIG1lc3NhZ2UgPSAnV2FybmluZzogJyArIHRleHQ7XG4gICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgY29uc29sZS5lcnJvcihtZXNzYWdlKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIC8vIC0tLSBXZWxjb21lIHRvIGRlYnVnZ2luZyBSZWFjdCAtLS1cbiAgICAgIC8vIFRoaXMgZXJyb3Igd2FzIHRocm93biBhcyBhIGNvbnZlbmllbmNlIHNvIHRoYXQgeW91IGNhbiB1c2UgdGhpcyBzdGFja1xuICAgICAgLy8gdG8gZmluZCB0aGUgY2FsbHNpdGUgdGhhdCBjYXVzZWQgdGhpcyB3YXJuaW5nIHRvIGZpcmUuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgfSBjYXRjaCAoeCkgeyAvKiovIH1cbiAgfTtcbn1cblxuLyoqXG4gKiBBc3NlcnQgdGhhdCB0aGUgdmFsdWVzIG1hdGNoIHdpdGggdGhlIHR5cGUgc3BlY3MuXG4gKiBFcnJvciBtZXNzYWdlcyBhcmUgbWVtb3JpemVkIGFuZCB3aWxsIG9ubHkgYmUgc2hvd24gb25jZS5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gdHlwZVNwZWNzIE1hcCBvZiBuYW1lIHRvIGEgUmVhY3RQcm9wVHlwZVxuICogQHBhcmFtIHtvYmplY3R9IHZhbHVlcyBSdW50aW1lIHZhbHVlcyB0aGF0IG5lZWQgdG8gYmUgdHlwZS1jaGVja2VkXG4gKiBAcGFyYW0ge3N0cmluZ30gbG9jYXRpb24gZS5nLiBcInByb3BcIiwgXCJjb250ZXh0XCIsIFwiY2hpbGQgY29udGV4dFwiXG4gKiBAcGFyYW0ge3N0cmluZ30gY29tcG9uZW50TmFtZSBOYW1lIG9mIHRoZSBjb21wb25lbnQgZm9yIGVycm9yIG1lc3NhZ2VzLlxuICogQHBhcmFtIHs/RnVuY3Rpb259IGdldFN0YWNrIFJldHVybnMgdGhlIGNvbXBvbmVudCBzdGFjay5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGNoZWNrUHJvcFR5cGVzKHR5cGVTcGVjcywgdmFsdWVzLCBsb2NhdGlvbiwgY29tcG9uZW50TmFtZSwgZ2V0U3RhY2spIHtcbiAgaWYgKHRydWUpIHtcbiAgICBmb3IgKHZhciB0eXBlU3BlY05hbWUgaW4gdHlwZVNwZWNzKSB7XG4gICAgICBpZiAoaGFzKHR5cGVTcGVjcywgdHlwZVNwZWNOYW1lKSkge1xuICAgICAgICB2YXIgZXJyb3I7XG4gICAgICAgIC8vIFByb3AgdHlwZSB2YWxpZGF0aW9uIG1heSB0aHJvdy4gSW4gY2FzZSB0aGV5IGRvLCB3ZSBkb24ndCB3YW50IHRvXG4gICAgICAgIC8vIGZhaWwgdGhlIHJlbmRlciBwaGFzZSB3aGVyZSBpdCBkaWRuJ3QgZmFpbCBiZWZvcmUuIFNvIHdlIGxvZyBpdC5cbiAgICAgICAgLy8gQWZ0ZXIgdGhlc2UgaGF2ZSBiZWVuIGNsZWFuZWQgdXAsIHdlJ2xsIGxldCB0aGVtIHRocm93LlxuICAgICAgICB0cnkge1xuICAgICAgICAgIC8vIFRoaXMgaXMgaW50ZW50aW9uYWxseSBhbiBpbnZhcmlhbnQgdGhhdCBnZXRzIGNhdWdodC4gSXQncyB0aGUgc2FtZVxuICAgICAgICAgIC8vIGJlaGF2aW9yIGFzIHdpdGhvdXQgdGhpcyBzdGF0ZW1lbnQgZXhjZXB0IHdpdGggYSBiZXR0ZXIgbWVzc2FnZS5cbiAgICAgICAgICBpZiAodHlwZW9mIHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB2YXIgZXJyID0gRXJyb3IoXG4gICAgICAgICAgICAgIChjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycpICsgJzogJyArIGxvY2F0aW9uICsgJyB0eXBlIGAnICsgdHlwZVNwZWNOYW1lICsgJ2AgaXMgaW52YWxpZDsgJyArXG4gICAgICAgICAgICAgICdpdCBtdXN0IGJlIGEgZnVuY3Rpb24sIHVzdWFsbHkgZnJvbSB0aGUgYHByb3AtdHlwZXNgIHBhY2thZ2UsIGJ1dCByZWNlaXZlZCBgJyArIHR5cGVvZiB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSArICdgLicgK1xuICAgICAgICAgICAgICAnVGhpcyBvZnRlbiBoYXBwZW5zIGJlY2F1c2Ugb2YgdHlwb3Mgc3VjaCBhcyBgUHJvcFR5cGVzLmZ1bmN0aW9uYCBpbnN0ZWFkIG9mIGBQcm9wVHlwZXMuZnVuY2AuJ1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGVyci5uYW1lID0gJ0ludmFyaWFudCBWaW9sYXRpb24nO1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlcnJvciA9IHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdKHZhbHVlcywgdHlwZVNwZWNOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgbnVsbCwgUmVhY3RQcm9wVHlwZXNTZWNyZXQpO1xuICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgIGVycm9yID0gZXg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVycm9yICYmICEoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikpIHtcbiAgICAgICAgICBwcmludFdhcm5pbmcoXG4gICAgICAgICAgICAoY29tcG9uZW50TmFtZSB8fCAnUmVhY3QgY2xhc3MnKSArICc6IHR5cGUgc3BlY2lmaWNhdGlvbiBvZiAnICtcbiAgICAgICAgICAgIGxvY2F0aW9uICsgJyBgJyArIHR5cGVTcGVjTmFtZSArICdgIGlzIGludmFsaWQ7IHRoZSB0eXBlIGNoZWNrZXIgJyArXG4gICAgICAgICAgICAnZnVuY3Rpb24gbXVzdCByZXR1cm4gYG51bGxgIG9yIGFuIGBFcnJvcmAgYnV0IHJldHVybmVkIGEgJyArIHR5cGVvZiBlcnJvciArICcuICcgK1xuICAgICAgICAgICAgJ1lvdSBtYXkgaGF2ZSBmb3Jnb3R0ZW4gdG8gcGFzcyBhbiBhcmd1bWVudCB0byB0aGUgdHlwZSBjaGVja2VyICcgK1xuICAgICAgICAgICAgJ2NyZWF0b3IgKGFycmF5T2YsIGluc3RhbmNlT2YsIG9iamVjdE9mLCBvbmVPZiwgb25lT2ZUeXBlLCBhbmQgJyArXG4gICAgICAgICAgICAnc2hhcGUgYWxsIHJlcXVpcmUgYW4gYXJndW1lbnQpLidcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yICYmICEoZXJyb3IubWVzc2FnZSBpbiBsb2dnZWRUeXBlRmFpbHVyZXMpKSB7XG4gICAgICAgICAgLy8gT25seSBtb25pdG9yIHRoaXMgZmFpbHVyZSBvbmNlIGJlY2F1c2UgdGhlcmUgdGVuZHMgdG8gYmUgYSBsb3Qgb2YgdGhlXG4gICAgICAgICAgLy8gc2FtZSBlcnJvci5cbiAgICAgICAgICBsb2dnZWRUeXBlRmFpbHVyZXNbZXJyb3IubWVzc2FnZV0gPSB0cnVlO1xuXG4gICAgICAgICAgdmFyIHN0YWNrID0gZ2V0U3RhY2sgPyBnZXRTdGFjaygpIDogJyc7XG5cbiAgICAgICAgICBwcmludFdhcm5pbmcoXG4gICAgICAgICAgICAnRmFpbGVkICcgKyBsb2NhdGlvbiArICcgdHlwZTogJyArIGVycm9yLm1lc3NhZ2UgKyAoc3RhY2sgIT0gbnVsbCA/IHN0YWNrIDogJycpXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFJlc2V0cyB3YXJuaW5nIGNhY2hlIHdoZW4gdGVzdGluZy5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5jaGVja1Byb3BUeXBlcy5yZXNldFdhcm5pbmdDYWNoZSA9IGZ1bmN0aW9uKCkge1xuICBpZiAodHJ1ZSkge1xuICAgIGxvZ2dlZFR5cGVGYWlsdXJlcyA9IHt9O1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2hlY2tQcm9wVHlwZXM7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9mYWN0b3J5V2l0aFR5cGVDaGVja2Vycy5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvZmFjdG9yeVdpdGhUeXBlQ2hlY2tlcnMuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cblxuXG52YXIgUmVhY3RJcyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIHJlYWN0LWlzICovIFwiLi9ub2RlX21vZHVsZXMvcmVhY3QtaXMvaW5kZXguanNcIik7XG52YXIgYXNzaWduID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgb2JqZWN0LWFzc2lnbiAqLyBcIi4vbm9kZV9tb2R1bGVzL29iamVjdC1hc3NpZ24vaW5kZXguanNcIik7XG5cbnZhciBSZWFjdFByb3BUeXBlc1NlY3JldCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vbGliL1JlYWN0UHJvcFR5cGVzU2VjcmV0ICovIFwiLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9saWIvUmVhY3RQcm9wVHlwZXNTZWNyZXQuanNcIik7XG52YXIgaGFzID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9saWIvaGFzICovIFwiLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9saWIvaGFzLmpzXCIpO1xudmFyIGNoZWNrUHJvcFR5cGVzID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9jaGVja1Byb3BUeXBlcyAqLyBcIi4vbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvY2hlY2tQcm9wVHlwZXMuanNcIik7XG5cbnZhciBwcmludFdhcm5pbmcgPSBmdW5jdGlvbigpIHt9O1xuXG5pZiAodHJ1ZSkge1xuICBwcmludFdhcm5pbmcgPSBmdW5jdGlvbih0ZXh0KSB7XG4gICAgdmFyIG1lc3NhZ2UgPSAnV2FybmluZzogJyArIHRleHQ7XG4gICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgY29uc29sZS5lcnJvcihtZXNzYWdlKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIC8vIC0tLSBXZWxjb21lIHRvIGRlYnVnZ2luZyBSZWFjdCAtLS1cbiAgICAgIC8vIFRoaXMgZXJyb3Igd2FzIHRocm93biBhcyBhIGNvbnZlbmllbmNlIHNvIHRoYXQgeW91IGNhbiB1c2UgdGhpcyBzdGFja1xuICAgICAgLy8gdG8gZmluZCB0aGUgY2FsbHNpdGUgdGhhdCBjYXVzZWQgdGhpcyB3YXJuaW5nIHRvIGZpcmUuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgfSBjYXRjaCAoeCkge31cbiAgfTtcbn1cblxuZnVuY3Rpb24gZW1wdHlGdW5jdGlvblRoYXRSZXR1cm5zTnVsbCgpIHtcbiAgcmV0dXJuIG51bGw7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXNWYWxpZEVsZW1lbnQsIHRocm93T25EaXJlY3RBY2Nlc3MpIHtcbiAgLyogZ2xvYmFsIFN5bWJvbCAqL1xuICB2YXIgSVRFUkFUT1JfU1lNQk9MID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wuaXRlcmF0b3I7XG4gIHZhciBGQVVYX0lURVJBVE9SX1NZTUJPTCA9ICdAQGl0ZXJhdG9yJzsgLy8gQmVmb3JlIFN5bWJvbCBzcGVjLlxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBpdGVyYXRvciBtZXRob2QgZnVuY3Rpb24gY29udGFpbmVkIG9uIHRoZSBpdGVyYWJsZSBvYmplY3QuXG4gICAqXG4gICAqIEJlIHN1cmUgdG8gaW52b2tlIHRoZSBmdW5jdGlvbiB3aXRoIHRoZSBpdGVyYWJsZSBhcyBjb250ZXh0OlxuICAgKlxuICAgKiAgICAgdmFyIGl0ZXJhdG9yRm4gPSBnZXRJdGVyYXRvckZuKG15SXRlcmFibGUpO1xuICAgKiAgICAgaWYgKGl0ZXJhdG9yRm4pIHtcbiAgICogICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmF0b3JGbi5jYWxsKG15SXRlcmFibGUpO1xuICAgKiAgICAgICAuLi5cbiAgICogICAgIH1cbiAgICpcbiAgICogQHBhcmFtIHs/b2JqZWN0fSBtYXliZUl0ZXJhYmxlXG4gICAqIEByZXR1cm4gez9mdW5jdGlvbn1cbiAgICovXG4gIGZ1bmN0aW9uIGdldEl0ZXJhdG9yRm4obWF5YmVJdGVyYWJsZSkge1xuICAgIHZhciBpdGVyYXRvckZuID0gbWF5YmVJdGVyYWJsZSAmJiAoSVRFUkFUT1JfU1lNQk9MICYmIG1heWJlSXRlcmFibGVbSVRFUkFUT1JfU1lNQk9MXSB8fCBtYXliZUl0ZXJhYmxlW0ZBVVhfSVRFUkFUT1JfU1lNQk9MXSk7XG4gICAgaWYgKHR5cGVvZiBpdGVyYXRvckZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gaXRlcmF0b3JGbjtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ29sbGVjdGlvbiBvZiBtZXRob2RzIHRoYXQgYWxsb3cgZGVjbGFyYXRpb24gYW5kIHZhbGlkYXRpb24gb2YgcHJvcHMgdGhhdCBhcmVcbiAgICogc3VwcGxpZWQgdG8gUmVhY3QgY29tcG9uZW50cy4gRXhhbXBsZSB1c2FnZTpcbiAgICpcbiAgICogICB2YXIgUHJvcHMgPSByZXF1aXJlKCdSZWFjdFByb3BUeXBlcycpO1xuICAgKiAgIHZhciBNeUFydGljbGUgPSBSZWFjdC5jcmVhdGVDbGFzcyh7XG4gICAqICAgICBwcm9wVHlwZXM6IHtcbiAgICogICAgICAgLy8gQW4gb3B0aW9uYWwgc3RyaW5nIHByb3AgbmFtZWQgXCJkZXNjcmlwdGlvblwiLlxuICAgKiAgICAgICBkZXNjcmlwdGlvbjogUHJvcHMuc3RyaW5nLFxuICAgKlxuICAgKiAgICAgICAvLyBBIHJlcXVpcmVkIGVudW0gcHJvcCBuYW1lZCBcImNhdGVnb3J5XCIuXG4gICAqICAgICAgIGNhdGVnb3J5OiBQcm9wcy5vbmVPZihbJ05ld3MnLCdQaG90b3MnXSkuaXNSZXF1aXJlZCxcbiAgICpcbiAgICogICAgICAgLy8gQSBwcm9wIG5hbWVkIFwiZGlhbG9nXCIgdGhhdCByZXF1aXJlcyBhbiBpbnN0YW5jZSBvZiBEaWFsb2cuXG4gICAqICAgICAgIGRpYWxvZzogUHJvcHMuaW5zdGFuY2VPZihEaWFsb2cpLmlzUmVxdWlyZWRcbiAgICogICAgIH0sXG4gICAqICAgICByZW5kZXI6IGZ1bmN0aW9uKCkgeyAuLi4gfVxuICAgKiAgIH0pO1xuICAgKlxuICAgKiBBIG1vcmUgZm9ybWFsIHNwZWNpZmljYXRpb24gb2YgaG93IHRoZXNlIG1ldGhvZHMgYXJlIHVzZWQ6XG4gICAqXG4gICAqICAgdHlwZSA6PSBhcnJheXxib29sfGZ1bmN8b2JqZWN0fG51bWJlcnxzdHJpbmd8b25lT2YoWy4uLl0pfGluc3RhbmNlT2YoLi4uKVxuICAgKiAgIGRlY2wgOj0gUmVhY3RQcm9wVHlwZXMue3R5cGV9KC5pc1JlcXVpcmVkKT9cbiAgICpcbiAgICogRWFjaCBhbmQgZXZlcnkgZGVjbGFyYXRpb24gcHJvZHVjZXMgYSBmdW5jdGlvbiB3aXRoIHRoZSBzYW1lIHNpZ25hdHVyZS4gVGhpc1xuICAgKiBhbGxvd3MgdGhlIGNyZWF0aW9uIG9mIGN1c3RvbSB2YWxpZGF0aW9uIGZ1bmN0aW9ucy4gRm9yIGV4YW1wbGU6XG4gICAqXG4gICAqICB2YXIgTXlMaW5rID0gUmVhY3QuY3JlYXRlQ2xhc3Moe1xuICAgKiAgICBwcm9wVHlwZXM6IHtcbiAgICogICAgICAvLyBBbiBvcHRpb25hbCBzdHJpbmcgb3IgVVJJIHByb3AgbmFtZWQgXCJocmVmXCIuXG4gICAqICAgICAgaHJlZjogZnVuY3Rpb24ocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lKSB7XG4gICAqICAgICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgKiAgICAgICAgaWYgKHByb3BWYWx1ZSAhPSBudWxsICYmIHR5cGVvZiBwcm9wVmFsdWUgIT09ICdzdHJpbmcnICYmXG4gICAqICAgICAgICAgICAgIShwcm9wVmFsdWUgaW5zdGFuY2VvZiBVUkkpKSB7XG4gICAqICAgICAgICAgIHJldHVybiBuZXcgRXJyb3IoXG4gICAqICAgICAgICAgICAgJ0V4cGVjdGVkIGEgc3RyaW5nIG9yIGFuIFVSSSBmb3IgJyArIHByb3BOYW1lICsgJyBpbiAnICtcbiAgICogICAgICAgICAgICBjb21wb25lbnROYW1lXG4gICAqICAgICAgICAgICk7XG4gICAqICAgICAgICB9XG4gICAqICAgICAgfVxuICAgKiAgICB9LFxuICAgKiAgICByZW5kZXI6IGZ1bmN0aW9uKCkgey4uLn1cbiAgICogIH0pO1xuICAgKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG5cbiAgdmFyIEFOT05ZTU9VUyA9ICc8PGFub255bW91cz4+JztcblxuICAvLyBJbXBvcnRhbnQhXG4gIC8vIEtlZXAgdGhpcyBsaXN0IGluIHN5bmMgd2l0aCBwcm9kdWN0aW9uIHZlcnNpb24gaW4gYC4vZmFjdG9yeVdpdGhUaHJvd2luZ1NoaW1zLmpzYC5cbiAgdmFyIFJlYWN0UHJvcFR5cGVzID0ge1xuICAgIGFycmF5OiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignYXJyYXknKSxcbiAgICBiaWdpbnQ6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdiaWdpbnQnKSxcbiAgICBib29sOiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignYm9vbGVhbicpLFxuICAgIGZ1bmM6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdmdW5jdGlvbicpLFxuICAgIG51bWJlcjogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ251bWJlcicpLFxuICAgIG9iamVjdDogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ29iamVjdCcpLFxuICAgIHN0cmluZzogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ3N0cmluZycpLFxuICAgIHN5bWJvbDogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ3N5bWJvbCcpLFxuXG4gICAgYW55OiBjcmVhdGVBbnlUeXBlQ2hlY2tlcigpLFxuICAgIGFycmF5T2Y6IGNyZWF0ZUFycmF5T2ZUeXBlQ2hlY2tlcixcbiAgICBlbGVtZW50OiBjcmVhdGVFbGVtZW50VHlwZUNoZWNrZXIoKSxcbiAgICBlbGVtZW50VHlwZTogY3JlYXRlRWxlbWVudFR5cGVUeXBlQ2hlY2tlcigpLFxuICAgIGluc3RhbmNlT2Y6IGNyZWF0ZUluc3RhbmNlVHlwZUNoZWNrZXIsXG4gICAgbm9kZTogY3JlYXRlTm9kZUNoZWNrZXIoKSxcbiAgICBvYmplY3RPZjogY3JlYXRlT2JqZWN0T2ZUeXBlQ2hlY2tlcixcbiAgICBvbmVPZjogY3JlYXRlRW51bVR5cGVDaGVja2VyLFxuICAgIG9uZU9mVHlwZTogY3JlYXRlVW5pb25UeXBlQ2hlY2tlcixcbiAgICBzaGFwZTogY3JlYXRlU2hhcGVUeXBlQ2hlY2tlcixcbiAgICBleGFjdDogY3JlYXRlU3RyaWN0U2hhcGVUeXBlQ2hlY2tlcixcbiAgfTtcblxuICAvKipcbiAgICogaW5saW5lZCBPYmplY3QuaXMgcG9seWZpbGwgdG8gYXZvaWQgcmVxdWlyaW5nIGNvbnN1bWVycyBzaGlwIHRoZWlyIG93blxuICAgKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9PYmplY3QvaXNcbiAgICovXG4gIC8qZXNsaW50LWRpc2FibGUgbm8tc2VsZi1jb21wYXJlKi9cbiAgZnVuY3Rpb24gaXMoeCwgeSkge1xuICAgIC8vIFNhbWVWYWx1ZSBhbGdvcml0aG1cbiAgICBpZiAoeCA9PT0geSkge1xuICAgICAgLy8gU3RlcHMgMS01LCA3LTEwXG4gICAgICAvLyBTdGVwcyA2LmItNi5lOiArMCAhPSAtMFxuICAgICAgcmV0dXJuIHggIT09IDAgfHwgMSAvIHggPT09IDEgLyB5O1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBTdGVwIDYuYTogTmFOID09IE5hTlxuICAgICAgcmV0dXJuIHggIT09IHggJiYgeSAhPT0geTtcbiAgICB9XG4gIH1cbiAgLyplc2xpbnQtZW5hYmxlIG5vLXNlbGYtY29tcGFyZSovXG5cbiAgLyoqXG4gICAqIFdlIHVzZSBhbiBFcnJvci1saWtlIG9iamVjdCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSBhcyBwZW9wbGUgbWF5IGNhbGxcbiAgICogUHJvcFR5cGVzIGRpcmVjdGx5IGFuZCBpbnNwZWN0IHRoZWlyIG91dHB1dC4gSG93ZXZlciwgd2UgZG9uJ3QgdXNlIHJlYWxcbiAgICogRXJyb3JzIGFueW1vcmUuIFdlIGRvbid0IGluc3BlY3QgdGhlaXIgc3RhY2sgYW55d2F5LCBhbmQgY3JlYXRpbmcgdGhlbVxuICAgKiBpcyBwcm9oaWJpdGl2ZWx5IGV4cGVuc2l2ZSBpZiB0aGV5IGFyZSBjcmVhdGVkIHRvbyBvZnRlbiwgc3VjaCBhcyB3aGF0XG4gICAqIGhhcHBlbnMgaW4gb25lT2ZUeXBlKCkgZm9yIGFueSB0eXBlIGJlZm9yZSB0aGUgb25lIHRoYXQgbWF0Y2hlZC5cbiAgICovXG4gIGZ1bmN0aW9uIFByb3BUeXBlRXJyb3IobWVzc2FnZSwgZGF0YSkge1xuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgdGhpcy5kYXRhID0gZGF0YSAmJiB0eXBlb2YgZGF0YSA9PT0gJ29iamVjdCcgPyBkYXRhOiB7fTtcbiAgICB0aGlzLnN0YWNrID0gJyc7XG4gIH1cbiAgLy8gTWFrZSBgaW5zdGFuY2VvZiBFcnJvcmAgc3RpbGwgd29yayBmb3IgcmV0dXJuZWQgZXJyb3JzLlxuICBQcm9wVHlwZUVycm9yLnByb3RvdHlwZSA9IEVycm9yLnByb3RvdHlwZTtcblxuICBmdW5jdGlvbiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSkge1xuICAgIGlmICh0cnVlKSB7XG4gICAgICB2YXIgbWFudWFsUHJvcFR5cGVDYWxsQ2FjaGUgPSB7fTtcbiAgICAgIHZhciBtYW51YWxQcm9wVHlwZVdhcm5pbmdDb3VudCA9IDA7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNoZWNrVHlwZShpc1JlcXVpcmVkLCBwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUsIHNlY3JldCkge1xuICAgICAgY29tcG9uZW50TmFtZSA9IGNvbXBvbmVudE5hbWUgfHwgQU5PTllNT1VTO1xuICAgICAgcHJvcEZ1bGxOYW1lID0gcHJvcEZ1bGxOYW1lIHx8IHByb3BOYW1lO1xuXG4gICAgICBpZiAoc2VjcmV0ICE9PSBSZWFjdFByb3BUeXBlc1NlY3JldCkge1xuICAgICAgICBpZiAodGhyb3dPbkRpcmVjdEFjY2Vzcykge1xuICAgICAgICAgIC8vIE5ldyBiZWhhdmlvciBvbmx5IGZvciB1c2VycyBvZiBgcHJvcC10eXBlc2AgcGFja2FnZVxuICAgICAgICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoXG4gICAgICAgICAgICAnQ2FsbGluZyBQcm9wVHlwZXMgdmFsaWRhdG9ycyBkaXJlY3RseSBpcyBub3Qgc3VwcG9ydGVkIGJ5IHRoZSBgcHJvcC10eXBlc2AgcGFja2FnZS4gJyArXG4gICAgICAgICAgICAnVXNlIGBQcm9wVHlwZXMuY2hlY2tQcm9wVHlwZXMoKWAgdG8gY2FsbCB0aGVtLiAnICtcbiAgICAgICAgICAgICdSZWFkIG1vcmUgYXQgaHR0cDovL2ZiLm1lL3VzZS1jaGVjay1wcm9wLXR5cGVzJ1xuICAgICAgICAgICk7XG4gICAgICAgICAgZXJyLm5hbWUgPSAnSW52YXJpYW50IFZpb2xhdGlvbic7XG4gICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9IGVsc2UgaWYgKCB0cnVlICYmIHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIC8vIE9sZCBiZWhhdmlvciBmb3IgcGVvcGxlIHVzaW5nIFJlYWN0LlByb3BUeXBlc1xuICAgICAgICAgIHZhciBjYWNoZUtleSA9IGNvbXBvbmVudE5hbWUgKyAnOicgKyBwcm9wTmFtZTtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAhbWFudWFsUHJvcFR5cGVDYWxsQ2FjaGVbY2FjaGVLZXldICYmXG4gICAgICAgICAgICAvLyBBdm9pZCBzcGFtbWluZyB0aGUgY29uc29sZSBiZWNhdXNlIHRoZXkgYXJlIG9mdGVuIG5vdCBhY3Rpb25hYmxlIGV4Y2VwdCBmb3IgbGliIGF1dGhvcnNcbiAgICAgICAgICAgIG1hbnVhbFByb3BUeXBlV2FybmluZ0NvdW50IDwgM1xuICAgICAgICAgICkge1xuICAgICAgICAgICAgcHJpbnRXYXJuaW5nKFxuICAgICAgICAgICAgICAnWW91IGFyZSBtYW51YWxseSBjYWxsaW5nIGEgUmVhY3QuUHJvcFR5cGVzIHZhbGlkYXRpb24gJyArXG4gICAgICAgICAgICAgICdmdW5jdGlvbiBmb3IgdGhlIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2AgcHJvcCBvbiBgJyArIGNvbXBvbmVudE5hbWUgKyAnYC4gVGhpcyBpcyBkZXByZWNhdGVkICcgK1xuICAgICAgICAgICAgICAnYW5kIHdpbGwgdGhyb3cgaW4gdGhlIHN0YW5kYWxvbmUgYHByb3AtdHlwZXNgIHBhY2thZ2UuICcgK1xuICAgICAgICAgICAgICAnWW91IG1heSBiZSBzZWVpbmcgdGhpcyB3YXJuaW5nIGR1ZSB0byBhIHRoaXJkLXBhcnR5IFByb3BUeXBlcyAnICtcbiAgICAgICAgICAgICAgJ2xpYnJhcnkuIFNlZSBodHRwczovL2ZiLm1lL3JlYWN0LXdhcm5pbmctZG9udC1jYWxsLXByb3B0eXBlcyAnICsgJ2ZvciBkZXRhaWxzLidcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBtYW51YWxQcm9wVHlwZUNhbGxDYWNoZVtjYWNoZUtleV0gPSB0cnVlO1xuICAgICAgICAgICAgbWFudWFsUHJvcFR5cGVXYXJuaW5nQ291bnQrKztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChwcm9wc1twcm9wTmFtZV0gPT0gbnVsbCkge1xuICAgICAgICBpZiAoaXNSZXF1aXJlZCkge1xuICAgICAgICAgIGlmIChwcm9wc1twcm9wTmFtZV0gPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignVGhlICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBpcyBtYXJrZWQgYXMgcmVxdWlyZWQgJyArICgnaW4gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGJ1dCBpdHMgdmFsdWUgaXMgYG51bGxgLicpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdUaGUgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIGlzIG1hcmtlZCBhcyByZXF1aXJlZCBpbiAnICsgKCdgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgYnV0IGl0cyB2YWx1ZSBpcyBgdW5kZWZpbmVkYC4nKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgY2hhaW5lZENoZWNrVHlwZSA9IGNoZWNrVHlwZS5iaW5kKG51bGwsIGZhbHNlKTtcbiAgICBjaGFpbmVkQ2hlY2tUeXBlLmlzUmVxdWlyZWQgPSBjaGVja1R5cGUuYmluZChudWxsLCB0cnVlKTtcblxuICAgIHJldHVybiBjaGFpbmVkQ2hlY2tUeXBlO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoZXhwZWN0ZWRUeXBlKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lLCBzZWNyZXQpIHtcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgICAgaWYgKHByb3BUeXBlICE9PSBleHBlY3RlZFR5cGUpIHtcbiAgICAgICAgLy8gYHByb3BWYWx1ZWAgYmVpbmcgaW5zdGFuY2Ugb2YsIHNheSwgZGF0ZS9yZWdleHAsIHBhc3MgdGhlICdvYmplY3QnXG4gICAgICAgIC8vIGNoZWNrLCBidXQgd2UgY2FuIG9mZmVyIGEgbW9yZSBwcmVjaXNlIGVycm9yIG1lc3NhZ2UgaGVyZSByYXRoZXIgdGhhblxuICAgICAgICAvLyAnb2YgdHlwZSBgb2JqZWN0YCcuXG4gICAgICAgIHZhciBwcmVjaXNlVHlwZSA9IGdldFByZWNpc2VUeXBlKHByb3BWYWx1ZSk7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKFxuICAgICAgICAgICdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlICcgKyAoJ2AnICsgcHJlY2lzZVR5cGUgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgJykgKyAoJ2AnICsgZXhwZWN0ZWRUeXBlICsgJ2AuJyksXG4gICAgICAgICAge2V4cGVjdGVkVHlwZTogZXhwZWN0ZWRUeXBlfVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVBbnlUeXBlQ2hlY2tlcigpIHtcbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIoZW1wdHlGdW5jdGlvblRoYXRSZXR1cm5zTnVsbCk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVBcnJheU9mVHlwZUNoZWNrZXIodHlwZUNoZWNrZXIpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIGlmICh0eXBlb2YgdHlwZUNoZWNrZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdQcm9wZXJ0eSBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIGNvbXBvbmVudCBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCBoYXMgaW52YWxpZCBQcm9wVHlwZSBub3RhdGlvbiBpbnNpZGUgYXJyYXlPZi4nKTtcbiAgICAgIH1cbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkocHJvcFZhbHVlKSkge1xuICAgICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBwcm9wVHlwZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBhbiBhcnJheS4nKSk7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BWYWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZXJyb3IgPSB0eXBlQ2hlY2tlcihwcm9wVmFsdWUsIGksIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUgKyAnWycgKyBpICsgJ10nLCBSZWFjdFByb3BUeXBlc1NlY3JldCk7XG4gICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnRUeXBlQ2hlY2tlcigpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICBpZiAoIWlzVmFsaWRFbGVtZW50KHByb3BWYWx1ZSkpIHtcbiAgICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlICcgKyAoJ2AnICsgcHJvcFR5cGUgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYSBzaW5nbGUgUmVhY3RFbGVtZW50LicpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlRWxlbWVudFR5cGVUeXBlQ2hlY2tlcigpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICBpZiAoIVJlYWN0SXMuaXNWYWxpZEVsZW1lbnRUeXBlKHByb3BWYWx1ZSkpIHtcbiAgICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlICcgKyAoJ2AnICsgcHJvcFR5cGUgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYSBzaW5nbGUgUmVhY3RFbGVtZW50IHR5cGUuJykpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVJbnN0YW5jZVR5cGVDaGVja2VyKGV4cGVjdGVkQ2xhc3MpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIGlmICghKHByb3BzW3Byb3BOYW1lXSBpbnN0YW5jZW9mIGV4cGVjdGVkQ2xhc3MpKSB7XG4gICAgICAgIHZhciBleHBlY3RlZENsYXNzTmFtZSA9IGV4cGVjdGVkQ2xhc3MubmFtZSB8fCBBTk9OWU1PVVM7XG4gICAgICAgIHZhciBhY3R1YWxDbGFzc05hbWUgPSBnZXRDbGFzc05hbWUocHJvcHNbcHJvcE5hbWVdKTtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlICcgKyAoJ2AnICsgYWN0dWFsQ2xhc3NOYW1lICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkICcpICsgKCdpbnN0YW5jZSBvZiBgJyArIGV4cGVjdGVkQ2xhc3NOYW1lICsgJ2AuJykpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVFbnVtVHlwZUNoZWNrZXIoZXhwZWN0ZWRWYWx1ZXMpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoZXhwZWN0ZWRWYWx1ZXMpKSB7XG4gICAgICBpZiAodHJ1ZSkge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICBwcmludFdhcm5pbmcoXG4gICAgICAgICAgICAnSW52YWxpZCBhcmd1bWVudHMgc3VwcGxpZWQgdG8gb25lT2YsIGV4cGVjdGVkIGFuIGFycmF5LCBnb3QgJyArIGFyZ3VtZW50cy5sZW5ndGggKyAnIGFyZ3VtZW50cy4gJyArXG4gICAgICAgICAgICAnQSBjb21tb24gbWlzdGFrZSBpcyB0byB3cml0ZSBvbmVPZih4LCB5LCB6KSBpbnN0ZWFkIG9mIG9uZU9mKFt4LCB5LCB6XSkuJ1xuICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHJpbnRXYXJuaW5nKCdJbnZhbGlkIGFyZ3VtZW50IHN1cHBsaWVkIHRvIG9uZU9mLCBleHBlY3RlZCBhbiBhcnJheS4nKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGVtcHR5RnVuY3Rpb25UaGF0UmV0dXJuc051bGw7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBleHBlY3RlZFZhbHVlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoaXMocHJvcFZhbHVlLCBleHBlY3RlZFZhbHVlc1tpXSkpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgdmFsdWVzU3RyaW5nID0gSlNPTi5zdHJpbmdpZnkoZXhwZWN0ZWRWYWx1ZXMsIGZ1bmN0aW9uIHJlcGxhY2VyKGtleSwgdmFsdWUpIHtcbiAgICAgICAgdmFyIHR5cGUgPSBnZXRQcmVjaXNlVHlwZSh2YWx1ZSk7XG4gICAgICAgIGlmICh0eXBlID09PSAnc3ltYm9sJykge1xuICAgICAgICAgIHJldHVybiBTdHJpbmcodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB2YWx1ZSBgJyArIFN0cmluZyhwcm9wVmFsdWUpICsgJ2AgJyArICgnc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIG9uZSBvZiAnICsgdmFsdWVzU3RyaW5nICsgJy4nKSk7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVPYmplY3RPZlR5cGVDaGVja2VyKHR5cGVDaGVja2VyKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICBpZiAodHlwZW9mIHR5cGVDaGVja2VyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignUHJvcGVydHkgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiBjb21wb25lbnQgYCcgKyBjb21wb25lbnROYW1lICsgJ2AgaGFzIGludmFsaWQgUHJvcFR5cGUgbm90YXRpb24gaW5zaWRlIG9iamVjdE9mLicpO1xuICAgICAgfVxuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICBpZiAocHJvcFR5cGUgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIHByb3BUeXBlICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGFuIG9iamVjdC4nKSk7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBrZXkgaW4gcHJvcFZhbHVlKSB7XG4gICAgICAgIGlmIChoYXMocHJvcFZhbHVlLCBrZXkpKSB7XG4gICAgICAgICAgdmFyIGVycm9yID0gdHlwZUNoZWNrZXIocHJvcFZhbHVlLCBrZXksIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUgKyAnLicgKyBrZXksIFJlYWN0UHJvcFR5cGVzU2VjcmV0KTtcbiAgICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVVbmlvblR5cGVDaGVja2VyKGFycmF5T2ZUeXBlQ2hlY2tlcnMpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoYXJyYXlPZlR5cGVDaGVja2VycykpIHtcbiAgICAgICB0cnVlID8gcHJpbnRXYXJuaW5nKCdJbnZhbGlkIGFyZ3VtZW50IHN1cHBsaWVkIHRvIG9uZU9mVHlwZSwgZXhwZWN0ZWQgYW4gaW5zdGFuY2Ugb2YgYXJyYXkuJykgOiAwO1xuICAgICAgcmV0dXJuIGVtcHR5RnVuY3Rpb25UaGF0UmV0dXJuc051bGw7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheU9mVHlwZUNoZWNrZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgY2hlY2tlciA9IGFycmF5T2ZUeXBlQ2hlY2tlcnNbaV07XG4gICAgICBpZiAodHlwZW9mIGNoZWNrZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcHJpbnRXYXJuaW5nKFxuICAgICAgICAgICdJbnZhbGlkIGFyZ3VtZW50IHN1cHBsaWVkIHRvIG9uZU9mVHlwZS4gRXhwZWN0ZWQgYW4gYXJyYXkgb2YgY2hlY2sgZnVuY3Rpb25zLCBidXQgJyArXG4gICAgICAgICAgJ3JlY2VpdmVkICcgKyBnZXRQb3N0Zml4Rm9yVHlwZVdhcm5pbmcoY2hlY2tlcikgKyAnIGF0IGluZGV4ICcgKyBpICsgJy4nXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiBlbXB0eUZ1bmN0aW9uVGhhdFJldHVybnNOdWxsO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgdmFyIGV4cGVjdGVkVHlwZXMgPSBbXTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXlPZlR5cGVDaGVja2Vycy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY2hlY2tlciA9IGFycmF5T2ZUeXBlQ2hlY2tlcnNbaV07XG4gICAgICAgIHZhciBjaGVja2VyUmVzdWx0ID0gY2hlY2tlcihwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUsIFJlYWN0UHJvcFR5cGVzU2VjcmV0KTtcbiAgICAgICAgaWYgKGNoZWNrZXJSZXN1bHQgPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGVja2VyUmVzdWx0LmRhdGEgJiYgaGFzKGNoZWNrZXJSZXN1bHQuZGF0YSwgJ2V4cGVjdGVkVHlwZScpKSB7XG4gICAgICAgICAgZXhwZWN0ZWRUeXBlcy5wdXNoKGNoZWNrZXJSZXN1bHQuZGF0YS5leHBlY3RlZFR5cGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgZXhwZWN0ZWRUeXBlc01lc3NhZ2UgPSAoZXhwZWN0ZWRUeXBlcy5sZW5ndGggPiAwKSA/ICcsIGV4cGVjdGVkIG9uZSBvZiB0eXBlIFsnICsgZXhwZWN0ZWRUeXBlcy5qb2luKCcsICcpICsgJ10nOiAnJztcbiAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agc3VwcGxpZWQgdG8gJyArICgnYCcgKyBjb21wb25lbnROYW1lICsgJ2AnICsgZXhwZWN0ZWRUeXBlc01lc3NhZ2UgKyAnLicpKTtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZU5vZGVDaGVja2VyKCkge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgaWYgKCFpc05vZGUocHJvcHNbcHJvcE5hbWVdKSkge1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIHN1cHBsaWVkIHRvICcgKyAoJ2AnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBhIFJlYWN0Tm9kZS4nKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGludmFsaWRWYWxpZGF0b3JFcnJvcihjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lLCBrZXksIHR5cGUpIHtcbiAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoXG4gICAgICAoY29tcG9uZW50TmFtZSB8fCAnUmVhY3QgY2xhc3MnKSArICc6ICcgKyBsb2NhdGlvbiArICcgdHlwZSBgJyArIHByb3BGdWxsTmFtZSArICcuJyArIGtleSArICdgIGlzIGludmFsaWQ7ICcgK1xuICAgICAgJ2l0IG11c3QgYmUgYSBmdW5jdGlvbiwgdXN1YWxseSBmcm9tIHRoZSBgcHJvcC10eXBlc2AgcGFja2FnZSwgYnV0IHJlY2VpdmVkIGAnICsgdHlwZSArICdgLidcbiAgICApO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlU2hhcGVUeXBlQ2hlY2tlcihzaGFwZVR5cGVzKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICAgIGlmIChwcm9wVHlwZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlIGAnICsgcHJvcFR5cGUgKyAnYCAnICsgKCdzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYG9iamVjdGAuJykpO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIga2V5IGluIHNoYXBlVHlwZXMpIHtcbiAgICAgICAgdmFyIGNoZWNrZXIgPSBzaGFwZVR5cGVzW2tleV07XG4gICAgICAgIGlmICh0eXBlb2YgY2hlY2tlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHJldHVybiBpbnZhbGlkVmFsaWRhdG9yRXJyb3IoY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSwga2V5LCBnZXRQcmVjaXNlVHlwZShjaGVja2VyKSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGVycm9yID0gY2hlY2tlcihwcm9wVmFsdWUsIGtleSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSArICcuJyArIGtleSwgUmVhY3RQcm9wVHlwZXNTZWNyZXQpO1xuICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlU3RyaWN0U2hhcGVUeXBlQ2hlY2tlcihzaGFwZVR5cGVzKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICAgIGlmIChwcm9wVHlwZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlIGAnICsgcHJvcFR5cGUgKyAnYCAnICsgKCdzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYG9iamVjdGAuJykpO1xuICAgICAgfVxuICAgICAgLy8gV2UgbmVlZCB0byBjaGVjayBhbGwga2V5cyBpbiBjYXNlIHNvbWUgYXJlIHJlcXVpcmVkIGJ1dCBtaXNzaW5nIGZyb20gcHJvcHMuXG4gICAgICB2YXIgYWxsS2V5cyA9IGFzc2lnbih7fSwgcHJvcHNbcHJvcE5hbWVdLCBzaGFwZVR5cGVzKTtcbiAgICAgIGZvciAodmFyIGtleSBpbiBhbGxLZXlzKSB7XG4gICAgICAgIHZhciBjaGVja2VyID0gc2hhcGVUeXBlc1trZXldO1xuICAgICAgICBpZiAoaGFzKHNoYXBlVHlwZXMsIGtleSkgJiYgdHlwZW9mIGNoZWNrZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICByZXR1cm4gaW52YWxpZFZhbGlkYXRvckVycm9yKGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUsIGtleSwgZ2V0UHJlY2lzZVR5cGUoY2hlY2tlcikpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghY2hlY2tlcikge1xuICAgICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcihcbiAgICAgICAgICAgICdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBrZXkgYCcgKyBrZXkgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYC4nICtcbiAgICAgICAgICAgICdcXG5CYWQgb2JqZWN0OiAnICsgSlNPTi5zdHJpbmdpZnkocHJvcHNbcHJvcE5hbWVdLCBudWxsLCAnICAnKSArXG4gICAgICAgICAgICAnXFxuVmFsaWQga2V5czogJyArIEpTT04uc3RyaW5naWZ5KE9iamVjdC5rZXlzKHNoYXBlVHlwZXMpLCBudWxsLCAnICAnKVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGVycm9yID0gY2hlY2tlcihwcm9wVmFsdWUsIGtleSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSArICcuJyArIGtleSwgUmVhY3RQcm9wVHlwZXNTZWNyZXQpO1xuICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBpc05vZGUocHJvcFZhbHVlKSB7XG4gICAgc3dpdGNoICh0eXBlb2YgcHJvcFZhbHVlKSB7XG4gICAgICBjYXNlICdudW1iZXInOlxuICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgIGNhc2UgJ3VuZGVmaW5lZCc6XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgIHJldHVybiAhcHJvcFZhbHVlO1xuICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocHJvcFZhbHVlKSkge1xuICAgICAgICAgIHJldHVybiBwcm9wVmFsdWUuZXZlcnkoaXNOb2RlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvcFZhbHVlID09PSBudWxsIHx8IGlzVmFsaWRFbGVtZW50KHByb3BWYWx1ZSkpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpdGVyYXRvckZuID0gZ2V0SXRlcmF0b3JGbihwcm9wVmFsdWUpO1xuICAgICAgICBpZiAoaXRlcmF0b3JGbikge1xuICAgICAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhdG9yRm4uY2FsbChwcm9wVmFsdWUpO1xuICAgICAgICAgIHZhciBzdGVwO1xuICAgICAgICAgIGlmIChpdGVyYXRvckZuICE9PSBwcm9wVmFsdWUuZW50cmllcykge1xuICAgICAgICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgICAgICAgICBpZiAoIWlzTm9kZShzdGVwLnZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBJdGVyYXRvciB3aWxsIHByb3ZpZGUgZW50cnkgW2ssdl0gdHVwbGVzIHJhdGhlciB0aGFuIHZhbHVlcy5cbiAgICAgICAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgICAgICAgdmFyIGVudHJ5ID0gc3RlcC52YWx1ZTtcbiAgICAgICAgICAgICAgaWYgKGVudHJ5KSB7XG4gICAgICAgICAgICAgICAgaWYgKCFpc05vZGUoZW50cnlbMV0pKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGlzU3ltYm9sKHByb3BUeXBlLCBwcm9wVmFsdWUpIHtcbiAgICAvLyBOYXRpdmUgU3ltYm9sLlxuICAgIGlmIChwcm9wVHlwZSA9PT0gJ3N5bWJvbCcpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8vIGZhbHN5IHZhbHVlIGNhbid0IGJlIGEgU3ltYm9sXG4gICAgaWYgKCFwcm9wVmFsdWUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyAxOS40LjMuNSBTeW1ib2wucHJvdG90eXBlW0BAdG9TdHJpbmdUYWddID09PSAnU3ltYm9sJ1xuICAgIGlmIChwcm9wVmFsdWVbJ0BAdG9TdHJpbmdUYWcnXSA9PT0gJ1N5bWJvbCcpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8vIEZhbGxiYWNrIGZvciBub24tc3BlYyBjb21wbGlhbnQgU3ltYm9scyB3aGljaCBhcmUgcG9seWZpbGxlZC5cbiAgICBpZiAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBwcm9wVmFsdWUgaW5zdGFuY2VvZiBTeW1ib2wpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIEVxdWl2YWxlbnQgb2YgYHR5cGVvZmAgYnV0IHdpdGggc3BlY2lhbCBoYW5kbGluZyBmb3IgYXJyYXkgYW5kIHJlZ2V4cC5cbiAgZnVuY3Rpb24gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKSB7XG4gICAgdmFyIHByb3BUeXBlID0gdHlwZW9mIHByb3BWYWx1ZTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShwcm9wVmFsdWUpKSB7XG4gICAgICByZXR1cm4gJ2FycmF5JztcbiAgICB9XG4gICAgaWYgKHByb3BWYWx1ZSBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgLy8gT2xkIHdlYmtpdHMgKGF0IGxlYXN0IHVudGlsIEFuZHJvaWQgNC4wKSByZXR1cm4gJ2Z1bmN0aW9uJyByYXRoZXIgdGhhblxuICAgICAgLy8gJ29iamVjdCcgZm9yIHR5cGVvZiBhIFJlZ0V4cC4gV2UnbGwgbm9ybWFsaXplIHRoaXMgaGVyZSBzbyB0aGF0IC9ibGEvXG4gICAgICAvLyBwYXNzZXMgUHJvcFR5cGVzLm9iamVjdC5cbiAgICAgIHJldHVybiAnb2JqZWN0JztcbiAgICB9XG4gICAgaWYgKGlzU3ltYm9sKHByb3BUeXBlLCBwcm9wVmFsdWUpKSB7XG4gICAgICByZXR1cm4gJ3N5bWJvbCc7XG4gICAgfVxuICAgIHJldHVybiBwcm9wVHlwZTtcbiAgfVxuXG4gIC8vIFRoaXMgaGFuZGxlcyBtb3JlIHR5cGVzIHRoYW4gYGdldFByb3BUeXBlYC4gT25seSB1c2VkIGZvciBlcnJvciBtZXNzYWdlcy5cbiAgLy8gU2VlIGBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcmAuXG4gIGZ1bmN0aW9uIGdldFByZWNpc2VUeXBlKHByb3BWYWx1ZSkge1xuICAgIGlmICh0eXBlb2YgcHJvcFZhbHVlID09PSAndW5kZWZpbmVkJyB8fCBwcm9wVmFsdWUgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiAnJyArIHByb3BWYWx1ZTtcbiAgICB9XG4gICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICBpZiAocHJvcFR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgICBpZiAocHJvcFZhbHVlIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICByZXR1cm4gJ2RhdGUnO1xuICAgICAgfSBlbHNlIGlmIChwcm9wVmFsdWUgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgICAgcmV0dXJuICdyZWdleHAnO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcHJvcFR5cGU7XG4gIH1cblxuICAvLyBSZXR1cm5zIGEgc3RyaW5nIHRoYXQgaXMgcG9zdGZpeGVkIHRvIGEgd2FybmluZyBhYm91dCBhbiBpbnZhbGlkIHR5cGUuXG4gIC8vIEZvciBleGFtcGxlLCBcInVuZGVmaW5lZFwiIG9yIFwib2YgdHlwZSBhcnJheVwiXG4gIGZ1bmN0aW9uIGdldFBvc3RmaXhGb3JUeXBlV2FybmluZyh2YWx1ZSkge1xuICAgIHZhciB0eXBlID0gZ2V0UHJlY2lzZVR5cGUodmFsdWUpO1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSAnYXJyYXknOlxuICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgcmV0dXJuICdhbiAnICsgdHlwZTtcbiAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgY2FzZSAnZGF0ZSc6XG4gICAgICBjYXNlICdyZWdleHAnOlxuICAgICAgICByZXR1cm4gJ2EgJyArIHR5cGU7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gdHlwZTtcbiAgICB9XG4gIH1cblxuICAvLyBSZXR1cm5zIGNsYXNzIG5hbWUgb2YgdGhlIG9iamVjdCwgaWYgYW55LlxuICBmdW5jdGlvbiBnZXRDbGFzc05hbWUocHJvcFZhbHVlKSB7XG4gICAgaWYgKCFwcm9wVmFsdWUuY29uc3RydWN0b3IgfHwgIXByb3BWYWx1ZS5jb25zdHJ1Y3Rvci5uYW1lKSB7XG4gICAgICByZXR1cm4gQU5PTllNT1VTO1xuICAgIH1cbiAgICByZXR1cm4gcHJvcFZhbHVlLmNvbnN0cnVjdG9yLm5hbWU7XG4gIH1cblxuICBSZWFjdFByb3BUeXBlcy5jaGVja1Byb3BUeXBlcyA9IGNoZWNrUHJvcFR5cGVzO1xuICBSZWFjdFByb3BUeXBlcy5yZXNldFdhcm5pbmdDYWNoZSA9IGNoZWNrUHJvcFR5cGVzLnJlc2V0V2FybmluZ0NhY2hlO1xuICBSZWFjdFByb3BUeXBlcy5Qcm9wVHlwZXMgPSBSZWFjdFByb3BUeXBlcztcblxuICByZXR1cm4gUmVhY3RQcm9wVHlwZXM7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvaW5kZXguanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL2luZGV4LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuaWYgKHRydWUpIHtcbiAgdmFyIFJlYWN0SXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISByZWFjdC1pcyAqLyBcIi4vbm9kZV9tb2R1bGVzL3JlYWN0LWlzL2luZGV4LmpzXCIpO1xuXG4gIC8vIEJ5IGV4cGxpY2l0bHkgdXNpbmcgYHByb3AtdHlwZXNgIHlvdSBhcmUgb3B0aW5nIGludG8gbmV3IGRldmVsb3BtZW50IGJlaGF2aW9yLlxuICAvLyBodHRwOi8vZmIubWUvcHJvcC10eXBlcy1pbi1wcm9kXG4gIHZhciB0aHJvd09uRGlyZWN0QWNjZXNzID0gdHJ1ZTtcbiAgbW9kdWxlLmV4cG9ydHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2ZhY3RvcnlXaXRoVHlwZUNoZWNrZXJzICovIFwiLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9mYWN0b3J5V2l0aFR5cGVDaGVja2Vycy5qc1wiKShSZWFjdElzLmlzRWxlbWVudCwgdGhyb3dPbkRpcmVjdEFjY2Vzcyk7XG59IGVsc2Uge31cblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL2xpYi9SZWFjdFByb3BUeXBlc1NlY3JldC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL2xpYi9SZWFjdFByb3BUeXBlc1NlY3JldC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgobW9kdWxlKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG5cblxudmFyIFJlYWN0UHJvcFR5cGVzU2VjcmV0ID0gJ1NFQ1JFVF9ET19OT1RfUEFTU19USElTX09SX1lPVV9XSUxMX0JFX0ZJUkVEJztcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdFByb3BUeXBlc1NlY3JldDtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL2xpYi9oYXMuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvbGliL2hhcy5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKG1vZHVsZSkgPT4ge1xuXG5tb2R1bGUuZXhwb3J0cyA9IEZ1bmN0aW9uLmNhbGwuYmluZChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5KTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9yZWFjdC1pcy9janMvcmVhY3QtaXMuZGV2ZWxvcG1lbnQuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL3JlYWN0LWlzL2Nqcy9yZWFjdC1pcy5kZXZlbG9wbWVudC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuLyoqIEBsaWNlbnNlIFJlYWN0IHYxNi4xMy4xXG4gKiByZWFjdC1pcy5kZXZlbG9wbWVudC5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cblxuXG5cblxuaWYgKHRydWUpIHtcbiAgKGZ1bmN0aW9uKCkge1xuJ3VzZSBzdHJpY3QnO1xuXG4vLyBUaGUgU3ltYm9sIHVzZWQgdG8gdGFnIHRoZSBSZWFjdEVsZW1lbnQtbGlrZSB0eXBlcy4gSWYgdGhlcmUgaXMgbm8gbmF0aXZlIFN5bWJvbFxuLy8gbm9yIHBvbHlmaWxsLCB0aGVuIGEgcGxhaW4gbnVtYmVyIGlzIHVzZWQgZm9yIHBlcmZvcm1hbmNlLlxudmFyIGhhc1N5bWJvbCA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLmZvcjtcbnZhciBSRUFDVF9FTEVNRU5UX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5lbGVtZW50JykgOiAweGVhYzc7XG52YXIgUkVBQ1RfUE9SVEFMX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5wb3J0YWwnKSA6IDB4ZWFjYTtcbnZhciBSRUFDVF9GUkFHTUVOVF9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QuZnJhZ21lbnQnKSA6IDB4ZWFjYjtcbnZhciBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3Quc3RyaWN0X21vZGUnKSA6IDB4ZWFjYztcbnZhciBSRUFDVF9QUk9GSUxFUl9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QucHJvZmlsZXInKSA6IDB4ZWFkMjtcbnZhciBSRUFDVF9QUk9WSURFUl9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QucHJvdmlkZXInKSA6IDB4ZWFjZDtcbnZhciBSRUFDVF9DT05URVhUX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5jb250ZXh0JykgOiAweGVhY2U7IC8vIFRPRE86IFdlIGRvbid0IHVzZSBBc3luY01vZGUgb3IgQ29uY3VycmVudE1vZGUgYW55bW9yZS4gVGhleSB3ZXJlIHRlbXBvcmFyeVxuLy8gKHVuc3RhYmxlKSBBUElzIHRoYXQgaGF2ZSBiZWVuIHJlbW92ZWQuIENhbiB3ZSByZW1vdmUgdGhlIHN5bWJvbHM/XG5cbnZhciBSRUFDVF9BU1lOQ19NT0RFX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5hc3luY19tb2RlJykgOiAweGVhY2Y7XG52YXIgUkVBQ1RfQ09OQ1VSUkVOVF9NT0RFX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5jb25jdXJyZW50X21vZGUnKSA6IDB4ZWFjZjtcbnZhciBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QuZm9yd2FyZF9yZWYnKSA6IDB4ZWFkMDtcbnZhciBSRUFDVF9TVVNQRU5TRV9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3Quc3VzcGVuc2UnKSA6IDB4ZWFkMTtcbnZhciBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5zdXNwZW5zZV9saXN0JykgOiAweGVhZDg7XG52YXIgUkVBQ1RfTUVNT19UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QubWVtbycpIDogMHhlYWQzO1xudmFyIFJFQUNUX0xBWllfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LmxhenknKSA6IDB4ZWFkNDtcbnZhciBSRUFDVF9CTE9DS19UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QuYmxvY2snKSA6IDB4ZWFkOTtcbnZhciBSRUFDVF9GVU5EQU1FTlRBTF9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QuZnVuZGFtZW50YWwnKSA6IDB4ZWFkNTtcbnZhciBSRUFDVF9SRVNQT05ERVJfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LnJlc3BvbmRlcicpIDogMHhlYWQ2O1xudmFyIFJFQUNUX1NDT1BFX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5zY29wZScpIDogMHhlYWQ3O1xuXG5mdW5jdGlvbiBpc1ZhbGlkRWxlbWVudFR5cGUodHlwZSkge1xuICByZXR1cm4gdHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nIHx8IC8vIE5vdGU6IGl0cyB0eXBlb2YgbWlnaHQgYmUgb3RoZXIgdGhhbiAnc3ltYm9sJyBvciAnbnVtYmVyJyBpZiBpdCdzIGEgcG9seWZpbGwuXG4gIHR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfQ09OQ1VSUkVOVF9NT0RFX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfUFJPRklMRVJfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1NVU1BFTlNFX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFIHx8IHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiB0eXBlICE9PSBudWxsICYmICh0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9MQVpZX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTUVNT19UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX1BST1ZJREVSX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQ09OVEVYVF9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRlVOREFNRU5UQUxfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9SRVNQT05ERVJfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9TQ09QRV9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0JMT0NLX1RZUEUpO1xufVxuXG5mdW5jdGlvbiB0eXBlT2Yob2JqZWN0KSB7XG4gIGlmICh0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJiBvYmplY3QgIT09IG51bGwpIHtcbiAgICB2YXIgJCR0eXBlb2YgPSBvYmplY3QuJCR0eXBlb2Y7XG5cbiAgICBzd2l0Y2ggKCQkdHlwZW9mKSB7XG4gICAgICBjYXNlIFJFQUNUX0VMRU1FTlRfVFlQRTpcbiAgICAgICAgdmFyIHR5cGUgPSBvYmplY3QudHlwZTtcblxuICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICBjYXNlIFJFQUNUX0FTWU5DX01PREVfVFlQRTpcbiAgICAgICAgICBjYXNlIFJFQUNUX0NPTkNVUlJFTlRfTU9ERV9UWVBFOlxuICAgICAgICAgIGNhc2UgUkVBQ1RfRlJBR01FTlRfVFlQRTpcbiAgICAgICAgICBjYXNlIFJFQUNUX1BST0ZJTEVSX1RZUEU6XG4gICAgICAgICAgY2FzZSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFOlxuICAgICAgICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfVFlQRTpcbiAgICAgICAgICAgIHJldHVybiB0eXBlO1xuXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHZhciAkJHR5cGVvZlR5cGUgPSB0eXBlICYmIHR5cGUuJCR0eXBlb2Y7XG5cbiAgICAgICAgICAgIHN3aXRjaCAoJCR0eXBlb2ZUeXBlKSB7XG4gICAgICAgICAgICAgIGNhc2UgUkVBQ1RfQ09OVEVYVF9UWVBFOlxuICAgICAgICAgICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgICAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxuICAgICAgICAgICAgICBjYXNlIFJFQUNUX01FTU9fVFlQRTpcbiAgICAgICAgICAgICAgY2FzZSBSRUFDVF9QUk9WSURFUl9UWVBFOlxuICAgICAgICAgICAgICAgIHJldHVybiAkJHR5cGVvZlR5cGU7XG5cbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gJCR0eXBlb2Y7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgICByZXR1cm4gJCR0eXBlb2Y7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn0gLy8gQXN5bmNNb2RlIGlzIGRlcHJlY2F0ZWQgYWxvbmcgd2l0aCBpc0FzeW5jTW9kZVxuXG52YXIgQXN5bmNNb2RlID0gUkVBQ1RfQVNZTkNfTU9ERV9UWVBFO1xudmFyIENvbmN1cnJlbnRNb2RlID0gUkVBQ1RfQ09OQ1VSUkVOVF9NT0RFX1RZUEU7XG52YXIgQ29udGV4dENvbnN1bWVyID0gUkVBQ1RfQ09OVEVYVF9UWVBFO1xudmFyIENvbnRleHRQcm92aWRlciA9IFJFQUNUX1BST1ZJREVSX1RZUEU7XG52YXIgRWxlbWVudCA9IFJFQUNUX0VMRU1FTlRfVFlQRTtcbnZhciBGb3J3YXJkUmVmID0gUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTtcbnZhciBGcmFnbWVudCA9IFJFQUNUX0ZSQUdNRU5UX1RZUEU7XG52YXIgTGF6eSA9IFJFQUNUX0xBWllfVFlQRTtcbnZhciBNZW1vID0gUkVBQ1RfTUVNT19UWVBFO1xudmFyIFBvcnRhbCA9IFJFQUNUX1BPUlRBTF9UWVBFO1xudmFyIFByb2ZpbGVyID0gUkVBQ1RfUFJPRklMRVJfVFlQRTtcbnZhciBTdHJpY3RNb2RlID0gUkVBQ1RfU1RSSUNUX01PREVfVFlQRTtcbnZhciBTdXNwZW5zZSA9IFJFQUNUX1NVU1BFTlNFX1RZUEU7XG52YXIgaGFzV2FybmVkQWJvdXREZXByZWNhdGVkSXNBc3luY01vZGUgPSBmYWxzZTsgLy8gQXN5bmNNb2RlIHNob3VsZCBiZSBkZXByZWNhdGVkXG5cbmZ1bmN0aW9uIGlzQXN5bmNNb2RlKG9iamVjdCkge1xuICB7XG4gICAgaWYgKCFoYXNXYXJuZWRBYm91dERlcHJlY2F0ZWRJc0FzeW5jTW9kZSkge1xuICAgICAgaGFzV2FybmVkQWJvdXREZXByZWNhdGVkSXNBc3luY01vZGUgPSB0cnVlOyAvLyBVc2luZyBjb25zb2xlWyd3YXJuJ10gdG8gZXZhZGUgQmFiZWwgYW5kIEVTTGludFxuXG4gICAgICBjb25zb2xlWyd3YXJuJ10oJ1RoZSBSZWFjdElzLmlzQXN5bmNNb2RlKCkgYWxpYXMgaGFzIGJlZW4gZGVwcmVjYXRlZCwgJyArICdhbmQgd2lsbCBiZSByZW1vdmVkIGluIFJlYWN0IDE3Ky4gVXBkYXRlIHlvdXIgY29kZSB0byB1c2UgJyArICdSZWFjdElzLmlzQ29uY3VycmVudE1vZGUoKSBpbnN0ZWFkLiBJdCBoYXMgdGhlIGV4YWN0IHNhbWUgQVBJLicpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBpc0NvbmN1cnJlbnRNb2RlKG9iamVjdCkgfHwgdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX0FTWU5DX01PREVfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzQ29uY3VycmVudE1vZGUob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfQ09OQ1VSUkVOVF9NT0RFX1RZUEU7XG59XG5mdW5jdGlvbiBpc0NvbnRleHRDb25zdW1lcihvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9DT05URVhUX1RZUEU7XG59XG5mdW5jdGlvbiBpc0NvbnRleHRQcm92aWRlcihvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9QUk9WSURFUl9UWVBFO1xufVxuZnVuY3Rpb24gaXNFbGVtZW50KG9iamVjdCkge1xuICByZXR1cm4gdHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCcgJiYgb2JqZWN0ICE9PSBudWxsICYmIG9iamVjdC4kJHR5cGVvZiA9PT0gUkVBQ1RfRUxFTUVOVF9UWVBFO1xufVxuZnVuY3Rpb24gaXNGb3J3YXJkUmVmKG9iamVjdCkge1xuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU7XG59XG5mdW5jdGlvbiBpc0ZyYWdtZW50KG9iamVjdCkge1xuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEU7XG59XG5mdW5jdGlvbiBpc0xhenkob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfTEFaWV9UWVBFO1xufVxuZnVuY3Rpb24gaXNNZW1vKG9iamVjdCkge1xuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX01FTU9fVFlQRTtcbn1cbmZ1bmN0aW9uIGlzUG9ydGFsKG9iamVjdCkge1xuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX1BPUlRBTF9UWVBFO1xufVxuZnVuY3Rpb24gaXNQcm9maWxlcihvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9QUk9GSUxFUl9UWVBFO1xufVxuZnVuY3Rpb24gaXNTdHJpY3RNb2RlKG9iamVjdCkge1xuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX1NUUklDVF9NT0RFX1RZUEU7XG59XG5mdW5jdGlvbiBpc1N1c3BlbnNlKG9iamVjdCkge1xuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX1NVU1BFTlNFX1RZUEU7XG59XG5cbmV4cG9ydHMuQXN5bmNNb2RlID0gQXN5bmNNb2RlO1xuZXhwb3J0cy5Db25jdXJyZW50TW9kZSA9IENvbmN1cnJlbnRNb2RlO1xuZXhwb3J0cy5Db250ZXh0Q29uc3VtZXIgPSBDb250ZXh0Q29uc3VtZXI7XG5leHBvcnRzLkNvbnRleHRQcm92aWRlciA9IENvbnRleHRQcm92aWRlcjtcbmV4cG9ydHMuRWxlbWVudCA9IEVsZW1lbnQ7XG5leHBvcnRzLkZvcndhcmRSZWYgPSBGb3J3YXJkUmVmO1xuZXhwb3J0cy5GcmFnbWVudCA9IEZyYWdtZW50O1xuZXhwb3J0cy5MYXp5ID0gTGF6eTtcbmV4cG9ydHMuTWVtbyA9IE1lbW87XG5leHBvcnRzLlBvcnRhbCA9IFBvcnRhbDtcbmV4cG9ydHMuUHJvZmlsZXIgPSBQcm9maWxlcjtcbmV4cG9ydHMuU3RyaWN0TW9kZSA9IFN0cmljdE1vZGU7XG5leHBvcnRzLlN1c3BlbnNlID0gU3VzcGVuc2U7XG5leHBvcnRzLmlzQXN5bmNNb2RlID0gaXNBc3luY01vZGU7XG5leHBvcnRzLmlzQ29uY3VycmVudE1vZGUgPSBpc0NvbmN1cnJlbnRNb2RlO1xuZXhwb3J0cy5pc0NvbnRleHRDb25zdW1lciA9IGlzQ29udGV4dENvbnN1bWVyO1xuZXhwb3J0cy5pc0NvbnRleHRQcm92aWRlciA9IGlzQ29udGV4dFByb3ZpZGVyO1xuZXhwb3J0cy5pc0VsZW1lbnQgPSBpc0VsZW1lbnQ7XG5leHBvcnRzLmlzRm9yd2FyZFJlZiA9IGlzRm9yd2FyZFJlZjtcbmV4cG9ydHMuaXNGcmFnbWVudCA9IGlzRnJhZ21lbnQ7XG5leHBvcnRzLmlzTGF6eSA9IGlzTGF6eTtcbmV4cG9ydHMuaXNNZW1vID0gaXNNZW1vO1xuZXhwb3J0cy5pc1BvcnRhbCA9IGlzUG9ydGFsO1xuZXhwb3J0cy5pc1Byb2ZpbGVyID0gaXNQcm9maWxlcjtcbmV4cG9ydHMuaXNTdHJpY3RNb2RlID0gaXNTdHJpY3RNb2RlO1xuZXhwb3J0cy5pc1N1c3BlbnNlID0gaXNTdXNwZW5zZTtcbmV4cG9ydHMuaXNWYWxpZEVsZW1lbnRUeXBlID0gaXNWYWxpZEVsZW1lbnRUeXBlO1xuZXhwb3J0cy50eXBlT2YgPSB0eXBlT2Y7XG4gIH0pKCk7XG59XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvcmVhY3QtaXMvaW5kZXguanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvcmVhY3QtaXMvaW5kZXguanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbmlmIChmYWxzZSkge30gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9janMvcmVhY3QtaXMuZGV2ZWxvcG1lbnQuanMgKi8gXCIuL25vZGVfbW9kdWxlcy9yZWFjdC1pcy9janMvcmVhY3QtaXMuZGV2ZWxvcG1lbnQuanNcIik7XG59XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvc2hhbGxvdy1lcXVhbC9kaXN0L2luZGV4LmVzbS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL3NoYWxsb3ctZXF1YWwvZGlzdC9pbmRleC5lc20uanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGV4cG9ydCAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywge1xuLyogaGFybW9ueSBleHBvcnQgKi8gICBcInNoYWxsb3dFcXVhbEFycmF5c1wiOiAoKSA9PiAoLyogYmluZGluZyAqLyBzaGFsbG93RXF1YWxBcnJheXMpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBcInNoYWxsb3dFcXVhbE9iamVjdHNcIjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gc2hhbGxvd0VxdWFsT2JqZWN0cylcbi8qIGhhcm1vbnkgZXhwb3J0ICovIH0pO1xuZnVuY3Rpb24gc2hhbGxvd0VxdWFsT2JqZWN0cyhvYmpBLCBvYmpCKSB7XG4gIGlmIChvYmpBID09PSBvYmpCKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAoIW9iakEgfHwgIW9iakIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgYUtleXMgPSBPYmplY3Qua2V5cyhvYmpBKTtcbiAgdmFyIGJLZXlzID0gT2JqZWN0LmtleXMob2JqQik7XG4gIHZhciBsZW4gPSBhS2V5cy5sZW5ndGg7XG5cbiAgaWYgKGJLZXlzLmxlbmd0aCAhPT0gbGVuKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIHZhciBrZXkgPSBhS2V5c1tpXTtcblxuICAgIGlmIChvYmpBW2tleV0gIT09IG9iakJba2V5XSB8fCAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iakIsIGtleSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gc2hhbGxvd0VxdWFsQXJyYXlzKGFyckEsIGFyckIpIHtcbiAgaWYgKGFyckEgPT09IGFyckIpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmICghYXJyQSB8fCAhYXJyQikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBsZW4gPSBhcnJBLmxlbmd0aDtcblxuICBpZiAoYXJyQi5sZW5ndGggIT09IGxlbikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICBpZiAoYXJyQVtpXSAhPT0gYXJyQltpXSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5cblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9Db21wb25lbnQudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL0NvbXBvbmVudC50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoZnVuY3Rpb24oX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfX3Jlc3QgPSAodGhpcyAmJiB0aGlzLl9fcmVzdCkgfHwgZnVuY3Rpb24gKHMsIGUpIHtcbiAgICB2YXIgdCA9IHt9O1xuICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSAmJiBlLmluZGV4T2YocCkgPCAwKVxuICAgICAgICB0W3BdID0gc1twXTtcbiAgICBpZiAocyAhPSBudWxsICYmIHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID09PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBwID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzKTsgaSA8IHAubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChlLmluZGV4T2YocFtpXSkgPCAwICYmIE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzLCBwW2ldKSlcbiAgICAgICAgICAgICAgICB0W3BbaV1dID0gc1twW2ldXTtcbiAgICAgICAgfVxuICAgIHJldHVybiB0O1xufTtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xudmFyIHVzZU1lZGlhUXVlcnlfMSA9IF9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3VzZU1lZGlhUXVlcnkgKi8gXCIuL3NyYy91c2VNZWRpYVF1ZXJ5LnRzXCIpKTtcbi8vIFJlYWN0Tm9kZSBhbmQgUmVhY3RFbGVtZW50IHR5cGluZ3MgYXJlIGEgbGl0dGxlIGZ1bmt5IGZvciBmdW5jdGlvbmFsIGNvbXBvbmVudHMsIHNvIHRoZSBSZWFjdEVsZW1lbnQgY2FzdCBpcyBuZWVkZWQgb24gdGhlIHJldHVyblxudmFyIE1lZGlhUXVlcnkgPSBmdW5jdGlvbiAoX2EpIHtcbiAgICB2YXIgY2hpbGRyZW4gPSBfYS5jaGlsZHJlbiwgZGV2aWNlID0gX2EuZGV2aWNlLCBvbkNoYW5nZSA9IF9hLm9uQ2hhbmdlLCBzZXR0aW5ncyA9IF9fcmVzdChfYSwgW1wiY2hpbGRyZW5cIiwgXCJkZXZpY2VcIiwgXCJvbkNoYW5nZVwiXSk7XG4gICAgdmFyIG1hdGNoZXMgPSAoMCwgdXNlTWVkaWFRdWVyeV8xLmRlZmF1bHQpKHNldHRpbmdzLCBkZXZpY2UsIG9uQ2hhbmdlKTtcbiAgICBpZiAodHlwZW9mIGNoaWxkcmVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBjaGlsZHJlbihtYXRjaGVzKTtcbiAgICB9XG4gICAgcmV0dXJuIG1hdGNoZXMgPyBjaGlsZHJlbiA6IG51bGw7XG59O1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBNZWRpYVF1ZXJ5O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL0NvbnRleHQudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9Db250ZXh0LnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcbnZhciByZWFjdF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgcmVhY3QgKi8gXCJyZWFjdFwiKTtcbnZhciBDb250ZXh0ID0gKDAsIHJlYWN0XzEuY3JlYXRlQ29udGV4dCkodW5kZWZpbmVkKTtcbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gQ29udGV4dDtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9pbmRleC50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9pbmRleC50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XG5leHBvcnRzLkNvbnRleHQgPSBleHBvcnRzLnRvUXVlcnkgPSBleHBvcnRzLnVzZU1lZGlhUXVlcnkgPSBleHBvcnRzW1wiZGVmYXVsdFwiXSA9IHZvaWQgMDtcbnZhciB1c2VNZWRpYVF1ZXJ5XzEgPSBfX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi91c2VNZWRpYVF1ZXJ5ICovIFwiLi9zcmMvdXNlTWVkaWFRdWVyeS50c1wiKSk7XG5leHBvcnRzLnVzZU1lZGlhUXVlcnkgPSB1c2VNZWRpYVF1ZXJ5XzEuZGVmYXVsdDtcbnZhciBDb21wb25lbnRfMSA9IF9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL0NvbXBvbmVudCAqLyBcIi4vc3JjL0NvbXBvbmVudC50c1wiKSk7XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IENvbXBvbmVudF8xLmRlZmF1bHQ7XG52YXIgdG9RdWVyeV8xID0gX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vdG9RdWVyeSAqLyBcIi4vc3JjL3RvUXVlcnkudHNcIikpO1xuZXhwb3J0cy50b1F1ZXJ5ID0gdG9RdWVyeV8xLmRlZmF1bHQ7XG52YXIgQ29udGV4dF8xID0gX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vQ29udGV4dCAqLyBcIi4vc3JjL0NvbnRleHQudHNcIikpO1xuZXhwb3J0cy5Db250ZXh0ID0gQ29udGV4dF8xLmRlZmF1bHQ7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvbWVkaWFRdWVyeS50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL21lZGlhUXVlcnkudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIF9fYXNzaWduID0gKHRoaXMgJiYgdGhpcy5fX2Fzc2lnbikgfHwgZnVuY3Rpb24gKCkge1xuICAgIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbih0KSB7XG4gICAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSlcbiAgICAgICAgICAgICAgICB0W3BdID0gc1twXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdDtcbiAgICB9O1xuICAgIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufTtcbnZhciBfX3Jlc3QgPSAodGhpcyAmJiB0aGlzLl9fcmVzdCkgfHwgZnVuY3Rpb24gKHMsIGUpIHtcbiAgICB2YXIgdCA9IHt9O1xuICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSAmJiBlLmluZGV4T2YocCkgPCAwKVxuICAgICAgICB0W3BdID0gc1twXTtcbiAgICBpZiAocyAhPSBudWxsICYmIHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID09PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBwID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzKTsgaSA8IHAubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChlLmluZGV4T2YocFtpXSkgPCAwICYmIE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzLCBwW2ldKSlcbiAgICAgICAgICAgICAgICB0W3BbaV1dID0gc1twW2ldXTtcbiAgICAgICAgfVxuICAgIHJldHVybiB0O1xufTtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xudmFyIHByb3BfdHlwZXNfMSA9IF9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBwcm9wLXR5cGVzICovIFwiLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9pbmRleC5qc1wiKSk7XG52YXIgc3RyaW5nT3JOdW1iZXIgPSBwcm9wX3R5cGVzXzEuZGVmYXVsdC5vbmVPZlR5cGUoW1xuICAgIHByb3BfdHlwZXNfMS5kZWZhdWx0LnN0cmluZyxcbiAgICBwcm9wX3R5cGVzXzEuZGVmYXVsdC5udW1iZXJcbl0pO1xuLy8gbWVkaWEgdHlwZXNcbnZhciB0eXBlcyA9IHtcbiAgICBhbGw6IHByb3BfdHlwZXNfMS5kZWZhdWx0LmJvb2wsXG4gICAgZ3JpZDogcHJvcF90eXBlc18xLmRlZmF1bHQuYm9vbCxcbiAgICBhdXJhbDogcHJvcF90eXBlc18xLmRlZmF1bHQuYm9vbCxcbiAgICBicmFpbGxlOiBwcm9wX3R5cGVzXzEuZGVmYXVsdC5ib29sLFxuICAgIGhhbmRoZWxkOiBwcm9wX3R5cGVzXzEuZGVmYXVsdC5ib29sLFxuICAgIHByaW50OiBwcm9wX3R5cGVzXzEuZGVmYXVsdC5ib29sLFxuICAgIHByb2plY3Rpb246IHByb3BfdHlwZXNfMS5kZWZhdWx0LmJvb2wsXG4gICAgc2NyZWVuOiBwcm9wX3R5cGVzXzEuZGVmYXVsdC5ib29sLFxuICAgIHR0eTogcHJvcF90eXBlc18xLmRlZmF1bHQuYm9vbCxcbiAgICB0djogcHJvcF90eXBlc18xLmRlZmF1bHQuYm9vbCxcbiAgICBlbWJvc3NlZDogcHJvcF90eXBlc18xLmRlZmF1bHQuYm9vbFxufTtcbi8vIHByb3BlcnRpZXMgdGhhdCBtYXRjaCBtZWRpYSBxdWVyaWVzXG52YXIgbWF0Y2hlcnMgPSB7XG4gICAgb3JpZW50YXRpb246IHByb3BfdHlwZXNfMS5kZWZhdWx0Lm9uZU9mKFtcbiAgICAgICAgJ3BvcnRyYWl0JyxcbiAgICAgICAgJ2xhbmRzY2FwZSdcbiAgICBdKSxcbiAgICBzY2FuOiBwcm9wX3R5cGVzXzEuZGVmYXVsdC5vbmVPZihbXG4gICAgICAgICdwcm9ncmVzc2l2ZScsXG4gICAgICAgICdpbnRlcmxhY2UnXG4gICAgXSksXG4gICAgYXNwZWN0UmF0aW86IHByb3BfdHlwZXNfMS5kZWZhdWx0LnN0cmluZyxcbiAgICBkZXZpY2VBc3BlY3RSYXRpbzogcHJvcF90eXBlc18xLmRlZmF1bHQuc3RyaW5nLFxuICAgIGhlaWdodDogc3RyaW5nT3JOdW1iZXIsXG4gICAgZGV2aWNlSGVpZ2h0OiBzdHJpbmdPck51bWJlcixcbiAgICB3aWR0aDogc3RyaW5nT3JOdW1iZXIsXG4gICAgZGV2aWNlV2lkdGg6IHN0cmluZ09yTnVtYmVyLFxuICAgIGNvbG9yOiBwcm9wX3R5cGVzXzEuZGVmYXVsdC5ib29sLFxuICAgIGNvbG9ySW5kZXg6IHByb3BfdHlwZXNfMS5kZWZhdWx0LmJvb2wsXG4gICAgbW9ub2Nocm9tZTogcHJvcF90eXBlc18xLmRlZmF1bHQuYm9vbCxcbiAgICByZXNvbHV0aW9uOiBzdHJpbmdPck51bWJlcixcbiAgICB0eXBlOiBPYmplY3Qua2V5cyh0eXBlcylcbn07XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG52YXIgdHlwZSA9IG1hdGNoZXJzLnR5cGUsIGZlYXR1cmVNYXRjaGVycyA9IF9fcmVzdChtYXRjaGVyc1xuLy8gbWVkaWEgZmVhdHVyZXNcbiwgW1widHlwZVwiXSk7XG4vLyBtZWRpYSBmZWF0dXJlc1xudmFyIGZlYXR1cmVzID0gX19hc3NpZ24oeyBtaW5Bc3BlY3RSYXRpbzogcHJvcF90eXBlc18xLmRlZmF1bHQuc3RyaW5nLCBtYXhBc3BlY3RSYXRpbzogcHJvcF90eXBlc18xLmRlZmF1bHQuc3RyaW5nLCBtaW5EZXZpY2VBc3BlY3RSYXRpbzogcHJvcF90eXBlc18xLmRlZmF1bHQuc3RyaW5nLCBtYXhEZXZpY2VBc3BlY3RSYXRpbzogcHJvcF90eXBlc18xLmRlZmF1bHQuc3RyaW5nLCBtaW5IZWlnaHQ6IHN0cmluZ09yTnVtYmVyLCBtYXhIZWlnaHQ6IHN0cmluZ09yTnVtYmVyLCBtaW5EZXZpY2VIZWlnaHQ6IHN0cmluZ09yTnVtYmVyLCBtYXhEZXZpY2VIZWlnaHQ6IHN0cmluZ09yTnVtYmVyLCBtaW5XaWR0aDogc3RyaW5nT3JOdW1iZXIsIG1heFdpZHRoOiBzdHJpbmdPck51bWJlciwgbWluRGV2aWNlV2lkdGg6IHN0cmluZ09yTnVtYmVyLCBtYXhEZXZpY2VXaWR0aDogc3RyaW5nT3JOdW1iZXIsIG1pbkNvbG9yOiBwcm9wX3R5cGVzXzEuZGVmYXVsdC5udW1iZXIsIG1heENvbG9yOiBwcm9wX3R5cGVzXzEuZGVmYXVsdC5udW1iZXIsIG1pbkNvbG9ySW5kZXg6IHByb3BfdHlwZXNfMS5kZWZhdWx0Lm51bWJlciwgbWF4Q29sb3JJbmRleDogcHJvcF90eXBlc18xLmRlZmF1bHQubnVtYmVyLCBtaW5Nb25vY2hyb21lOiBwcm9wX3R5cGVzXzEuZGVmYXVsdC5udW1iZXIsIG1heE1vbm9jaHJvbWU6IHByb3BfdHlwZXNfMS5kZWZhdWx0Lm51bWJlciwgbWluUmVzb2x1dGlvbjogc3RyaW5nT3JOdW1iZXIsIG1heFJlc29sdXRpb246IHN0cmluZ09yTnVtYmVyIH0sIGZlYXR1cmVNYXRjaGVycyk7XG52YXIgYWxsID0gX19hc3NpZ24oX19hc3NpZ24oe30sIHR5cGVzKSwgZmVhdHVyZXMpO1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSB7XG4gICAgYWxsOiBhbGwsXG4gICAgdHlwZXM6IHR5cGVzLFxuICAgIG1hdGNoZXJzOiBtYXRjaGVycyxcbiAgICBmZWF0dXJlczogZmVhdHVyZXNcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvdG9RdWVyeS50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL3RvUXVlcnkudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XG52YXIgaHlwaGVuYXRlX3N0eWxlX25hbWVfMSA9IF9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBoeXBoZW5hdGUtc3R5bGUtbmFtZSAqLyBcIi4vbm9kZV9tb2R1bGVzL2h5cGhlbmF0ZS1zdHlsZS1uYW1lL2luZGV4LmpzXCIpKTtcbnZhciBtZWRpYVF1ZXJ5XzEgPSBfX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9tZWRpYVF1ZXJ5ICovIFwiLi9zcmMvbWVkaWFRdWVyeS50c1wiKSk7XG52YXIgbmVnYXRlID0gZnVuY3Rpb24gKGNvbmQpIHsgcmV0dXJuIFwibm90IFwiLmNvbmNhdChjb25kKTsgfTtcbnZhciBrZXlWYWwgPSBmdW5jdGlvbiAoaywgdikge1xuICAgIHZhciByZWFsS2V5ID0gKDAsIGh5cGhlbmF0ZV9zdHlsZV9uYW1lXzEuZGVmYXVsdCkoayk7XG4gICAgLy8gcHggc2hvcnRoYW5kXG4gICAgaWYgKHR5cGVvZiB2ID09PSAnbnVtYmVyJykge1xuICAgICAgICB2ID0gXCJcIi5jb25jYXQodiwgXCJweFwiKTtcbiAgICB9XG4gICAgaWYgKHYgPT09IHRydWUpIHtcbiAgICAgICAgcmV0dXJuIHJlYWxLZXk7XG4gICAgfVxuICAgIGlmICh2ID09PSBmYWxzZSkge1xuICAgICAgICByZXR1cm4gbmVnYXRlKHJlYWxLZXkpO1xuICAgIH1cbiAgICByZXR1cm4gXCIoXCIuY29uY2F0KHJlYWxLZXksIFwiOiBcIikuY29uY2F0KHYsIFwiKVwiKTtcbn07XG52YXIgam9pbiA9IGZ1bmN0aW9uIChjb25kcykgeyByZXR1cm4gY29uZHMuam9pbignIGFuZCAnKTsgfTtcbnZhciB0b1F1ZXJ5ID0gZnVuY3Rpb24gKG9iaikge1xuICAgIHZhciBydWxlcyA9IFtdO1xuICAgIE9iamVjdC5rZXlzKG1lZGlhUXVlcnlfMS5kZWZhdWx0LmFsbCkuZm9yRWFjaChmdW5jdGlvbiAoaykge1xuICAgICAgICB2YXIgdiA9IG9ialtrXTtcbiAgICAgICAgaWYgKHYgIT0gbnVsbCkge1xuICAgICAgICAgICAgcnVsZXMucHVzaChrZXlWYWwoaywgdikpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGpvaW4ocnVsZXMpO1xufTtcbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gdG9RdWVyeTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy91c2VNZWRpYVF1ZXJ5LnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvdXNlTWVkaWFRdWVyeS50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcbnZhciByZWFjdF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgcmVhY3QgKi8gXCJyZWFjdFwiKTtcbnZhciBtYXRjaG1lZGlhcXVlcnlfMSA9IF9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBtYXRjaG1lZGlhcXVlcnkgKi8gXCIuL25vZGVfbW9kdWxlcy9tYXRjaG1lZGlhcXVlcnkvaW5kZXguanNcIikpO1xudmFyIGh5cGhlbmF0ZV9zdHlsZV9uYW1lXzEgPSBfX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgaHlwaGVuYXRlLXN0eWxlLW5hbWUgKi8gXCIuL25vZGVfbW9kdWxlcy9oeXBoZW5hdGUtc3R5bGUtbmFtZS9pbmRleC5qc1wiKSk7XG52YXIgc2hhbGxvd19lcXVhbF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgc2hhbGxvdy1lcXVhbCAqLyBcIi4vbm9kZV9tb2R1bGVzL3NoYWxsb3ctZXF1YWwvZGlzdC9pbmRleC5lc20uanNcIik7XG52YXIgdG9RdWVyeV8xID0gX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vdG9RdWVyeSAqLyBcIi4vc3JjL3RvUXVlcnkudHNcIikpO1xudmFyIENvbnRleHRfMSA9IF9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL0NvbnRleHQgKi8gXCIuL3NyYy9Db250ZXh0LnRzXCIpKTtcbnZhciBtYWtlUXVlcnkgPSBmdW5jdGlvbiAoc2V0dGluZ3MpIHsgcmV0dXJuIHNldHRpbmdzLnF1ZXJ5IHx8ICgwLCB0b1F1ZXJ5XzEuZGVmYXVsdCkoc2V0dGluZ3MpOyB9O1xudmFyIGh5cGhlbmF0ZUtleXMgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgaWYgKCFvYmopXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmopO1xuICAgIHJldHVybiBrZXlzLnJlZHVjZShmdW5jdGlvbiAocmVzdWx0LCBrZXkpIHtcbiAgICAgICAgcmVzdWx0WygwLCBoeXBoZW5hdGVfc3R5bGVfbmFtZV8xLmRlZmF1bHQpKGtleSldID0gb2JqW2tleV07XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSwge30pO1xufTtcbnZhciB1c2VJc1VwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcmVmID0gKDAsIHJlYWN0XzEudXNlUmVmKShmYWxzZSk7XG4gICAgKDAsIHJlYWN0XzEudXNlRWZmZWN0KShmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJlZi5jdXJyZW50ID0gdHJ1ZTtcbiAgICB9LCBbXSk7XG4gICAgcmV0dXJuIHJlZi5jdXJyZW50O1xufTtcbnZhciB1c2VEZXZpY2UgPSBmdW5jdGlvbiAoZGV2aWNlRnJvbVByb3BzKSB7XG4gICAgdmFyIGRldmljZUZyb21Db250ZXh0ID0gKDAsIHJlYWN0XzEudXNlQ29udGV4dCkoQ29udGV4dF8xLmRlZmF1bHQpO1xuICAgIHZhciBnZXREZXZpY2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBoeXBoZW5hdGVLZXlzKGRldmljZUZyb21Qcm9wcykgfHwgaHlwaGVuYXRlS2V5cyhkZXZpY2VGcm9tQ29udGV4dCk7XG4gICAgfTtcbiAgICB2YXIgX2EgPSAoMCwgcmVhY3RfMS51c2VTdGF0ZSkoZ2V0RGV2aWNlKSwgZGV2aWNlID0gX2FbMF0sIHNldERldmljZSA9IF9hWzFdO1xuICAgICgwLCByZWFjdF8xLnVzZUVmZmVjdCkoZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbmV3RGV2aWNlID0gZ2V0RGV2aWNlKCk7XG4gICAgICAgIGlmICghKDAsIHNoYWxsb3dfZXF1YWxfMS5zaGFsbG93RXF1YWxPYmplY3RzKShkZXZpY2UsIG5ld0RldmljZSkpIHtcbiAgICAgICAgICAgIHNldERldmljZShuZXdEZXZpY2UpO1xuICAgICAgICB9XG4gICAgfSwgW2RldmljZUZyb21Qcm9wcywgZGV2aWNlRnJvbUNvbnRleHRdKTtcbiAgICByZXR1cm4gZGV2aWNlO1xufTtcbnZhciB1c2VRdWVyeSA9IGZ1bmN0aW9uIChzZXR0aW5ncykge1xuICAgIHZhciBnZXRRdWVyeSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1ha2VRdWVyeShzZXR0aW5ncyk7IH07XG4gICAgdmFyIF9hID0gKDAsIHJlYWN0XzEudXNlU3RhdGUpKGdldFF1ZXJ5KSwgcXVlcnkgPSBfYVswXSwgc2V0UXVlcnkgPSBfYVsxXTtcbiAgICAoMCwgcmVhY3RfMS51c2VFZmZlY3QpKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG5ld1F1ZXJ5ID0gZ2V0UXVlcnkoKTtcbiAgICAgICAgaWYgKHF1ZXJ5ICE9PSBuZXdRdWVyeSkge1xuICAgICAgICAgICAgc2V0UXVlcnkobmV3UXVlcnkpO1xuICAgICAgICB9XG4gICAgfSwgW3NldHRpbmdzXSk7XG4gICAgcmV0dXJuIHF1ZXJ5O1xufTtcbnZhciB1c2VNYXRjaE1lZGlhID0gZnVuY3Rpb24gKHF1ZXJ5LCBkZXZpY2UpIHtcbiAgICB2YXIgZ2V0TWF0Y2hNZWRpYSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICgwLCBtYXRjaG1lZGlhcXVlcnlfMS5kZWZhdWx0KShxdWVyeSwgZGV2aWNlIHx8IHt9LCAhIWRldmljZSk7IH07XG4gICAgdmFyIF9hID0gKDAsIHJlYWN0XzEudXNlU3RhdGUpKGdldE1hdGNoTWVkaWEpLCBtcSA9IF9hWzBdLCBzZXRNcSA9IF9hWzFdO1xuICAgIHZhciBpc1VwZGF0ZSA9IHVzZUlzVXBkYXRlKCk7XG4gICAgKDAsIHJlYWN0XzEudXNlRWZmZWN0KShmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChpc1VwZGF0ZSkge1xuICAgICAgICAgICAgLy8gc2tpcCBvbiBtb3VudGluZywgaXQgaGFzIGFscmVhZHkgYmVlbiBzZXRcbiAgICAgICAgICAgIHZhciBuZXdNcV8xID0gZ2V0TWF0Y2hNZWRpYSgpO1xuICAgICAgICAgICAgc2V0TXEobmV3TXFfMSk7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmIChuZXdNcV8xKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld01xXzEuZGlzcG9zZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9LCBbcXVlcnksIGRldmljZV0pO1xuICAgIHJldHVybiBtcTtcbn07XG52YXIgdXNlTWF0Y2hlcyA9IGZ1bmN0aW9uIChtZWRpYVF1ZXJ5KSB7XG4gICAgdmFyIF9hID0gKDAsIHJlYWN0XzEudXNlU3RhdGUpKG1lZGlhUXVlcnkubWF0Y2hlcyksIG1hdGNoZXMgPSBfYVswXSwgc2V0TWF0Y2hlcyA9IF9hWzFdO1xuICAgICgwLCByZWFjdF8xLnVzZUVmZmVjdCkoZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdXBkYXRlTWF0Y2hlcyA9IGZ1bmN0aW9uIChldikge1xuICAgICAgICAgICAgc2V0TWF0Y2hlcyhldi5tYXRjaGVzKTtcbiAgICAgICAgfTtcbiAgICAgICAgbWVkaWFRdWVyeS5hZGRMaXN0ZW5lcih1cGRhdGVNYXRjaGVzKTtcbiAgICAgICAgc2V0TWF0Y2hlcyhtZWRpYVF1ZXJ5Lm1hdGNoZXMpO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgbWVkaWFRdWVyeS5yZW1vdmVMaXN0ZW5lcih1cGRhdGVNYXRjaGVzKTtcbiAgICAgICAgfTtcbiAgICB9LCBbbWVkaWFRdWVyeV0pO1xuICAgIHJldHVybiBtYXRjaGVzO1xufTtcbnZhciB1c2VNZWRpYVF1ZXJ5ID0gZnVuY3Rpb24gKHNldHRpbmdzLCBkZXZpY2UsIG9uQ2hhbmdlKSB7XG4gICAgdmFyIGRldmljZVNldHRpbmdzID0gdXNlRGV2aWNlKGRldmljZSk7XG4gICAgdmFyIHF1ZXJ5ID0gdXNlUXVlcnkoc2V0dGluZ3MpO1xuICAgIGlmICghcXVlcnkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBvciBtaXNzaW5nIE1lZGlhUXVlcnkhJyk7XG4gICAgdmFyIG1xID0gdXNlTWF0Y2hNZWRpYShxdWVyeSwgZGV2aWNlU2V0dGluZ3MpO1xuICAgIHZhciBtYXRjaGVzID0gdXNlTWF0Y2hlcyhtcSk7XG4gICAgdmFyIGlzVXBkYXRlID0gdXNlSXNVcGRhdGUoKTtcbiAgICAoMCwgcmVhY3RfMS51c2VFZmZlY3QpKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKGlzVXBkYXRlICYmIG9uQ2hhbmdlKSB7XG4gICAgICAgICAgICBvbkNoYW5nZShtYXRjaGVzKTtcbiAgICAgICAgfVxuICAgIH0sIFttYXRjaGVzXSk7XG4gICAgKDAsIHJlYWN0XzEudXNlRWZmZWN0KShmdW5jdGlvbiAoKSB7IHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChtcSkge1xuICAgICAgICAgICAgbXEuZGlzcG9zZSgpO1xuICAgICAgICB9XG4gICAgfTsgfSwgW10pO1xuICAgIHJldHVybiBtYXRjaGVzO1xufTtcbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gdXNlTWVkaWFRdWVyeTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCJyZWFjdFwiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogZXh0ZXJuYWwge1wiY29tbW9uanNcIjpcInJlYWN0XCIsXCJjb21tb25qczJcIjpcInJlYWN0XCIsXCJhbWRcIjpcInJlYWN0XCIsXCJyb290XCI6XCJSZWFjdFwifSAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKG1vZHVsZSkgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9yZWFjdF9fO1xuXG4vKioqLyB9KVxuXG4vKioqKioqLyBcdH0pO1xuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKiovIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHR2YXIgX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fID0ge307XG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuLyoqKioqKi8gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG4vKioqKioqLyBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4vKioqKioqLyBcdFx0dmFyIGNhY2hlZE1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF07XG4vKioqKioqLyBcdFx0aWYgKGNhY2hlZE1vZHVsZSAhPT0gdW5kZWZpbmVkKSB7XG4vKioqKioqLyBcdFx0XHRyZXR1cm4gY2FjaGVkTW9kdWxlLmV4cG9ydHM7XG4vKioqKioqLyBcdFx0fVxuLyoqKioqKi8gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4vKioqKioqLyBcdFx0dmFyIG1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF0gPSB7XG4vKioqKioqLyBcdFx0XHQvLyBubyBtb2R1bGUuaWQgbmVlZGVkXG4vKioqKioqLyBcdFx0XHQvLyBubyBtb2R1bGUubG9hZGVkIG5lZWRlZFxuLyoqKioqKi8gXHRcdFx0ZXhwb3J0czoge31cbi8qKioqKiovIFx0XHR9O1xuLyoqKioqKi8gXHRcbi8qKioqKiovIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbi8qKioqKiovIFx0XHRfX3dlYnBhY2tfbW9kdWxlc19fW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcbi8qKioqKiovIFx0XG4vKioqKioqLyBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbi8qKioqKiovIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4vKioqKioqLyBcdH1cbi8qKioqKiovIFx0XG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKi8gXHQvKiB3ZWJwYWNrL3J1bnRpbWUvZGVmaW5lIHByb3BlcnR5IGdldHRlcnMgKi9cbi8qKioqKiovIFx0KCgpID0+IHtcbi8qKioqKiovIFx0XHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9ucyBmb3IgaGFybW9ueSBleHBvcnRzXG4vKioqKioqLyBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gKGV4cG9ydHMsIGRlZmluaXRpb24pID0+IHtcbi8qKioqKiovIFx0XHRcdGZvcih2YXIga2V5IGluIGRlZmluaXRpb24pIHtcbi8qKioqKiovIFx0XHRcdFx0aWYoX193ZWJwYWNrX3JlcXVpcmVfXy5vKGRlZmluaXRpb24sIGtleSkgJiYgIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBrZXkpKSB7XG4vKioqKioqLyBcdFx0XHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGRlZmluaXRpb25ba2V5XSB9KTtcbi8qKioqKiovIFx0XHRcdFx0fVxuLyoqKioqKi8gXHRcdFx0fVxuLyoqKioqKi8gXHRcdH07XG4vKioqKioqLyBcdH0pKCk7XG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHQvKiB3ZWJwYWNrL3J1bnRpbWUvaGFzT3duUHJvcGVydHkgc2hvcnRoYW5kICovXG4vKioqKioqLyBcdCgoKSA9PiB7XG4vKioqKioqLyBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gKG9iaiwgcHJvcCkgPT4gKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApKVxuLyoqKioqKi8gXHR9KSgpO1xuLyoqKioqKi8gXHRcbi8qKioqKiovIFx0Lyogd2VicGFjay9ydW50aW1lL21ha2UgbmFtZXNwYWNlIG9iamVjdCAqL1xuLyoqKioqKi8gXHQoKCkgPT4ge1xuLyoqKioqKi8gXHRcdC8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbi8qKioqKiovIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSAoZXhwb3J0cykgPT4ge1xuLyoqKioqKi8gXHRcdFx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG4vKioqKioqLyBcdFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuLyoqKioqKi8gXHRcdFx0fVxuLyoqKioqKi8gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKioqKiovIFx0XHR9O1xuLyoqKioqKi8gXHR9KSgpO1xuLyoqKioqKi8gXHRcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHQvLyBzdGFydHVwXG4vKioqKioqLyBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuLyoqKioqKi8gXHQvLyBUaGlzIGVudHJ5IG1vZHVsZSBpcyByZWZlcmVuY2VkIGJ5IG90aGVyIG1vZHVsZXMgc28gaXQgY2FuJ3QgYmUgaW5saW5lZFxuLyoqKioqKi8gXHR2YXIgX193ZWJwYWNrX2V4cG9ydHNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oXCIuL3NyYy9pbmRleC50c1wiKTtcbi8qKioqKiovIFx0XG4vKioqKioqLyBcdHJldHVybiBfX3dlYnBhY2tfZXhwb3J0c19fO1xuLyoqKioqKi8gfSkoKVxuO1xufSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZWFjdC1yZXNwb25zaXZlLmpzLm1hcCJdLCJuYW1lcyI6WyJ3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbiIsInJvb3QiLCJmYWN0b3J5IiwiZXhwb3J0cyIsIm1vZHVsZSIsInJlcXVpcmUiLCJkZWZpbmUiLCJhbWQiLCJfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX3JlYWN0X18iLCJfX3dlYnBhY2tfbW9kdWxlc19fIiwiX191bnVzZWRfd2VicGFja19tb2R1bGUiLCJtYXRjaCIsIm1hdGNoUXVlcnkiLCJwYXJzZSIsInBhcnNlUXVlcnkiLCJSRV9NRURJQV9RVUVSWSIsIlJFX01RX0VYUFJFU1NJT04iLCJSRV9NUV9GRUFUVVJFIiwiUkVfTEVOR1RIX1VOSVQiLCJSRV9SRVNPTFVUSU9OX1VOSVQiLCJtZWRpYVF1ZXJ5IiwidmFsdWVzIiwic29tZSIsInF1ZXJ5IiwiaW52ZXJzZSIsInR5cGVNYXRjaCIsInR5cGUiLCJleHByZXNzaW9uc01hdGNoIiwiZXhwcmVzc2lvbnMiLCJldmVyeSIsImV4cHJlc3Npb24iLCJmZWF0dXJlIiwibW9kaWZpZXIiLCJleHBWYWx1ZSIsInZhbHVlIiwidG9Mb3dlckNhc2UiLCJ0b1B4IiwidG9EcGkiLCJ0b0RlY2ltYWwiLCJwYXJzZUludCIsInNwbGl0IiwibWFwIiwidHJpbSIsImNhcHR1cmVzIiwicGFyc2VkIiwicmF0aW8iLCJkZWNpbWFsIiwiTnVtYmVyIiwibnVtYmVycyIsInJlc29sdXRpb24iLCJwYXJzZUZsb2F0IiwidW5pdHMiLCJTdHJpbmciLCJsZW5ndGgiLCJfX3dlYnBhY2tfZXhwb3J0c19fIiwiX193ZWJwYWNrX3JlcXVpcmVfXyIsInIiLCJkIiwiX19XRUJQQUNLX0RFRkFVTFRfRVhQT1JUX18iLCJ1cHBlcmNhc2VQYXR0ZXJuIiwibXNQYXR0ZXJuIiwiY2FjaGUiLCJ0b0h5cGhlbkxvd2VyIiwiaHlwaGVuYXRlU3R5bGVOYW1lIiwibmFtZSIsImhhc093blByb3BlcnR5IiwiaE5hbWUiLCJyZXBsYWNlIiwidGVzdCIsIl9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cyIsInN0YXRpY01hdGNoIiwiZHluYW1pY01hdGNoIiwid2luZG93IiwibWF0Y2hNZWRpYSIsIk1xbCIsImZvcmNlU3RhdGljIiwic2VsZiIsIm1xbCIsImNhbGwiLCJtYXRjaGVzIiwibWVkaWEiLCJhZGRMaXN0ZW5lciIsInVwZGF0ZSIsInJlbW92ZUxpc3RlbmVyIiwiZGlzcG9zZSIsImxpc3RlbmVyIiwiZXZ0IiwiZ2V0T3duUHJvcGVydHlTeW1ib2xzIiwiT2JqZWN0IiwicHJvdG90eXBlIiwicHJvcElzRW51bWVyYWJsZSIsInByb3BlcnR5SXNFbnVtZXJhYmxlIiwidG9PYmplY3QiLCJ2YWwiLCJ1bmRlZmluZWQiLCJUeXBlRXJyb3IiLCJzaG91bGRVc2VOYXRpdmUiLCJhc3NpZ24iLCJ0ZXN0MSIsImdldE93blByb3BlcnR5TmFtZXMiLCJ0ZXN0MiIsImkiLCJmcm9tQ2hhckNvZGUiLCJvcmRlcjIiLCJuIiwiam9pbiIsInRlc3QzIiwiZm9yRWFjaCIsImxldHRlciIsImtleXMiLCJlcnIiLCJ0YXJnZXQiLCJzb3VyY2UiLCJmcm9tIiwidG8iLCJzeW1ib2xzIiwicyIsImFyZ3VtZW50cyIsImtleSIsInByaW50V2FybmluZyIsIlJlYWN0UHJvcFR5cGVzU2VjcmV0IiwibG9nZ2VkVHlwZUZhaWx1cmVzIiwiaGFzIiwidGV4dCIsIm1lc3NhZ2UiLCJjb25zb2xlIiwiZXJyb3IiLCJFcnJvciIsIngiLCJjaGVja1Byb3BUeXBlcyIsInR5cGVTcGVjcyIsImxvY2F0aW9uIiwiY29tcG9uZW50TmFtZSIsImdldFN0YWNrIiwidHlwZVNwZWNOYW1lIiwiZXgiLCJzdGFjayIsInJlc2V0V2FybmluZ0NhY2hlIiwiUmVhY3RJcyIsImVtcHR5RnVuY3Rpb25UaGF0UmV0dXJuc051bGwiLCJpc1ZhbGlkRWxlbWVudCIsInRocm93T25EaXJlY3RBY2Nlc3MiLCJJVEVSQVRPUl9TWU1CT0wiLCJTeW1ib2wiLCJpdGVyYXRvciIsIkZBVVhfSVRFUkFUT1JfU1lNQk9MIiwiZ2V0SXRlcmF0b3JGbiIsIm1heWJlSXRlcmFibGUiLCJpdGVyYXRvckZuIiwiQU5PTllNT1VTIiwiUmVhY3RQcm9wVHlwZXMiLCJhcnJheSIsImNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyIiwiYmlnaW50IiwiYm9vbCIsImZ1bmMiLCJudW1iZXIiLCJvYmplY3QiLCJzdHJpbmciLCJzeW1ib2wiLCJhbnkiLCJjcmVhdGVBbnlUeXBlQ2hlY2tlciIsImFycmF5T2YiLCJjcmVhdGVBcnJheU9mVHlwZUNoZWNrZXIiLCJlbGVtZW50IiwiY3JlYXRlRWxlbWVudFR5cGVDaGVja2VyIiwiZWxlbWVudFR5cGUiLCJjcmVhdGVFbGVtZW50VHlwZVR5cGVDaGVja2VyIiwiaW5zdGFuY2VPZiIsImNyZWF0ZUluc3RhbmNlVHlwZUNoZWNrZXIiLCJub2RlIiwiY3JlYXRlTm9kZUNoZWNrZXIiLCJvYmplY3RPZiIsImNyZWF0ZU9iamVjdE9mVHlwZUNoZWNrZXIiLCJvbmVPZiIsImNyZWF0ZUVudW1UeXBlQ2hlY2tlciIsIm9uZU9mVHlwZSIsImNyZWF0ZVVuaW9uVHlwZUNoZWNrZXIiLCJzaGFwZSIsImNyZWF0ZVNoYXBlVHlwZUNoZWNrZXIiLCJleGFjdCIsImNyZWF0ZVN0cmljdFNoYXBlVHlwZUNoZWNrZXIiLCJpcyIsInkiLCJQcm9wVHlwZUVycm9yIiwiZGF0YSIsImNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyIiwidmFsaWRhdGUiLCJtYW51YWxQcm9wVHlwZUNhbGxDYWNoZSIsIm1hbnVhbFByb3BUeXBlV2FybmluZ0NvdW50IiwiY2hlY2tUeXBlIiwiaXNSZXF1aXJlZCIsInByb3BzIiwicHJvcE5hbWUiLCJwcm9wRnVsbE5hbWUiLCJzZWNyZXQiLCJjYWNoZUtleSIsImNoYWluZWRDaGVja1R5cGUiLCJiaW5kIiwiZXhwZWN0ZWRUeXBlIiwicHJvcFZhbHVlIiwicHJvcFR5cGUiLCJnZXRQcm9wVHlwZSIsInByZWNpc2VUeXBlIiwiZ2V0UHJlY2lzZVR5cGUiLCJ0eXBlQ2hlY2tlciIsIkFycmF5IiwiaXNBcnJheSIsImlzVmFsaWRFbGVtZW50VHlwZSIsImV4cGVjdGVkQ2xhc3MiLCJleHBlY3RlZENsYXNzTmFtZSIsImFjdHVhbENsYXNzTmFtZSIsImdldENsYXNzTmFtZSIsImV4cGVjdGVkVmFsdWVzIiwidmFsdWVzU3RyaW5nIiwiSlNPTiIsInN0cmluZ2lmeSIsInJlcGxhY2VyIiwiYXJyYXlPZlR5cGVDaGVja2VycyIsImNoZWNrZXIiLCJnZXRQb3N0Zml4Rm9yVHlwZVdhcm5pbmciLCJleHBlY3RlZFR5cGVzIiwiY2hlY2tlclJlc3VsdCIsInB1c2giLCJleHBlY3RlZFR5cGVzTWVzc2FnZSIsImlzTm9kZSIsImludmFsaWRWYWxpZGF0b3JFcnJvciIsInNoYXBlVHlwZXMiLCJhbGxLZXlzIiwic3RlcCIsImVudHJpZXMiLCJuZXh0IiwiZG9uZSIsImVudHJ5IiwiaXNTeW1ib2wiLCJSZWdFeHAiLCJEYXRlIiwiY29uc3RydWN0b3IiLCJQcm9wVHlwZXMiLCJpc0VsZW1lbnQiLCJGdW5jdGlvbiIsImhhc1N5bWJvbCIsImZvciIsIlJFQUNUX0VMRU1FTlRfVFlQRSIsIlJFQUNUX1BPUlRBTF9UWVBFIiwiUkVBQ1RfRlJBR01FTlRfVFlQRSIsIlJFQUNUX1NUUklDVF9NT0RFX1RZUEUiLCJSRUFDVF9QUk9GSUxFUl9UWVBFIiwiUkVBQ1RfUFJPVklERVJfVFlQRSIsIlJFQUNUX0NPTlRFWFRfVFlQRSIsIlJFQUNUX0FTWU5DX01PREVfVFlQRSIsIlJFQUNUX0NPTkNVUlJFTlRfTU9ERV9UWVBFIiwiUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSIsIlJFQUNUX1NVU1BFTlNFX1RZUEUiLCJSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUiLCJSRUFDVF9NRU1PX1RZUEUiLCJSRUFDVF9MQVpZX1RZUEUiLCJSRUFDVF9CTE9DS19UWVBFIiwiUkVBQ1RfRlVOREFNRU5UQUxfVFlQRSIsIlJFQUNUX1JFU1BPTkRFUl9UWVBFIiwiUkVBQ1RfU0NPUEVfVFlQRSIsIiQkdHlwZW9mIiwidHlwZU9mIiwiJCR0eXBlb2ZUeXBlIiwiQXN5bmNNb2RlIiwiQ29uY3VycmVudE1vZGUiLCJDb250ZXh0Q29uc3VtZXIiLCJDb250ZXh0UHJvdmlkZXIiLCJFbGVtZW50IiwiRm9yd2FyZFJlZiIsIkZyYWdtZW50IiwiTGF6eSIsIk1lbW8iLCJQb3J0YWwiLCJQcm9maWxlciIsIlN0cmljdE1vZGUiLCJTdXNwZW5zZSIsImhhc1dhcm5lZEFib3V0RGVwcmVjYXRlZElzQXN5bmNNb2RlIiwiaXNBc3luY01vZGUiLCJpc0NvbmN1cnJlbnRNb2RlIiwiaXNDb250ZXh0Q29uc3VtZXIiLCJpc0NvbnRleHRQcm92aWRlciIsImlzRm9yd2FyZFJlZiIsImlzRnJhZ21lbnQiLCJpc0xhenkiLCJpc01lbW8iLCJpc1BvcnRhbCIsImlzUHJvZmlsZXIiLCJpc1N0cmljdE1vZGUiLCJpc1N1c3BlbnNlIiwic2hhbGxvd0VxdWFsQXJyYXlzIiwic2hhbGxvd0VxdWFsT2JqZWN0cyIsIm9iakEiLCJvYmpCIiwiYUtleXMiLCJiS2V5cyIsImxlbiIsImFyckEiLCJhcnJCIiwiX19yZXN0IiwiZSIsInQiLCJwIiwiaW5kZXhPZiIsIl9faW1wb3J0RGVmYXVsdCIsIm1vZCIsIl9fZXNNb2R1bGUiLCJkZWZpbmVQcm9wZXJ0eSIsInVzZU1lZGlhUXVlcnlfMSIsIk1lZGlhUXVlcnkiLCJfYSIsImNoaWxkcmVuIiwiZGV2aWNlIiwib25DaGFuZ2UiLCJzZXR0aW5ncyIsImRlZmF1bHQiLCJyZWFjdF8xIiwiQ29udGV4dCIsImNyZWF0ZUNvbnRleHQiLCJ0b1F1ZXJ5IiwidXNlTWVkaWFRdWVyeSIsIkNvbXBvbmVudF8xIiwidG9RdWVyeV8xIiwiQ29udGV4dF8xIiwiX19hc3NpZ24iLCJhcHBseSIsInByb3BfdHlwZXNfMSIsInN0cmluZ09yTnVtYmVyIiwidHlwZXMiLCJhbGwiLCJncmlkIiwiYXVyYWwiLCJicmFpbGxlIiwiaGFuZGhlbGQiLCJwcmludCIsInByb2plY3Rpb24iLCJzY3JlZW4iLCJ0dHkiLCJ0diIsImVtYm9zc2VkIiwibWF0Y2hlcnMiLCJvcmllbnRhdGlvbiIsInNjYW4iLCJhc3BlY3RSYXRpbyIsImRldmljZUFzcGVjdFJhdGlvIiwiaGVpZ2h0IiwiZGV2aWNlSGVpZ2h0Iiwid2lkdGgiLCJkZXZpY2VXaWR0aCIsImNvbG9yIiwiY29sb3JJbmRleCIsIm1vbm9jaHJvbWUiLCJmZWF0dXJlTWF0Y2hlcnMiLCJmZWF0dXJlcyIsIm1pbkFzcGVjdFJhdGlvIiwibWF4QXNwZWN0UmF0aW8iLCJtaW5EZXZpY2VBc3BlY3RSYXRpbyIsIm1heERldmljZUFzcGVjdFJhdGlvIiwibWluSGVpZ2h0IiwibWF4SGVpZ2h0IiwibWluRGV2aWNlSGVpZ2h0IiwibWF4RGV2aWNlSGVpZ2h0IiwibWluV2lkdGgiLCJtYXhXaWR0aCIsIm1pbkRldmljZVdpZHRoIiwibWF4RGV2aWNlV2lkdGgiLCJtaW5Db2xvciIsIm1heENvbG9yIiwibWluQ29sb3JJbmRleCIsIm1heENvbG9ySW5kZXgiLCJtaW5Nb25vY2hyb21lIiwibWF4TW9ub2Nocm9tZSIsIm1pblJlc29sdXRpb24iLCJtYXhSZXNvbHV0aW9uIiwiaHlwaGVuYXRlX3N0eWxlX25hbWVfMSIsIm1lZGlhUXVlcnlfMSIsIm5lZ2F0ZSIsImNvbmQiLCJjb25jYXQiLCJrZXlWYWwiLCJrIiwidiIsInJlYWxLZXkiLCJjb25kcyIsIm9iaiIsInJ1bGVzIiwibWF0Y2htZWRpYXF1ZXJ5XzEiLCJzaGFsbG93X2VxdWFsXzEiLCJtYWtlUXVlcnkiLCJoeXBoZW5hdGVLZXlzIiwicmVkdWNlIiwicmVzdWx0IiwidXNlSXNVcGRhdGUiLCJyZWYiLCJ1c2VSZWYiLCJ1c2VFZmZlY3QiLCJjdXJyZW50IiwidXNlRGV2aWNlIiwiZGV2aWNlRnJvbVByb3BzIiwiZGV2aWNlRnJvbUNvbnRleHQiLCJ1c2VDb250ZXh0IiwiZ2V0RGV2aWNlIiwidXNlU3RhdGUiLCJzZXREZXZpY2UiLCJuZXdEZXZpY2UiLCJ1c2VRdWVyeSIsImdldFF1ZXJ5Iiwic2V0UXVlcnkiLCJuZXdRdWVyeSIsInVzZU1hdGNoTWVkaWEiLCJnZXRNYXRjaE1lZGlhIiwibXEiLCJzZXRNcSIsImlzVXBkYXRlIiwibmV3TXFfMSIsInVzZU1hdGNoZXMiLCJzZXRNYXRjaGVzIiwidXBkYXRlTWF0Y2hlcyIsImV2IiwiZGV2aWNlU2V0dGluZ3MiLCJfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX18iLCJtb2R1bGVJZCIsImNhY2hlZE1vZHVsZSIsImRlZmluaXRpb24iLCJvIiwiZW51bWVyYWJsZSIsImdldCIsInByb3AiLCJ0b1N0cmluZ1RhZyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-responsive/dist/react-responsive.js\n");

/***/ })

};
;